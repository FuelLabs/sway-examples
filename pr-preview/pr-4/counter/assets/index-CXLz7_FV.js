var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e2, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i, _client2, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _j, _hasNestedOption, _k, _caseIndexCoder, _encodedValueSize, _shouldValidateLength, _EnumCoder_instances, isNativeEnum_fn, encodeNativeEnum_fn, decodeNativeEnum_fn, _l, _hasNestedOption2, _m, _hasNestedOption3, _n2, _hasNestedOption4, _o2, _paddingLength, _p, _operations, _q, _r2, _s, _t5;
function _mergeNamespaces(n3, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n3)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n3, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n3) {
  if (n3.__esModule) return n3;
  var f2 = n3.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n3).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n3, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n3[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$6 = Symbol.for("react.element"), n$9 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$6 = Symbol.for("react.strict_mode"), r$7 = Symbol.for("react.profiler"), t$6 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$5 = Symbol.iterator;
function A$3(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = z$5 && a2[z$5] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$4 = {};
function E$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$3;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$4() {
}
F$4.prototype = E$2.prototype;
function G$5(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$3;
}
var H$3 = G$5.prototype = new F$4();
H$3.constructor = G$5;
C$1(H$3, E$2.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$3 = Object.prototype.hasOwnProperty, K$5 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$4(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J$3.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$6, type: a2, key: k2, ref: h2, props: c2, _owner: K$5.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$6, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$4(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$6;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$3 = /\/+/g;
function Q$4(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2) a2 = null;
  var h2 = false;
  if (null === a2) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a2.$$typeof) {
        case l$6:
        case n$9:
          h2 = true;
      }
  }
  if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$4(h2, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$3, "$&/") + "/"), R$3(c2, b2, e2, "", function(a3) {
    return a3;
  })) : null != c2 && (O$4(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
    k2 = a2[g2];
    var f2 = d2 + Q$4(k2, g2);
    h2 += R$3(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$3(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q$4(k2, g2++), h2 += R$3(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$5(a2, b2, e2) {
  if (null == a2) return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$4(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status) return a2._result.default;
  throw a2._result;
}
var U$5 = { current: null }, V$5 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$5, ReactCurrentBatchConfig: V$5, ReactCurrentOwner: K$5 };
function X$4() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$5, forEach: function(a2, b2, e2) {
  S$5(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$5(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$5(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$4(a2)) throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$7;
react_production_min.PureComponent = G$5;
react_production_min.StrictMode = q$6;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
react_production_min.act = X$4;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$5.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
    for (f2 in b2) J$3.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$6, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$6, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$4;
react_production_min.createFactory = function(a2) {
  var b2 = M$4.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$4;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$4 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$5.transition;
  V$5.transition = {};
  try {
    a2();
  } finally {
    V$5.transition = b2;
  }
};
react_production_min.unstable_act = X$4;
react_production_min.useCallback = function(a2, b2) {
  return U$5.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$5.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$5.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$5.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$5.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$5.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$5.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$5.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$5.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$5.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$5.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$5.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$5.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$5.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$9 = reactExports, k$4 = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$8 = f$9.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q$5(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$5.call(a2, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$4, type: c2, key: e2, ref: h2, props: d2, _owner: n$8.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q$5;
reactJsxRuntime_production_min.jsxs = q$5;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client$1 = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a2[d2];
      if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length) return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n3 = m2 + 1, x2 = a2[n3];
        if (0 > g2(C2, c2)) n3 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n3] = c2, d2 = n3) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
        else if (n3 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n3] = c2, d2 = n3;
        else break a;
      }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q3 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q3;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B3 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F3 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G3(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B3 = false;
    G3(a2);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K3(H2, b2.startTime - a2);
    }
  }
  function J2(a2, b2) {
    A2 = false;
    B3 && (B3 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G3(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G3(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K3(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F3) S2 = function() {
    F3(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K3(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B3 ? (E2(L2), L2 = -1) : B3 = true, K3(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$4(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2)) return true;
  if (ja.call(la, a2)) return false;
  if (ka.test(a2)) return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$4(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$4 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$4[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$4[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$4[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$4[b2] = new v$4(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$4.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$4.hasOwnProperty(b2) ? z$4[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$2 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a2, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a2.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2) return null;
  if ("function" === typeof a2) return a2.displayName || a2.name || null;
  if ("string" === typeof a2) return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2) switch (a2.$$typeof) {
    case Ca:
      return (a2.displayName || "Context") + ".Consumer";
    case Ba:
      return (a2._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a2.render;
      a2 = a2.displayName;
      a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      return a2;
    case Ga:
      return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
    case Ha:
      b2 = a2._payload;
      a2 = a2._init;
      try {
        return Qa(a2(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2) return false;
  var b2 = a2._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2) return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
  } else a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$4(91));
  return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$4(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$4(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
    for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
  }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$4(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$4(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$4(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$4(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb) throw Error(p$4(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib) return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
      a2 = !d2;
      break a;
    default:
      a2 = false;
  }
  if (a2) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$4(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a2) {
  Lb = false;
}
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$4(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2) throw Error(p$4(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2) throw Error(p$4(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a2;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$4(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$4(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$4(190));
  }
  if (3 !== c2.tag) throw Error(p$4(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2) return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn) return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2) hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
  else if (c2 = b2.tag, 13 === c2) {
    a2 = Wb(b2);
    if (null !== a2) return a2;
    a2 = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a2 = null;
  } else b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2) return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$1 = A$2({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id$1), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$2 = null;
ia && "documentMode" in document && (be$2 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$2, de$3 = ia && (!ae$2 || be$2 && 8 < be$2 && 11 >= be$2), ee$2 = String.fromCharCode(32), fe$3 = false;
function ge$4(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$3(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$2 = false;
function je$2(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$3(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe$3 = true;
      return ee$2;
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$3 ? null : a2;
    default:
      return null;
  }
}
function ke$3(a2, b2) {
  if (ie$2) return "compositionend" === a2 || !ae$2 && ge$4(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$3 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$3 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$3[a2.type] : "textarea" === b2 ? true : false;
}
function ne$3(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$3(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$3 = null, qe$2 = null;
function re$4(a2) {
  se$3(a2, 0);
}
function te$1(a2) {
  var b2 = ue$2(a2);
  if (Wa(b2)) return a2;
}
function ve$3(a2, b2) {
  if ("change" === a2) return b2;
}
var we$2 = false;
if (ia) {
  var xe$2;
  if (ia) {
    var ye$3 = "oninput" in document;
    if (!ye$3) {
      var ze$2 = document.createElement("div");
      ze$2.setAttribute("oninput", "return;");
      ye$3 = "function" === typeof ze$2.oninput;
    }
    xe$2 = ye$3;
  } else xe$2 = false;
  we$2 = xe$2 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$3() {
  pe$3 && (pe$3.detachEvent("onpropertychange", Be$1), qe$2 = pe$3 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$2)) {
    var b2 = [];
    ne$3(b2, qe$2, a2, xb(a2));
    Jb(re$4, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$3(), pe$3 = b2, qe$2 = c2, pe$3.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$3();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te$1(qe$2);
}
function Ee$3(a2, b2) {
  if ("click" === a2) return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2) return te$1(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$2 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$3(a2, b2) {
  if (He$2(a2, b2)) return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$2(a2[e2], b2[e2])) return false;
  }
  return true;
}
function Je$2(a2) {
  for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b2) {
  var c2 = Je$2(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$2(c2);
  }
}
function Le$2(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a2 = b2.contentWindow;
    else break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$2(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$2(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$1(c2, f2);
        var g2 = Ke$1(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$2 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$4 = null, Se$2 = null, Te$2 = false;
function Ue$2(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$2 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$2(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$2 && Ie$3(Se$2, d2) || (Se$2 = d2, d2 = oe$3(Re$4, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$2(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$2 = { animationend: Ve$2("Animation", "AnimationEnd"), animationiteration: Ve$2("Animation", "AnimationIteration"), animationstart: Ve$2("Animation", "AnimationStart"), transitionend: Ve$2("Transition", "TransitionEnd") }, Xe$2 = {}, Ye$2 = {};
ia && (Ye$2 = document.createElement("div").style, "AnimationEvent" in window || (delete We$2.animationend.animation, delete We$2.animationiteration.animation, delete We$2.animationstart.animation), "TransitionEvent" in window || delete We$2.transitionend.transition);
function Ze$2(a2) {
  if (Xe$2[a2]) return Xe$2[a2];
  if (!We$2[a2]) return a2;
  var b2 = We$2[a2], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye$2) return Xe$2[a2] = b2[c2];
  return a2;
}
var $e$2 = Ze$2("animationend"), af = Ze$2("animationiteration"), bf = Ze$2("animationstart"), cf = Ze$2("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$2, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$3(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$3(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n3 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n3 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n3 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$2:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F3 = u2.stateNode;
          5 === u2.tag && null !== F3 && (u2 = F3, null !== x2 && (F3 = Kb(w2, x2), null != F3 && t2.push(tf(w2, F3, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n3, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n3 = c2.relatedTarget || c2.fromElement) && (Wc(n3) || n3[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n3 = c2.relatedTarget || c2.toElement, k3 = d3, n3 = n3 ? Wc(n3) : null, null !== n3 && (J2 = Vb(n3), n3 !== J2 || 5 !== n3.tag && 6 !== n3.tag)) n3 = null;
          } else k3 = null, n3 = d3;
          if (k3 !== n3) {
            t2 = Bd;
            F3 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F3 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$2(k3);
            u2 = null == n3 ? h3 : ue$2(n3);
            h3 = new t2(F3, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F3 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n3, c2, e3), t2.target = u2, t2.relatedTarget = J2, F3 = t2);
            J2 = F3;
            if (k3 && n3) b: {
              t2 = k3;
              x2 = n3;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F3 = x2; F3; F3 = vf(F3)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n3 && null !== J2 && wf(g3, J2, n3, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$2(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve$3;
        else if (me$2(h3)) if (we$2) na = Fe$1;
        else {
          na = De$1;
          var xa = Ce$1;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$3);
        if (na && (na = na(a2, d3))) {
          ne$3(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$2(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable) Qe$1 = xa, Re$4 = d3, Se$2 = null;
          break;
        case "focusout":
          Se$2 = Re$4 = Qe$1 = null;
          break;
        case "mousedown":
          Te$2 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$2 = false;
          Ue$2(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$2) break;
        case "keydown":
        case "keyup":
          Ue$2(g3, c2, e3);
      }
      var $a;
      if (ae$2) b: {
        switch (a2) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie$2 ? ge$4(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$3 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$3(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$3(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$2(a2, c2) : ke$3(a2, c2)) d3 = oe$3(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$3(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$3(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2) return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2) throw Error(p$4(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a2.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a2;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2) return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
        if (c2 = a2[Of]) return c2;
        a2 = Mf(a2);
      }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$2(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
  throw Error(p$4(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$4(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf) throw Error(p$4(168));
  G$4(H$2, b2);
  G$4(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$4(108, Ra(a2) || "Unknown", e2));
  return A$2({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$4(H$2, a2);
  G$4(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2) throw Error(p$4(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$4(H$2, a2)) : E$1(Wf);
  G$4(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2)) throw Error(p$4(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2)) throw Error(p$4(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg) return false;
  if (!I$2) return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2)) throw Hg(), Error(p$4(418));
    for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2) throw Error(p$4(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$4(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$4(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2) throw Error(p$4(284));
    if (!c2._owner) throw Error(p$4(290, a2));
  }
  return a2;
}
function Mg(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$4(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function Ng(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function Og(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Pg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Lg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q3(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q3(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
      Mg(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      Mg(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n3(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n4 = r2(e3, u2, h3[w2], k3);
      if (null === n4) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n4.alternate && b2(e3, u2);
      g3 = f2(n4, g3, w2);
      null === m3 ? l3 = n4 : m3.sibling = n4;
      m3 = n4;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q3(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$4(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$4(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n4 = h3.next(); null !== m3 && !n4.done; w2++, n4 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n4.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n4.done) return c2(
      e3,
      m3
    ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n4.done; w2++, n4 = h3.next()) n4 = q3(e3, n4.value, k3), null !== n4 && (g3 = f2(n4, g3, w2), null === u2 ? l3 = n4 : u2.sibling = n4, u2 = n4);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n4.done; w2++, n4 = h3.next()) n4 = y2(m3, e3, w2, n4.value, k3), null !== n4 && (a2 && null !== n4.alternate && m3.delete(null === n4.key ? w2 : n4.key), g3 = f2(n4, g3, w2), null === u2 ? l3 = n4 : u2.sibling = n4, u2 = n4);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a3, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a3;
                a3 = d3;
                break a;
              } else {
                c2(a3, d3);
                break;
              }
              else b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n3(a3, d3, f3, h3);
      if (Ka(f3)) return t2(a3, d3, f3, h3);
      Mg(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a2) {
  var b2 = Wg.current;
  E$1(Wg);
  a2._currentValue = b2;
}
function bh(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2) break;
    a2 = a2.return;
  }
}
function ch(a2, b2) {
  Xg = a2;
  Zg = Yg = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
}
function eh(a2) {
  var b2 = a2._currentValue;
  if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$4(308));
    Yg = a2;
    Xg.dependencies = { lanes: 0, firstContext: a2 };
  } else Yg = Yg.next = a2;
  return b2;
}
var fh = null;
function gh(a2) {
  null === fh ? fh = [a2] : fh.push(a2);
}
function hh(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a2, d2);
}
function ih(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function mh(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K$4 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a2, c2);
}
function oh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function ph(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q3 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n3 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n3 = t2.payload;
              if ("function" === typeof n3) {
                q3 = n3.call(y2, q3, r2);
                break a;
              }
              q3 = n3;
              break a;
            case 3:
              n3.flags = n3.flags & -65537 | 128;
            case 0:
              n3 = t2.payload;
              r2 = "function" === typeof n3 ? n3.call(y2, q3, r2) : n3;
              if (null === r2 || void 0 === r2) break a;
              q3 = A$2({}, q3, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q3) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q3);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh$1 |= g2;
    a2.lanes = g2;
    a2.memoizedState = q3;
  }
}
function sh$1(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
    var d2 = a2[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$4(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a2) {
  if (a2 === th) throw Error(p$4(174));
  return a2;
}
function yh(a2, b2) {
  G$4(wh, b2);
  G$4(vh, a2);
  G$4(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(uh);
  G$4(uh, b2);
}
function zh() {
  E$1(uh);
  E$1(vh);
  E$1(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$4(vh, a2), G$4(uh, c2));
}
function Bh(a2) {
  vh.current === a2 && (E$1(uh), E$1(vh));
}
var L = Uf(0);
function Ch(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$3 = null, N$1 = null, O$3 = null, Ih = false, Jh = false, Kh$1 = 0, Lh = 0;
function P$2() {
  throw Error(p$4(321));
}
function Mh(a2, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He$2(a2[c2], b2[c2])) return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  M$3 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh$1 = 0;
      if (25 <= f2) throw Error(p$4(301));
      f2 += 1;
      O$3 = N$1 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$1 && null !== N$1.next;
  Hh = 0;
  O$3 = N$1 = M$3 = null;
  Ih = false;
  if (b2) throw Error(p$4(300));
  return a2;
}
function Sh() {
  var a2 = 0 !== Kh$1;
  Kh$1 = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O$3 ? M$3.memoizedState = O$3 = a2 : O$3 = O$3.next = a2;
  return O$3;
}
function Uh() {
  if (null === N$1) {
    var a2 = M$3.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else a2 = N$1.next;
  var b2 = null === O$3 ? M$3.memoizedState : O$3.next;
  if (null !== b2) O$3 = b2, N$1 = a2;
  else {
    if (null === a2) throw Error(p$4(310));
    N$1 = a2;
    a2 = { memoizedState: N$1.memoizedState, baseState: N$1.baseState, baseQueue: N$1.baseQueue, queue: N$1.queue, next: null };
    null === O$3 ? M$3.memoizedState = O$3 = a2 : O$3 = O$3.next = a2;
  }
  return O$3;
}
function Vh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d2 = N$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q3 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q3, g2 = d2) : k2 = k2.next = q3;
        M$3.lanes |= m2;
        rh$1 |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$2(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, M$3.lanes |= f2, rh$1 |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$2(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = M$3, d2 = Uh(), e2 = b2(), f2 = !He$2(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== O$3 && O$3.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi$1(9, ci$1.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q$3) throw Error(p$4(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = M$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$3.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function ci$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei$1(b2) && fi(a2);
}
function ai$1(a2, b2, c2) {
  return c2(function() {
    ei$1(b2) && fi(a2);
  });
}
function ei$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$2(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = ih(a2, 1);
  null !== b2 && gi$1(b2, a2, 1, -1);
}
function hi$1(a2) {
  var b2 = Th();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ii$1.bind(null, M$3, a2);
  return [b2.memoizedState, a2];
}
function bi$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$3.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a2, b2, c2, d2) {
  var e2 = Th();
  M$3.flags |= a2;
  e2.memoizedState = bi$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N$1) {
    var g2 = N$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi$1(b2, c2, f2, d2);
      return;
    }
  }
  M$3.flags |= a2;
  e2.memoizedState = bi$1(1 | b2, c2, f2, d2);
}
function mi(a2, b2) {
  return ki(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return li(2048, 8, a2, b2);
}
function ni$1(a2, b2) {
  return li(4, 2, a2, b2);
}
function oi(a2, b2) {
  return li(4, 4, a2, b2);
}
function pi(a2, b2) {
  if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
    b2.current = null;
  };
}
function qi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return li(4, 4, pi.bind(null, b2, a2), c2);
}
function ri$1() {
}
function si$1(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ti$1(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function ui$1(a2, b2, c2) {
  if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
  He$2(c2, b2) || (c2 = yc(), M$3.lanes |= c2, rh$1 |= c2, a2.baseState = true);
  return b2;
}
function vi(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi$1() {
  return Uh().memoizedState;
}
function xi$1(a2, b2, c2) {
  var d2 = yi$1(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, c2);
  else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
    var e2 = R$2();
    gi$1(c2, a2, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii$1(a2, b2, c2) {
  var d2 = yi$1(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He$2(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a2, b2, e2, d2);
    null !== c2 && (e2 = R$2(), gi$1(c2, a2, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a2) {
  var b2 = a2.alternate;
  return a2 === M$3 || null !== b2 && b2 === M$3;
}
function Ai(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Bi(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var Rh = { readContext: eh, useCallback: P$2, useContext: P$2, useEffect: P$2, useImperativeHandle: P$2, useInsertionEffect: P$2, useLayoutEffect: P$2, useMemo: P$2, useReducer: P$2, useRef: P$2, useState: P$2, useDebugValue: P$2, useDeferredValue: P$2, useTransition: P$2, useMutableSource: P$2, useSyncExternalStore: P$2, useId: P$2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ki(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ki(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = xi$1.bind(null, M$3, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: hi$1, useDebugValue: ri$1, useDeferredValue: function(a2) {
  return Th().memoizedState = a2;
}, useTransition: function() {
  var a2 = hi$1(false), b2 = a2[0];
  a2 = vi.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = M$3, e2 = Th();
  if (I$2) {
    if (void 0 === c2) throw Error(p$4(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q$3) throw Error(p$4(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  bi$1(9, ci$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = Q$3.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh$1++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si$1,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni$1,
  useLayoutEffect: oi,
  useMemo: ti$1,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri$1,
  useDeferredValue: function(a2) {
    var b2 = Uh();
    return ui$1(b2, N$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi$1,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si$1, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni$1, useLayoutEffect: oi, useMemo: ti$1, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri$1, useDeferredValue: function(a2) {
  var b2 = Uh();
  return null === N$1 ? b2.memoizedState = a2 : ui$1(b2, N$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a2, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi$1, unstable_isNewReconciler: false };
function Ci(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$2({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Di(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R$2(), e2 = yi$1(a2), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi$1(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R$2(), e2 = yi$1(a2), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi$1(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = R$2(), d2 = yi$1(a2), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a2, e2, d2);
  null !== b2 && (gi$1(b2, a2, d2, c2), oh(b2, a2, d2));
} };
function Fi(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$3(c2, d2) || !Ie$3(e2, f2) : true;
}
function Gi(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = {};
  kh(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function Ji(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Ki(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi$1 = d2);
    Li(a2, b2);
  };
  return c2;
}
function Qi(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a2, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ui$1(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Vi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$3;
    if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = Pg(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$3(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
    else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  }
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$4(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$4(ej, fj), fj |= a2, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G$4(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$4(ej, fj), fj |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function gj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I$2 && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function hj(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q3 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q3 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q3 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q3 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q3 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n3 = b2.memoizedState;
    h2 !== q3 || r2 !== n3 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n3 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n3, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n3, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n3, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n3), g2.props = d2, g2.state = n3, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a2, b2, c2, d2, f2, e2);
}
function jj(a2, b2, c2, d2, e2, f2) {
  gj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function lj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function oj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
  G$4(L, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a2, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a2.child, null, c2);
  a2 = qj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function rj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$4(422))), sj(a2, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$4(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (dh || h2) {
    d2 = Q$3;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi$1(d2, a2, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$4(421)));
    return sj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a2.return, b2, c2);
}
function wj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
      if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
      else if (19 === a2.tag) vj(a2, c2, b2);
      else if (null !== a2.child) {
        a2.child.return = a2;
        a2 = a2.child;
        continue;
      }
      if (a2 === b2) break a;
      for (; null === a2.sibling; ) {
        if (null === a2.return || a2.return === b2) break a;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      a2 = a2.sibling;
    }
    d2 &= 1;
  }
  G$4(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a2 = e2.alternate;
        if (null !== a2 && null === Ch(a2)) {
          b2.child = e2;
          break;
        }
        a2 = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a2;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  rh$1 |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a2 && b2.child !== a2.child) throw Error(p$4(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = Pg(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$4(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G$4(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
        G$4(L, L.current & 1);
        a2 = Zi(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$4(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2) return xj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$4(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$2({}, e2, { value: void 0 });
        d2 = A$2({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$3("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a2, b2) {
  if (!I$2) switch (a2.tailMode) {
    case "hidden":
      b2 = a2.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a2.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a2.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
  }
}
function S$4(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Ej(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$4(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E$1(Wf);
      E$1(H$2);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a2, b2);
      S$4(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$4(166));
          S$4(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$3("cancel", d2);
              D$3("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$3("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D$3(lf[e2], d2);
              break;
            case "source":
              D$3("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$3(
                "error",
                d2
              );
              D$3("load", d2);
              break;
            case "details":
              D$3("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$3("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$3("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$3("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a2
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$3("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          zj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$3("cancel", a2);
                D$3("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$3("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D$3(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$3("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$3(
                  "error",
                  a2
                );
                D$3("load", a2);
                e2 = d2;
                break;
              case "details":
                D$3("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$3("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$2({}, d2, { value: void 0 });
                D$3("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$3("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$3("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$4(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$4(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2) switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                break;
              case 5:
                true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$4(b2);
      return null;
    case 13:
      E$1(L);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2) throw Error(p$4(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$4(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$4(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T$3 && (T$3 = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$4(b2);
      return null;
    case 4:
      return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$4(b2), null;
    case 10:
      return ah(b2.type._context), S$4(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 19:
      E$1(L);
      f2 = b2.memoizedState;
      if (null === f2) return S$4(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T$3 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
          g2 = Ch(a2);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
            G$4(L, L.current & 1 | 2);
            return b2.child;
          }
          a2 = a2.sibling;
        }
        null !== f2.tail && B$2() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a2 = Ch(g2), null !== a2) {
          if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2) return S$4(b2), null;
        } else 2 * B$2() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = L.current, G$4(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$4(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$4(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$4(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$4(156, b2.tag));
}
function Ij(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E$1(Wf), E$1(H$2), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E$1(L);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate) throw Error(p$4(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$4 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$4 = null;
function Lj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W$2(a2, b2, d2);
  }
  else c2.current = null;
}
function Mj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$2(a2, b2, d2);
  }
}
var Nj = false;
function Oj(a2, b2) {
  Cf = dd;
  a2 = Me$2();
  if (Ne$2(a2)) {
    if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else a: {
      c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F3) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q3 = a2, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q3 !== c2 || 0 !== e2 && 3 !== q3.nodeType || (h2 = g2 + e2);
            q3 !== f2 || 0 !== d2 && 3 !== q3.nodeType || (k2 = g2 + d2);
            3 === q3.nodeType && (g2 += q3.nodeValue.length);
            if (null === (y2 = q3.firstChild)) break;
            r2 = q3;
            q3 = y2;
          }
          for (; ; ) {
            if (q3 === a2) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q3.nextSibling)) break;
            q3 = r2;
            r2 = q3.parentNode;
          }
          q3 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$4 = b2; null !== V$4; ) if (b2 = V$4, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V$4 = a2;
  else for (; null !== V$4; ) {
    b2 = V$4;
    try {
      var n3 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n3) {
            var t2 = n3.memoizedProps, J2 = n3.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$4(163));
      }
    } catch (F3) {
      W$2(b2, b2.return, F3);
    }
    a2 = b2.sibling;
    if (null !== a2) {
      a2.return = b2.return;
      V$4 = a2;
      break;
    }
    V$4 = b2.return;
  }
  n3 = Nj;
  Nj = false;
  return n3;
}
function Pj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Sj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Sj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Tj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Uj(a2) {
  a: for (; ; ) {
    for (; null === a2.sibling; ) {
      if (null === a2.return || Tj(a2.return)) return null;
      a2 = a2.return;
    }
    a2.sibling.return = a2.return;
    for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
      if (a2.flags & 2) continue a;
      if (null === a2.child || 4 === a2.tag) continue a;
      else a2.child.return = a2, a2 = a2.child;
    }
    if (!(a2.flags & 2)) return a2.stateNode;
  }
}
function Vj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
}
var X$3 = null, Xj = false;
function Yj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
}
function Zj(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U$4 || Lj(c2, b2);
    case 6:
      var d2 = X$3, e2 = Xj;
      X$3 = null;
      Yj(a2, b2, c2);
      X$3 = d2;
      Xj = e2;
      null !== X$3 && (Xj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$3.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$3 && (Xj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$3, c2.stateNode));
      break;
    case 4:
      d2 = X$3;
      e2 = Xj;
      X$3 = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a2, b2, c2);
      X$3 = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$4 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a2, b2, c2);
      break;
    case 1:
      if (!U$4 && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W$2(c2, b2, h2);
      }
      Yj(a2, b2, c2);
      break;
    case 21:
      Yj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$4 = (d2 = U$4) || null !== c2.memoizedState, Yj(a2, b2, c2), U$4 = d2) : Yj(a2, b2, c2);
      break;
    default:
      Yj(a2, b2, c2);
  }
}
function ak(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a2, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X$3 = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X$3 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$3 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X$3) throw Error(p$4(160));
      Zj(f2, g2, e2);
      X$3 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W$2(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
}
function dk(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        try {
          Pj(3, a2, a2.return), Qj(3, a2);
        } catch (t2) {
          W$2(a2, a2.return, t2);
        }
        try {
          Pj(5, a2, a2.return);
        } catch (t2) {
          W$2(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$2(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q3 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q3) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q3) : "children" === m2 ? ob(e2, q3) : ta(e2, m2, q3, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W$2(a2, a2.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        if (null === a2.stateNode) throw Error(p$4(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$2(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W$2(a2, a2.return, t2);
      }
      break;
    case 4:
      ck(b2, a2);
      ek(a2);
      break;
    case 13:
      ck(b2, a2);
      ek(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B$2()));
      d2 & 4 && ak(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$4 = (l2 = U$4) || m2, ck(b2, a2), U$4 = l2) : ck(b2, a2);
      ek(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V$4 = a2, m2 = a2.child; null !== m2; ) {
          for (q3 = V$4 = m2; null !== V$4; ) {
            r2 = V$4;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n3 = r2.stateNode;
                if ("function" === typeof n3.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n3.props = b2.memoizedProps, n3.state = b2.memoizedState, n3.componentWillUnmount();
                  } catch (t2) {
                    W$2(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q3);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V$4 = y2) : gk(q3);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q3 = a2; ; ) {
          if (5 === q3.tag) {
            if (null === m2) {
              m2 = q3;
              try {
                e2 = q3.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q3.stateNode, k2 = q3.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W$2(a2, a2.return, t2);
              }
            }
          } else if (6 === q3.tag) {
            if (null === m2) try {
              q3.stateNode.nodeValue = l2 ? "" : q3.memoizedProps;
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
          } else if ((22 !== q3.tag && 23 !== q3.tag || null === q3.memoizedState || q3 === a2) && null !== q3.child) {
            q3.child.return = q3;
            q3 = q3.child;
            continue;
          }
          if (q3 === a2) break a;
          for (; null === q3.sibling; ) {
            if (null === q3.return || q3.return === a2) break a;
            m2 === q3 && (m2 = null);
            q3 = q3.return;
          }
          m2 === q3 && (m2 = null);
          q3.sibling.return = q3.return;
          q3 = q3.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a2);
      ek(a2);
      d2 & 4 && ak(a2);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a2
      ), ek(a2);
  }
}
function ek(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$4(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a2);
          Wj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
          Vj(a2, h2, g2);
          break;
        default:
          throw Error(p$4(161));
      }
    } catch (k2) {
      W$2(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function hk(a2, b2, c2) {
  V$4 = a2;
  ik(a2);
}
function ik(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$4; ) {
    var e2 = V$4, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$4;
        h2 = Jj;
        var l2 = U$4;
        Jj = g2;
        if ((U$4 = k2) && !l2) for (V$4 = e2; null !== V$4; ) g2 = V$4, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V$4 = k2) : jk(e2);
        for (; null !== f2; ) V$4 = f2, ik(f2), f2 = f2.sibling;
        V$4 = e2;
        Jj = h2;
        U$4 = l2;
      }
      kk(a2);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$4 = f2) : kk(a2);
  }
}
function kk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U$4 || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U$4) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh$1(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh$1(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q3 = m2.dehydrated;
                  null !== q3 && bd(q3);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$4(163));
        }
        U$4 || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W$2(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function gk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function jk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W$2(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$2(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W$2(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W$2(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$2(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$4 = h2;
      break;
    }
    V$4 = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K$4 = 0, Q$3 = null, Y$3 = null, Z$4 = 0, fj = 0, ej = Uf(0), T$3 = 0, pk = null, rh$1 = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi$1 = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R$2() {
  return 0 !== (K$4 & 6) ? B$2() : -1 !== Ak ? Ak : Ak = B$2();
}
function yi$1(a2) {
  if (0 === (a2.mode & 1)) return 1;
  if (0 !== (K$4 & 2) && 0 !== Z$4) return Z$4 & -Z$4;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a2 = C;
  if (0 !== a2) return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function gi$1(a2, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$4(185));
  Ac(a2, c2, d2);
  if (0 === (K$4 & 2) || a2 !== Q$3) a2 === Q$3 && (0 === (K$4 & 2) && (qk |= c2), 4 === T$3 && Ck(a2, Z$4)), Dk(a2, d2), 1 === c2 && 0 === K$4 && 0 === (b2.mode & 1) && (Gj = B$2() + 500, fg && jg());
}
function Dk(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === Q$3 ? Z$4 : 0);
  if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
      0 === (K$4 & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Gk(a2, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K$4 & 6)) throw Error(p$4(327));
  var c2 = a2.callbackNode;
  if (Hk() && a2.callbackNode !== c2) return null;
  var d2 = uc(a2, a2 === Q$3 ? Z$4 : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
  else {
    b2 = d2;
    var e2 = K$4;
    K$4 |= 2;
    var f2 = Jk();
    if (Q$3 !== a2 || Z$4 !== b2) uk = null, Gj = B$2() + 500, Kk(a2, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a2, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K$4 = e2;
    null !== Y$3 ? b2 = 0 : (Q$3 = null, Z$4 = 0, b2 = T$3);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
    if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B$2()), c2;
    if (6 === b2) Ck(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B$2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$4(345));
        case 2:
          Pk(a2, tk, uk);
          break;
        case 3:
          Ck(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0)) break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R$2();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 4:
          Ck(a2, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 5:
          Pk(a2, tk, uk);
          break;
        default:
          throw Error(p$4(329));
      }
    }
  }
  Dk(a2, B$2());
  return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
}
function Nk(a2, b2) {
  var c2 = sk;
  a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
  a2 = Ik(a2, b2);
  2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a2;
}
function Fj(a2) {
  null === tk ? tk = a2 : tk.push.apply(tk, a2);
}
function Ok(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He$2(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a2, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a2) {
  if (0 !== (K$4 & 6)) throw Error(p$4(327));
  Hk();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1)) return Dk(a2, B$2()), null;
  var c2 = Ik(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B$2()), c2;
  if (6 === c2) throw Error(p$4(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Pk(a2, tk, uk);
  Dk(a2, B$2());
  return null;
}
function Qk(a2, b2) {
  var c2 = K$4;
  K$4 |= 1;
  try {
    return a2(b2);
  } finally {
    K$4 = c2, 0 === K$4 && (Gj = B$2() + 500, fg && jg());
  }
}
function Rk(a2) {
  null !== wk && 0 === wk.tag && 0 === (K$4 & 6) && Hk();
  var b2 = K$4;
  K$4 |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a2) return a2();
  } finally {
    C = d2, ok.transition = c2, K$4 = b2, 0 === (K$4 & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$1(ej);
}
function Kk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$3) for (c2 = Y$3.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E$1(Wf);
        E$1(H$2);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E$1(L);
        break;
      case 19:
        E$1(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q$3 = a2;
  Y$3 = a2 = Pg(a2.current, null);
  Z$4 = fj = b2;
  T$3 = 0;
  pk = null;
  rk = qk = rh$1 = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a2;
}
function Mk(a2, b2) {
  do {
    var c2 = Y$3;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M$3.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O$3 = N$1 = M$3 = null;
      Jh = false;
      Kh$1 = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T$3 = 1;
        pk = b2;
        Y$3 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$4;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q3 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q3 || 11 === q3 || 15 === q3)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n3 = b2.updateQueue;
            if (null === n3) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n3.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$4(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Ui$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T$3 && (T$3 = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F3 = Qi(f2, h2, b2);
                ph(f2, F3);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y$3 === c2 && null !== c2 && (Y$3 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a2 = mk.current;
  mk.current = Rh;
  return null === a2 ? Rh : a2;
}
function tj() {
  if (0 === T$3 || 3 === T$3 || 2 === T$3) T$3 = 4;
  null === Q$3 || 0 === (rh$1 & 268435455) && 0 === (qk & 268435455) || Ck(Q$3, Z$4);
}
function Ik(a2, b2) {
  var c2 = K$4;
  K$4 |= 2;
  var d2 = Jk();
  if (Q$3 !== a2 || Z$4 !== b2) uk = null, Kk(a2, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a2, e2);
    }
  while (1);
  $g();
  K$4 = c2;
  mk.current = d2;
  if (null !== Y$3) throw Error(p$4(261));
  Q$3 = null;
  Z$4 = 0;
  return T$3;
}
function Tk() {
  for (; null !== Y$3; ) Uk(Y$3);
}
function Lk() {
  for (; null !== Y$3 && !cc(); ) Uk(Y$3);
}
function Uk(a2) {
  var b2 = Vk(a2.alternate, a2, fj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Sk(a2) : Y$3 = b2;
  nk.current = null;
}
function Sk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y$3 = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$3 = c2;
        return;
      }
      if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$3 = 6;
        Y$3 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$3 = b2;
      return;
    }
    Y$3 = b2 = a2;
  } while (null !== b2);
  0 === T$3 && (T$3 = 5);
}
function Pk(a2, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a2, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K$4 & 6)) throw Error(p$4(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2) return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current) throw Error(p$4(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === Q$3 && (Y$3 = Q$3 = null, Z$4 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K$4;
    K$4 |= 4;
    nk.current = null;
    Oj(a2, c2);
    dk(c2, a2);
    Oe$2(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    hk(c2);
    dc();
    K$4 = h2;
    C = g2;
    ok.transition = f2;
  } else a2.current = c2;
  vk && (vk = false, wk = a2, xk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a2, B$2());
  if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a2 = Pi$1, Pi$1 = null, a2;
  0 !== (xk & 1) && 0 !== a2.tag && Hk();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a2 = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === wk) var d2 = false;
      else {
        a2 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K$4 & 6)) throw Error(p$4(331));
        var e2 = K$4;
        K$4 |= 4;
        for (V$4 = a2.current; null !== V$4; ) {
          var f2 = V$4, g2 = f2.child;
          if (0 !== (V$4.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$4 = l2; null !== V$4; ) {
                  var m2 = V$4;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q3 = m2.child;
                  if (null !== q3) q3.return = m2, V$4 = q3;
                  else for (; null !== V$4; ) {
                    m2 = V$4;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V$4 = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V$4 = r2;
                      break;
                    }
                    V$4 = y2;
                  }
                }
              }
              var n3 = f2.alternate;
              if (null !== n3) {
                var t2 = n3.child;
                if (null !== t2) {
                  n3.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$4 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V$4 = g2;
          else b: for (; null !== V$4; ) {
            f2 = V$4;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V$4 = x2;
              break b;
            }
            V$4 = f2.return;
          }
        }
        var w2 = a2.current;
        for (V$4 = w2; null !== V$4; ) {
          g2 = V$4;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V$4 = u2;
          else b: for (g2 = w2; null !== V$4; ) {
            h2 = V$4;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W$2(h2, h2.return, na);
            }
            if (h2 === g2) {
              V$4 = null;
              break b;
            }
            var F3 = h2.sibling;
            if (null !== F3) {
              F3.return = h2.return;
              V$4 = F3;
              break b;
            }
            V$4 = h2.return;
          }
        }
        K$4 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a2);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a2, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a2, b2, 1);
  a2 = nh(a2, b2, 1);
  b2 = R$2();
  null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
}
function W$2(a2, b2, c2) {
  if (3 === a2.tag) Xk(a2, a2, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a2, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a2 = Ji(c2, a2);
        a2 = Qi(b2, a2, 1);
        b2 = nh(b2, a2, 1);
        a2 = R$2();
        null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  Q$3 === a2 && (Z$4 & c2) === c2 && (4 === T$3 || 3 === T$3 && (Z$4 & 130023424) === Z$4 && 500 > B$2() - fk ? Kk(a2, 0) : rk |= c2);
  Dk(a2, b2);
}
function Yk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R$2();
  a2 = ih(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
}
function uj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a2, c2);
}
function bk(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$4(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a2, c2);
}
var Vk;
Vk = function(a2, b2, c2) {
  if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
    dh = 0 !== (a2.flags & 131072) ? true : false;
  }
  else dh = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a2 = Ci(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
            break a;
        }
        throw Error(p$4(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a2) throw Error(p$4(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a2, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$4(423)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$4(424)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return oj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$4(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He$2(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$4(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
    case 19:
      return xj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$4(156, b2.tag));
};
function Fk(a2, b2) {
  return ac(a2, b2);
}
function $k(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new $k(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Zk(a2) {
  if ("function" === typeof a2) return aj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da) return 11;
    if (a2 === Ga) return 14;
  }
  return 2;
}
function Pg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Rg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2) aj(a2) && (g2 = 1);
  else if ("string" === typeof a2) g2 = 5;
  else a: switch (a2) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
    case Ea:
      return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
    case Fa:
      return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$4(130, null == a2 ? a2 : typeof a2, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function pj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function Qg(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Sg(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function al(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new al(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a2;
}
function cl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function dl(a2) {
  if (!a2) return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p$4(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$4(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2)) return bg(a2, c2, b2);
  }
  return b2;
}
function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = dl(null);
  c2 = a2.current;
  d2 = R$2();
  e2 = yi$1(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Dk(a2, d2);
  return a2;
}
function fl$1(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = R$2(), g2 = yi$1(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = nh(e2, b2, g2);
  null !== a2 && (gi$1(a2, e2, g2, f2), oh(a2, e2, g2));
  return g2;
}
function gl(a2) {
  a2 = a2.current;
  if (!a2.child) return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function hl(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a2, b2) {
  hl(a2, b2);
  (a2 = a2.alternate) && hl(a2, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ll(a2) {
  this._internalRoot = a2;
}
ml.prototype.render = ll.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$4(409));
  fl$1(a2, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Rk(function() {
      fl$1(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a2) {
  this._internalRoot = a2;
}
ml.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function nl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function pl() {
}
function ql(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = gl(g2);
        f2.call(a3);
      };
    }
    var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk();
    return g2;
  }
  for (; e2 = a2.lastChild; ) a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = gl(k2);
      h2.call(a3);
    };
  }
  var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Rk(function() {
    fl$1(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = gl(g2);
        h2.call(a3);
      };
    }
    fl$1(b2, g2, a2, e2);
  } else g2 = ql(c2, b2, a2, e2, d2);
  return gl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B$2()), 0 === (K$4 & 6) && (Gj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a2, 1);
        if (null !== b3) {
          var c3 = R$2();
          gi$1(b3, a2, 1, c3);
        }
      }), il(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = ih(a2, 134217728);
    if (null !== b2) {
      var c2 = R$2();
      gi$1(b2, a2, 134217728, c2);
    }
    il(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = yi$1(a2), c2 = ih(a2, b2);
    if (null !== c2) {
      var d2 = R$2();
      gi$1(c2, a2, b2, d2);
    }
    il(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$4(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl$1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl$1.isDisabled && vl$1.supportsFiber) try {
    kc = vl$1.inject(ul), lc = vl$1;
  } catch (a2) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$4(200));
  return cl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!nl(a2)) throw Error(p$4(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2) return null;
  if (1 === a2.nodeType) return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render) throw Error(p$4(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$4(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Rk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$4(200));
  return rl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!nl(a2)) throw Error(p$4(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$4(200));
  return rl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!ol(a2)) throw Error(p$4(40));
  return a2._reactRootContainer ? (Rk(function() {
    rl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$4(200));
  if (null == a2 || void 0 === a2._reactInternals) throw Error(p$4(38));
  return rl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$4 = reactDomExports;
{
  client$1.createRoot = m$4.createRoot;
  client$1.hydrateRoot = m$4.hydrateRoot;
}
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$3() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value2) {
  return typeof value2 === "number" && value2 >= 0 && value2 !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type: type3 = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey: queryKey2,
    stale
  } = filters;
  if (queryKey2) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey2, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey2)) {
      return false;
    }
  }
  if (type3 !== "all") {
    const isActive = query.isActive();
    if (type3 === "active" && !isActive) {
      return false;
    }
    if (type3 === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey2, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey2);
}
function hashKey(queryKey2) {
  return JSON.stringify(
    queryKey2,
    (_2, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialMatchKey(a2[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array2 = isPlainArray(a2) && isPlainArray(b2);
  if (array2 || isPlainObject$1(a2) && isPlainObject$1(b2)) {
    const aItems = array2 ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array2 ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array2 ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array2 ? i2 : bItems[i2];
      if ((!array2 && aItems.includes(key) || array2) && a2[key] === void 0 && b2[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(a2[key], b2[key]);
        if (copy2[key] === a2[key] && a2[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value2) {
  return Array.isArray(value2) && value2.length === Object.keys(value2).length;
}
function isPlainObject$1(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep$1(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data2, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data2);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data2);
  }
  return data2;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value2) {
  return value2 instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value2) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value2);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value2);
    }
  };
  const reject = (value2) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value2);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value2);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value2) => {
        if (isResolved || canContinue()) {
          continueResolve(value2);
        }
      };
      (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
      }
    });
  };
  const run2 = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
      sleep$1(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run2();
        }
      });
    });
  };
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run2();
      } else {
        pause().then(run2);
      }
      return promise;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const setScheduler = (fn2) => {
    scheduleFn = fn2;
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn2) => {
    notifyFn = fn2;
  };
  const setBatchNotifyFunction = (fn2) => {
    batchNotifyFn = fn2;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction,
    setScheduler
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a2;
    return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data2 = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data: data2,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data2;
  }
  setState(state2, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state: state2, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$3).catch(noop$3) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError2 = (error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data2) => {
        var _a3, _b3, _c3, _d2;
        if (data2 === void 0) {
          onError2(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data2);
        } catch (error) {
          onError2(error);
          return;
        }
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data2, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data2,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError: onError2,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state2) => {
    switch (action.type) {
      case "failed":
        return {
          ...state2,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state2,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state2,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state2,
          ...fetchState(state2.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state2,
          data: action.data,
          dataUpdateCount: state2.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state2,
          error,
          errorUpdateCount: state2.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state2.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state2,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state2,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data2, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data2 === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data2 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data2 !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data: data2,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e2 = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state2) {
    const queryKey2 = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey2, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey: queryKey2,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state: state2,
        defaultOptions: client2.getQueryDefaults(queryKey2)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e2);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n3, _o3, _p2, _q2, _r3, _s2, _t6;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data2 = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e3 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e3,
        data2,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data2, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data2,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l2 = (_k2 = this.options).onSettled) == null ? void 0 : _l2.call(_k2, data2, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data: data2 });
      return data2;
    } catch (error) {
      try {
        await ((_n3 = (_m2 = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n3.call(
          _m2,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p2 = (_o3 = this.options).onError) == null ? void 0 : _p2.call(
          _o3,
          error,
          variables,
          this.state.context
        ));
        await ((_r3 = (_q2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r3.call(
          _q2,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t6 = (_s2 = this.options).onSettled) == null ? void 0 : _t6.call(
          _s2,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state2) => {
    switch (action.type) {
      case "failed":
        return {
          ...state2,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state2,
          isPaused: true
        };
      case "continue":
        return {
          ...state2,
          isPaused: false
        };
      case "pending":
        return {
          ...state2,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state2,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state2,
          data: void 0,
          error: action.error,
          failureCount: state2.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client2, options, state2) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state: state2
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a2 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a2.filter((x2) => x2 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a2;
    const firstPendingMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a2;
    const foundMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$3))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a2;
  return ((_a2 = mutation.options.scope) == null ? void 0 : _a2.id) ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const fetchFn = async () => {
        var _a2, _b2, _c2, _d2, _e3;
        const options = context.options;
        const direction = (_c2 = (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e3 = context.state.data) == null ? void 0 : _e3.pageParams) || [];
        const empty2 = { pages: [], pageParams: [] };
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data2, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data2.pages.length) {
            return Promise.resolve(data2);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data2.pages, page, maxPages),
            pageParams: addTo(data2.pageParams, param, maxPages)
          };
        };
        let result;
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          result = await fetchPage(
            empty2,
            oldPageParams[0] ?? options.initialPageParam
          );
          const remainingPages = pages ?? oldPages.length;
          for (let i2 = 1; i2 < remainingPages; i2++) {
            const param = getNextPageParam(options, result);
            if (param == null) {
              break;
            }
            result = await fetchPage(result, param);
          }
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a2, _b2;
          return (_b2 = (_a2 = context.options).persister) == null ? void 0 : _b2.call(
            _a2,
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return pages.length > 0 ? (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey2) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey: queryKey2 });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey: queryKey2, state: state2 }) => {
      const data2 = state2.data;
      return [queryKey2, data2];
    });
  }
  setQueryData(queryKey2, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey: queryKey2 });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data2 = functionalUpdate(updater, prevData);
    if (data2 === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data2, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey: queryKey2 }) => [
        queryKey2,
        this.setQueryData(queryKey2, updater, options)
      ])
    );
  }
  getQueryState(queryKey2) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey: queryKey2 });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$3).catch(noop$3);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$3);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$3);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$3).catch(noop$3);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$3).catch(noop$3);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey2, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey2), {
      queryKey: queryKey2,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey2) {
    const defaults = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey2, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var QueryObserver = (_i = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client2);
    __privateSet(this, _selectError, null);
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a2;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state: state2 } = query;
    let newState = { ...state2 };
    let isPlaceholderData = false;
    let data2;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state2.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data2 = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data2 = options.select(newState.data);
          data2 = replaceData(prevResult == null ? void 0 : prevResult.data, data2, options);
          __privateSet(this, _selectResult, data2);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data2 = newState.data;
    }
    if (options.placeholderData !== void 0 && data2 === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data2 = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data2 = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data2 !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data: data2,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop$3);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _i);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value2 = typeof field === "function" ? field(query) : field;
    return value2 === "always" || value2 !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var MutationObserver$1 = (_j = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client2);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a2;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a2;
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a2;
    __privateSet(this, _mutateOptions, options);
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a2;
  const state2 = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
  __privateSet(this, _currentResult2, {
    ...state2,
    isPending: state2.status === "pending",
    isSuccess: state2.status === "success",
    isError: state2.status === "error",
    isIdle: state2.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e3 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e3, action.error, variables, context);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _j);
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop$2() {
}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
};
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient) {
  var _a2, _b2, _c2, _d2;
  const client2 = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client2.defaultQueryOptions(options);
  (_b2 = (_a2 = client2.getDefaultOptions().queries) == null ? void 0 : _a2._experimental_beforeQuery) == null ? void 0 : _b2.call(
    _a2,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(
    () => new Observer(
      client2,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      },
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client2.getQueryCache().get(defaultedOptions.queryHash)
  })) {
    throw result.error;
  }
  (_d2 = (_c2 = client2.getDefaultOptions().queries) == null ? void 0 : _c2._experimental_afterQuery) == null ? void 0 : _d2.call(
    _c2,
    defaultedOptions,
    result
  );
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver);
}
function useMutation(options, queryClient) {
  const client2 = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function setRef$1(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value2;
  }
}
function composeRefs(...refs) {
  return (node2) => refs.forEach((ref2) => setRef$1(ref2, node2));
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context = reactExports.createContext(defaultContext);
  function Provider2(props) {
    const { children, ...context } = props;
    const value2 = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: value2, children });
  }
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider2.displayName = rootComponentName + "Provider";
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const value2 = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: value2, children });
    }
    function useContext2(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = React$1["useId".toString()] || (() => void 0);
var count$1 = 0;
function useId$1(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value2 = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value22 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value22 !== prop) handleChange(value22);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value2, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value2] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value2);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value2) {
      handleChange(value2);
      prevValueRef.current = value2;
    }
  }, [value2, prevValueRef, handleChange]);
  return uncontrolledState;
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    return reactExports.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node2) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node2;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node2}`;
  return { ...primitive, [node2]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument2.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument2.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument2]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node2, setNode] = reactExports.useState(null);
    const ownerDocument2 = (node2 == null ? void 0 : node2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node22) => setNode(node22));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index = node2 ? layers.indexOf(node2) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument2);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument2);
    useEscapeKeydown((event) => {
      const isHighestLayer = index === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument2);
    reactExports.useEffect(() => {
      if (!node2) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument2.body.style.pointerEvents;
          ownerDocument2.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node2);
      }
      context.layers.add(node2);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument2.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node2, ownerDocument2, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node2) return;
        context.layers.delete(node2);
        context.layersWithOutsidePointerEventsDisabled.delete(node2);
        dispatchUpdate();
      };
    }, [node2, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref2 = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  reactExports.useEffect(() => {
    const node2 = ref2.current;
    if (node2) {
      context.branches.add(node2);
      return () => {
        context.branches.delete(node2);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown2 = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument2.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument2.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument2.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument2.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument2.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument2.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument2, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument2.addEventListener("focusin", handleFocus);
    return () => ownerDocument2.removeEventListener("focusin", handleFocus);
  }, [ownerDocument2, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setContainer(node2));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown2 = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node2) => {
      const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
      if (node2.disabled || node2.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node2, { upTo }) {
  if (getComputedStyle(node2).visibility === "hidden") return true;
  while (node2) {
    if (upTo !== void 0 && node2 === upTo) return false;
    if (getComputedStyle(node2).display === "none") return true;
    node2 = node2.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var PORTAL_NAME$1 = "Portal";
var Portal$2 = reactExports.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$2.displayName = PORTAL_NAME$1;
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state2, event) => {
    const nextState = machine[state2][event];
    return nextState ?? state2;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref2 = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref: ref2 }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node2, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state2, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state2 === "mounted" ? currentAnimationName : "none";
  }, [state2]);
  useLayoutEffect2(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles2);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles2 == null ? void 0 : styles2.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node2) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node2 && isCurrentAnimation) {
          reactDomExports.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node2) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node2.addEventListener("animationstart", handleAnimationStart);
      node2.addEventListener("animationcancel", handleAnimationEnd);
      node2.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node2.removeEventListener("animationstart", handleAnimationStart);
        node2.removeEventListener("animationcancel", handleAnimationEnd);
        node2.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node2, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state2),
    ref: reactExports.useCallback((node22) => {
      if (node22) stylesRef.current = getComputedStyle(node22);
      setNode(node22);
    }, [])
  };
}
function getAnimationName(styles2) {
  return (styles2 == null ? void 0 : styles2.animationName) || "none";
}
function getElementRef(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node2) => node2.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$2(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate$2E(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param$1(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value2) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value2 = useValue ? initializers[i2].call(thisArg, value2) : initializers[i2].call(thisArg);
  }
  return useValue ? value2 : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f2, name, prefix2) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix2 ? "".concat(prefix2, " ", name) : name });
}
function __metadata$1(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$2 = Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
};
function __exportStar$1(m2, o2) {
  for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding$2(o2, m2, p2);
}
function __values$1(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o2, n3) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spread$1() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read$1(arguments[i2]));
  return ar;
}
function __spreadArrays$1() {
  for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to2.concat(ar || Array.prototype.slice.call(from2));
}
function __await$1(v2) {
  return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject);
    };
  }
  function verb(n3, f2) {
    if (g2[n3]) {
      i2[n3] = function(v2) {
        return new Promise(function(a2, b2) {
          q3.push([n3, v2, a2, b2]) > 1 || resume(n3, v2);
        });
      };
      if (f2) i2[n3] = f2(i2[n3]);
    }
  }
  function resume(n3, v2) {
    try {
      step(g2[n3](v2));
    } catch (e2) {
      settle(q3[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q3[0][2], r2);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f2, v2) {
    if (f2(v2), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator$1(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n3, f2) {
    i2[n3] = o2[n3] ? function(v2) {
      return (p2 = !p2) ? { value: __await$1(o2[n3](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues$1(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values$1 === "function" ? __values$1(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n3) {
    i2[n3] = o2[n3] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n3](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject$1(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault$1 = Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
};
function __importStar$2(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding$2(result, mod2, k2);
  }
  __setModuleDefault$1(result, mod2);
  return result;
}
function __importDefault$3(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet$1(receiver, state2, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state2, value2, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state2.set(receiver, value2), value2;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env2, value2, async) {
  if (value2 !== null && value2 !== void 0) {
    if (typeof value2 !== "object" && typeof value2 !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value2[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value2[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    };
    env2.stack.push({ value: value2, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value2;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env2) {
  function fail(e2) {
    env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
    env2.hasError = true;
  }
  var r2, s2 = 0;
  function next2() {
    while (r2 = env2.stack.pop()) {
      try {
        if (!r2.async && s2 === 1) return s2 = 0, env2.stack.push(r2), Promise.resolve().then(next2);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s2 |= 2, Promise.resolve(result).then(next2, function(e2) {
            fail(e2);
            return next2();
          });
        } else s2 |= 1;
      } catch (e2) {
        fail(e2);
      }
    }
    if (s2 === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
    if (env2.hasError) throw env2.error;
  }
  return next2();
}
const tslib_es6$1 = {
  __extends: __extends$2,
  __assign: __assign$1,
  __rest: __rest$1,
  __decorate: __decorate$2E,
  __param: __param$1,
  __metadata: __metadata$1,
  __awaiter: __awaiter$1,
  __generator: __generator$1,
  __createBinding: __createBinding$2,
  __exportStar: __exportStar$1,
  __values: __values$1,
  __read: __read$1,
  __spread: __spread$1,
  __spreadArrays: __spreadArrays$1,
  __spreadArray,
  __await: __await$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncDelegator: __asyncDelegator$1,
  __asyncValues: __asyncValues$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __importStar: __importStar$2,
  __importDefault: __importDefault$3,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign$1;
  },
  __asyncDelegator: __asyncDelegator$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncValues: __asyncValues$1,
  __await: __await$1,
  __awaiter: __awaiter$1,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __createBinding: __createBinding$2,
  __decorate: __decorate$2E,
  __disposeResources,
  __esDecorate,
  __exportStar: __exportStar$1,
  __extends: __extends$2,
  __generator: __generator$1,
  __importDefault: __importDefault$3,
  __importStar: __importStar$2,
  __makeTemplateObject: __makeTemplateObject$1,
  __metadata: __metadata$1,
  __param: __param$1,
  __propKey,
  __read: __read$1,
  __rest: __rest$1,
  __runInitializers,
  __setFunctionName,
  __spread: __spread$1,
  __spreadArray,
  __spreadArrays: __spreadArrays$1,
  __values: __values$1,
  default: tslib_es6$1
}, Symbol.toStringTag, { value: "Module" }));
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2) {
    ref2.current = value2;
  }
  return ref2;
}
function useCallbackRef(initialValue, callback) {
  var ref2 = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref2.value;
        },
        set current(value2) {
          var last = ref2.value;
          if (last !== value2) {
            ref2.value = value2;
            ref2.callback(value2, last);
          }
        }
      }
    };
  })[0];
  ref2.callback = callback;
  return ref2.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref2) {
      return assignRef(ref2, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref2) {
        if (!nextRefs_1.has(ref2)) {
          assignRef(ref2, null);
        }
      });
      nextRefs_1.forEach(function(ref2) {
        if (!prevRefs_1.has(ref2)) {
          assignRef(ref2, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults;
    },
    useMedium: function(data2) {
      var item = middleware2(data2, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$1({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest$1(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$1({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref2 = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref2, parentRef]);
  var containerProps = __assign$1(__assign$1({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref2, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$1(__assign$1({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$1({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles2 = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles2, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$4 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$4(left), parse$4(top), parse$4(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap2 = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap2, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap2, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap2 = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap2, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument2 = node2.ownerDocument;
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument2.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position2 = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref2) {
  return ref2 && "current" in ref2 ? ref2.current : ref2;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  var shadowParent = null;
  while (node2 !== null) {
    if (node2 instanceof ShadowRoot) {
      shadowParent = node2.host;
      node2 = node2.host;
    }
    node2 = node2.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref2) {
  return reactExports.createElement(RemoveScroll, __assign$1({}, props, { ref: ref2, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          var attr = node2.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node2) || 0) + 1;
          var markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId$1(),
      titleId: useId$1(),
      descriptionId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog$1;
var Portal$1 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent$1;
var Title = DialogTitle;
var Close = DialogClose;
function getBuiltinVersions() {
  return {
    FORC: "0.62.0",
    FUEL_CORE: "0.31.0",
    FUELS: "0.93.0"
  };
}
function parseVersion(version2) {
  const [major, minor, patch] = version2.split(".").map((v2) => parseInt(v2, 10));
  return { major, minor, patch };
}
function versionDiffs(version1, version2) {
  const semver1 = parseVersion(version1);
  const semver2 = parseVersion(version2);
  const major = semver1.major - semver2.major;
  const minor = semver1.minor - semver2.minor;
  const patch = semver1.patch - semver2.patch;
  return {
    major,
    minor,
    patch,
    fullVersionDiff: major || minor || patch
  };
}
function majorEq(version1, version2) {
  const { major } = versionDiffs(version1, version2);
  return major === 0;
}
function minorEq(version1, version2) {
  const { minor } = versionDiffs(version1, version2);
  return minor === 0;
}
function patchEq(version1, version2) {
  const { patch } = versionDiffs(version1, version2);
  return patch === 0;
}
function checkFuelCoreVersionCompatibility(networkVersion) {
  const { FUEL_CORE: supportedVersion } = getBuiltinVersions();
  if (/^\d+\.\d+\.\d+\D+/m.test(networkVersion)) {
    console.warn(`You're running against an unreleased fuel-core version: ${networkVersion}. Things may work as expected, but it's not guaranteed. Please use a released version.      
This unreleased fuel-core build may include features and updates not yet supported by this version of the TS-SDK.`);
  }
  return {
    supportedVersion,
    isMajorSupported: majorEq(networkVersion, supportedVersion),
    isMinorSupported: minorEq(networkVersion, supportedVersion),
    isPatchSupported: patchEq(networkVersion, supportedVersion)
  };
}
var versions = getBuiltinVersions();
var __defProp$4 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value2) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField$3 = (obj, key, value2) => {
  __defNormalProp$3(obj, key + "", value2);
  return value2;
};
var ErrorCode$1 = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["NO_ABIS_FOUND"] = "no-abis-found";
  ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
  ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
  ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
  ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
  ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
  ErrorCode2["LOG_TYPE_NOT_FOUND"] = "log-type-not-found";
  ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
  ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
  ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
  ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
  ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
  ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
  ErrorCode2["INVALID_DATA"] = "invalid-data";
  ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
  ErrorCode2["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
  ErrorCode2["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
  ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
  ErrorCode2["INVALID_B256_ADDRESS"] = "invalid-b256-address";
  ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
  ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
  ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
  ErrorCode2["INVALID_PROVIDER"] = "invalid-provider";
  ErrorCode2["CONNECTION_REFUSED"] = "connection-refused";
  ErrorCode2["INVALID_PUBLIC_KEY"] = "invalid-public-key";
  ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
  ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
  ErrorCode2["MISSING_CONNECTOR"] = "missing-connector";
  ErrorCode2["PARSE_FAILED"] = "parse-failed";
  ErrorCode2["ENCODE_ERROR"] = "encode-error";
  ErrorCode2["DECODE_ERROR"] = "decode-error";
  ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
  ErrorCode2["INVALID_TTL"] = "invalid-ttl";
  ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
  ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
  ErrorCode2["NOT_SUPPORTED"] = "not-supported";
  ErrorCode2["CONVERTING_FAILED"] = "converting-error";
  ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
  ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
  ErrorCode2["INVALID_REQUEST"] = "invalid-request";
  ErrorCode2["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
  ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
  ErrorCode2["HASHER_LOCKED"] = "hasher-locked";
  ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
  ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
  ErrorCode2["MAX_FEE_TOO_LOW"] = "max-fee-too-low";
  ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
  ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
  ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
  ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
  ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
  ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
  ErrorCode2["UNSUPPORTED_TRANSACTION_TYPE"] = "unsupported-transaction-type";
  ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
  ErrorCode2["INVALID_POLICY_TYPE"] = "invalid-policy-type";
  ErrorCode2["DUPLICATED_POLICY"] = "duplicated-policy";
  ErrorCode2["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
  ErrorCode2["CONTRACT_SIZE_EXCEEDS_LIMIT"] = "contract-size-exceeds-limit";
  ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
  ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
  ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
  ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
  ErrorCode2["INVALID_SEED"] = "invalid-seed";
  ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
  ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
  ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
  ErrorCode2["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
  ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
  ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
  ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
  ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
  ErrorCode2["STREAM_PARSING_ERROR"] = "stream-parsing-error";
  ErrorCode2["NODE_LAUNCH_FAILED"] = "node-launch-failed";
  ErrorCode2["UNKNOWN"] = "unknown";
  return ErrorCode2;
})(ErrorCode$1 || {});
var _FuelError = class extends Error {
  constructor(code2, message, metadata = {}, rawError = {}) {
    super(message);
    __publicField(this, "VERSIONS", versions);
    __publicField(this, "metadata");
    __publicField(this, "rawError");
    __publicField(this, "code");
    this.code = code2;
    this.name = "FuelError";
    this.metadata = metadata;
    this.rawError = rawError;
  }
  static parse(e2) {
    const error = e2;
    if (error.code === void 0) {
      throw new _FuelError(
        "parse-failed",
        "Failed to parse the error object. The required 'code' property is missing."
      );
    }
    const enumValues = Object.values(ErrorCode$1);
    const codeIsKnown = enumValues.includes(error.code);
    if (!codeIsKnown) {
      throw new _FuelError(
        "parse-failed",
        `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`
      );
    }
    return new _FuelError(error.code, error.message);
  }
  toObject() {
    const { code: code2, name, message, metadata, VERSIONS, rawError } = this;
    return { code: code2, name, message, metadata, VERSIONS, rawError };
  }
};
var FuelError = _FuelError;
__publicField$3(FuelError, "CODES", ErrorCode$1);
var bn$2 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn$2.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$3.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN2.prototype._init = function init2(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le") return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number2.length; i2 += 3) {
          w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index) {
      var c2 = string2.charCodeAt(index);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index) {
      var r2 = parseHex4Bits(string2, index);
      if (index - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul2) {
      var r2 = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i2 = start; i2 < len; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul2;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul2, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word = parseBase(number2, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i2, number2.length, base2);
        for (i2 = 0; i2 < mod2; i2++) {
          pow3 *= base2;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone3() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
      } catch (e2) {
        BN2.prototype.inspect = inspect2;
      }
    } else {
      BN2.prototype.inspect = inspect2;
    }
    function inspect2() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret2 = this.words[0];
      if (this.length === 2) {
        ret2 += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret2 += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret2 : ret2;
    };
    BN2.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position2 = 0;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position2++] = word & 255;
        if (position2 < res.length) {
          res[position2++] = word >> 8 & 255;
        }
        if (position2 < res.length) {
          res[position2++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 < res.length) {
            res[position2++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 < res.length) {
        res[position2++] = carry;
        while (position2 < res.length) {
          res[position2++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position2 = res.length - 1;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position2--] = word & 255;
        if (position2 >= 0) {
          res[position2--] = word >> 8 & 255;
        }
        if (position2 >= 0) {
          res[position2--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 >= 0) {
            res[position2--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 >= 0) {
        res[position2--] = carry;
        while (position2 >= 0) {
          res[position2--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0) return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26) break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width2) {
      if (this.negative !== 0) {
        return this.abs().inotn(width2).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width2) {
      if (this.testn(width2 - 1)) {
        return this.notn(width2).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width2) {
      assert2(typeof width2 === "number" && width2 >= 0);
      var bytesNeeded = Math.ceil(width2 / 26) | 0;
      var bitsLeft = width2 % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width2) {
      return this.clone().inotn(width2);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add2(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul2(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow3(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0) return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0) break;
      }
      if (++i2 < w2.length) {
        for (var q3 = res.sqr(); i2 < w2.length; i2++, q3 = q3.sqr()) {
          if (w2[i2] === 0) continue;
          res = res.mul(q3);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0) ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q3 = 1 << r2;
      if (this.length <= s2) return false;
      var w2 = this.words[s2];
      return !!(w2 & q3);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs2() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
      var len = num.length + shift;
      var i2;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul2;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0) return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q3;
      if (mode2 !== "mod") {
        q3 = new BN2(null);
        q3.length = m2 + 1;
        q3.words = new Array(q3.length);
        for (var i2 = 0; i2 < q3.length; i2++) {
          q3.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q3) {
          q3.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj2 = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj2, j2);
        while (a2.negative !== 0) {
          qj2--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q3) {
          q3.words[j2] = qj2;
        }
      }
      if (q3) {
        q3._strip();
      }
      a2._strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q3 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B3 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B3.isOdd()) {
              A2.iadd(yp);
              B3.isub(xp);
            }
            A2.iushrn(1);
            B3.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B3.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B3);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd2() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q3 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q3;
        return this;
      }
      var carry = q3;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2) continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output2.words[i2] = input.words[i2];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev2 = input.words[9];
      output2.words[output2.length++] = prev2 & mask2;
      for (i2 = 10; i2 < input.length; i2++) {
        var next2 = input.words[i2] | 0;
        input.words[i2 - 10] = (next2 & mask2) << 4 | prev2 >>> 22;
        prev2 = next2;
      }
      prev2 >>>= 22;
      input.words[i2 - 10] = prev2;
      if (prev2 === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi2 = (num.words[i2] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i2] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name]) return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add2(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul2(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero()) return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow3);
      }
      var q3 = this.m.subn(1);
      var s2 = 0;
      while (!q3.isZero() && q3.andln(1) === 0) {
        s2++;
        q3.iushrn(1);
      }
      assert2(!q3.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q3);
      var r2 = this.pow(a2, q3.addn(1).iushrn(1));
      var t2 = this.pow(a2, q3);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow3(a2, num) {
      if (num.isZero()) return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0) return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul2(a2, b2) {
      if (a2.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$2);
var bnExports = bn$2.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
var DEFAULT_PRECISION = 9;
var DEFAULT_MIN_PRECISION = 3;
var DEFAULT_DECIMAL_UNITS = 9;
function toFixed(value2, options) {
  const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};
  const [valueUnits = "0", valueDecimals = "0"] = String(value2 || "0.0").split(".");
  const groupRegex = /(\d)(?=(\d{3})+\b)/g;
  const units = valueUnits.replace(groupRegex, "$1,");
  let decimals = valueDecimals.slice(0, precision);
  if (minPrecision < precision) {
    const trimmedDecimal = decimals.match(/.*[1-9]{1}/);
    const lastNonZeroIndex = (trimmedDecimal == null ? void 0 : trimmedDecimal[0].length) || 0;
    const keepChars = Math.max(minPrecision, lastNonZeroIndex);
    decimals = decimals.slice(0, keepChars);
  }
  const decimalPortion = decimals ? `.${decimals}` : "";
  return `${units}${decimalPortion}`;
}
var BN = class extends BN$1 {
  constructor(value2, base2, endian) {
    let bnValue = value2;
    let bnBase = base2;
    if (BN.isBN(value2)) {
      bnValue = value2.toArray();
    } else if (typeof value2 === "string" && value2.slice(0, 2) === "0x") {
      bnValue = value2.substring(2);
      bnBase = base2 || "hex";
    }
    super(bnValue == null ? 0 : bnValue, bnBase, endian);
    __publicField(this, "MAX_U64", "0xFFFFFFFFFFFFFFFF");
  }
  // ANCHOR: HELPERS
  // make sure we always include `0x` in hex strings
  toString(base2, length2) {
    const output2 = super.toString(base2, length2);
    if (base2 === 16 || base2 === "hex") {
      return `0x${output2}`;
    }
    return output2;
  }
  toHex(bytesPadding) {
    const bytes2 = bytesPadding || 0;
    const bytesLength = bytes2 * 2;
    if (this.isNeg()) {
      throw new FuelError(ErrorCode$1.CONVERTING_FAILED, "Cannot convert negative value to hex.");
    }
    if (bytesPadding && this.byteLength() > bytesPadding) {
      throw new FuelError(
        ErrorCode$1.CONVERTING_FAILED,
        `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`
      );
    }
    return this.toString(16, bytesLength);
  }
  toBytes(bytesPadding) {
    if (this.isNeg()) {
      throw new FuelError(ErrorCode$1.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
    }
    return Uint8Array.from(this.toArray(void 0, bytesPadding));
  }
  toJSON() {
    return this.toString(16);
  }
  valueOf() {
    return this.toString();
  }
  format(options) {
    const {
      units = DEFAULT_DECIMAL_UNITS,
      precision = DEFAULT_PRECISION,
      minPrecision = DEFAULT_MIN_PRECISION
    } = options || {};
    const formattedUnits = this.formatUnits(units);
    const formattedFixed = toFixed(formattedUnits, { precision, minPrecision });
    if (!parseFloat(formattedFixed)) {
      const [, originalDecimals = "0"] = formattedUnits.split(".");
      const firstNonZero = originalDecimals.match(/[1-9]/);
      if (firstNonZero && firstNonZero.index && firstNonZero.index + 1 > precision) {
        const [valueUnits = "0"] = formattedFixed.split(".");
        return `${valueUnits}.${originalDecimals.slice(0, firstNonZero.index + 1)}`;
      }
    }
    return formattedFixed;
  }
  formatUnits(units = DEFAULT_DECIMAL_UNITS) {
    const valueUnits = this.toString().slice(0, units * -1);
    const valueDecimals = this.toString().slice(units * -1);
    const length2 = valueDecimals.length;
    const defaultDecimals = Array.from({ length: units - length2 }).fill("0").join("");
    const integerPortion = valueUnits ? `${valueUnits}.` : "0.";
    return `${integerPortion}${defaultDecimals}${valueDecimals}`;
  }
  // END ANCHOR: HELPERS
  // ANCHOR: OVERRIDES to accept better inputs
  add(v2) {
    return this.caller(v2, "add");
  }
  pow(v2) {
    return this.caller(v2, "pow");
  }
  sub(v2) {
    return this.caller(v2, "sub");
  }
  div(v2) {
    return this.caller(v2, "div");
  }
  mul(v2) {
    return this.caller(v2, "mul");
  }
  mod(v2) {
    return this.caller(v2, "mod");
  }
  divRound(v2) {
    return this.caller(v2, "divRound");
  }
  lt(v2) {
    return this.caller(v2, "lt");
  }
  lte(v2) {
    return this.caller(v2, "lte");
  }
  gt(v2) {
    return this.caller(v2, "gt");
  }
  gte(v2) {
    return this.caller(v2, "gte");
  }
  eq(v2) {
    return this.caller(v2, "eq");
  }
  cmp(v2) {
    return this.caller(v2, "cmp");
  }
  // END ANCHOR: OVERRIDES to accept better inputs
  // ANCHOR: OVERRIDES to output our BN type
  sqr() {
    return new BN(super.sqr().toArray());
  }
  neg() {
    return new BN(super.neg().toArray());
  }
  abs() {
    return new BN(super.abs().toArray());
  }
  toTwos(width2) {
    return new BN(super.toTwos(width2).toArray());
  }
  fromTwos(width2) {
    return new BN(super.fromTwos(width2).toArray());
  }
  // END ANCHOR: OVERRIDES to output our BN type
  // ANCHOR: OVERRIDES to avoid losing references
  caller(v2, methodName) {
    const output2 = super[methodName](new BN(v2));
    if (BN.isBN(output2)) {
      return new BN(output2.toArray());
    }
    if (typeof output2 === "boolean") {
      return output2;
    }
    return output2;
  }
  clone() {
    return new BN(this.toArray());
  }
  mulTo(num, out) {
    const output2 = new BN$1(this.toArray()).mulTo(num, out);
    return new BN(output2.toArray());
  }
  egcd(p2) {
    const { a: a2, b: b2, gcd } = new BN$1(this.toArray()).egcd(p2);
    return {
      a: new BN(a2.toArray()),
      b: new BN(b2.toArray()),
      gcd: new BN(gcd.toArray())
    };
  }
  divmod(num, mode2, positive) {
    const { div, mod: mod2 } = new BN$1(this.toArray()).divmod(new BN(num), mode2, positive);
    return {
      div: new BN(div == null ? void 0 : div.toArray()),
      mod: new BN(mod2 == null ? void 0 : mod2.toArray())
    };
  }
  maxU64() {
    return this.gte(this.MAX_U64) ? new BN(this.MAX_U64) : this;
  }
  normalizeZeroToOne() {
    return this.isZero() ? new BN(1) : this;
  }
  // END ANCHOR: OVERRIDES to avoid losing references
};
var bn$1 = (value2, base2, endian) => new BN(value2, base2, endian);
bn$1.parseUnits = (value2, units = DEFAULT_DECIMAL_UNITS) => {
  const valueToParse = value2 === "." ? "0." : value2;
  const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
  const length2 = valueDecimals.length;
  if (length2 > units) {
    throw new FuelError(
      ErrorCode$1.CONVERTING_FAILED,
      `Decimal can't have more than ${units} digits.`
    );
  }
  const decimals = Array.from({ length: units }).fill("0");
  decimals.splice(0, length2, valueDecimals);
  const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
  return bn$1(amount);
};
function toNumber(value2) {
  return bn$1(value2).toNumber();
}
function toHex$1(value2, bytesPadding) {
  return bn$1(value2).toHex(bytesPadding);
}
function toBytes$2(value2, bytesPadding) {
  return bn$1(value2).toBytes(bytesPadding);
}
var __defProp$3 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value2) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField$2 = (obj, key, value2) => {
  __defNormalProp$2(obj, key + "", value2);
  return value2;
};
var chunkAndPadBytes = (bytes2, chunkSize) => {
  const chunks = [];
  for (let offset2 = 0; offset2 < bytes2.length; offset2 += chunkSize) {
    const chunk = new Uint8Array(chunkSize);
    chunk.set(bytes2.slice(offset2, offset2 + chunkSize));
    chunks.push(chunk);
  }
  const lastChunk = chunks[chunks.length - 1];
  const remainingBytes = bytes2.length % chunkSize;
  const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
  const newChunk = lastChunk.slice(0, paddedChunkLength);
  chunks[chunks.length - 1] = newChunk;
  return chunks;
};
var arrayify$1 = (value2, name, copy2 = true) => {
  if (value2 instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value2);
    }
    return value2;
  }
  if (typeof value2 === "string" && value2.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value2.length - 2) / 2);
    let offset2 = 2;
    for (let i2 = 0; i2 < result.length; i2++) {
      result[i2] = parseInt(value2.substring(offset2, offset2 + 2), 16);
      offset2 += 2;
    }
    return result;
  }
  const nameMessage = name ? ` ${name} -` : "";
  const message = `invalid data:${nameMessage} ${value2}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;
  throw new FuelError(ErrorCode$1.INVALID_DATA, message);
};
var concatBytes$4 = (arrays) => {
  const byteArrays = arrays.map((array2) => {
    if (array2 instanceof Uint8Array) {
      return array2;
    }
    return Uint8Array.from(array2);
  });
  const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
  const concatenated = new Uint8Array(totalSize);
  byteArrays.reduce((offset2, object) => {
    concatenated.set(object, offset2);
    return offset2 + object.length;
  }, 0);
  return concatenated;
};
var concat = (arrays) => {
  const bytes2 = arrays.map((v2) => arrayify$1(v2));
  return concatBytes$4(bytes2);
};
var HexCharacters = "0123456789abcdef";
function hexlify(data2) {
  const bytes2 = arrayify$1(data2);
  let result = "0x";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    const v2 = bytes2[i2];
    result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
  }
  return result;
}
var TAI64_LEAP_SECONDS = 37;
var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
var msToSeconds = (ms) => Math.floor(ms / 1e3);
var secondsToMs = (seconds) => seconds * 1e3;
var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
var _DateTime = class extends Date {
  /**
   * Generates a new DateTime instance from a Tai64 timestamp.
   *
   * @param tai64 - Tai64 timestamp
   * @returns a new DateTime instance
   */
  static fromTai64(tai64) {
    return new _DateTime(tai64ToUnixMilliseconds(tai64));
  }
  /**
   * @param unixMilliseconds - unix milliseconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixMilliseconds(unixMilliseconds) {
    return new _DateTime(unixMilliseconds);
  }
  /**
   * @param unixSeconds - unix seconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixSeconds(unixSeconds) {
    return new _DateTime(secondsToMs(unixSeconds));
  }
  /**
   * Hide the constructor to prevent direct instantiation.
   */
  constructor(date) {
    super(date);
  }
  /**
   * Returns the Tai64 timestamp.
   *
   * @returns the Tai64 timestamp
   */
  toTai64() {
    return unixSecondsToTai64(this.toUnixSeconds());
  }
  /**
   * @returns the unix milliseconds timestamp
   */
  toUnixMilliseconds() {
    return this.getTime();
  }
  /**
   * @returns the unix seconds timestamp
   */
  toUnixSeconds() {
    return msToSeconds(this.getTime());
  }
};
var DateTime = _DateTime;
__publicField$2(DateTime, "TAI64_NULL", "");
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
}
function isDefined(value2) {
  return value2 !== void 0;
}
var BN_0 = bn$1(0);
var BN_58 = bn$1(58);
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i2 = 0; i2 < Alphabet.length; i2++) {
      Lookup[Alphabet[i2]] = bn$1(i2);
    }
  }
  const result = Lookup[letter];
  if (result == null) {
    throw new FuelError(ErrorCode$1.INVALID_DATA, `invalid base58 value ${letter}`);
  }
  return bn$1(result);
}
function encodeBase58(_value) {
  const bytes2 = arrayify$1(_value);
  let value2 = bn$1(bytes2);
  let result = "";
  while (value2.gt(BN_0)) {
    result = Alphabet[Number(value2.mod(BN_58))] + result;
    value2 = value2.div(BN_58);
  }
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    if (bytes2[i2]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value2) {
  let result = BN_0;
  for (let i2 = 0; i2 < value2.length; i2++) {
    result = result.mul(BN_58);
    result = result.add(getAlpha(value2[i2].toString()));
  }
  return result;
}
function dataSlice(data2, start, end) {
  const bytes2 = arrayify$1(data2);
  if (end > bytes2.length) {
    throw new FuelError(ErrorCode$1.INVALID_DATA, "cannot slice beyond data bounds");
  }
  return hexlify(bytes2.slice(start, end));
}
function toUtf8Bytes(stri, form = true) {
  let str = stri;
  if (form) {
    str = stri.normalize("NFC");
  }
  const result = [];
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) === 55296) {
      i2 += 1;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new FuelError(
          ErrorCode$1.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function onError(reason, offset2, bytes2, output2, badCodepoint) {
  console.log(`invalid codepoint at offset ${offset2}; ${reason}, bytes: ${bytes2}`);
  return offset2;
}
function helper$1(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode(
      (codePoint >> 10 & 1023) + 55296,
      (codePoint & 1023) + 56320
    );
  }).join("");
}
function getUtf8CodePoints(_bytes) {
  const bytes2 = arrayify$1(_bytes, "bytes");
  const result = [];
  let i2 = 0;
  while (i2 < bytes2.length) {
    const c2 = bytes2[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError("UNEXPECTED_CONTINUE", i2 - 1, bytes2);
      } else {
        i2 += onError("BAD_PREFIX", i2 - 1, bytes2);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes2.length) {
      i2 += onError("OVERRUN", i2 - 1, bytes2);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      const nextChar = bytes2[i2];
      if ((nextChar & 192) !== 128) {
        i2 += onError("MISSING_CONTINUE", i2, bytes2);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError("OUT_OF_RANGE", i2 - 1 - extraLength, bytes2);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError("UTF16_SURROGATE", i2 - 1 - extraLength, bytes2);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError("OVERLONG", i2 - 1 - extraLength, bytes2);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8String(bytes2) {
  return helper$1(getUtf8CodePoints(bytes2));
}
function number$3(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error(`positive integer expected, not ${n3}`);
}
function isBytes$4(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes$1(b2, ...lengths) {
  if (!isBytes$4(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash$5(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$3(h2.outputLen);
  number$3(h2.blockLen);
}
function exists$1(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance2) {
  bytes$1(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
const rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
}
function utf8ToBytes$3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$3(data2);
  bytes$1(data2);
  return data2;
}
function concatBytes$3(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    bytes$1(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
let Hash$1 = class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$2(bytesLength = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues === "function") {
    return crypto$3.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$3 && typeof crypto$3.randomBytes === "function") {
    return crypto$3.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(view, byteOffset, value2, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value2 >> _32n2 & _u32_max);
  const wl = Number(value2 & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi$1 = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj$1 = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
let HashMD$1 = class HashMD extends Hash$1 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data2) {
    exists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = toBytes$1(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data2);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state2 = this.get();
    if (outLen > state2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state2[i2], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished: finished2, destroyed, pos } = this;
    to2.length = length2;
    to2.pos = pos;
    to2.finished = finished2;
    to2.destroyed = destroyed;
    if (length2 % blockLen)
      to2.buffer.set(buffer2);
    return to2;
  }
};
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$3 = class SHA256 extends HashMD$1 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV$1[0] | 0;
    this.B = SHA256_IV$1[1] | 0;
    this.C = SHA256_IV$1[2] | 0;
    this.D = SHA256_IV$1[3] | 0;
    this.E = SHA256_IV$1[4] | 0;
    this.F = SHA256_IV$1[5] | 0;
    this.G = SHA256_IV$1[6] | 0;
    this.H = SHA256_IV$1[7] | 0;
  }
  get() {
    const { A: A2, B: B3, C: C2, D: D2, E: E2, F: F3, G: G3, H: H2 } = this;
    return [A2, B3, C2, D2, E2, F3, G3, H2];
  }
  // prettier-ignore
  set(A2, B3, C2, D2, E2, F3, G3, H2) {
    this.A = A2 | 0;
    this.B = B3 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F3 | 0;
    this.G = G3 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4)
      SHA256_W$1[i2] = view.getUint32(offset2, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W$1[i2 - 15];
      const W2 = SHA256_W$1[i2 - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i2] = s1 + SHA256_W$1[i2 - 7] + s0 + SHA256_W$1[i2 - 16] | 0;
    }
    let { A: A2, B: B3, C: C2, D: D2, E: E2, F: F3, G: G3, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr$1(E2, 6) ^ rotr$1(E2, 11) ^ rotr$1(E2, 25);
      const T1 = H2 + sigma1 + Chi$1(E2, F3, G3) + SHA256_K$1[i2] + SHA256_W$1[i2] | 0;
      const sigma0 = rotr$1(A2, 2) ^ rotr$1(A2, 13) ^ rotr$1(A2, 22);
      const T2 = sigma0 + Maj$1(A2, B3, C2) | 0;
      H2 = G3;
      G3 = F3;
      F3 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B3;
      B3 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B3 = B3 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F3 = F3 + this.F | 0;
    G3 = G3 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B3, C2, D2, E2, F3, G3, H2);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$3());
let HMAC$1 = class HMAC extends Hash$1 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$5(hash2);
    const key = toBytes$1(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$1(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished2;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$2 = (hash2, key, message) => new HMAC$1(hash2, key).update(message).digest();
hmac$2.create = (hash2, key) => new HMAC$1(hash2, key);
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash$5(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number$3(c2);
  number$3(dkLen);
  number$3(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes$1(_password);
  const salt = toBytes$1(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac$2.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView$1(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti2.set(u2.subarray(0, Ti2.length));
    for (let ui2 = 1; ui2 < c2; ui2++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti2.length; i2++)
        Ti2[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
function XorAndSalsa(prev2, pi2, input, ii2, out, oi2) {
  let y00 = prev2[pi2++] ^ input[ii2++], y01 = prev2[pi2++] ^ input[ii2++];
  let y02 = prev2[pi2++] ^ input[ii2++], y03 = prev2[pi2++] ^ input[ii2++];
  let y04 = prev2[pi2++] ^ input[ii2++], y05 = prev2[pi2++] ^ input[ii2++];
  let y06 = prev2[pi2++] ^ input[ii2++], y07 = prev2[pi2++] ^ input[ii2++];
  let y08 = prev2[pi2++] ^ input[ii2++], y09 = prev2[pi2++] ^ input[ii2++];
  let y10 = prev2[pi2++] ^ input[ii2++], y11 = prev2[pi2++] ^ input[ii2++];
  let y12 = prev2[pi2++] ^ input[ii2++], y13 = prev2[pi2++] ^ input[ii2++];
  let y14 = prev2[pi2++] ^ input[ii2++], y15 = prev2[pi2++] ^ input[ii2++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i2 = 0; i2 < 8; i2 += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi2++] = y00 + x00 | 0;
  out[oi2++] = y01 + x01 | 0;
  out[oi2++] = y02 + x02 | 0;
  out[oi2++] = y03 + x03 | 0;
  out[oi2++] = y04 + x04 | 0;
  out[oi2++] = y05 + x05 | 0;
  out[oi2++] = y06 + x06 | 0;
  out[oi2++] = y07 + x07 | 0;
  out[oi2++] = y08 + x08 | 0;
  out[oi2++] = y09 + x09 | 0;
  out[oi2++] = y10 + x10 | 0;
  out[oi2++] = y11 + x11 | 0;
  out[oi2++] = y12 + x12 | 0;
  out[oi2++] = y13 + x13 | 0;
  out[oi2++] = y14 + x14 | 0;
  out[oi2++] = y15 + x15 | 0;
}
function BlockMix(input, ii2, out, oi2, r2) {
  let head = oi2 + 0;
  let tail = oi2 + 16 * r2;
  for (let i2 = 0; i2 < 16; i2++)
    out[tail + i2] = input[ii2 + (2 * r2 - 1) * 16 + i2];
  for (let i2 = 0; i2 < r2; i2++, head += 16, ii2 += 16) {
    XorAndSalsa(out, tail, input, ii2, out, head);
    if (i2 > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii2 += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r: r2, p: p2, dkLen, asyncTick, maxmem, onProgress } = opts;
  number$3(N2);
  number$3(r2);
  number$3(p2);
  number$3(dkLen);
  number$3(asyncTick);
  number$3(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p2 < 0 || p2 > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p2);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B3 = pbkdf2$1(sha256$3, password, salt, { c: 1, dkLen: blockSize * p2 });
  const B32 = u32$1(B3);
  const V2 = u32$1(new Uint8Array(blockSize * N2));
  const tmp = u32$1(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p2;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B3, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B3, V2, tmp) {
  const res = pbkdf2$1(sha256$3, password, B3, { c: 1, dkLen });
  B3.fill(0);
  V2.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B3, tmp, blockMixCb } = scryptInit(password, salt, opts);
  if (!isLE)
    byteSwap32(B32);
  for (let pi2 = 0; pi2 < p2; pi2++) {
    const Pi2 = blockSize32 * pi2;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V2[i2] = B32[Pi2 + i2];
    for (let i2 = 0, pos = 0; i2 < N2 - 1; i2++) {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    for (let i2 = 0; i2 < N2; i2++) {
      const j2 = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k2 = 0; k2 < blockSize32; k2++)
        tmp[k2] = B32[Pi2 + k2] ^ V2[j2 * blockSize32 + k2];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    }
  }
  if (!isLE)
    byteSwap32(B32);
  return scryptOutput(password, dkLen, B3, V2, tmp);
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n3, le2 = false) {
  if (le2)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le2);
    [Ah2[i2], Al[i2]] = [h2, l2];
  }
  return [Ah2, Al];
}
const toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
const shrSH = (h2, _l2, s2) => h2 >>> s2;
const shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
const rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
const rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
const rotr32H = (_h2, l2) => l2;
const rotr32L = (h2, _l2) => h2;
const rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
const rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
const rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
const rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
function add(Ah2, Al, Bh2, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
const u64$2 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n$9 = /* @__PURE__ */ BigInt(0);
const _1n$c = /* @__PURE__ */ BigInt(1);
const _2n$8 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R2 = _1n$c, x2 = 1, y2 = 0; round2 < 24; round2++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$9;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n$c ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n$8)
      t2 ^= _1n$c << (_1n$c << /* @__PURE__ */ BigInt(j2)) - _1n$c;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
const rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
const rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B3[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th2;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th2;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B3[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B3[(x2 + 2) % 10] & B3[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  B3.fill(0);
}
class Keccak extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$3(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists$1(this);
    const { blockLen, state: state2 } = this;
    data2 = toBytes$1(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state2[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$1(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number$3(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to2) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to2 || (to2 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to2.state32.set(this.state32);
    to2.pos = this.pos;
    to2.posOut = this.posOut;
    to2.finished = this.finished;
    to2.rounds = rounds;
    to2.suffix = suffix;
    to2.outputLen = outputLen;
    to2.enableXOF = enableXOF;
    to2.destroyed = this.destroyed;
    return to2;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_2, i2) => i2));
const Pi = /* @__PURE__ */ Id.map((i2) => (9 * i2 + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i2 = 0; i2 < 4; i2++)
  for (let j2 of [idxL, idxR])
    j2.push(j2[i2].map((k2) => Rho[k2]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr$1 = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f$8(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  else if (group === 1)
    return x2 & y2 | ~x2 & z2;
  else if (group === 2)
    return (x2 | ~y2) ^ z2;
  else if (group === 3)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
let RIPEMD160$1 = class RIPEMD160 extends HashMD$1 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4)
      R_BUF[i2] = view.getUint32(offset2, true);
    let al2 = this.h0 | 0, ar = al2, bl2 = this.h1 | 0, br2 = bl2, cl2 = this.h2 | 0, cr2 = cl2, dl2 = this.h3 | 0, dr2 = dl2, el2 = this.h4 | 0, er2 = el2;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr$1[group];
      const rl2 = idxL[group], rr2 = idxR[group];
      const sl2 = shiftsL[group], sr2 = shiftsR[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl2 = rotl(al2 + f$8(group, bl2, cl2, dl2) + R_BUF[rl2[i2]] + hbl, sl2[i2]) + el2 | 0;
        al2 = el2, el2 = dl2, dl2 = rotl(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr2 = rotl(ar + f$8(rGroup, br2, cr2, dr2) + R_BUF[rr2[i2]] + hbr, sr2[i2]) + er2 | 0;
        ar = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
      }
    }
    this.set(this.h1 + cl2 + dr2 | 0, this.h2 + dl2 + er2 | 0, this.h3 + el2 + ar | 0, this.h4 + al2 + br2 | 0, this.h0 + bl2 + cr2 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
const ripemd160$1 = /* @__PURE__ */ wrapConstructor$1(() => new RIPEMD160$1());
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64$2.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n3) => BigInt(n3))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
let SHA512$2 = class SHA512 extends HashMD$1 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    return [Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl];
  }
  // prettier-ignore
  set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl) {
    this.Ah = Ah2 | 0;
    this.Al = Al | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh2 | 0;
    this.El = El | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4) {
      SHA512_W_H[i2] = view.getUint32(offset2);
      SHA512_W_L[i2] = view.getUint32(offset2 += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64$2.rotrSH(W15h, W15l, 1) ^ u64$2.rotrSH(W15h, W15l, 8) ^ u64$2.shrSH(W15h, W15l, 7);
      const s0l = u64$2.rotrSL(W15h, W15l, 1) ^ u64$2.rotrSL(W15h, W15l, 8) ^ u64$2.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64$2.rotrSH(W2h, W2l, 19) ^ u64$2.rotrBH(W2h, W2l, 61) ^ u64$2.shrSH(W2h, W2l, 6);
      const s1l = u64$2.rotrSL(W2h, W2l, 19) ^ u64$2.rotrBL(W2h, W2l, 61) ^ u64$2.shrSL(W2h, W2l, 6);
      const SUMl = u64$2.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64$2.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64$2.rotrSH(Eh2, El, 14) ^ u64$2.rotrSH(Eh2, El, 18) ^ u64$2.rotrBH(Eh2, El, 41);
      const sigma1l = u64$2.rotrSL(Eh2, El, 14) ^ u64$2.rotrSL(Eh2, El, 18) ^ u64$2.rotrBL(Eh2, El, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64$2.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64$2.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64$2.rotrSH(Ah2, Al, 28) ^ u64$2.rotrBH(Ah2, Al, 34) ^ u64$2.rotrBH(Ah2, Al, 39);
      const sigma0l = u64$2.rotrSL(Ah2, Al, 28) ^ u64$2.rotrBL(Ah2, Al, 34) ^ u64$2.rotrBL(Ah2, Al, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh2 = Gh2 | 0;
      Hl = Gl | 0;
      Gh2 = Fh2 | 0;
      Gl = Fl | 0;
      Fh2 = Eh2 | 0;
      Fl = El | 0;
      ({ h: Eh2, l: El } = u64$2.add(Dh2 | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl = Cl | 0;
      Ch2 = Bh2 | 0;
      Cl = Bl | 0;
      Bh2 = Ah2 | 0;
      Bl = Al | 0;
      const All = u64$2.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64$2.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah2, l: Al } = u64$2.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al | 0));
    ({ h: Bh2, l: Bl } = u64$2.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl | 0));
    ({ h: Ch2, l: Cl } = u64$2.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl | 0));
    ({ h: Dh2, l: Dl } = u64$2.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl | 0));
    ({ h: Eh2, l: El } = u64$2.add(this.Eh | 0, this.El | 0, Eh2 | 0, El | 0));
    ({ h: Fh2, l: Fl } = u64$2.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl | 0));
    ({ h: Gh2, l: Gl } = u64$2.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl | 0));
    ({ h: Hh2, l: Hl } = u64$2.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl | 0));
    this.set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const sha512 = /* @__PURE__ */ wrapConstructor$1(() => new SHA512$2());
var scrypt = (params) => {
  const { password, salt, n: n3, p: p2, r: r2, dklen } = params;
  const derivedKey = scrypt$1(password, salt, { N: n3, r: r2, p: p2, dkLen: dklen });
  return derivedKey;
};
var keccak256 = (data2) => keccak_256(data2);
var locked = false;
var helper = (data2) => ripemd160$1(data2);
var ripemd$1 = helper;
function ripemd160(_data) {
  const data2 = arrayify$1(_data, "data");
  return ripemd$1(data2);
}
ripemd160._ = helper;
ripemd160.lock = () => {
  locked = true;
};
ripemd160.register = (func) => {
  if (locked) {
    throw new FuelError(ErrorCode$1.HASHER_LOCKED, "ripemd160 is locked");
  }
  ripemd$1 = func;
};
Object.freeze(ripemd160);
var bufferFromString = (string2, encoding2 = "base64") => {
  switch (encoding2) {
    case "utf-8": {
      return new TextEncoder().encode(string2);
    }
    case "base64": {
      const binaryString = atob(string2);
      const len = binaryString.length;
      const bytes2 = new Uint8Array(len).map((_2, i2) => binaryString.charCodeAt(i2));
      return bytes2;
    }
    case "hex":
    default: {
      const bufferLength = string2.length / 2;
      const buffer2 = new Uint8Array(bufferLength).map((_2, i2) => {
        const startIndex = i2 * 2;
        const byteValue = parseInt(string2.substring(startIndex, startIndex + 2), 16);
        return byteValue;
      });
      return buffer2;
    }
  }
};
var pbkdf2 = (password, salt, iterations, keylen, algo) => {
  const algorithm = { sha256: sha256$3, sha512 }[algo];
  return hexlify(pbkdf2$1(algorithm, password, salt, { c: iterations, dkLen: keylen }));
};
var { crypto: crypto2, btoa } = globalThis;
if (!crypto2) {
  throw new FuelError(
    ErrorCode$1.ENV_DEPENDENCY_MISSING,
    `Could not find 'crypto' in current browser environment.`
  );
}
if (!btoa) {
  throw new FuelError(
    ErrorCode$1.ENV_DEPENDENCY_MISSING,
    `Could not find 'btoa' in current browser environment.`
  );
}
var randomBytes$1 = (length2) => {
  const randomValues = crypto2.getRandomValues(new Uint8Array(length2));
  return randomValues;
};
var stringFromBuffer = (buffer2, encoding2 = "base64") => {
  switch (encoding2) {
    case "utf-8": {
      return new TextDecoder().decode(buffer2);
    }
    case "base64": {
      const binary = String.fromCharCode.apply(null, new Uint8Array(buffer2));
      return btoa(binary);
    }
    case "hex":
    default: {
      let hexString = "";
      for (let i2 = 0; i2 < buffer2.length; i2 += 1) {
        const hex = buffer2[i2].toString(16);
        hexString += hex.length === 1 ? `0${hex}` : hex;
      }
      return hexString;
    }
  }
};
var ALGORITHM = "AES-CTR";
var keyFromPassword = (password, saltBuffer) => {
  const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
  const key = pbkdf2(passBuffer, saltBuffer, 1e5, 32, "sha256");
  return arrayify$1(key);
};
var encrypt = async (password, data2) => {
  const iv = randomBytes$1(16);
  const salt = randomBytes$1(32);
  const secret = keyFromPassword(password, salt);
  const dataString = JSON.stringify(data2);
  const dataBuffer = bufferFromString(dataString, "utf-8");
  const alg = {
    name: ALGORITHM,
    counter: iv,
    length: 64
  };
  const key = await crypto.subtle.importKey("raw", secret, alg, false, ["encrypt"]);
  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);
  return {
    data: stringFromBuffer(new Uint8Array(encBuffer)),
    iv: stringFromBuffer(iv),
    salt: stringFromBuffer(salt)
  };
};
var decrypt = async (password, keystore) => {
  const iv = bufferFromString(keystore.iv);
  const salt = bufferFromString(keystore.salt);
  const secret = keyFromPassword(password, salt);
  const encryptedText = bufferFromString(keystore.data);
  const alg = {
    name: ALGORITHM,
    counter: iv,
    length: 64
  };
  const key = await crypto.subtle.importKey("raw", secret, alg, false, ["decrypt"]);
  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);
  const decryptedData = new TextDecoder().decode(ptBuffer);
  try {
    return JSON.parse(decryptedData);
  } catch {
    throw new FuelError(ErrorCode$1.INVALID_CREDENTIALS, "Invalid credentials.");
  }
};
var encryptJsonWalletData = async (data2, key, iv) => {
  const subtle = crypto2.subtle;
  const keyBuffer = new Uint8Array(key.subarray(0, 16));
  const ivBuffer = iv;
  const dataBuffer = data2;
  const cryptoKey = await subtle.importKey(
    "raw",
    keyBuffer,
    { name: "AES-CTR", length: 128 },
    false,
    ["encrypt", "decrypt"]
  );
  const encrypted = await subtle.encrypt(
    { name: "AES-CTR", counter: ivBuffer, length: 128 },
    cryptoKey,
    dataBuffer
  );
  return new Uint8Array(encrypted);
};
var decryptJsonWalletData = async (data2, key, iv) => {
  const subtle = crypto2.subtle;
  const keyBuffer = new Uint8Array(key.subarray(0, 16)).buffer;
  const ivBuffer = new Uint8Array(iv).buffer;
  const dataBuffer = new Uint8Array(data2).buffer;
  const cryptoKey = await subtle.importKey(
    "raw",
    keyBuffer,
    { name: "AES-CTR", length: 128 },
    false,
    ["encrypt", "decrypt"]
  );
  const decrypted = await subtle.decrypt(
    { name: "AES-CTR", counter: ivBuffer, length: 128 },
    cryptoKey,
    dataBuffer
  );
  return new Uint8Array(decrypted);
};
var computeHmac = (algorithm, key, data2) => {
  const hash2 = algorithm === "sha256" ? sha256$3 : sha512;
  const signature = hmac$2.create(hash2, key).update(data2).digest();
  return hexlify(signature);
};
var api$3 = {
  bufferFromString,
  stringFromBuffer,
  decrypt,
  encrypt,
  keyFromPassword,
  randomBytes: randomBytes$1,
  scrypt,
  keccak256,
  decryptJsonWalletData,
  encryptJsonWalletData,
  computeHmac,
  pbkdf2,
  ripemd160
};
var browser_default = api$3;
var {
  bufferFromString: bufferFromString2,
  decrypt: decrypt2,
  encrypt: encrypt2,
  keyFromPassword: keyFromPassword2,
  randomBytes: randomBytes2,
  stringFromBuffer: stringFromBuffer2,
  scrypt: scrypt2,
  keccak256: keccak2562,
  decryptJsonWalletData: decryptJsonWalletData2,
  encryptJsonWalletData: encryptJsonWalletData2,
  pbkdf2: pbkdf22,
  computeHmac: computeHmac2,
  ripemd160: ripemd1602
} = browser_default;
function sha256$2(data2) {
  return hexlify(sha256$3(arrayify$1(data2)));
}
function hash$4(data2) {
  return sha256$2(data2);
}
function uint64ToBytesBE(value2) {
  const bigIntValue = BigInt(value2);
  const buffer2 = new ArrayBuffer(8);
  const dataView = new DataView(buffer2);
  dataView.setBigUint64(0, bigIntValue, false);
  return new Uint8Array(dataView.buffer);
}
function hashMessage(msg) {
  return hash$4(bufferFromString2(msg, "utf-8"));
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value2) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField$1 = (obj, key, value2) => {
  __defNormalProp$1(obj, key + "", value2);
  return value2;
};
var Coder = class {
  constructor(name, type3, encodedLength) {
    __publicField(this, "name");
    __publicField(this, "type");
    __publicField(this, "encodedLength");
    this.name = name;
    this.type = type3;
    this.encodedLength = encodedLength;
  }
};
var U8_CODER_TYPE = "u8";
var U16_CODER_TYPE = "u16";
var U32_CODER_TYPE = "u32";
var U64_CODER_TYPE = "u64";
var U256_CODER_TYPE = "u256";
var RAW_PTR_CODER_TYPE = "raw untyped ptr";
var RAW_SLICE_CODER_TYPE = "raw untyped slice";
var BOOL_CODER_TYPE = "bool";
var B256_CODER_TYPE = "b256";
var B512_CODER_TYPE = "struct B512";
var OPTION_CODER_TYPE = "enum Option";
var VEC_CODER_TYPE = "struct Vec";
var BYTES_CODER_TYPE = "struct Bytes";
var STD_STRING_CODER_TYPE = "struct String";
var STR_SLICE_CODER_TYPE = "str";
var stringRegEx = /str\[(?<length>[0-9]+)\]/;
var arrayRegEx = /\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
var structRegEx = /^struct (?<name>\w+)$/;
var enumRegEx = /^enum (?<name>\w+)$/;
var tupleRegEx = /^\((?<items>.*)\)$/;
var genericRegEx = /^generic (?<name>\w+)$/;
var ENCODING_V1 = "1";
var WORD_SIZE = 8;
var BYTES_32 = 32;
var UTXO_ID_LEN = BYTES_32 + 2;
var ASSET_ID_LEN = BYTES_32;
var CONTRACT_ID_LEN = BYTES_32;
var MAX_BYTES = 2 ** 32 - 1;
var calculateVmTxMemory = ({ maxInputs }) => BYTES_32 + // Tx ID
ASSET_ID_LEN + // Base asset ID
// Asset ID/Balance coin input pairs
maxInputs * (ASSET_ID_LEN + WORD_SIZE) + WORD_SIZE;
var SCRIPT_FIXED_SIZE = WORD_SIZE + // Identifier
WORD_SIZE + // Gas limit
WORD_SIZE + // Script size
WORD_SIZE + // Script data size
WORD_SIZE + // Policies
WORD_SIZE + // Inputs size
WORD_SIZE + // Outputs size
WORD_SIZE + // Witnesses size
BYTES_32;
var isUint8Array = (value2) => value2 instanceof Uint8Array;
var hasNestedOption = (coders) => {
  const array2 = Array.isArray(coders) ? coders : Object.values(coders);
  for (const node2 of array2) {
    if (node2.type === OPTION_CODER_TYPE) {
      return true;
    }
    if ("coder" in node2 && node2.coder.type === OPTION_CODER_TYPE) {
      return true;
    }
    if ("coders" in node2) {
      const child = hasNestedOption(node2.coders);
      if (child) {
        return true;
      }
    }
  }
  return false;
};
var ArrayCoder = (_k = class extends Coder {
  constructor(coder, length2) {
    super("array", `[${coder.type}; ${length2}]`, length2 * coder.encodedLength);
    __publicField(this, "coder");
    __publicField(this, "length");
    __privateAdd(this, _hasNestedOption);
    this.coder = coder;
    this.length = length2;
    __privateSet(this, _hasNestedOption, hasNestedOption([coder]));
  }
  encode(value2) {
    if (!Array.isArray(value2)) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Expected array value.`);
    }
    if (this.length !== value2.length) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Types/values length mismatch.`);
    }
    return concat(Array.from(value2).map((v2) => this.coder.encode(v2)));
  }
  decode(data2, offset2) {
    if (!__privateGet(this, _hasNestedOption) && data2.length < this.encodedLength || data2.length > MAX_BYTES) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid array data size.`);
    }
    let newOffset = offset2;
    const decodedValue = Array(this.length).fill(0).map(() => {
      let decoded;
      [decoded, newOffset] = this.coder.decode(data2, newOffset);
      return decoded;
    });
    return [decodedValue, newOffset];
  }
}, _hasNestedOption = new WeakMap(), _k);
var B256Coder = class extends Coder {
  constructor() {
    super("b256", "b256", WORD_SIZE * 4);
  }
  encode(value2) {
    let encodedValue;
    try {
      encodedValue = arrayify$1(value2);
    } catch (error) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (encodedValue.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return encodedValue;
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid b256 data size.`);
    }
    let bytes2 = data2.slice(offset2, offset2 + this.encodedLength);
    const decoded = bn$1(bytes2);
    if (decoded.isZero()) {
      bytes2 = new Uint8Array(32);
    }
    if (bytes2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid b256 byte data size.`);
    }
    return [toHex$1(bytes2, 32), offset2 + 32];
  }
};
var B512Coder = class extends Coder {
  constructor() {
    super("b512", "struct B512", WORD_SIZE * 8);
  }
  encode(value2) {
    let encodedValue;
    try {
      encodedValue = arrayify$1(value2);
    } catch (error) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (encodedValue.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return encodedValue;
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid b512 data size.`);
    }
    let bytes2 = data2.slice(offset2, offset2 + this.encodedLength);
    const decoded = bn$1(bytes2);
    if (decoded.isZero()) {
      bytes2 = new Uint8Array(64);
    }
    if (bytes2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid b512 byte data size.`);
    }
    return [toHex$1(bytes2, this.encodedLength), offset2 + this.encodedLength];
  }
};
var encodedLengths = {
  u64: WORD_SIZE,
  u256: WORD_SIZE * 4
};
var BigNumberCoder = class extends Coder {
  constructor(baseType) {
    super("bigNumber", baseType, encodedLengths[baseType]);
  }
  encode(value2) {
    let bytes2;
    try {
      bytes2 = toBytes$2(value2, this.encodedLength);
    } catch (error) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return bytes2;
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid ${this.type} data size.`);
    }
    let bytes2 = data2.slice(offset2, offset2 + this.encodedLength);
    bytes2 = bytes2.slice(0, this.encodedLength);
    if (bytes2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid ${this.type} byte data size.`);
    }
    return [bn$1(bytes2), offset2 + this.encodedLength];
  }
};
var BooleanCoder = class extends Coder {
  constructor(options = {
    padToWordSize: false
  }) {
    const encodedLength = options.padToWordSize ? WORD_SIZE : 1;
    super("boolean", "boolean", encodedLength);
    __publicField(this, "options");
    this.options = options;
  }
  encode(value2) {
    const isTrueBool = value2 === true || value2 === false;
    if (!isTrueBool) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid boolean value.`);
    }
    return toBytes$2(value2 ? 1 : 0, this.encodedLength);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid boolean data size.`);
    }
    const bytes2 = bn$1(data2.slice(offset2, offset2 + this.encodedLength));
    if (bytes2.isZero()) {
      return [false, offset2 + this.encodedLength];
    }
    if (!bytes2.eq(bn$1(1))) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid boolean value.`);
    }
    return [true, offset2 + this.encodedLength];
  }
};
var ByteCoder = class extends Coder {
  constructor() {
    super("struct", "struct Bytes", WORD_SIZE);
  }
  encode(value2) {
    const bytes2 = value2 instanceof Uint8Array ? value2 : new Uint8Array(value2);
    const lengthBytes = new BigNumberCoder("u64").encode(bytes2.length);
    return new Uint8Array([...lengthBytes, ...bytes2]);
  }
  decode(data2, offset2) {
    if (data2.length < WORD_SIZE) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid byte data size.`);
    }
    const offsetAndLength = offset2 + WORD_SIZE;
    const lengthBytes = data2.slice(offset2, offsetAndLength);
    const length2 = bn$1(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
    const dataBytes = data2.slice(offsetAndLength, offsetAndLength + length2);
    if (dataBytes.length !== length2) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid bytes byte data size.`);
    }
    return [dataBytes, offsetAndLength + length2];
  }
};
__publicField$1(ByteCoder, "memorySize", 1);
var EnumCoder = (_l = class extends Coder {
  constructor(name, coders) {
    const caseIndexCoder = new BigNumberCoder("u64");
    const encodedValueSize = Object.values(coders).reduce(
      (min, coder) => Math.min(min, coder.encodedLength),
      0
    );
    super(`enum ${name}`, `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
    __privateAdd(this, _EnumCoder_instances);
    __publicField(this, "name");
    __publicField(this, "coders");
    __privateAdd(this, _caseIndexCoder);
    __privateAdd(this, _encodedValueSize);
    __privateAdd(this, _shouldValidateLength);
    this.name = name;
    this.coders = coders;
    __privateSet(this, _caseIndexCoder, caseIndexCoder);
    __privateSet(this, _encodedValueSize, encodedValueSize);
    __privateSet(this, _shouldValidateLength, !(this.type === OPTION_CODER_TYPE || hasNestedOption(coders)));
  }
  encode(value2) {
    if (typeof value2 === "string" && this.coders[value2]) {
      return __privateMethod(this, _EnumCoder_instances, encodeNativeEnum_fn).call(this, value2);
    }
    const [caseKey, ...empty2] = Object.keys(value2);
    if (!caseKey) {
      throw new FuelError(ErrorCode$1.INVALID_DECODE_VALUE, "A field for the case must be provided.");
    }
    if (empty2.length !== 0) {
      throw new FuelError(ErrorCode$1.INVALID_DECODE_VALUE, "Only one field must be provided.");
    }
    const valueCoder = this.coders[caseKey];
    const caseIndex = Object.keys(this.coders).indexOf(caseKey);
    if (caseIndex === -1) {
      const validCases = Object.keys(this.coders).map((v2) => `'${v2}'`).join(", ");
      throw new FuelError(
        ErrorCode$1.INVALID_DECODE_VALUE,
        `Invalid case '${caseKey}'. Valid cases: ${validCases}.`
      );
    }
    const encodedValue = valueCoder.encode(value2[caseKey]);
    return new Uint8Array([...__privateGet(this, _caseIndexCoder).encode(caseIndex), ...encodedValue]);
  }
  decode(data2, offset2) {
    if (__privateGet(this, _shouldValidateLength) && data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid enum data size.`);
    }
    const caseBytes = new BigNumberCoder("u64").decode(data2, offset2)[0];
    const caseIndex = toNumber(caseBytes);
    const caseKey = Object.keys(this.coders)[caseIndex];
    if (!caseKey) {
      throw new FuelError(
        ErrorCode$1.INVALID_DECODE_VALUE,
        `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`
      );
    }
    const valueCoder = this.coders[caseKey];
    const offsetAndCase = offset2 + __privateGet(this, _caseIndexCoder).encodedLength;
    if (__privateGet(this, _shouldValidateLength) && data2.length < offsetAndCase + valueCoder.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid enum data size.`);
    }
    const [decoded, newOffset] = valueCoder.decode(data2, offsetAndCase);
    if (__privateMethod(this, _EnumCoder_instances, isNativeEnum_fn).call(this, this.coders[caseKey])) {
      return __privateMethod(this, _EnumCoder_instances, decodeNativeEnum_fn).call(this, caseKey, newOffset);
    }
    return [{ [caseKey]: decoded }, newOffset];
  }
}, _caseIndexCoder = new WeakMap(), _encodedValueSize = new WeakMap(), _shouldValidateLength = new WeakMap(), _EnumCoder_instances = new WeakSet(), // We parse a native enum as an empty tuple, so we are looking for a tuple with no child coders.
// The '()' is enough but the child coders is a stricter check.
isNativeEnum_fn = function(coder) {
  if (this.type !== OPTION_CODER_TYPE && coder.type === "()") {
    const tupleCoder = coder;
    return tupleCoder.coders.length === 0;
  }
  return false;
}, encodeNativeEnum_fn = function(value2) {
  const valueCoder = this.coders[value2];
  const encodedValue = valueCoder.encode([]);
  const caseIndex = Object.keys(this.coders).indexOf(value2);
  const padding2 = new Uint8Array(__privateGet(this, _encodedValueSize) - valueCoder.encodedLength);
  return concat([__privateGet(this, _caseIndexCoder).encode(caseIndex), padding2, encodedValue]);
}, decodeNativeEnum_fn = function(caseKey, newOffset) {
  return [caseKey, newOffset];
}, _l);
var getLength = (baseType) => {
  switch (baseType) {
    case "u8":
      return 1;
    case "u16":
      return 2;
    case "u32":
      return 4;
    default:
      throw new FuelError(ErrorCode$1.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);
  }
};
var NumberCoder = class extends Coder {
  constructor(baseType, options = {
    padToWordSize: false
  }) {
    const length2 = options.padToWordSize ? WORD_SIZE : getLength(baseType);
    super("number", baseType, length2);
    __publicField(this, "baseType");
    __publicField(this, "options");
    this.baseType = baseType;
    this.options = options;
  }
  encode(value2) {
    let bytes2;
    try {
      bytes2 = toBytes$2(value2);
    } catch (error) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.baseType}.`);
    }
    if (bytes2.length > this.encodedLength) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
    }
    return toBytes$2(bytes2, this.encodedLength);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid number data size.`);
    }
    const bytes2 = data2.slice(offset2, offset2 + this.encodedLength);
    if (bytes2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid number byte data size.`);
    }
    return [toNumber(bytes2), offset2 + this.encodedLength];
  }
};
var OptionCoder = class extends EnumCoder {
  encode(value2) {
    const result = super.encode(this.toSwayOption(value2));
    return result;
  }
  toSwayOption(input) {
    if (input !== void 0) {
      return { Some: input };
    }
    return { None: [] };
  }
  decode(data2, offset2) {
    const [decoded, newOffset] = super.decode(data2, offset2);
    return [this.toOption(decoded), newOffset];
  }
  toOption(output2) {
    if (output2 && "Some" in output2) {
      return output2.Some;
    }
    return void 0;
  }
};
var RawSliceCoder = class extends Coder {
  constructor() {
    super("raw untyped slice", "raw untyped slice", WORD_SIZE);
  }
  encode(value2) {
    if (!Array.isArray(value2)) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Expected array value.`);
    }
    const internalCoder = new ArrayCoder(new NumberCoder("u8"), value2.length);
    const bytes2 = internalCoder.encode(value2);
    const lengthBytes = new BigNumberCoder("u64").encode(bytes2.length);
    return new Uint8Array([...lengthBytes, ...bytes2]);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid raw slice data size.`);
    }
    const offsetAndLength = offset2 + WORD_SIZE;
    const lengthBytes = data2.slice(offset2, offsetAndLength);
    const length2 = bn$1(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
    const dataBytes = data2.slice(offsetAndLength, offsetAndLength + length2);
    if (dataBytes.length !== length2) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid raw slice byte data size.`);
    }
    const internalCoder = new ArrayCoder(new NumberCoder("u8"), length2);
    const [decodedValue] = internalCoder.decode(dataBytes, 0);
    return [decodedValue, offsetAndLength + length2];
  }
};
var StdStringCoder = class extends Coder {
  constructor() {
    super("struct", "struct String", WORD_SIZE);
  }
  encode(value2) {
    const bytes2 = toUtf8Bytes(value2);
    const lengthBytes = new BigNumberCoder("u64").encode(value2.length);
    return new Uint8Array([...lengthBytes, ...bytes2]);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid std string data size.`);
    }
    const offsetAndLength = offset2 + WORD_SIZE;
    const lengthBytes = data2.slice(offset2, offsetAndLength);
    const length2 = bn$1(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
    const dataBytes = data2.slice(offsetAndLength, offsetAndLength + length2);
    if (dataBytes.length !== length2) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid std string byte data size.`);
    }
    return [toUtf8String(dataBytes), offsetAndLength + length2];
  }
};
__publicField$1(StdStringCoder, "memorySize", 1);
var StrSliceCoder = class extends Coder {
  constructor() {
    super("strSlice", "str", WORD_SIZE);
  }
  encode(value2) {
    const bytes2 = toUtf8Bytes(value2);
    const lengthBytes = new BigNumberCoder("u64").encode(value2.length);
    return new Uint8Array([...lengthBytes, ...bytes2]);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid string slice data size.`);
    }
    const offsetAndLength = offset2 + WORD_SIZE;
    const lengthBytes = data2.slice(offset2, offsetAndLength);
    const length2 = bn$1(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
    const bytes2 = data2.slice(offsetAndLength, offsetAndLength + length2);
    if (bytes2.length !== length2) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid string slice byte data size.`);
    }
    return [toUtf8String(bytes2), offsetAndLength + length2];
  }
};
__publicField$1(StrSliceCoder, "memorySize", 1);
var StringCoder = class extends Coder {
  constructor(length2) {
    super("string", `str[${length2}]`, length2);
  }
  encode(value2) {
    if (value2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Value length mismatch during encode.`);
    }
    return toUtf8Bytes(value2);
  }
  decode(data2, offset2) {
    if (data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid string data size.`);
    }
    const bytes2 = data2.slice(offset2, offset2 + this.encodedLength);
    if (bytes2.length !== this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid string byte data size.`);
    }
    return [toUtf8String(bytes2), offset2 + this.encodedLength];
  }
};
var StructCoder = (_m = class extends Coder {
  constructor(name, coders) {
    const encodedLength = Object.values(coders).reduce(
      (acc, coder) => acc + coder.encodedLength,
      0
    );
    super("struct", `struct ${name}`, encodedLength);
    __publicField(this, "name");
    __publicField(this, "coders");
    __privateAdd(this, _hasNestedOption2);
    this.name = name;
    this.coders = coders;
    __privateSet(this, _hasNestedOption2, hasNestedOption(coders));
  }
  encode(value2) {
    return concatBytes$4(
      Object.keys(this.coders).map((fieldName) => {
        const fieldCoder = this.coders[fieldName];
        const fieldValue = value2[fieldName];
        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
          throw new FuelError(
            ErrorCode$1.ENCODE_ERROR,
            `Invalid ${this.type}. Field "${fieldName}" not present.`
          );
        }
        return fieldCoder.encode(fieldValue);
      })
    );
  }
  decode(data2, offset2) {
    if (!__privateGet(this, _hasNestedOption2) && data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid struct data size.`);
    }
    let newOffset = offset2;
    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
      const fieldCoder = this.coders[fieldName];
      let decoded;
      [decoded, newOffset] = fieldCoder.decode(data2, newOffset);
      obj[fieldName] = decoded;
      return obj;
    }, {});
    return [decodedValue, newOffset];
  }
}, _hasNestedOption2 = new WeakMap(), _m);
var TupleCoder = (_n2 = class extends Coder {
  constructor(coders) {
    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
    super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
    __publicField(this, "coders");
    __privateAdd(this, _hasNestedOption3);
    this.coders = coders;
    __privateSet(this, _hasNestedOption3, hasNestedOption(coders));
  }
  encode(value2) {
    if (this.coders.length !== value2.length) {
      throw new FuelError(ErrorCode$1.ENCODE_ERROR, `Types/values length mismatch.`);
    }
    return concatBytes$4(this.coders.map((coder, i2) => coder.encode(value2[i2])));
  }
  decode(data2, offset2) {
    if (!__privateGet(this, _hasNestedOption3) && data2.length < this.encodedLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid tuple data size.`);
    }
    let newOffset = offset2;
    const decodedValue = this.coders.map((coder) => {
      let decoded;
      [decoded, newOffset] = coder.decode(data2, newOffset);
      return decoded;
    });
    return [decodedValue, newOffset];
  }
}, _hasNestedOption3 = new WeakMap(), _n2);
var VecCoder = (_o2 = class extends Coder {
  constructor(coder) {
    super("struct", `struct Vec`, WORD_SIZE);
    __publicField(this, "coder");
    __privateAdd(this, _hasNestedOption4);
    this.coder = coder;
    __privateSet(this, _hasNestedOption4, hasNestedOption([coder]));
  }
  encode(value2) {
    if (!Array.isArray(value2) && !isUint8Array(value2)) {
      throw new FuelError(
        ErrorCode$1.ENCODE_ERROR,
        `Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.`
      );
    }
    const lengthCoder = new BigNumberCoder("u64");
    if (isUint8Array(value2)) {
      return new Uint8Array([...lengthCoder.encode(value2.length), ...value2]);
    }
    const bytes2 = value2.map((v2) => this.coder.encode(v2));
    const lengthBytes = lengthCoder.encode(value2.length);
    return new Uint8Array([...lengthBytes, ...concatBytes$4(bytes2)]);
  }
  decode(data2, offset2) {
    if (!__privateGet(this, _hasNestedOption4) && data2.length < this.encodedLength || data2.length > MAX_BYTES) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid vec data size.`);
    }
    const offsetAndLength = offset2 + WORD_SIZE;
    const lengthBytes = data2.slice(offset2, offsetAndLength);
    const length2 = bn$1(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
    const dataLength = length2 * this.coder.encodedLength;
    const dataBytes = data2.slice(offsetAndLength, offsetAndLength + dataLength);
    if (!__privateGet(this, _hasNestedOption4) && dataBytes.length !== dataLength) {
      throw new FuelError(ErrorCode$1.DECODE_ERROR, `Invalid vec byte data size.`);
    }
    let newOffset = offsetAndLength;
    const chunks = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const [decoded, optionOffset] = this.coder.decode(data2, newOffset);
      chunks.push(decoded);
      newOffset = optionOffset;
    }
    return [chunks, newOffset];
  }
}, _hasNestedOption4 = new WeakMap(), _o2);
var getEncodingVersion = (encoding2) => {
  switch (encoding2) {
    case void 0:
    case ENCODING_V1:
      return ENCODING_V1;
    default:
      throw new FuelError(
        ErrorCode$1.UNSUPPORTED_ENCODING_VERSION,
        `Encoding version '${encoding2}' is unsupported.`
      );
  }
};
var findFunctionByName = (abi, name) => {
  const fn2 = abi.functions.find((f2) => f2.name === name);
  if (!fn2) {
    throw new FuelError(
      ErrorCode$1.FUNCTION_NOT_FOUND,
      `Function with name '${name}' doesn't exist in the ABI`
    );
  }
  return fn2;
};
var findTypeById = (abi, typeId) => {
  const type3 = abi.types.find((t2) => t2.typeId === typeId);
  if (!type3) {
    throw new FuelError(
      ErrorCode$1.TYPE_NOT_FOUND,
      `Type with typeId '${typeId}' doesn't exist in the ABI.`
    );
  }
  return type3;
};
var findNonEmptyInputs = (abi, inputs) => inputs.filter((input) => findTypeById(abi, input.type).type !== "()");
var findVectorBufferArgument = (components) => {
  var _a2;
  const bufferComponent = components.find((c2) => c2.name === "buf");
  const bufferTypeArgument = (_a2 = bufferComponent == null ? void 0 : bufferComponent.originalTypeArguments) == null ? void 0 : _a2[0];
  if (!bufferComponent || !bufferTypeArgument) {
    throw new FuelError(
      ErrorCode$1.INVALID_COMPONENT,
      `The Vec type provided is missing or has a malformed 'buf' component.`
    );
  }
  return bufferTypeArgument;
};
var ResolvedAbiType = class {
  constructor(abi, argument) {
    __publicField(this, "abi");
    __publicField(this, "name");
    __publicField(this, "type");
    __publicField(this, "originalTypeArguments");
    __publicField(this, "components");
    this.abi = abi;
    this.name = argument.name;
    const jsonABIType = findTypeById(abi, argument.type);
    if (jsonABIType.type.length > 256) {
      throw new FuelError(
        ErrorCode$1.INVALID_COMPONENT,
        `The provided ABI type is too long: ${jsonABIType.type}.`
      );
    }
    this.type = jsonABIType.type;
    this.originalTypeArguments = argument.typeArguments;
    this.components = ResolvedAbiType.getResolvedGenericComponents(
      abi,
      argument,
      jsonABIType.components,
      jsonABIType.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, jsonABIType.components)
    );
  }
  static getResolvedGenericComponents(abi, arg, components, typeParameters) {
    if (components === null) {
      return null;
    }
    if (typeParameters === null || typeParameters.length === 0) {
      return components.map((c2) => new ResolvedAbiType(abi, c2));
    }
    const typeParametersAndArgsMap = typeParameters.reduce(
      (obj, typeParameter, typeParameterIndex) => {
        var _a2;
        const o2 = { ...obj };
        o2[typeParameter] = structuredClone(
          (_a2 = arg.typeArguments) == null ? void 0 : _a2[typeParameterIndex]
        );
        return o2;
      },
      {}
    );
    const resolvedComponents = this.resolveGenericArgTypes(
      abi,
      components,
      typeParametersAndArgsMap
    );
    return resolvedComponents.map((c2) => new ResolvedAbiType(abi, c2));
  }
  static resolveGenericArgTypes(abi, args, typeParametersAndArgsMap) {
    return args.map((arg) => {
      if (typeParametersAndArgsMap[arg.type] !== void 0) {
        return {
          ...typeParametersAndArgsMap[arg.type],
          name: arg.name
        };
      }
      if (arg.typeArguments) {
        return {
          ...structuredClone(arg),
          typeArguments: this.resolveGenericArgTypes(
            abi,
            arg.typeArguments,
            typeParametersAndArgsMap
          )
        };
      }
      const argType = findTypeById(abi, arg.type);
      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);
      if (implicitTypeParameters && implicitTypeParameters.length > 0) {
        return {
          ...structuredClone(arg),
          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])
        };
      }
      return arg;
    });
  }
  static getImplicitGenericTypeParameters(abi, args, implicitGenericParametersParam) {
    if (!Array.isArray(args)) {
      return null;
    }
    const implicitGenericParameters = implicitGenericParametersParam ?? [];
    args.forEach((a2) => {
      const argType = findTypeById(abi, a2.type);
      if (genericRegEx.test(argType.type)) {
        implicitGenericParameters.push(argType.typeId);
        return;
      }
      if (!Array.isArray(a2.typeArguments)) {
        return;
      }
      this.getImplicitGenericTypeParameters(abi, a2.typeArguments, implicitGenericParameters);
    });
    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;
  }
  getSignature() {
    const prefix2 = this.getArgSignaturePrefix();
    const content = this.getArgSignatureContent();
    return `${prefix2}${content}`;
  }
  getArgSignaturePrefix() {
    const structMatch = structRegEx.test(this.type);
    if (structMatch) {
      return "s";
    }
    const arrayMatch = arrayRegEx.test(this.type);
    if (arrayMatch) {
      return "a";
    }
    const enumMatch = enumRegEx.test(this.type);
    if (enumMatch) {
      return "e";
    }
    return "";
  }
  getArgSignatureContent() {
    var _a2, _b2;
    if (this.type === "raw untyped ptr") {
      return "rawptr";
    }
    if (this.type === "raw untyped slice") {
      return "rawslice";
    }
    const strMatch = (_a2 = stringRegEx.exec(this.type)) == null ? void 0 : _a2.groups;
    if (strMatch) {
      return `str[${strMatch.length}]`;
    }
    if (this.components === null) {
      return this.type;
    }
    const arrayMatch = (_b2 = arrayRegEx.exec(this.type)) == null ? void 0 : _b2.groups;
    if (arrayMatch) {
      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;
    }
    const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a2) => new ResolvedAbiType(this.abi, a2).getSignature()).join(",")}>` : "";
    const componentsSignature = `(${this.components.map((c2) => c2.getSignature()).join(",")})`;
    return `${typeArgumentsSignature}${componentsSignature}`;
  }
};
function getCoders(components, options) {
  const { getCoder: getCoder2 } = options;
  return components.reduce((obj, component) => {
    const o2 = obj;
    o2[component.name] = getCoder2(component, options);
    return o2;
  }, {});
}
var getCoder = (resolvedAbiType, _options) => {
  var _a2, _b2, _c2, _d2, _e3;
  switch (resolvedAbiType.type) {
    case U8_CODER_TYPE:
    case U16_CODER_TYPE:
    case U32_CODER_TYPE:
      return new NumberCoder(resolvedAbiType.type);
    case U64_CODER_TYPE:
    case RAW_PTR_CODER_TYPE:
      return new BigNumberCoder("u64");
    case U256_CODER_TYPE:
      return new BigNumberCoder("u256");
    case RAW_SLICE_CODER_TYPE:
      return new RawSliceCoder();
    case BOOL_CODER_TYPE:
      return new BooleanCoder();
    case B256_CODER_TYPE:
      return new B256Coder();
    case B512_CODER_TYPE:
      return new B512Coder();
    case BYTES_CODER_TYPE:
      return new ByteCoder();
    case STD_STRING_CODER_TYPE:
      return new StdStringCoder();
    case STR_SLICE_CODER_TYPE:
      return new StrSliceCoder();
  }
  const stringMatch = (_a2 = stringRegEx.exec(resolvedAbiType.type)) == null ? void 0 : _a2.groups;
  if (stringMatch) {
    const length2 = parseInt(stringMatch.length, 10);
    return new StringCoder(length2);
  }
  const components = resolvedAbiType.components;
  const arrayMatch = (_b2 = arrayRegEx.exec(resolvedAbiType.type)) == null ? void 0 : _b2.groups;
  if (arrayMatch) {
    const length2 = parseInt(arrayMatch.length, 10);
    const arg = components[0];
    if (!arg) {
      throw new FuelError(
        ErrorCode$1.INVALID_COMPONENT,
        `The provided Array type is missing an item of 'component'.`
      );
    }
    const arrayElementCoder = getCoder(arg);
    return new ArrayCoder(arrayElementCoder, length2);
  }
  if (resolvedAbiType.type === VEC_CODER_TYPE) {
    const arg = findVectorBufferArgument(components);
    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
    const itemCoder = getCoder(argType);
    return new VecCoder(itemCoder);
  }
  const structMatch = (_c2 = structRegEx.exec(resolvedAbiType.type)) == null ? void 0 : _c2.groups;
  if (structMatch) {
    const coders = getCoders(components, { getCoder });
    return new StructCoder(structMatch.name, coders);
  }
  const enumMatch = (_d2 = enumRegEx.exec(resolvedAbiType.type)) == null ? void 0 : _d2.groups;
  if (enumMatch) {
    const coders = getCoders(components, { getCoder });
    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
    if (isOptionEnum) {
      return new OptionCoder(enumMatch.name, coders);
    }
    return new EnumCoder(enumMatch.name, coders);
  }
  const tupleMatch = (_e3 = tupleRegEx.exec(resolvedAbiType.type)) == null ? void 0 : _e3.groups;
  if (tupleMatch) {
    const coders = components.map((component) => getCoder(component));
    return new TupleCoder(coders);
  }
  throw new FuelError(
    ErrorCode$1.CODER_NOT_FOUND,
    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`
  );
};
function getCoderForEncoding(encoding2 = ENCODING_V1) {
  switch (encoding2) {
    case ENCODING_V1:
      return getCoder;
    default:
      throw new FuelError(
        ErrorCode$1.UNSUPPORTED_ENCODING_VERSION,
        `Encoding version ${encoding2} is unsupported.`
      );
  }
}
var AbiCoder = class {
  static getCoder(abi, argument, options = {
    padToWordSize: false
  }) {
    const resolvedAbiType = new ResolvedAbiType(abi, argument);
    return getCoderForEncoding(options.encoding)(resolvedAbiType, options);
  }
  static encode(abi, argument, value2, options) {
    return this.getCoder(abi, argument, options).encode(value2);
  }
  static decode(abi, argument, data2, offset2, options) {
    return this.getCoder(abi, argument, options).decode(data2, offset2);
  }
};
var FunctionFragment = class {
  constructor(jsonAbi, name) {
    __publicField(this, "signature");
    __publicField(this, "selector");
    __publicField(this, "selectorBytes");
    __publicField(this, "encoding");
    __publicField(this, "name");
    __publicField(this, "jsonFn");
    __publicField(this, "attributes");
    __publicField(this, "jsonAbi");
    this.jsonAbi = jsonAbi;
    this.jsonFn = findFunctionByName(this.jsonAbi, name);
    this.name = name;
    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);
    this.selector = FunctionFragment.getFunctionSelector(this.signature);
    this.selectorBytes = new StdStringCoder().encode(name);
    this.encoding = getEncodingVersion(jsonAbi.encoding);
    this.attributes = this.jsonFn.attributes ?? [];
  }
  static getSignature(abi, fn2) {
    const inputsSignatures = fn2.inputs.map(
      (input) => new ResolvedAbiType(abi, input).getSignature()
    );
    return `${fn2.name}(${inputsSignatures.join(",")})`;
  }
  static getFunctionSelector(functionSignature) {
    const hashedFunctionSignature = sha256$2(bufferFromString2(functionSignature, "utf-8"));
    return bn$1(hashedFunctionSignature.slice(0, 10)).toHex(8);
  }
  encodeArguments(values2) {
    FunctionFragment.verifyArgsAndInputsAlign(values2, this.jsonFn.inputs, this.jsonAbi);
    const shallowCopyValues = values2.slice();
    const nonEmptyInputs = findNonEmptyInputs(this.jsonAbi, this.jsonFn.inputs);
    if (Array.isArray(values2) && nonEmptyInputs.length !== values2.length) {
      shallowCopyValues.length = this.jsonFn.inputs.length;
      shallowCopyValues.fill(void 0, values2.length);
    }
    const coders = nonEmptyInputs.map(
      (t2) => AbiCoder.getCoder(this.jsonAbi, t2, {
        encoding: this.encoding
      })
    );
    return new TupleCoder(coders).encode(shallowCopyValues);
  }
  static verifyArgsAndInputsAlign(args, inputs, abi) {
    if (args.length === inputs.length) {
      return;
    }
    const inputTypes = inputs.map((input) => findTypeById(abi, input.type));
    const optionalInputs = inputTypes.filter(
      (x2) => x2.type === OPTION_CODER_TYPE || x2.type === "()"
    );
    if (optionalInputs.length === inputTypes.length) {
      return;
    }
    if (inputTypes.length - optionalInputs.length === args.length) {
      return;
    }
    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${args.length} arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${optionalInputs.length} optional inputs).`;
    throw new FuelError(ErrorCode$1.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);
  }
  decodeArguments(data2) {
    const bytes2 = arrayify$1(data2);
    const nonEmptyInputs = findNonEmptyInputs(this.jsonAbi, this.jsonFn.inputs);
    if (nonEmptyInputs.length === 0) {
      if (bytes2.length === 0) {
        return void 0;
      }
      throw new FuelError(
        ErrorCode$1.DECODE_ERROR,
        `Types/values length mismatch during decode. ${JSON.stringify({
          count: {
            types: this.jsonFn.inputs.length,
            nonEmptyInputs: nonEmptyInputs.length,
            values: bytes2.length
          },
          value: {
            args: this.jsonFn.inputs,
            nonEmptyInputs,
            values: bytes2
          }
        })}`
      );
    }
    const result = nonEmptyInputs.reduce(
      (obj, input) => {
        const coder = AbiCoder.getCoder(this.jsonAbi, input, { encoding: this.encoding });
        const [decodedValue, decodedValueByteSize] = coder.decode(bytes2, obj.offset);
        return {
          decoded: [...obj.decoded, decodedValue],
          offset: obj.offset + decodedValueByteSize
        };
      },
      { decoded: [], offset: 0 }
    );
    return result.decoded;
  }
  decodeOutput(data2) {
    const outputAbiType = findTypeById(this.jsonAbi, this.jsonFn.output.type);
    if (outputAbiType.type === "()") {
      return [void 0, 0];
    }
    const bytes2 = arrayify$1(data2);
    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output, {
      encoding: this.encoding
    });
    return coder.decode(bytes2, 0);
  }
  /**
   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.
   *
   * @returns True if the function is read-only or pure, false otherwise.
   */
  isReadOnly() {
    const storageAttribute = this.attributes.find((attr) => attr.name === "storage");
    return !(storageAttribute == null ? void 0 : storageAttribute.arguments.includes("write"));
  }
};
var Interface = class {
  constructor(jsonAbi) {
    __publicField(this, "functions");
    __publicField(this, "configurables");
    __publicField(this, "jsonAbi");
    __publicField(this, "encoding");
    this.jsonAbi = jsonAbi;
    this.encoding = getEncodingVersion(jsonAbi.encoding);
    this.functions = Object.fromEntries(
      this.jsonAbi.functions.map((x2) => [x2.name, new FunctionFragment(this.jsonAbi, x2.name)])
    );
    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x2) => [x2.name, x2]));
  }
  /**
   * Returns function fragment for a dynamic input.
   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
   */
  getFunction(nameOrSignatureOrSelector) {
    const fn2 = Object.values(this.functions).find(
      (f2) => f2.name === nameOrSignatureOrSelector || f2.signature === nameOrSignatureOrSelector || f2.selector === nameOrSignatureOrSelector
    );
    if (fn2 !== void 0) {
      return fn2;
    }
    throw new FuelError(
      ErrorCode$1.FUNCTION_NOT_FOUND,
      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn2)}.`
    );
  }
  // Decode the result of a function call
  decodeFunctionResult(functionFragment, data2) {
    const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
    return fragment.decodeOutput(data2);
  }
  decodeLog(data2, logId) {
    const loggedType = this.jsonAbi.loggedTypes.find((type3) => type3.logId === logId);
    if (!loggedType) {
      throw new FuelError(
        ErrorCode$1.LOG_TYPE_NOT_FOUND,
        `Log type with logId '${logId}' doesn't exist in the ABI.`
      );
    }
    return AbiCoder.decode(this.jsonAbi, loggedType.loggedType, arrayify$1(data2), 0, {
      encoding: this.encoding
    });
  }
  encodeConfigurable(name, value2) {
    const configurable = this.jsonAbi.configurables.find((c2) => c2.name === name);
    if (!configurable) {
      throw new FuelError(
        ErrorCode$1.CONFIGURABLE_NOT_FOUND,
        `A configurable with the '${name}' was not found in the ABI.`
      );
    }
    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value2, {
      encoding: this.encoding
    });
  }
  getTypeById(typeId) {
    return findTypeById(this.jsonAbi, typeId);
  }
};
var AbstractAddress = class {
};
var AbstractAccount = class {
};
var AbstractProgram = class {
};
var AbstractContract = class extends AbstractProgram {
};
var AbstractScript = class extends AbstractProgram {
};
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: true });
var bech32m = dist$1.bech32m = dist$1.bech32 = void 0;
const ALPHABET$2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
const ALPHABET_MAP = {};
for (let z2 = 0; z2 < ALPHABET$2.length; z2++) {
  const x2 = ALPHABET$2.charAt(z2);
  ALPHABET_MAP[x2] = z2;
}
function polymodStep(pre) {
  const b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix2) {
  let chk = 1;
  for (let i2 = 0; i2 < prefix2.length; ++i2) {
    const c2 = prefix2.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix2 + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (let i2 = 0; i2 < prefix2.length; ++i2) {
    const v2 = prefix2.charCodeAt(i2);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function convert(data2, inBits, outBits, pad2) {
  let value2 = 0;
  let bits = 0;
  const maxV = (1 << outBits) - 1;
  const result = [];
  for (let i2 = 0; i2 < data2.length; ++i2) {
    value2 = value2 << inBits | data2[i2];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value2 >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value2 << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value2 << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWords(bytes2) {
  return convert(bytes2, 8, 5, true);
}
function fromWordsUnsafe(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function getLibraryFromEncoding(encoding2) {
  let ENCODING_CONST;
  if (encoding2 === "bech32") {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 734539939;
  }
  function encode4(prefix2, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix2.length + 7 + words.length > LIMIT)
      throw new TypeError("Exceeds length limit");
    prefix2 = prefix2.toLowerCase();
    let chk = prefixChk(prefix2);
    if (typeof chk === "string")
      throw new Error(chk);
    let result = prefix2 + "1";
    for (let i2 = 0; i2 < words.length; ++i2) {
      const x2 = words[i2];
      if (x2 >> 5 !== 0)
        throw new Error("Non 5-bit word");
      chk = polymodStep(chk) ^ x2;
      result += ALPHABET$2.charAt(x2);
    }
    for (let i2 = 0; i2 < 6; ++i2) {
      chk = polymodStep(chk);
    }
    chk ^= ENCODING_CONST;
    for (let i2 = 0; i2 < 6; ++i2) {
      const v2 = chk >> (5 - i2) * 5 & 31;
      result += ALPHABET$2.charAt(v2);
    }
    return result;
  }
  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8)
      return str + " too short";
    if (str.length > LIMIT)
      return "Exceeds length limit";
    const lowered = str.toLowerCase();
    const uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered)
      return "Mixed-case string " + str;
    str = lowered;
    const split2 = str.lastIndexOf("1");
    if (split2 === -1)
      return "No separator character for " + str;
    if (split2 === 0)
      return "Missing prefix for " + str;
    const prefix2 = str.slice(0, split2);
    const wordChars = str.slice(split2 + 1);
    if (wordChars.length < 6)
      return "Data too short";
    let chk = prefixChk(prefix2);
    if (typeof chk === "string")
      return chk;
    const words = [];
    for (let i2 = 0; i2 < wordChars.length; ++i2) {
      const c2 = wordChars.charAt(i2);
      const v2 = ALPHABET_MAP[c2];
      if (v2 === void 0)
        return "Unknown character " + c2;
      chk = polymodStep(chk) ^ v2;
      if (i2 + 6 >= wordChars.length)
        continue;
      words.push(v2);
    }
    if (chk !== ENCODING_CONST)
      return "Invalid checksum for " + str;
    return { prefix: prefix2, words };
  }
  function decodeUnsafe(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
  }
  function decode3(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
    throw new Error(res);
  }
  return {
    decodeUnsafe,
    decode: decode3,
    encode: encode4,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist$1.bech32 = getLibraryFromEncoding("bech32");
bech32m = dist$1.bech32m = getLibraryFromEncoding("bech32m");
var FUEL_BECH32_HRP_PREFIX = "fuel";
function fromBech32(address) {
  return bech32m.decode(address);
}
function toBech32(address) {
  return bech32m.encode(
    FUEL_BECH32_HRP_PREFIX,
    bech32m.toWords(arrayify$1(hexlify(address)))
  );
}
function isBech32(address) {
  return typeof address === "string" && address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address).prefix === FUEL_BECH32_HRP_PREFIX;
}
function isB256(address) {
  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
}
function isPublicKey(address) {
  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
}
function isEvmAddress(address) {
  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
}
function getBytesFromBech32(address) {
  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));
}
function toB256(address) {
  if (!isBech32(address)) {
    throw new FuelError(
      FuelError.CODES.INVALID_BECH32_ADDRESS,
      `Invalid Bech32 Address: ${address}.`
    );
  }
  return hexlify(getBytesFromBech32(address));
}
function normalizeBech32(address) {
  const { words } = fromBech32(address);
  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
}
var addressify = (addressLike) => {
  if (addressLike instanceof AbstractAccount) {
    return addressLike.address;
  }
  if (addressLike instanceof AbstractContract) {
    return addressLike.id;
  }
  return addressLike;
};
var getRandomB256 = () => hexlify(randomBytes2(32));
var clearFirst12BytesFromB256 = (b256) => {
  let bytes2;
  try {
    if (!isB256(b256)) {
      throw new FuelError(
        FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${b256}.`
      );
    }
    bytes2 = getBytesFromBech32(toBech32(b256));
    bytes2 = hexlify(bytes2.fill(0, 0, 12));
  } catch (error) {
    throw new FuelError(
      FuelError.CODES.PARSE_FAILED,
      `Cannot generate EVM Address B256 from: ${b256}.`
    );
  }
  return bytes2;
};
var padFirst12BytesOfEvmAddress = (address) => {
  if (!isEvmAddress(address)) {
    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
  }
  return address.replace("0x", "0x000000000000000000000000");
};
var Address = class extends AbstractAddress {
  // #endregion address-2
  /**
   * @param address - A Bech32 address
   */
  constructor(address) {
    super();
    // #region address-2
    __publicField(this, "bech32Address");
    this.bech32Address = normalizeBech32(address);
    if (!isBech32(this.bech32Address)) {
      throw new FuelError(
        FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${address}.`
      );
    }
  }
  /**
   * Returns the `bech32Address` property
   *
   * @returns The `bech32Address` property
   */
  toAddress() {
    return this.bech32Address;
  }
  /**
   * Converts and returns the `bech32Address` property to a 256 bit hash string
   *
   * @returns The `bech32Address` property as a 256 bit hash string
   */
  toB256() {
    return toB256(this.bech32Address);
  }
  /**
   * Converts and returns the `bech32Address` property to a byte array
   *
   * @returns The `bech32Address` property as a byte array
   */
  toBytes() {
    return getBytesFromBech32(this.bech32Address);
  }
  /**
   * Converts
   *
   * @returns The `bech32Address` property as a 256 bit hash string
   */
  toHexString() {
    return this.toB256();
  }
  /**
   * Converts and returns the `bech32Address` property as a string
   *
   * @returns The `bech32Address` property as a string
   */
  toString() {
    return this.bech32Address;
  }
  /**
   * Converts and returns the `bech32Address` property as a string
   *
   * @returns The `bech32Address` property as a string
   */
  toJSON() {
    return this.bech32Address;
  }
  /**
   * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
   *
   * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
   */
  toEvmAddress() {
    const b256Address = toB256(this.bech32Address);
    return {
      bits: clearFirst12BytesFromB256(b256Address)
    };
  }
  /**
   * Wraps the `bech32Address` property and returns as an `AssetId`.
   *
   * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
   */
  toAssetId() {
    return {
      bits: this.toB256()
    };
  }
  /**
   * Returns the value of the `bech32Address` property
   *
   * @returns The value of `bech32Address` property
   */
  valueOf() {
    return this.bech32Address;
  }
  /**
   * Compares this the `bech32Address` property to another for direct equality
   *
   * @param other - Another address to compare against
   * @returns The equality of the comparison
   */
  equals(other) {
    return this.bech32Address === other.bech32Address;
  }
  /**
   * Takes a Public Key, hashes it, and creates an `Address`
   *
   * @param publicKey - A wallets public key
   * @returns A new `Address` instance
   */
  static fromPublicKey(publicKey2) {
    if (!isPublicKey(publicKey2)) {
      throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey2}.`);
    }
    const b256Address = hexlify(sha256$3(arrayify$1(publicKey2)));
    return new Address(toBech32(b256Address));
  }
  /**
   * Takes a B256 Address and creates an `Address`
   *
   * @param b256Address - A b256 hash
   * @returns A new `Address` instance
   */
  static fromB256(b256Address) {
    if (!isB256(b256Address)) {
      throw new FuelError(
        FuelError.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${b256Address}.`
      );
    }
    return new Address(toBech32(b256Address));
  }
  /**
   * Creates an `Address` with a randomized `bech32Address` property
   *
   * @returns A new `Address` instance
   */
  static fromRandom() {
    return this.fromB256(getRandomB256());
  }
  /**
   * Takes an ambiguous string and attempts to create an `Address`
   *
   * @param address - An ambiguous string
   * @returns A new `Address` instance
   */
  static fromString(address) {
    return isBech32(address) ? new Address(address) : this.fromB256(address);
  }
  /**
   * Takes an ambiguous string or address and creates an `Address`
   *
   * @returns a new `Address` instance
   */
  static fromAddressOrString(address) {
    return typeof address === "string" ? this.fromString(address) : address;
  }
  /**
   * Takes a dynamic string or `AbstractAddress` and creates an `Address`
   *
   * @param addressId - A string containing Bech32, B256, or Public Key
   * @throws Error - Unknown address if the format is not recognised
   * @returns A new `Address` instance
   */
  static fromDynamicInput(address) {
    if (typeof address !== "string" && "toB256" in address) {
      return Address.fromB256(address.toB256());
    }
    if (isPublicKey(address)) {
      return Address.fromPublicKey(address);
    }
    if (isBech32(address)) {
      return new Address(address);
    }
    if (isB256(address)) {
      return Address.fromB256(address);
    }
    if (isEvmAddress(address)) {
      return Address.fromEvmAddress(address);
    }
    throw new FuelError(
      FuelError.CODES.PARSE_FAILED,
      `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`
    );
  }
  /**
   * Takes an Evm Address and returns back an `Address`
   *
   * @returns A new `Address` instance
   */
  static fromEvmAddress(evmAddress) {
    if (!isEvmAddress(evmAddress)) {
      throw new FuelError(
        FuelError.CODES.INVALID_EVM_ADDRESS,
        `Invalid Evm Address: ${evmAddress}.`
      );
    }
    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
    return new Address(toBech32(paddedAddress));
  }
};
function _isPlaceholder(a2) {
  return a2 != null && typeof a2 === "object" && a2["@@functional/placeholder"] === true;
}
function _curry1(fn2) {
  return function f1(a2) {
    if (arguments.length === 0 || _isPlaceholder(a2)) {
      return f1;
    } else {
      return fn2.apply(this, arguments);
    }
  };
}
var type$2 = /* @__PURE__ */ _curry1(function type(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
}
function _clone(value2, deep, map2) {
  map2 || (map2 = new _ObjectMap());
  if (_isPrimitive(value2)) {
    return value2;
  }
  var copy2 = function copy3(copiedValue) {
    var cachedCopy = map2.get(value2);
    if (cachedCopy) {
      return cachedCopy;
    }
    map2.set(value2, copiedValue);
    for (var key in value2) {
      if (Object.prototype.hasOwnProperty.call(value2, key)) {
        copiedValue[key] = _clone(value2[key], true, map2);
      }
    }
    return copiedValue;
  };
  switch (type$2(value2)) {
    case "Object":
      return copy2(Object.create(Object.getPrototypeOf(value2)));
    case "Array":
      return copy2(Array(value2.length));
    case "Date":
      return new Date(value2.valueOf());
    case "RegExp":
      return _cloneRegExp(value2);
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      return value2.slice();
    default:
      return value2;
  }
}
function _isPrimitive(param) {
  var type3 = typeof param;
  return param == null || type3 != "object" && type3 != "function";
}
var _ObjectMap = /* @__PURE__ */ function() {
  function _ObjectMap2() {
    this.map = {};
    this.length = 0;
  }
  _ObjectMap2.prototype.set = function(key, value2) {
    var hashedKey = this.hash(key);
    var bucket = this.map[hashedKey];
    if (!bucket) {
      this.map[hashedKey] = bucket = [];
    }
    bucket.push([key, value2]);
    this.length += 1;
  };
  _ObjectMap2.prototype.hash = function(key) {
    var hashedKey = [];
    for (var value2 in key) {
      hashedKey.push(Object.prototype.toString.call(key[value2]));
    }
    return hashedKey.join();
  };
  _ObjectMap2.prototype.get = function(key) {
    if (this.length <= 180) {
      for (var p2 in this.map) {
        var bucket = this.map[p2];
        for (var i2 = 0; i2 < bucket.length; i2 += 1) {
          var element = bucket[i2];
          if (element[0] === key) {
            return element[1];
          }
        }
      }
      return;
    }
    var hashedKey = this.hash(key);
    var bucket = this.map[hashedKey];
    if (!bucket) {
      return;
    }
    for (var i2 = 0; i2 < bucket.length; i2 += 1) {
      var element = bucket[i2];
      if (element[0] === key) {
        return element[1];
      }
    }
  };
  return _ObjectMap2;
}();
var clone$1 = /* @__PURE__ */ _curry1(function clone(value2) {
  return value2 != null && typeof value2.clone === "function" ? value2.clone() : _clone(value2);
});
var ByteArrayCoder = (_p = class extends Coder {
  constructor(length2) {
    const paddingLength = (8 - length2 % 8) % 8;
    const encodedLength = length2 + paddingLength;
    super(
      "ByteArray",
      // While this might sound like a [u8; N] coder it's actually not.
      // A [u8; N] coder would pad every u8 to 8 bytes which would
      // make every u8 have the same size as a u64.
      // We are packing four u8s into u64s here, avoiding this padding.
      `[u64; ${encodedLength / 4}]`,
      encodedLength
    );
    __publicField(this, "length");
    __privateAdd(this, _paddingLength);
    this.length = length2;
    __privateSet(this, _paddingLength, paddingLength);
  }
  encode(value2) {
    const parts2 = [];
    const data2 = arrayify$1(value2);
    parts2.push(data2);
    if (__privateGet(this, _paddingLength)) {
      parts2.push(new Uint8Array(__privateGet(this, _paddingLength)));
    }
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = [hexlify(data2.slice(o2, o2 + this.length)), o2 + this.length];
    const value2 = decoded;
    if (__privateGet(this, _paddingLength)) {
      [decoded, o2] = [null, o2 + __privateGet(this, _paddingLength)];
    }
    return [value2, o2];
  }
}, _paddingLength = new WeakMap(), _p);
var TxPointerCoder = class extends StructCoder {
  constructor() {
    super("TxPointer", {
      blockHeight: new NumberCoder("u32", { padToWordSize: true }),
      txIndex: new NumberCoder("u16", { padToWordSize: true })
    });
  }
};
var InputType = /* @__PURE__ */ ((InputType2) => {
  InputType2[InputType2["Coin"] = 0] = "Coin";
  InputType2[InputType2["Contract"] = 1] = "Contract";
  InputType2[InputType2["Message"] = 2] = "Message";
  return InputType2;
})(InputType || {});
var InputCoinCoder = class extends Coder {
  constructor() {
    super("InputCoin", "struct InputCoin", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.txID));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputIndex));
    parts2.push(new B256Coder().encode(value2.owner));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new B256Coder().encode(value2.assetId));
    parts2.push(new TxPointerCoder().encode(value2.txPointer));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessIndex));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateGasUsed));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateLength));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateDataLength));
    parts2.push(new ByteArrayCoder(value2.predicateLength.toNumber()).encode(value2.predicate));
    parts2.push(
      new ByteArrayCoder(value2.predicateDataLength.toNumber()).encode(value2.predicateData)
    );
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const txID = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputIndex = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const owner = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const assetId = decoded;
    [decoded, o2] = new TxPointerCoder().decode(data2, o2);
    const txPointer = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessIndex = Number(decoded);
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateGasUsed = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateLength = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateDataLength = decoded;
    [decoded, o2] = new ByteArrayCoder(predicateLength.toNumber()).decode(data2, o2);
    const predicate = decoded;
    [decoded, o2] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data2, o2);
    const predicateData = decoded;
    return [
      {
        type: 0,
        txID,
        outputIndex,
        owner,
        amount,
        assetId,
        txPointer,
        witnessIndex,
        predicateGasUsed,
        predicateLength,
        predicateDataLength,
        predicate,
        predicateData
      },
      o2
    ];
  }
};
var InputContractCoder = class extends Coder {
  constructor() {
    super("InputContract", "struct InputContract", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.txID));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputIndex));
    parts2.push(new B256Coder().encode(value2.balanceRoot));
    parts2.push(new B256Coder().encode(value2.stateRoot));
    parts2.push(new TxPointerCoder().encode(value2.txPointer));
    parts2.push(new B256Coder().encode(value2.contractID));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const txID = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputIndex = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const balanceRoot = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const stateRoot = decoded;
    [decoded, o2] = new TxPointerCoder().decode(data2, o2);
    const txPointer = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const contractID = decoded;
    return [
      {
        type: 1,
        txID,
        outputIndex,
        balanceRoot,
        stateRoot,
        txPointer,
        contractID
      },
      o2
    ];
  }
};
var InputMessageCoder = class extends Coder {
  constructor() {
    super("InputMessage", "struct InputMessage", 0);
  }
  static getMessageId(value2) {
    const parts2 = [];
    parts2.push(new ByteArrayCoder(32).encode(value2.sender));
    parts2.push(new ByteArrayCoder(32).encode(value2.recipient));
    parts2.push(new ByteArrayCoder(32).encode(value2.nonce));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(arrayify$1(value2.data || "0x"));
    return sha256$2(concat(parts2));
  }
  static encodeData(messageData) {
    const bytes2 = arrayify$1(messageData || "0x");
    const dataLength = bytes2.length;
    return new ByteArrayCoder(dataLength).encode(bytes2);
  }
  encode(value2) {
    const parts2 = [];
    const data2 = InputMessageCoder.encodeData(value2.data);
    parts2.push(new ByteArrayCoder(32).encode(value2.sender));
    parts2.push(new ByteArrayCoder(32).encode(value2.recipient));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new ByteArrayCoder(32).encode(value2.nonce));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessIndex));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateGasUsed));
    parts2.push(new BigNumberCoder("u64").encode(data2.length));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateLength));
    parts2.push(new BigNumberCoder("u64").encode(value2.predicateDataLength));
    parts2.push(new ByteArrayCoder(data2.length).encode(data2));
    parts2.push(new ByteArrayCoder(value2.predicateLength.toNumber()).encode(value2.predicate));
    parts2.push(
      new ByteArrayCoder(value2.predicateDataLength.toNumber()).encode(value2.predicateData)
    );
    return concat(parts2);
  }
  static decodeData(messageData) {
    const bytes2 = arrayify$1(messageData);
    const dataLength = bytes2.length;
    const [data2] = new ByteArrayCoder(dataLength).decode(bytes2, 0);
    return arrayify$1(data2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const sender = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const recipient = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const nonce = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessIndex = Number(decoded);
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateGasUsed = decoded;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const dataLength = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateLength = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const predicateDataLength = decoded;
    [decoded, o2] = new ByteArrayCoder(dataLength).decode(data2, o2);
    const messageData = decoded;
    [decoded, o2] = new ByteArrayCoder(predicateLength.toNumber()).decode(data2, o2);
    const predicate = decoded;
    [decoded, o2] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data2, o2);
    const predicateData = decoded;
    return [
      {
        type: 2,
        sender,
        recipient,
        amount,
        witnessIndex,
        nonce,
        predicateGasUsed,
        dataLength,
        predicateLength,
        predicateDataLength,
        data: messageData,
        predicate,
        predicateData
      },
      o2
    ];
  }
};
var InputCoder = class extends Coder {
  constructor() {
    super("Input", "struct Input", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u8", { padToWordSize: true }).encode(value2.type));
    const { type: type3 } = value2;
    switch (type3) {
      case 0: {
        parts2.push(new InputCoinCoder().encode(value2));
        break;
      }
      case 1: {
        parts2.push(new InputContractCoder().encode(value2));
        break;
      }
      case 2: {
        parts2.push(new InputMessageCoder().encode(value2));
        break;
      }
      default: {
        throw new FuelError(
          ErrorCode$1.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u8", { padToWordSize: true }).decode(data2, o2);
    const type3 = decoded;
    switch (type3) {
      case 0: {
        [decoded, o2] = new InputCoinCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 1: {
        [decoded, o2] = new InputContractCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 2: {
        [decoded, o2] = new InputMessageCoder().decode(data2, o2);
        return [decoded, o2];
      }
      default: {
        throw new FuelError(
          ErrorCode$1.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  }
};
var OutputType = /* @__PURE__ */ ((OutputType2) => {
  OutputType2[OutputType2["Coin"] = 0] = "Coin";
  OutputType2[OutputType2["Contract"] = 1] = "Contract";
  OutputType2[OutputType2["Change"] = 2] = "Change";
  OutputType2[OutputType2["Variable"] = 3] = "Variable";
  OutputType2[OutputType2["ContractCreated"] = 4] = "ContractCreated";
  return OutputType2;
})(OutputType || {});
var OutputCoinCoder = class extends Coder {
  constructor() {
    super("OutputCoin", "struct OutputCoin", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.to));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new B256Coder().encode(value2.assetId));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const to2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const assetId = decoded;
    return [
      {
        type: 0,
        to: to2,
        amount,
        assetId
      },
      o2
    ];
  }
};
var OutputContractCoder = class extends Coder {
  constructor() {
    super("OutputContract", "struct OutputContract", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u8", { padToWordSize: true }).encode(value2.inputIndex));
    parts2.push(new B256Coder().encode(value2.balanceRoot));
    parts2.push(new B256Coder().encode(value2.stateRoot));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u8", { padToWordSize: true }).decode(data2, o2);
    const inputIndex = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const balanceRoot = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const stateRoot = decoded;
    return [
      {
        type: 1,
        inputIndex,
        balanceRoot,
        stateRoot
      },
      o2
    ];
  }
};
var OutputChangeCoder = class extends Coder {
  constructor() {
    super("OutputChange", "struct OutputChange", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.to));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new B256Coder().encode(value2.assetId));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const to2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const assetId = decoded;
    return [
      {
        type: 2,
        to: to2,
        amount,
        assetId
      },
      o2
    ];
  }
};
var OutputVariableCoder = class extends Coder {
  constructor() {
    super("OutputVariable", "struct OutputVariable", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.to));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new B256Coder().encode(value2.assetId));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const to2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const assetId = decoded;
    return [
      {
        type: 3,
        to: to2,
        amount,
        assetId
      },
      o2
    ];
  }
};
var OutputContractCreatedCoder = class extends Coder {
  constructor() {
    super("OutputContractCreated", "struct OutputContractCreated", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.contractId));
    parts2.push(new B256Coder().encode(value2.stateRoot));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const contractId2 = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const stateRoot = decoded;
    return [
      {
        type: 4,
        contractId: contractId2,
        stateRoot
      },
      o2
    ];
  }
};
var OutputCoder = class extends Coder {
  constructor() {
    super("Output", " struct Output", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u8", { padToWordSize: true }).encode(value2.type));
    const { type: type3 } = value2;
    switch (type3) {
      case 0: {
        parts2.push(new OutputCoinCoder().encode(value2));
        break;
      }
      case 1: {
        parts2.push(new OutputContractCoder().encode(value2));
        break;
      }
      case 2: {
        parts2.push(new OutputChangeCoder().encode(value2));
        break;
      }
      case 3: {
        parts2.push(new OutputVariableCoder().encode(value2));
        break;
      }
      case 4: {
        parts2.push(new OutputContractCreatedCoder().encode(value2));
        break;
      }
      default: {
        throw new FuelError(
          ErrorCode$1.INVALID_TRANSACTION_OUTPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u8", { padToWordSize: true }).decode(data2, o2);
    const type3 = decoded;
    switch (type3) {
      case 0: {
        [decoded, o2] = new OutputCoinCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 1: {
        [decoded, o2] = new OutputContractCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 2: {
        [decoded, o2] = new OutputChangeCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 3: {
        [decoded, o2] = new OutputVariableCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 4: {
        [decoded, o2] = new OutputContractCreatedCoder().decode(data2, o2);
        return [decoded, o2];
      }
      default: {
        throw new FuelError(
          ErrorCode$1.INVALID_TRANSACTION_OUTPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  }
};
var PolicyType = /* @__PURE__ */ ((PolicyType2) => {
  PolicyType2[PolicyType2["Tip"] = 1] = "Tip";
  PolicyType2[PolicyType2["WitnessLimit"] = 2] = "WitnessLimit";
  PolicyType2[PolicyType2["Maturity"] = 4] = "Maturity";
  PolicyType2[PolicyType2["MaxFee"] = 8] = "MaxFee";
  return PolicyType2;
})(PolicyType || {});
var sortPolicies = (policies) => policies.sort((a2, b2) => a2.type - b2.type);
function validateDuplicatedPolicies(policies) {
  const seenTypes = /* @__PURE__ */ new Set();
  policies.forEach((policy) => {
    if (seenTypes.has(policy.type)) {
      throw new FuelError(
        ErrorCode$1.DUPLICATED_POLICY,
        `Duplicate policy type found: ${8}`
      );
    }
    seenTypes.add(policy.type);
  });
}
var PoliciesCoder = class extends Coder {
  constructor() {
    super("Policies", "array Policy", 0);
  }
  encode(policies) {
    validateDuplicatedPolicies(policies);
    const sortedPolicies = sortPolicies(policies);
    const parts2 = [];
    sortedPolicies.forEach(({ data: data2, type: type3 }) => {
      switch (type3) {
        case 8:
        case 1:
        case 2:
          parts2.push(new BigNumberCoder("u64").encode(data2));
          break;
        case 4:
          parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(data2));
          break;
        default: {
          throw new FuelError(ErrorCode$1.INVALID_POLICY_TYPE, `Invalid policy type: ${type3}`);
        }
      }
    });
    return concat(parts2);
  }
  decode(data2, offset2, policyTypes) {
    let o2 = offset2;
    const policies = [];
    if (policyTypes & 1) {
      const [tip, nextOffset] = new BigNumberCoder("u64").decode(data2, o2);
      o2 = nextOffset;
      policies.push({ type: 1, data: tip });
    }
    if (policyTypes & 2) {
      const [witnessLimit, nextOffset] = new BigNumberCoder("u64").decode(data2, o2);
      o2 = nextOffset;
      policies.push({ type: 2, data: witnessLimit });
    }
    if (policyTypes & 4) {
      const [maturity, nextOffset] = new NumberCoder("u32", { padToWordSize: true }).decode(
        data2,
        o2
      );
      o2 = nextOffset;
      policies.push({ type: 4, data: maturity });
    }
    if (policyTypes & 8) {
      const [maxFee, nextOffset] = new BigNumberCoder("u64").decode(data2, o2);
      o2 = nextOffset;
      policies.push({ type: 8, data: maxFee });
    }
    return [policies, o2];
  }
};
var ReceiptType = /* @__PURE__ */ ((ReceiptType2) => {
  ReceiptType2[ReceiptType2["Call"] = 0] = "Call";
  ReceiptType2[ReceiptType2["Return"] = 1] = "Return";
  ReceiptType2[ReceiptType2["ReturnData"] = 2] = "ReturnData";
  ReceiptType2[ReceiptType2["Panic"] = 3] = "Panic";
  ReceiptType2[ReceiptType2["Revert"] = 4] = "Revert";
  ReceiptType2[ReceiptType2["Log"] = 5] = "Log";
  ReceiptType2[ReceiptType2["LogData"] = 6] = "LogData";
  ReceiptType2[ReceiptType2["Transfer"] = 7] = "Transfer";
  ReceiptType2[ReceiptType2["TransferOut"] = 8] = "TransferOut";
  ReceiptType2[ReceiptType2["ScriptResult"] = 9] = "ScriptResult";
  ReceiptType2[ReceiptType2["MessageOut"] = 10] = "MessageOut";
  ReceiptType2[ReceiptType2["Mint"] = 11] = "Mint";
  ReceiptType2[ReceiptType2["Burn"] = 12] = "Burn";
  return ReceiptType2;
})(ReceiptType || {});
var ReceiptMessageOutCoder = class extends Coder {
  constructor() {
    super("ReceiptMessageOut", "struct ReceiptMessageOut", 0);
  }
  static getMessageId(value2) {
    const parts2 = [];
    parts2.push(new ByteArrayCoder(32).encode(value2.sender));
    parts2.push(new ByteArrayCoder(32).encode(value2.recipient));
    parts2.push(new ByteArrayCoder(32).encode(value2.nonce));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(arrayify$1(value2.data || "0x"));
    return sha256$2(concat(parts2));
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.sender));
    parts2.push(new B256Coder().encode(value2.recipient));
    parts2.push(new BigNumberCoder("u64").encode(value2.amount));
    parts2.push(new B256Coder().encode(value2.nonce));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.data.length));
    parts2.push(new B256Coder().encode(value2.digest));
    parts2.push(new ByteArrayCoder(value2.data.length).encode(value2.data));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const sender = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const recipient = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const amount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const nonce = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const len = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const digest9 = decoded;
    [decoded, o2] = new ByteArrayCoder(len).decode(data2, o2);
    const messageData = arrayify$1(decoded);
    const receiptMessageOut = {
      type: 10,
      messageId: "",
      sender,
      recipient,
      amount,
      nonce,
      digest: digest9,
      data: messageData
    };
    receiptMessageOut.messageId = ReceiptMessageOutCoder.getMessageId(receiptMessageOut);
    return [receiptMessageOut, o2];
  }
};
var getMintedAssetId = (contractId2, subId) => {
  const contractIdBytes = arrayify$1(contractId2);
  const subIdBytes = arrayify$1(subId);
  return sha256$2(concat([contractIdBytes, subIdBytes]));
};
var ReceiptMintCoder = class extends Coder {
  constructor() {
    super("ReceiptMint", "struct ReceiptMint", 0);
  }
  static getAssetId(contractId2, subId) {
    return getMintedAssetId(contractId2, subId);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.subId));
    parts2.push(new B256Coder().encode(value2.contractId));
    parts2.push(new BigNumberCoder("u64").encode(value2.val));
    parts2.push(new BigNumberCoder("u64").encode(value2.pc));
    parts2.push(new BigNumberCoder("u64").encode(value2.is));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const subId = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const contractId2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const val = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const pc2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const is2 = decoded;
    const assetId = ReceiptMintCoder.getAssetId(contractId2, subId);
    const receiptMint = {
      type: 11,
      subId,
      contractId: contractId2,
      val,
      pc: pc2,
      is: is2,
      assetId
    };
    return [receiptMint, o2];
  }
};
var ReceiptBurnCoder = class extends Coder {
  constructor() {
    super("ReceiptBurn", "struct ReceiptBurn", 0);
  }
  static getAssetId(contractId2, subId) {
    return getMintedAssetId(contractId2, subId);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.subId));
    parts2.push(new B256Coder().encode(value2.contractId));
    parts2.push(new BigNumberCoder("u64").encode(value2.val));
    parts2.push(new BigNumberCoder("u64").encode(value2.pc));
    parts2.push(new BigNumberCoder("u64").encode(value2.is));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const subId = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const contractId2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const val = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const pc2 = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const is2 = decoded;
    const assetId = ReceiptMintCoder.getAssetId(contractId2, subId);
    const receiptBurn = {
      type: 12,
      subId,
      contractId: contractId2,
      val,
      pc: pc2,
      is: is2,
      assetId
    };
    return [receiptBurn, o2];
  }
};
var StorageSlotCoder = class extends StructCoder {
  constructor() {
    super("StorageSlot", {
      key: new B256Coder(),
      value: new B256Coder()
    });
  }
};
var UpgradePurposeCoder = class extends Coder {
  constructor() {
    super("UpgradePurpose", "UpgradePurpose", 0);
  }
  encode(upgradePurposeType) {
    const parts2 = [];
    const { type: type3 } = upgradePurposeType;
    parts2.push(new NumberCoder("u8", { padToWordSize: true }).encode(type3));
    switch (type3) {
      case 0: {
        const data2 = upgradePurposeType.data;
        parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(data2.witnessIndex));
        parts2.push(new B256Coder().encode(data2.checksum));
        break;
      }
      case 1: {
        const data2 = upgradePurposeType.data;
        parts2.push(new B256Coder().encode(data2.bytecodeRoot));
        break;
      }
      default: {
        throw new FuelError(
          ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}`
        );
      }
    }
    return concat(parts2);
  }
  decode(data2, offset2) {
    let o2 = offset2;
    let decoded;
    [decoded, o2] = new NumberCoder("u8", { padToWordSize: true }).decode(data2, o2);
    const type3 = decoded;
    switch (type3) {
      case 0: {
        [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
        const witnessIndex = decoded;
        [decoded, o2] = new B256Coder().decode(data2, o2);
        const checksum = decoded;
        return [{ type: type3, data: { witnessIndex, checksum } }, o2];
      }
      case 1: {
        [decoded, o2] = new B256Coder().decode(data2, o2);
        const bytecodeRoot = decoded;
        return [{ type: type3, data: { bytecodeRoot } }, o2];
      }
      default: {
        throw new FuelError(
          ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}`
        );
      }
    }
  }
};
var WitnessCoder = class extends Coder {
  constructor() {
    super(
      "Witness",
      // Types of dynamic length are not supported in the ABI
      "unknown",
      0
    );
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(value2.dataLength));
    parts2.push(new ByteArrayCoder(value2.dataLength).encode(value2.data));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const dataLength = decoded;
    [decoded, o2] = new ByteArrayCoder(dataLength).decode(data2, o2);
    const witnessData = decoded;
    return [
      {
        dataLength,
        data: witnessData
      },
      o2
    ];
  }
};
var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
  TransactionType2[TransactionType2["Script"] = 0] = "Script";
  TransactionType2[TransactionType2["Create"] = 1] = "Create";
  TransactionType2[TransactionType2["Mint"] = 2] = "Mint";
  TransactionType2[TransactionType2["Upgrade"] = 3] = "Upgrade";
  TransactionType2[TransactionType2["Upload"] = 4] = "Upload";
  return TransactionType2;
})(TransactionType || {});
var TransactionScriptCoder = class extends Coder {
  constructor() {
    super("TransactionScript", "struct TransactionScript", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new BigNumberCoder("u64").encode(value2.scriptGasLimit));
    parts2.push(new B256Coder().encode(value2.receiptsRoot));
    parts2.push(new BigNumberCoder("u64").encode(value2.scriptLength));
    parts2.push(new BigNumberCoder("u64").encode(value2.scriptDataLength));
    parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(value2.policyTypes));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.inputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessesCount));
    parts2.push(new ByteArrayCoder(value2.scriptLength.toNumber()).encode(value2.script));
    parts2.push(new ByteArrayCoder(value2.scriptDataLength.toNumber()).encode(value2.scriptData));
    parts2.push(new PoliciesCoder().encode(value2.policies));
    parts2.push(new ArrayCoder(new InputCoder(), value2.inputsCount).encode(value2.inputs));
    parts2.push(new ArrayCoder(new OutputCoder(), value2.outputsCount).encode(value2.outputs));
    parts2.push(new ArrayCoder(new WitnessCoder(), value2.witnessesCount).encode(value2.witnesses));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const scriptGasLimit = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const receiptsRoot = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const scriptLength = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const scriptDataLength = decoded;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const policyTypes = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const inputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessesCount = decoded;
    [decoded, o2] = new ByteArrayCoder(scriptLength.toNumber()).decode(data2, o2);
    const script = decoded;
    [decoded, o2] = new ByteArrayCoder(scriptDataLength.toNumber()).decode(data2, o2);
    const scriptData = decoded;
    [decoded, o2] = new PoliciesCoder().decode(data2, o2, policyTypes);
    const policies = decoded;
    [decoded, o2] = new ArrayCoder(new InputCoder(), inputsCount).decode(data2, o2);
    const inputs = decoded;
    [decoded, o2] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data2, o2);
    const outputs = decoded;
    [decoded, o2] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data2, o2);
    const witnesses = decoded;
    return [
      {
        type: 0,
        scriptGasLimit,
        scriptLength,
        scriptDataLength,
        policyTypes,
        inputsCount,
        outputsCount,
        witnessesCount,
        receiptsRoot,
        script,
        scriptData,
        policies,
        inputs,
        outputs,
        witnesses
      },
      o2
    ];
  }
};
var TransactionCreateCoder = class extends Coder {
  constructor() {
    super("TransactionCreate", "struct TransactionCreate", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.bytecodeWitnessIndex));
    parts2.push(new B256Coder().encode(value2.salt));
    parts2.push(new BigNumberCoder("u64").encode(value2.storageSlotsCount));
    parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(value2.policyTypes));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.inputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessesCount));
    parts2.push(
      new ArrayCoder(new StorageSlotCoder(), value2.storageSlotsCount.toNumber()).encode(
        value2.storageSlots
      )
    );
    parts2.push(new PoliciesCoder().encode(value2.policies));
    parts2.push(new ArrayCoder(new InputCoder(), value2.inputsCount).encode(value2.inputs));
    parts2.push(new ArrayCoder(new OutputCoder(), value2.outputsCount).encode(value2.outputs));
    parts2.push(new ArrayCoder(new WitnessCoder(), value2.witnessesCount).encode(value2.witnesses));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const bytecodeWitnessIndex = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const salt = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const storageSlotsCount = decoded;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const policyTypes = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const inputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessesCount = decoded;
    [decoded, o2] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount.toNumber()).decode(
      data2,
      o2
    );
    const storageSlots = decoded;
    [decoded, o2] = new PoliciesCoder().decode(data2, o2, policyTypes);
    const policies = decoded;
    [decoded, o2] = new ArrayCoder(new InputCoder(), inputsCount).decode(data2, o2);
    const inputs = decoded;
    [decoded, o2] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data2, o2);
    const outputs = decoded;
    [decoded, o2] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data2, o2);
    const witnesses = decoded;
    return [
      {
        type: 1,
        bytecodeWitnessIndex,
        policyTypes,
        storageSlotsCount,
        inputsCount,
        outputsCount,
        witnessesCount,
        salt,
        policies,
        storageSlots,
        inputs,
        outputs,
        witnesses
      },
      o2
    ];
  }
};
var TransactionMintCoder = class extends Coder {
  constructor() {
    super("TransactionMint", "struct TransactionMint", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new TxPointerCoder().encode(value2.txPointer));
    parts2.push(new InputContractCoder().encode(value2.inputContract));
    parts2.push(new OutputContractCoder().encode(value2.outputContract));
    parts2.push(new BigNumberCoder("u64").encode(value2.mintAmount));
    parts2.push(new B256Coder().encode(value2.mintAssetId));
    parts2.push(new BigNumberCoder("u64").encode(value2.gasPrice));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new TxPointerCoder().decode(data2, o2);
    const txPointer = decoded;
    [decoded, o2] = new InputContractCoder().decode(data2, o2);
    const inputContract = decoded;
    [decoded, o2] = new OutputContractCoder().decode(data2, o2);
    const outputContract = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const mintAmount = decoded;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const mintAssetId = decoded;
    [decoded, o2] = new BigNumberCoder("u64").decode(data2, o2);
    const gasPrice = decoded;
    return [
      {
        type: 2,
        txPointer,
        inputContract,
        outputContract,
        mintAmount,
        mintAssetId,
        gasPrice
      },
      o2
    ];
  }
};
var TransactionUpgradeCoder = class extends Coder {
  constructor() {
    super("TransactionUpgrade", "struct TransactionUpgrade", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new UpgradePurposeCoder().encode(value2.upgradePurpose));
    parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(value2.policyTypes));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.inputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessesCount));
    parts2.push(new PoliciesCoder().encode(value2.policies));
    parts2.push(new ArrayCoder(new InputCoder(), value2.inputsCount).encode(value2.inputs));
    parts2.push(new ArrayCoder(new OutputCoder(), value2.outputsCount).encode(value2.outputs));
    parts2.push(new ArrayCoder(new WitnessCoder(), value2.witnessesCount).encode(value2.witnesses));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new UpgradePurposeCoder().decode(data2, o2);
    const upgradePurpose = decoded;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const policyTypes = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const inputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessesCount = decoded;
    [decoded, o2] = new PoliciesCoder().decode(data2, o2, policyTypes);
    const policies = decoded;
    [decoded, o2] = new ArrayCoder(new InputCoder(), inputsCount).decode(data2, o2);
    const inputs = decoded;
    [decoded, o2] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data2, o2);
    const outputs = decoded;
    [decoded, o2] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data2, o2);
    const witnesses = decoded;
    return [
      {
        type: 3,
        upgradePurpose,
        policyTypes,
        inputsCount,
        outputsCount,
        witnessesCount,
        policies,
        inputs,
        outputs,
        witnesses
      },
      o2
    ];
  }
};
var TransactionUploadCoder = class extends Coder {
  constructor() {
    super("TransactionUpload", "struct TransactionUpload", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new B256Coder().encode(value2.root));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessIndex));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.subsectionIndex));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.subsectionsNumber));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.proofSetCount));
    parts2.push(new NumberCoder("u32", { padToWordSize: true }).encode(value2.policyTypes));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.inputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.outputsCount));
    parts2.push(new NumberCoder("u16", { padToWordSize: true }).encode(value2.witnessesCount));
    parts2.push(new ArrayCoder(new B256Coder(), value2.proofSetCount).encode(value2.proofSet));
    parts2.push(new PoliciesCoder().encode(value2.policies));
    parts2.push(new ArrayCoder(new InputCoder(), value2.inputsCount).encode(value2.inputs));
    parts2.push(new ArrayCoder(new OutputCoder(), value2.outputsCount).encode(value2.outputs));
    parts2.push(new ArrayCoder(new WitnessCoder(), value2.witnessesCount).encode(value2.witnesses));
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new B256Coder().decode(data2, o2);
    const root = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessIndex = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const subsectionIndex = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const subsectionsNumber = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const proofSetCount = decoded;
    [decoded, o2] = new NumberCoder("u32", { padToWordSize: true }).decode(data2, o2);
    const policyTypes = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const inputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const outputsCount = decoded;
    [decoded, o2] = new NumberCoder("u16", { padToWordSize: true }).decode(data2, o2);
    const witnessesCount = decoded;
    [decoded, o2] = new ArrayCoder(new B256Coder(), proofSetCount).decode(data2, o2);
    const proofSet = decoded;
    [decoded, o2] = new PoliciesCoder().decode(data2, o2, policyTypes);
    const policies = decoded;
    [decoded, o2] = new ArrayCoder(new InputCoder(), inputsCount).decode(data2, o2);
    const inputs = decoded;
    [decoded, o2] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data2, o2);
    const outputs = decoded;
    [decoded, o2] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data2, o2);
    const witnesses = decoded;
    return [
      {
        type: 4,
        root,
        witnessIndex,
        subsectionIndex,
        subsectionsNumber,
        proofSetCount,
        policyTypes,
        inputsCount,
        outputsCount,
        witnessesCount,
        proofSet,
        policies,
        inputs,
        outputs,
        witnesses
      },
      o2
    ];
  }
};
var TransactionCoder = class extends Coder {
  constructor() {
    super("Transaction", "struct Transaction", 0);
  }
  encode(value2) {
    const parts2 = [];
    parts2.push(new NumberCoder("u8", { padToWordSize: true }).encode(value2.type));
    const { type: type3 } = value2;
    switch (value2.type) {
      case 0: {
        parts2.push(
          new TransactionScriptCoder().encode(value2)
        );
        break;
      }
      case 1: {
        parts2.push(
          new TransactionCreateCoder().encode(value2)
        );
        break;
      }
      case 2: {
        parts2.push(new TransactionMintCoder().encode(value2));
        break;
      }
      case 3: {
        parts2.push(
          new TransactionUpgradeCoder().encode(value2)
        );
        break;
      }
      case 4: {
        parts2.push(
          new TransactionUploadCoder().encode(value2)
        );
        break;
      }
      default: {
        throw new FuelError(
          ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}`
        );
      }
    }
    return concat(parts2);
  }
  decode(data2, offset2) {
    let decoded;
    let o2 = offset2;
    [decoded, o2] = new NumberCoder("u8", { padToWordSize: true }).decode(data2, o2);
    const type3 = decoded;
    switch (type3) {
      case 0: {
        [decoded, o2] = new TransactionScriptCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 1: {
        [decoded, o2] = new TransactionCreateCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 2: {
        [decoded, o2] = new TransactionMintCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 3: {
        [decoded, o2] = new TransactionUpgradeCoder().decode(data2, o2);
        return [decoded, o2];
      }
      case 4: {
        [decoded, o2] = new TransactionUploadCoder().decode(data2, o2);
        return [decoded, o2];
      }
      default: {
        throw new FuelError(
          ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}`
        );
      }
    }
  }
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = /* @__PURE__ */ BigInt(0);
const _1n$b = /* @__PURE__ */ BigInt(1);
const _2n$7 = /* @__PURE__ */ BigInt(2);
function isBytes$3(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function abytes$1(item) {
  if (!isBytes$3(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value2) {
  if (typeof value2 !== "boolean")
    throw new Error(`${title} must be valid boolean, got "${value2}".`);
}
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes2) {
  abytes$1(bytes2);
  let hex = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex += hexes$1[bytes2[i2]];
  }
  return hex;
}
function numberToHexUnpadded$1(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
const asciis$1 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16$1(char2) {
  if (char2 >= asciis$1._0 && char2 <= asciis$1._9)
    return char2 - asciis$1._0;
  if (char2 >= asciis$1._A && char2 <= asciis$1._F)
    return char2 - (asciis$1._A - 10);
  if (char2 >= asciis$1._a && char2 <= asciis$1._f)
    return char2 - (asciis$1._a - 10);
  return;
}
function hexToBytes$2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl2 = hex.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16$1(hex.charCodeAt(hi2));
    const n22 = asciiToBase16$1(hex.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char2 = hex[hi2] + hex[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n22;
  }
  return array2;
}
function bytesToNumberBE$1(bytes2) {
  return hexToNumber$1(bytesToHex$1(bytes2));
}
function bytesToNumberLE$1(bytes2) {
  abytes$1(bytes2);
  return hexToNumber$1(bytesToHex$1(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE$1(n3, len) {
  return hexToBytes$2(n3.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE$1(n3, len) {
  return numberToBytesBE$1(n3, len).reverse();
}
function numberToVarBytesBE$1(n3) {
  return hexToBytes$2(numberToHexUnpadded$1(n3));
}
function ensureBytes$1(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$2(hex);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
    }
  } else if (isBytes$3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes$2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes$1(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
function equalBytes$1(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b2[i2];
  return diff === 0;
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
const isPosBig = (n3) => typeof n3 === "bigint" && _0n$8 <= n3;
function inRange$1(n3, min, max) {
  return isPosBig(n3) && isPosBig(min) && isPosBig(max) && min <= n3 && n3 < max;
}
function aInRange(title, n3, min, max) {
  if (!inRange$1(n3, min, max))
    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n3} ${n3}`);
}
function bitLen$1(n3) {
  let len;
  for (len = 0; n3 > _0n$8; n3 >>= _1n$b, len += 1)
    ;
  return len;
}
function bitGet$1(n3, pos) {
  return n3 >> BigInt(pos) & _1n$b;
}
function bitSet$1(n3, pos, value2) {
  return n3 | (value2 ? _1n$b : _0n$8) << BigInt(pos);
}
const bitMask$1 = (n3) => (_2n$7 << BigInt(n3 - 1)) - _1n$b;
const u8n$1 = (data2) => new Uint8Array(data2);
const u8fr$1 = (arr) => Uint8Array.from(arr);
function createHmacDrbg$1(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n$1(hashLen);
  let k2 = u8n$1(hashLen);
  let i2 = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i2 = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed2 = u8n$1()) => {
    k2 = h2(u8fr$1([0]), seed2);
    v2 = h2();
    if (seed2.length === 0)
      return;
    k2 = h2(u8fr$1([1]), seed2);
    v2 = h2();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len += v2.length;
    }
    return concatBytes$2(...out);
  };
  const genUntil = (seed2, pred) => {
    reset();
    reseed(seed2);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns$1 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes$3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject$1(object, validators, optValidators = {}) {
  const checkField = (fieldName, type3, isOptional) => {
    const checkVal = validatorFns$1[type3];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type3}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type3}`);
    }
  };
  for (const [fieldName, type3] of Object.entries(validators))
    checkField(fieldName, type3, false);
  for (const [fieldName, type3] of Object.entries(optValidators))
    checkField(fieldName, type3, true);
  return object;
}
const notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn2) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}
const ut$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange,
  abool,
  abytes: abytes$1,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$2,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$1,
  equalBytes: equalBytes$1,
  hexToBytes: hexToBytes$2,
  hexToNumber: hexToNumber$1,
  inRange: inRange$1,
  isBytes: isBytes$3,
  memoized,
  notImplemented,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$2,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
var dist = {};
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F3() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F3.prototype = global2;
    return new F3();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value2) {
        if (typeof value2 !== "string") {
          value2 = String(value2);
        }
        return value2;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value2 = items.shift();
            return { done: value2 === void 0, value: value2 };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value2, name) {
            this.append(name, value2);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value2) {
        name = normalizeName(name);
        value2 = normalizeValue(value2);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value2) {
        this.map[normalizeName(name)] = normalizeValue(value2);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value2, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value2) {
          items.push(value2);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value2, name) {
          items.push([name, value2]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob2) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob2);
        return promise;
      }
      function readBlobAsText(blob2) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob2);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars2 = new Array(view.length);
        for (var i2 = 0; i2 < view.length; i2++) {
          chars2[i2] = String.fromCharCode(view[i2]);
        }
        return chars2.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode3);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request2(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request2) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request2.prototype.clone = function() {
        return new Request2(this, { body: this._bodyInit });
      };
      function decode3(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split2 = bytes2.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value2 = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value2));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
          var parts2 = line2.split(":");
          var key = parts2.shift().trim();
          if (key) {
            var value2 = parts2.join(":").trim();
            headers.append(key, value2);
          }
        });
        return headers;
      }
      Body.call(Request2.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url2, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url2 } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init2) {
        return new Promise(function(resolve, reject) {
          var request = new Request2(input, init2);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value2, name) {
            xhr.setRequestHeader(name, value2);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers2;
        self2.Request = Request2;
        self2.Response = Response2;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request2;
      exports2.Response = Response2;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}
function invariant$1(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      "Unexpected invariant triggered."
    );
  }
}
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position2) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match2 of source.body.matchAll(LineRegExp)) {
    typeof match2.index === "number" || invariant$1(false);
    if (match2.index >= position2) {
      break;
    }
    lastLineStart = match2.index + match2[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position2 + 1 - lastLineStart
  };
}
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix2]) => prefix2.length));
  return existingLines.map(([prefix2, line2]) => prefix2.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
class GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output2 = this.message;
    if (this.nodes) {
      for (const node2 of this.nodes) {
        if (node2.loc) {
          output2 += "\n\n" + printLocation(node2.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output2 += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output2;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
function undefinedIfEmpty(array2) {
  return array2 === void 0 || array2.length === 0 ? void 0 : array2;
}
function syntaxError(source, position2, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position2]
  });
}
class Location {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class Token {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line2, column2, value2) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value2;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || // A-Z
  code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    var _firstNonEmptyLine;
    const line2 = lines[i2];
    const indent2 = leadingWhitespace(line2);
    if (indent2 === line2.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
    lastNonEmptyLine = i2;
    if (i2 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line2, i2) => i2 === 0 ? line2 : line2.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i2 = 0;
  while (i2 < str.length && isWhiteSpace(str.charCodeAt(i2))) {
    ++i2;
  }
  return i2;
}
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = (
    // add leading and trailing new lines only if it improves readability
    !isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes
  );
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));
class Lexer {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
}
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code2) {
  return code2 >= 0 && code2 <= 55295 || code2 >= 57344 && code2 <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code2) {
  return code2 >= 55296 && code2 <= 56319;
}
function isTrailingSurrogate(code2) {
  return code2 >= 56320 && code2 <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code2 = lexer.source.body.codePointAt(location2);
  if (code2 === void 0) {
    return TokenKind.EOF;
  } else if (code2 >= 32 && code2 <= 126) {
    const char2 = String.fromCodePoint(code2);
    return char2 === '"' ? `'"'` : `"${char2}"`;
  }
  return "U+" + code2.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value2) {
  const line2 = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line2, col, value2);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    switch (code2) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position2;
        continue;
      case 10:
        ++position2;
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 13:
        if (body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 35:
        return readComment(lexer, position2);
      case 33:
        return createToken(lexer, TokenKind.BANG, position2, position2 + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position2, position2 + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position2, position2 + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position2, position2 + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position2, position2 + 1);
      case 46:
        if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position2, position2 + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position2, position2 + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position2, position2 + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position2, position2 + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position2, position2 + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position2, position2 + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position2, position2 + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position2, position2 + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position2, position2 + 1);
      case 34:
        if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
          return readBlockString(lexer, position2);
        }
        return readString(lexer, position2);
    }
    if (isDigit(code2) || code2 === 45) {
      return readNumber(lexer, position2, code2);
    }
    if (isNameStart(code2)) {
      return readName(lexer, position2);
    }
    throw syntaxError(
      lexer.source,
      position2,
      code2 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code2) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position2,
    body.slice(start + 1, position2)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position2 = start;
  let code2 = firstCode;
  let isFloat = false;
  if (code2 === 45) {
    code2 = body.charCodeAt(++position2);
  }
  if (code2 === 48) {
    code2 = body.charCodeAt(++position2);
    if (isDigit(code2)) {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  } else {
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46) {
    isFloat = true;
    code2 = body.charCodeAt(++position2);
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 69 || code2 === 101) {
    isFloat = true;
    code2 = body.charCodeAt(++position2);
    if (code2 === 43 || code2 === 45) {
      code2 = body.charCodeAt(++position2);
    }
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46 || isNameStart(code2)) {
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position2
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position2,
    body.slice(start, position2)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position2 = start + 1;
  while (isDigit(body.charCodeAt(position2))) {
    ++position2;
  }
  return position2;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  let chunkStart = position2;
  let value2 = "";
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34) {
      value2 += body.slice(chunkStart, position2);
      return createToken(lexer, TokenKind.STRING, start, position2 + 1, value2);
    }
    if (code2 === 92) {
      value2 += body.slice(chunkStart, position2);
      const escape2 = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
      value2 += escape2.value;
      position2 += escape2.size;
      chunkStart = position2;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position2) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code2 = body.charCodeAt(position2 + size++);
    if (code2 === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code2);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(
      position2,
      position2 + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position2) {
  const body = lexer.source.body;
  const code2 = read16BitHexCode(body, position2 + 2);
  if (isUnicodeScalarValue(code2)) {
    return {
      value: String.fromCodePoint(code2),
      size: 6
    };
  }
  if (isLeadingSurrogate(code2)) {
    if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position2 + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code2, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`
  );
}
function read16BitHexCode(body, position2) {
  return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
}
function readHexDigit(code2) {
  return code2 >= 48 && code2 <= 57 ? code2 - 48 : code2 >= 65 && code2 <= 70 ? code2 - 55 : code2 >= 97 && code2 <= 102 ? code2 - 87 : -1;
}
function readEscapedCharacter(lexer, position2) {
  const body = lexer.source.body;
  const code2 = body.charCodeAt(position2 + 1);
  switch (code2) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid character escape sequence: "${body.slice(
      position2,
      position2 + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position2 = start + 3;
  let chunkStart = position2;
  let currentLine = "";
  const blockLines = [];
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      const token2 = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position2 + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code2 === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
      currentLine += body.slice(chunkStart, position2);
      chunkStart = position2 + 1;
      position2 += 4;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      if (code2 === 13 && body.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      currentLine = "";
      chunkStart = position2;
      lineStart = position2;
      continue;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (isNameContinue(code2)) {
      ++position2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position2,
    body.slice(start, position2)
  );
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries2 = Object.entries(object);
  if (entries2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties2 = entries2.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties2.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array2[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
const isProduction = globalThis.process && // eslint-disable-next-line no-undef
true;
const instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);
class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source);
}
function parse$3(source, options) {
  const parser2 = new Parser(source, options);
  return parser2.parseDocument();
}
function parseValue(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const value2 = parser2.parseValueLiteral(false);
  parser2.expectToken(TokenKind.EOF);
  return value2;
}
function parseConstValue(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const value2 = parser2.parseConstValueLiteral();
  parser2.expectToken(TokenKind.EOF);
  return value2;
}
function parseType(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const type3 = parser2.parseTypeReference();
  parser2.expectToken(TokenKind.EOF);
  return type3;
}
class Parser {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token2.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this.advanceLexer();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type3;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type3 = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type3 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type: type3
      });
    }
    return type3;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type3
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type: type3,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type3,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types: types2
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values2 = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values: values2
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    if (directives.length === 0 && types2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types: types2
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values2 = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values: values2
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node2) {
    if (this._options.noLocation !== true) {
      node2.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node2;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return token2;
    }
    throw syntaxError(
      this._lexer.source,
      token2.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected "${value2}", found ${getTokenDesc(token2)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token2.start,
      `Unexpected ${getTokenDesc(token2)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token2 = this._lexer.advance();
    if (maxTokens !== void 0 && token2.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
}
function getTokenDesc(token2) {
  const value2 = token2.value;
  return getTokenKindDesc(token2.kind) + (value2 != null ? ` "${value2}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
const parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Parser,
  parse: parse$3,
  parseConstValue,
  parseType,
  parseValue
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(parser$1);
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node2 = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node2)
          );
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node2 = parent[key];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node2 = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node2]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print$2(ast) {
  return visit(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  // Document
  Document: {
    leave: (node2) => join(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap$1("(", join(node2.variableDefinitions, ", "), ")");
      const prefix2 = join(
        [
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ],
        " "
      );
      return (prefix2 === "query" ? "" : prefix2 + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type3, defaultValue, directives }) => variable + ": " + type3 + wrap$1(" = ", defaultValue) + wrap$1(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix2 = wrap$1("", alias, ": ") + name;
      let argsLine = prefix2 + wrap$1("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix2 + wrap$1("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap$1(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap$1("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap$1("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$1("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values: values2 }) => "[" + join(values2, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap$1("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type: type3 }) => "[" + type3 + "]"
  },
  NonNullType: {
    leave: ({ type: type3 }) => type3 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$1("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type3 }) => operation + ": " + type3
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap$1("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "type",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type: type3, directives }) => wrap$1("", description, "\n") + name + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + ": " + type3 + wrap$1(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type: type3, defaultValue, directives }) => wrap$1("", description, "\n") + join(
      [name + ": " + type3, wrap$1("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "interface",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types: types2 }) => wrap$1("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap$1("= ", join(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values: values2 }) => wrap$1("", description, "\n") + join(["enum", name, join(directives, " "), block(values2)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap$1("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap$1("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap$1("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types: types2 }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap$1("= ", join(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values: values2 }) => join(["extend enum", name, join(directives, " "), block(values2)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap$1("{\n", indent(join(array2, "\n")), "\n}");
}
function wrap$1(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap$1("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
const printer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  print: print$2
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(printer);
var createRequestBody$1 = {};
var _public = {};
var ReactNativeFile$1 = function ReactNativeFile(_ref) {
  var uri = _ref.uri, name = _ref.name, type3 = _ref.type;
  this.uri = uri;
  this.name = name;
  this.type = type3;
};
var ReactNativeFile2 = ReactNativeFile$1;
var isExtractableFile = function isExtractableFile2(value2) {
  return typeof File !== "undefined" && value2 instanceof File || typeof Blob !== "undefined" && value2 instanceof Blob || value2 instanceof ReactNativeFile2;
};
var defaultIsExtractableFile = isExtractableFile;
var extractFiles = function extractFiles2(value2, path, isExtractableFile3) {
  if (path === void 0) {
    path = "";
  }
  if (isExtractableFile3 === void 0) {
    isExtractableFile3 = defaultIsExtractableFile;
  }
  var clone3;
  var files = /* @__PURE__ */ new Map();
  function addFile(paths, file) {
    var storedPaths = files.get(file);
    if (storedPaths) storedPaths.push.apply(storedPaths, paths);
    else files.set(file, paths);
  }
  if (isExtractableFile3(value2)) {
    clone3 = null;
    addFile([path], value2);
  } else {
    var prefix2 = path ? path + "." : "";
    if (typeof FileList !== "undefined" && value2 instanceof FileList)
      clone3 = Array.prototype.map.call(value2, function(file, i3) {
        addFile(["" + prefix2 + i3], file);
        return null;
      });
    else if (Array.isArray(value2))
      clone3 = value2.map(function(child, i3) {
        var result2 = extractFiles2(child, "" + prefix2 + i3, isExtractableFile3);
        result2.files.forEach(addFile);
        return result2.clone;
      });
    else if (value2 && value2.constructor === Object) {
      clone3 = {};
      for (var i2 in value2) {
        var result = extractFiles2(value2[i2], "" + prefix2 + i2, isExtractableFile3);
        result.files.forEach(addFile);
        clone3[i2] = result.clone;
      }
    } else clone3 = value2;
  }
  return {
    clone: clone3,
    files
  };
};
_public.ReactNativeFile = ReactNativeFile$1;
_public.extractFiles = extractFiles;
_public.isExtractableFile = isExtractableFile;
var browser$2 = typeof self == "object" ? self.FormData : window.FormData;
var defaultJsonSerializer = {};
Object.defineProperty(defaultJsonSerializer, "__esModule", { value: true });
defaultJsonSerializer.defaultJsonSerializer = void 0;
defaultJsonSerializer.defaultJsonSerializer = {
  parse: JSON.parse,
  stringify: JSON.stringify
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createRequestBody$1, "__esModule", { value: true });
var extract_files_1 = _public;
var form_data_1 = __importDefault$2(browser$2);
var defaultJsonSerializer_1 = defaultJsonSerializer;
var isExtractableFileEnhanced = function(value2) {
  return extract_files_1.isExtractableFile(value2) || value2 !== null && typeof value2 === "object" && typeof value2.pipe === "function";
};
function createRequestBody(query, variables, operationName, jsonSerializer) {
  if (jsonSerializer === void 0) {
    jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
  }
  var _a2 = extract_files_1.extractFiles({ query, variables, operationName }, "", isExtractableFileEnhanced), clone3 = _a2.clone, files = _a2.files;
  if (files.size === 0) {
    if (!Array.isArray(query)) {
      return jsonSerializer.stringify(clone3);
    }
    if (typeof variables !== "undefined" && !Array.isArray(variables)) {
      throw new Error("Cannot create request body with given variable type, array expected");
    }
    var payload = query.reduce(function(accu, currentQuery, index) {
      accu.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
      return accu;
    }, []);
    return jsonSerializer.stringify(payload);
  }
  var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
  var form = new Form();
  form.append("operations", jsonSerializer.stringify(clone3));
  var map2 = {};
  var i2 = 0;
  files.forEach(function(paths) {
    map2[++i2] = paths;
  });
  form.append("map", jsonSerializer.stringify(map2));
  i2 = 0;
  files.forEach(function(paths, file) {
    form.append("" + ++i2, file);
  });
  return form;
}
createRequestBody$1.default = createRequestBody;
var parseArgs = {};
Object.defineProperty(parseArgs, "__esModule", { value: true });
parseArgs.parseBatchRequestsExtendedArgs = parseArgs.parseRawRequestExtendedArgs = parseArgs.parseRequestExtendedArgs = parseArgs.parseBatchRequestArgs = parseArgs.parseRawRequestArgs = parseArgs.parseRequestArgs = void 0;
function parseRequestArgs(documentOrOptions, variables, requestHeaders) {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseRequestArgs = parseRequestArgs;
function parseRawRequestArgs(queryOrOptions, variables, requestHeaders) {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseRawRequestArgs = parseRawRequestArgs;
function parseBatchRequestArgs(documentsOrOptions, requestHeaders) {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseBatchRequestArgs = parseBatchRequestArgs;
function parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders) {
  return urlOrOptions.document ? urlOrOptions : {
    url: urlOrOptions,
    document: document2,
    variables,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseRequestExtendedArgs = parseRequestExtendedArgs;
function parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders) {
  return urlOrOptions.query ? urlOrOptions : {
    url: urlOrOptions,
    query,
    variables,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseRawRequestExtendedArgs = parseRawRequestExtendedArgs;
function parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders) {
  return urlOrOptions.documents ? urlOrOptions : {
    url: urlOrOptions,
    documents,
    requestHeaders,
    signal: void 0
  };
}
parseArgs.parseBatchRequestsExtendedArgs = parseBatchRequestsExtendedArgs;
var types = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(types, "__esModule", { value: true });
types.ClientError = void 0;
var ClientError = (
  /** @class */
  function(_super) {
    __extends$1(ClientError2, _super);
    function ClientError2(response, request) {
      var _this = this;
      var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
        response,
        request
      });
      _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, ClientError2.prototype);
      _this.response = response;
      _this.request = request;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, ClientError2);
      }
      return _this;
    }
    ClientError2.extractMessage = function(response) {
      try {
        return response.errors[0].message;
      } catch (e2) {
        return "GraphQL Error (Code: " + response.status + ")";
      }
    };
    return ClientError2;
  }(Error)
);
types.ClientError = ClientError;
var graphqlWs = {};
var hasRequiredGraphqlWs;
function requireGraphqlWs() {
  if (hasRequiredGraphqlWs) return graphqlWs;
  hasRequiredGraphqlWs = 1;
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign2.apply(this, arguments);
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n3) {
      return function(v2) {
        return step([n3, v2]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (_2) try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
        if (y2 = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(graphqlWs, "__esModule", { value: true });
  graphqlWs.GraphQLWebSocketClient = void 0;
  var types_1 = types;
  var _12 = requireDist();
  var CONNECTION_INIT = "connection_init";
  var CONNECTION_ACK = "connection_ack";
  var PING = "ping";
  var PONG = "pong";
  var SUBSCRIBE = "subscribe";
  var NEXT = "next";
  var ERROR = "error";
  var COMPLETE = "complete";
  var GraphQLWebSocketMessage = (
    /** @class */
    function() {
      function GraphQLWebSocketMessage2(type3, payload, id2) {
        this._type = type3;
        this._payload = payload;
        this._id = id2;
      }
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "type", {
        get: function() {
          return this._type;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "id", {
        get: function() {
          return this._id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "payload", {
        get: function() {
          return this._payload;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "text", {
        get: function() {
          var result = { type: this.type };
          if (this.id != null && this.id != void 0)
            result.id = this.id;
          if (this.payload != null && this.payload != void 0)
            result.payload = this.payload;
          return JSON.stringify(result);
        },
        enumerable: false,
        configurable: true
      });
      GraphQLWebSocketMessage2.parse = function(data2, f2) {
        var _a2 = JSON.parse(data2), type3 = _a2.type, payload = _a2.payload, id2 = _a2.id;
        return new GraphQLWebSocketMessage2(type3, f2(payload), id2);
      };
      return GraphQLWebSocketMessage2;
    }()
  );
  var GraphQLWebSocketClient = (
    /** @class */
    function() {
      function GraphQLWebSocketClient2(socket, _a2) {
        var _this = this;
        var onInit = _a2.onInit, onAcknowledged = _a2.onAcknowledged, onPing = _a2.onPing, onPong = _a2.onPong;
        this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
        this.socket = socket;
        socket.onopen = function(e2) {
          return __awaiter2(_this, void 0, void 0, function() {
            var _a3, _b2, _c2, _d2;
            return __generator2(this, function(_e3) {
              switch (_e3.label) {
                case 0:
                  this.socketState.acknowledged = false;
                  this.socketState.subscriptions = {};
                  _b2 = (_a3 = socket).send;
                  _c2 = ConnectionInit;
                  if (!onInit) return [3, 2];
                  return [4, onInit()];
                case 1:
                  _d2 = _e3.sent();
                  return [3, 3];
                case 2:
                  _d2 = null;
                  _e3.label = 3;
                case 3:
                  _b2.apply(_a3, [_c2.apply(void 0, [_d2]).text]);
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        socket.onclose = function(e2) {
          _this.socketState.acknowledged = false;
          _this.socketState.subscriptions = {};
        };
        socket.onerror = function(e2) {
          console.error(e2);
        };
        socket.onmessage = function(e2) {
          try {
            var message = parseMessage(e2.data);
            switch (message.type) {
              case CONNECTION_ACK: {
                if (_this.socketState.acknowledged) {
                  console.warn("Duplicate CONNECTION_ACK message ignored");
                } else {
                  _this.socketState.acknowledged = true;
                  if (onAcknowledged)
                    onAcknowledged(message.payload);
                }
                return;
              }
              case PING: {
                if (onPing)
                  onPing(message.payload).then(function(r2) {
                    return socket.send(Pong(r2).text);
                  });
                else
                  socket.send(Pong(null).text);
                return;
              }
              case PONG: {
                if (onPong)
                  onPong(message.payload);
                return;
              }
            }
            if (!_this.socketState.acknowledged) {
              return;
            }
            if (message.id === void 0 || message.id === null || !_this.socketState.subscriptions[message.id]) {
              return;
            }
            var _a3 = _this.socketState.subscriptions[message.id], query = _a3.query, variables = _a3.variables, subscriber = _a3.subscriber;
            switch (message.type) {
              case NEXT: {
                if (!message.payload.errors && message.payload.data) {
                  subscriber.next && subscriber.next(message.payload.data);
                }
                if (message.payload.errors) {
                  subscriber.error && subscriber.error(new types_1.ClientError(__assign2(__assign2({}, message.payload), { status: 200 }), { query, variables }));
                } else {
                }
                return;
              }
              case ERROR: {
                subscriber.error && subscriber.error(new types_1.ClientError({ errors: message.payload, status: 200 }, { query, variables }));
                return;
              }
              case COMPLETE: {
                subscriber.complete && subscriber.complete();
                delete _this.socketState.subscriptions[message.id];
                return;
              }
            }
          } catch (e3) {
            console.error(e3);
            socket.close(1006);
          }
          socket.close(4400, "Unknown graphql-ws message.");
        };
      }
      GraphQLWebSocketClient2.prototype.makeSubscribe = function(query, operationName, variables, subscriber) {
        var _this = this;
        var subscriptionId = (this.socketState.lastRequestId++).toString();
        this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
        this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
        return function() {
          _this.socket.send(Complete(subscriptionId).text);
          delete _this.socketState.subscriptions[subscriptionId];
        };
      };
      GraphQLWebSocketClient2.prototype.rawRequest = function(query, variables) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var result;
          _this.rawSubscribe(query, {
            next: function(data2, extensions) {
              return result = { data: data2, extensions };
            },
            error: reject,
            complete: function() {
              return resolve(result);
            }
          }, variables);
        });
      };
      GraphQLWebSocketClient2.prototype.request = function(document2, variables) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var result;
          _this.subscribe(document2, {
            next: function(data2) {
              return result = data2;
            },
            error: reject,
            complete: function() {
              return resolve(result);
            }
          }, variables);
        });
      };
      GraphQLWebSocketClient2.prototype.subscribe = function(document2, subscriber, variables) {
        var _a2 = _12.resolveRequestDocument(document2), query = _a2.query, operationName = _a2.operationName;
        return this.makeSubscribe(query, operationName, variables, subscriber);
      };
      GraphQLWebSocketClient2.prototype.rawSubscribe = function(query, subscriber, variables) {
        return this.makeSubscribe(query, void 0, variables, subscriber);
      };
      GraphQLWebSocketClient2.prototype.ping = function(payload) {
        this.socket.send(Ping(payload).text);
      };
      GraphQLWebSocketClient2.prototype.close = function() {
        this.socket.close(1e3);
      };
      GraphQLWebSocketClient2.PROTOCOL = "graphql-transport-ws";
      return GraphQLWebSocketClient2;
    }()
  );
  graphqlWs.GraphQLWebSocketClient = GraphQLWebSocketClient;
  function parseMessage(data2, f2) {
    if (f2 === void 0) {
      f2 = function(a2) {
        return a2;
      };
    }
    var m2 = GraphQLWebSocketMessage.parse(data2, f2);
    return m2;
  }
  function ConnectionInit(payload) {
    return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
  }
  function Ping(payload) {
    return new GraphQLWebSocketMessage(PING, payload, void 0);
  }
  function Pong(payload) {
    return new GraphQLWebSocketMessage(PONG, payload, void 0);
  }
  function Subscribe(id2, payload) {
    return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id2);
  }
  function Complete(id2) {
    return new GraphQLWebSocketMessage(COMPLETE, void 0, id2);
  }
  return graphqlWs;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding2(result, mod2, k2);
      }
      __setModuleDefault2(result, mod2);
      return result;
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value2) {
        return value2 instanceof P2 ? value2 : new P2(function(resolve) {
          resolve(value2);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1) throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n3) {
        return function(v2) {
          return step([n3, v2]);
        };
      }
      function step(op) {
        if (f2) throw new TypeError("Generator is already executing.");
        while (_2) try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
          if (y2 = 0, t2) op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2]) _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s2, e2) {
      var t2 = {};
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
            t2[p2[i2]] = s2[p2[i2]];
        }
      return t2;
    };
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLWebSocketClient = exports.gql = exports.resolveRequestDocument = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
    var cross_fetch_1 = __importStar2(browserPonyfillExports), CrossFetch = cross_fetch_1;
    var parser_1 = require$$1$2;
    var printer_1 = require$$2$2;
    var createRequestBody_1 = __importDefault2(createRequestBody$1);
    var defaultJsonSerializer_12 = defaultJsonSerializer;
    var parseArgs_1 = parseArgs;
    var types_1 = types;
    Object.defineProperty(exports, "ClientError", { enumerable: true, get: function() {
      return types_1.ClientError;
    } });
    var resolveHeaders = function(headers) {
      var oHeaders = {};
      if (headers) {
        if (typeof Headers !== "undefined" && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
          oHeaders = HeadersInstanceToPlainObject(headers);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(_a2) {
            var name = _a2[0], value2 = _a2[1];
            oHeaders[name] = value2;
          });
        } else {
          oHeaders = headers;
        }
      }
      return oHeaders;
    };
    var queryCleanner = function(str) {
      return str.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim();
    };
    var buildGetQueryParams = function(_a2) {
      var query = _a2.query, variables = _a2.variables, operationName = _a2.operationName, jsonSerializer = _a2.jsonSerializer;
      if (!Array.isArray(query)) {
        var search = ["query=" + encodeURIComponent(queryCleanner(query))];
        if (variables) {
          search.push("variables=" + encodeURIComponent(jsonSerializer.stringify(variables)));
        }
        if (operationName) {
          search.push("operationName=" + encodeURIComponent(operationName));
        }
        return search.join("&");
      }
      if (typeof variables !== "undefined" && !Array.isArray(variables)) {
        throw new Error("Cannot create query with given variable type, array expected");
      }
      var payload = query.reduce(function(accu, currentQuery, index) {
        accu.push({
          query: queryCleanner(currentQuery),
          variables: variables ? jsonSerializer.stringify(variables[index]) : void 0
        });
        return accu;
      }, []);
      return "query=" + encodeURIComponent(jsonSerializer.stringify(payload));
    };
    var post = function(_a2) {
      var url2 = _a2.url, query = _a2.query, variables = _a2.variables, operationName = _a2.operationName, headers = _a2.headers, fetch2 = _a2.fetch, fetchOptions = _a2.fetchOptions, middleware2 = _a2.middleware;
      return __awaiter2(void 0, void 0, void 0, function() {
        var body, options;
        return __generator2(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              body = createRequestBody_1.default(query, variables, operationName, fetchOptions.jsonSerializer);
              options = __assign2({ method: "POST", headers: __assign2(__assign2({}, typeof body === "string" ? { "Content-Type": "application/json" } : {}), headers), body }, fetchOptions);
              if (!middleware2) return [3, 2];
              return [4, Promise.resolve(middleware2(options))];
            case 1:
              options = _b2.sent();
              _b2.label = 2;
            case 2:
              return [4, fetch2(url2, options)];
            case 3:
              return [2, _b2.sent()];
          }
        });
      });
    };
    var get = function(_a2) {
      var url2 = _a2.url, query = _a2.query, variables = _a2.variables, operationName = _a2.operationName, headers = _a2.headers, fetch2 = _a2.fetch, fetchOptions = _a2.fetchOptions, middleware2 = _a2.middleware;
      return __awaiter2(void 0, void 0, void 0, function() {
        var queryParams, options;
        return __generator2(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              queryParams = buildGetQueryParams({
                query,
                variables,
                operationName,
                jsonSerializer: fetchOptions.jsonSerializer
              });
              options = __assign2({ method: "GET", headers }, fetchOptions);
              if (!middleware2) return [3, 2];
              return [4, Promise.resolve(middleware2(options))];
            case 1:
              options = _b2.sent();
              _b2.label = 2;
            case 2:
              return [4, fetch2(url2 + "?" + queryParams, options)];
            case 3:
              return [2, _b2.sent()];
          }
        });
      });
    };
    var GraphQLClient = (
      /** @class */
      function() {
        function GraphQLClient2(url2, options) {
          if (options === void 0) {
            options = {};
          }
          this.url = url2;
          this.options = options;
        }
        GraphQLClient2.prototype.rawRequest = function(queryOrOptions, variables, requestHeaders) {
          return __awaiter2(this, void 0, void 0, function() {
            var rawRequestOptions, _a2, headers, _b2, fetch2, _c2, method, requestMiddleware, responseMiddleware, fetchOptions, url2, operationName;
            return __generator2(this, function(_d2) {
              rawRequestOptions = parseArgs_1.parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
              _a2 = this.options, headers = _a2.headers, _b2 = _a2.fetch, fetch2 = _b2 === void 0 ? cross_fetch_1.default : _b2, _c2 = _a2.method, method = _c2 === void 0 ? "POST" : _c2, requestMiddleware = _a2.requestMiddleware, responseMiddleware = _a2.responseMiddleware, fetchOptions = __rest2(_a2, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
              url2 = this.url;
              if (rawRequestOptions.signal !== void 0) {
                fetchOptions.signal = rawRequestOptions.signal;
              }
              operationName = resolveRequestDocument(rawRequestOptions.query).operationName;
              return [2, makeRequest({
                url: url2,
                query: rawRequestOptions.query,
                variables: rawRequestOptions.variables,
                headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(rawRequestOptions.requestHeaders)),
                operationName,
                fetch: fetch2,
                method,
                fetchOptions,
                middleware: requestMiddleware
              }).then(function(response) {
                if (responseMiddleware) {
                  responseMiddleware(response);
                }
                return response;
              }).catch(function(error) {
                if (responseMiddleware) {
                  responseMiddleware(error);
                }
                throw error;
              })];
            });
          });
        };
        GraphQLClient2.prototype.request = function(documentOrOptions) {
          var variablesAndRequestHeaders = [];
          for (var _i2 = 1; _i2 < arguments.length; _i2++) {
            variablesAndRequestHeaders[_i2 - 1] = arguments[_i2];
          }
          var variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
          var requestOptions = parseArgs_1.parseRequestArgs(documentOrOptions, variables, requestHeaders);
          var _a2 = this.options, headers = _a2.headers, _b2 = _a2.fetch, fetch2 = _b2 === void 0 ? cross_fetch_1.default : _b2, _c2 = _a2.method, method = _c2 === void 0 ? "POST" : _c2, requestMiddleware = _a2.requestMiddleware, responseMiddleware = _a2.responseMiddleware, fetchOptions = __rest2(_a2, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
          var url2 = this.url;
          if (requestOptions.signal !== void 0) {
            fetchOptions.signal = requestOptions.signal;
          }
          var _d2 = resolveRequestDocument(requestOptions.document), query = _d2.query, operationName = _d2.operationName;
          return makeRequest({
            url: url2,
            query,
            variables: requestOptions.variables,
            headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(requestOptions.requestHeaders)),
            operationName,
            fetch: fetch2,
            method,
            fetchOptions,
            middleware: requestMiddleware
          }).then(function(response) {
            if (responseMiddleware) {
              responseMiddleware(response);
            }
            return response.data;
          }).catch(function(error) {
            if (responseMiddleware) {
              responseMiddleware(error);
            }
            throw error;
          });
        };
        GraphQLClient2.prototype.batchRequests = function(documentsOrOptions, requestHeaders) {
          var batchRequestOptions = parseArgs_1.parseBatchRequestArgs(documentsOrOptions, requestHeaders);
          var _a2 = this.options, headers = _a2.headers, _b2 = _a2.fetch, fetch2 = _b2 === void 0 ? cross_fetch_1.default : _b2, _c2 = _a2.method, method = _c2 === void 0 ? "POST" : _c2, requestMiddleware = _a2.requestMiddleware, responseMiddleware = _a2.responseMiddleware, fetchOptions = __rest2(_a2, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
          var url2 = this.url;
          if (batchRequestOptions.signal !== void 0) {
            fetchOptions.signal = batchRequestOptions.signal;
          }
          var queries = batchRequestOptions.documents.map(function(_a3) {
            var document2 = _a3.document;
            return resolveRequestDocument(document2).query;
          });
          var variables = batchRequestOptions.documents.map(function(_a3) {
            var variables2 = _a3.variables;
            return variables2;
          });
          return makeRequest({
            url: url2,
            query: queries,
            variables,
            headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(batchRequestOptions.requestHeaders)),
            operationName: void 0,
            fetch: fetch2,
            method,
            fetchOptions,
            middleware: requestMiddleware
          }).then(function(response) {
            if (responseMiddleware) {
              responseMiddleware(response);
            }
            return response.data;
          }).catch(function(error) {
            if (responseMiddleware) {
              responseMiddleware(error);
            }
            throw error;
          });
        };
        GraphQLClient2.prototype.setHeaders = function(headers) {
          this.options.headers = headers;
          return this;
        };
        GraphQLClient2.prototype.setHeader = function(key, value2) {
          var _a2;
          var headers = this.options.headers;
          if (headers) {
            headers[key] = value2;
          } else {
            this.options.headers = (_a2 = {}, _a2[key] = value2, _a2);
          }
          return this;
        };
        GraphQLClient2.prototype.setEndpoint = function(value2) {
          this.url = value2;
          return this;
        };
        return GraphQLClient2;
      }()
    );
    exports.GraphQLClient = GraphQLClient;
    function makeRequest(_a2) {
      var url2 = _a2.url, query = _a2.query, variables = _a2.variables, headers = _a2.headers, operationName = _a2.operationName, fetch2 = _a2.fetch, _b2 = _a2.method, method = _b2 === void 0 ? "POST" : _b2, fetchOptions = _a2.fetchOptions, middleware2 = _a2.middleware;
      return __awaiter2(this, void 0, void 0, function() {
        var fetcher, isBathchingQuery, response, result, successfullyReceivedData, successfullyPassedErrorPolicy, headers_1, status_1, rest, data2, errorResult;
        return __generator2(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              fetcher = method.toUpperCase() === "POST" ? post : get;
              isBathchingQuery = Array.isArray(query);
              return [4, fetcher({
                url: url2,
                query,
                variables,
                operationName,
                headers,
                fetch: fetch2,
                fetchOptions,
                middleware: middleware2
              })];
            case 1:
              response = _c2.sent();
              return [4, getResult(response, fetchOptions.jsonSerializer)];
            case 2:
              result = _c2.sent();
              successfullyReceivedData = isBathchingQuery && Array.isArray(result) ? !result.some(function(_a3) {
                var data3 = _a3.data;
                return !data3;
              }) : !!result.data;
              successfullyPassedErrorPolicy = !result.errors || fetchOptions.errorPolicy === "all" || fetchOptions.errorPolicy === "ignore";
              if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
                headers_1 = response.headers, status_1 = response.status;
                result.errors, rest = __rest2(result, ["errors"]);
                data2 = fetchOptions.errorPolicy === "ignore" ? rest : result;
                return [2, __assign2(__assign2({}, isBathchingQuery ? { data: data2 } : data2), { headers: headers_1, status: status_1 })];
              } else {
                errorResult = typeof result === "string" ? { error: result } : result;
                throw new types_1.ClientError(__assign2(__assign2({}, errorResult), { status: response.status, headers: response.headers }), { query, variables });
              }
          }
        });
      });
    }
    function rawRequest(urlOrOptions, query, variables, requestHeaders) {
      return __awaiter2(this, void 0, void 0, function() {
        var requestOptions, client2;
        return __generator2(this, function(_a2) {
          requestOptions = parseArgs_1.parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders);
          client2 = new GraphQLClient(requestOptions.url);
          return [2, client2.rawRequest(__assign2({}, requestOptions))];
        });
      });
    }
    exports.rawRequest = rawRequest;
    function request(urlOrOptions, document2) {
      var variablesAndRequestHeaders = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        variablesAndRequestHeaders[_i2 - 2] = arguments[_i2];
      }
      return __awaiter2(this, void 0, void 0, function() {
        var variables, requestHeaders, requestOptions, client2;
        return __generator2(this, function(_a2) {
          variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
          requestOptions = parseArgs_1.parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders);
          client2 = new GraphQLClient(requestOptions.url);
          return [2, client2.request(__assign2({}, requestOptions))];
        });
      });
    }
    exports.request = request;
    function batchRequests(urlOrOptions, documents, requestHeaders) {
      return __awaiter2(this, void 0, void 0, function() {
        var requestOptions, client2;
        return __generator2(this, function(_a2) {
          requestOptions = parseArgs_1.parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders);
          client2 = new GraphQLClient(requestOptions.url);
          return [2, client2.batchRequests(__assign2({}, requestOptions))];
        });
      });
    }
    exports.batchRequests = batchRequests;
    exports.default = request;
    function getResult(response, jsonSerializer) {
      if (jsonSerializer === void 0) {
        jsonSerializer = defaultJsonSerializer_12.defaultJsonSerializer;
      }
      return __awaiter2(this, void 0, void 0, function() {
        var contentType, _a2, _b2;
        return __generator2(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              response.headers.forEach(function(value2, key) {
                if (key.toLowerCase() === "content-type") {
                  contentType = value2;
                }
              });
              if (!(contentType && contentType.toLowerCase().startsWith("application/json"))) return [3, 2];
              _b2 = (_a2 = jsonSerializer).parse;
              return [4, response.text()];
            case 1:
              return [2, _b2.apply(_a2, [_c2.sent()])];
            case 2:
              return [2, response.text()];
          }
        });
      });
    }
    function extractOperationName(document2) {
      var _a2;
      var operationName = void 0;
      var operationDefinitions = document2.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      });
      if (operationDefinitions.length === 1) {
        operationName = (_a2 = operationDefinitions[0].name) === null || _a2 === void 0 ? void 0 : _a2.value;
      }
      return operationName;
    }
    function resolveRequestDocument(document2) {
      if (typeof document2 === "string") {
        var operationName_1 = void 0;
        try {
          var parsedDocument = parser_1.parse(document2);
          operationName_1 = extractOperationName(parsedDocument);
        } catch (err) {
        }
        return { query: document2, operationName: operationName_1 };
      }
      var operationName = extractOperationName(document2);
      return { query: printer_1.print(document2), operationName };
    }
    exports.resolveRequestDocument = resolveRequestDocument;
    function callOrIdentity(value2) {
      return typeof value2 === "function" ? value2() : value2;
    }
    function gql2(chunks) {
      var variables = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        variables[_i2 - 1] = arguments[_i2];
      }
      return chunks.reduce(function(accumulator, chunk, index) {
        return "" + accumulator + chunk + (index in variables ? variables[index] : "");
      }, "");
    }
    exports.gql = gql2;
    function HeadersInstanceToPlainObject(headers) {
      var o2 = {};
      headers.forEach(function(v2, k2) {
        o2[k2] = v2;
      });
      return o2;
    }
    var graphql_ws_1 = requireGraphqlWs();
    Object.defineProperty(exports, "GraphQLWebSocketClient", { enumerable: true, get: function() {
      return graphql_ws_1.GraphQLWebSocketClient;
    } });
  })(dist);
  return dist;
}
var distExports = requireDist();
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize$1(string2) {
  return string2.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize$1(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign$1(__assign$1({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node2) {
    if (node2.loc)
      delete node2.loc;
    Object.keys(node2).forEach(function(key) {
      var value2 = node2[key];
      if (value2 && typeof value2 === "object") {
        workSet.add(value2);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize$1(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse$3(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i2) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i2 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var ZeroBytes32 = "0x0000000000000000000000000000000000000000000000000000000000000000";
var FAILED_REQUIRE_SIGNAL = "0xffffffffffff0000";
var FAILED_TRANSFER_TO_ADDRESS_SIGNAL = "0xffffffffffff0001";
var FAILED_ASSERT_EQ_SIGNAL = "0xffffffffffff0003";
var FAILED_ASSERT_SIGNAL = "0xffffffffffff0004";
var FAILED_ASSERT_NE_SIGNAL = "0xffffffffffff0005";
var PANIC_REASONS = [
  "UnknownPanicReason",
  "Revert",
  "OutOfGas",
  "TransactionValidity",
  "MemoryOverflow",
  "ArithmeticOverflow",
  "ContractNotFound",
  "MemoryOwnership",
  "NotEnoughBalance",
  "ExpectedInternalContext",
  "AssetIdNotFound",
  "InputNotFound",
  "OutputNotFound",
  "WitnessNotFound",
  "TransactionMaturity",
  "InvalidMetadataIdentifier",
  "MalformedCallStructure",
  "ReservedRegisterNotWritable",
  "InvalidFlags",
  "InvalidImmediateValue",
  "ExpectedCoinInput",
  "EcalError",
  "MemoryWriteOverlap",
  "ContractNotInInputs",
  "InternalBalanceOverflow",
  "ContractMaxSize",
  "ExpectedUnallocatedStack",
  "MaxStaticContractsReached",
  "TransferAmountCannotBeZero",
  "ExpectedOutputVariable",
  "ExpectedParentInternalContext",
  "PredicateReturnedNonOne",
  "ContractIdAlreadyDeployed",
  "ContractMismatch",
  "MessageDataTooLong",
  "ArithmeticError",
  "ContractInstructionNotAllowed",
  "TransferZeroCoins",
  "InvalidInstruction",
  "MemoryNotExecutable",
  "PolicyIsNotSet",
  "PolicyNotFound",
  "TooManyReceipts",
  "BalanceOverflow",
  "InvalidBlockHeight",
  "TooManySlots"
];
var PANIC_DOC_URL = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";
let wasm$1;
const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
let cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function ret(value2) {
  const ret2 = wasm$1.ret(value2);
  return Instruction.__wrap(ret2);
}
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
  const ret2 = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
  return Instruction.__wrap(ret2);
}
function tr(contract_id_addr, amount, asset_id_addr) {
  const ret2 = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
  return Instruction.__wrap(ret2);
}
function addi(dst, lhs, rhs) {
  const ret2 = wasm$1.addi(dst, lhs, rhs);
  return Instruction.__wrap(ret2);
}
function lw(dst, addr, offset2) {
  const ret2 = wasm$1.lw(dst, addr, offset2);
  return Instruction.__wrap(ret2);
}
function gtf(dst, arg, selector) {
  const ret2 = wasm$1.gtf(dst, arg, selector);
  return Instruction.__wrap(ret2);
}
function movi(dst, val) {
  const ret2 = wasm$1.movi(dst, val);
  return Instruction.__wrap(ret2);
}
let cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
const GTFArgs = Object.freeze({
  /**
  *r" Set `$rA` to `tx.type`
  */
  Type: 1,
  "1": "Type",
  /**
  *r" Set `$rA` to `tx.scriptGasLimit`
  */
  ScriptGasLimit: 2,
  "2": "ScriptGasLimit",
  /**
  *r" Set `$rA` to `tx.scriptLength`
  */
  ScriptLength: 3,
  "3": "ScriptLength",
  /**
  *r" Set `$rA` to `tx.scriptDataLength`
  */
  ScriptDataLength: 4,
  "4": "ScriptDataLength",
  /**
  *r" Set `$rA` to `tx.inputsCount`
  */
  ScriptInputsCount: 5,
  "5": "ScriptInputsCount",
  /**
  *r" Set `$rA` to `tx.outputsCount`
  */
  ScriptOutputsCount: 6,
  "6": "ScriptOutputsCount",
  /**
  *r" Set `$rA` to `tx.witnessesCount`
  */
  ScriptWitnessesCount: 7,
  "7": "ScriptWitnessesCount",
  /**
  *r" Set `$rA` to `Memory address of tx.script`
  */
  Script: 9,
  "9": "Script",
  /**
  *r" Set `$rA` to `Memory address of tx.scriptData`
  */
  ScriptData: 10,
  "10": "ScriptData",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
  */
  ScriptInputAtIndex: 11,
  "11": "ScriptInputAtIndex",
  /**
  *r" Set `$rA` to `Memory address of t.outputs[$rB]`
  */
  ScriptOutputAtIndex: 12,
  "12": "ScriptOutputAtIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
  */
  ScriptWitnessAtIndex: 13,
  "13": "ScriptWitnessAtIndex",
  /**
  *r" Set `$rA` to size of the transaction in memory, in bytes
  */
  TxLength: 14,
  "14": "TxLength",
  /**
  *r" Set `$rA` to `tx.bytecodeWitnessIndex`
  */
  CreateBytecodeWitnessIndex: 257,
  "257": "CreateBytecodeWitnessIndex",
  /**
  *r" Set `$rA` to `tx.storageSlotsCount`
  */
  CreateStorageSlotsCount: 258,
  "258": "CreateStorageSlotsCount",
  /**
  *r" Set `$rA` to `tx.inputsCount`
  */
  CreateInputsCount: 259,
  "259": "CreateInputsCount",
  /**
  *r" Set `$rA` to `tx.outputsCount`
  */
  CreateOutputsCount: 260,
  "260": "CreateOutputsCount",
  /**
  *r" Set `$rA` to `tx.witnessesCount`
  */
  CreateWitnessesCount: 261,
  "261": "CreateWitnessesCount",
  /**
  *r" Set `$rA` to `Memory address of tx.salt`
  */
  CreateSalt: 262,
  "262": "CreateSalt",
  /**
  *r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
  */
  CreateStorageSlotAtIndex: 263,
  "263": "CreateStorageSlotAtIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
  */
  CreateInputAtIndex: 264,
  "264": "CreateInputAtIndex",
  /**
  *r" Set `$rA` to `Memory address of t.outputs[$rB]`
  */
  CreateOutputAtIndex: 265,
  "265": "CreateOutputAtIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
  */
  CreateWitnessAtIndex: 266,
  "266": "CreateWitnessAtIndex",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].type`
  */
  InputType: 512,
  "512": "InputType",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
  */
  InputCoinTxId: 513,
  "513": "InputCoinTxId",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
  */
  InputCoinOutputIndex: 514,
  "514": "InputCoinOutputIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
  */
  InputCoinOwner: 515,
  "515": "InputCoinOwner",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].amount`
  */
  InputCoinAmount: 516,
  "516": "InputCoinAmount",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
  */
  InputCoinAssetId: 517,
  "517": "InputCoinAssetId",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
  */
  InputCoinTxPointer: 518,
  "518": "InputCoinTxPointer",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
  */
  InputCoinWitnessIndex: 519,
  "519": "InputCoinWitnessIndex",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
  */
  InputCoinPredicateLength: 521,
  "521": "InputCoinPredicateLength",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
  */
  InputCoinPredicateDataLength: 522,
  "522": "InputCoinPredicateDataLength",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
  */
  InputCoinPredicate: 523,
  "523": "InputCoinPredicate",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
  */
  InputCoinPredicateData: 524,
  "524": "InputCoinPredicateData",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
  */
  InputCoinPredicateGasUsed: 525,
  "525": "InputCoinPredicateGasUsed",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
  */
  InputContractTxId: 544,
  "544": "InputContractTxId",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
  */
  InputContractOutputIndex: 545,
  "545": "InputContractOutputIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
  */
  InputContractId: 549,
  "549": "InputContractId",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
  */
  InputMessageSender: 576,
  "576": "InputMessageSender",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
  */
  InputMessageRecipient: 577,
  "577": "InputMessageRecipient",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].amount`
  */
  InputMessageAmount: 578,
  "578": "InputMessageAmount",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
  */
  InputMessageNonce: 579,
  "579": "InputMessageNonce",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
  */
  InputMessageWitnessIndex: 580,
  "580": "InputMessageWitnessIndex",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].dataLength`
  */
  InputMessageDataLength: 581,
  "581": "InputMessageDataLength",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
  */
  InputMessagePredicateLength: 582,
  "582": "InputMessagePredicateLength",
  /**
  *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
  */
  InputMessagePredicateDataLength: 583,
  "583": "InputMessagePredicateDataLength",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
  */
  InputMessageData: 584,
  "584": "InputMessageData",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
  */
  InputMessagePredicate: 585,
  "585": "InputMessagePredicate",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
  */
  InputMessagePredicateData: 586,
  "586": "InputMessagePredicateData",
  /**
  *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
  */
  InputMessagePredicateGasUsed: 587,
  "587": "InputMessagePredicateGasUsed",
  /**
  *r" Set `$rA` to `tx.outputs[$rB].type`
  */
  OutputType: 768,
  "768": "OutputType",
  /**
  *r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
  */
  OutputCoinTo: 769,
  "769": "OutputCoinTo",
  /**
  *r" Set `$rA` to `tx.outputs[$rB].amount`
  */
  OutputCoinAmount: 770,
  "770": "OutputCoinAmount",
  /**
  *r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
  */
  OutputCoinAssetId: 771,
  "771": "OutputCoinAssetId",
  /**
  *r" Set `$rA` to `tx.outputs[$rB].inputIndex`
  */
  OutputContractInputIndex: 772,
  "772": "OutputContractInputIndex",
  /**
  *r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
  */
  OutputContractCreatedContractId: 775,
  "775": "OutputContractCreatedContractId",
  /**
  *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
  */
  OutputContractCreatedStateRoot: 776,
  "776": "OutputContractCreatedStateRoot",
  /**
  *r" Set `$rA` to `tx.witnesses[$rB].dataLength`
  */
  WitnessDataLength: 1024,
  "1024": "WitnessDataLength",
  /**
  *r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
  */
  WitnessData: 1025,
  "1025": "WitnessData",
  /**
  *r" Set `$rA` to `tx.policyTypes`
  */
  PolicyTypes: 1280,
  "1280": "PolicyTypes",
  /**
  *r" Set `$rA` to `tx.policies[0x00].gasPrice`
  */
  PolicyTip: 1281,
  "1281": "PolicyTip",
  /**
  *r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
  */
  PolicyWitnessLimit: 1282,
  "1282": "PolicyWitnessLimit",
  /**
  *r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
  */
  PolicyMaturity: 1283,
  "1283": "PolicyMaturity",
  /**
  *r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
  */
  PolicyMaxFee: 1284,
  "1284": "PolicyMaxFee"
});
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_add_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_addi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_aloc_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_and_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_andi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bal_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bhei_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bhsh_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_burn_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_call_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ccp_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfe_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfei_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfs_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfsi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_croo_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_csiz_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_compareargs_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_div_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_divi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_divargs_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ecal_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_eck1_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ecr1_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ed19_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_eq_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_exp_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_expi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_flag_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gm_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gt_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gtf_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm06_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm12_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm18_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm24_free(ptr >>> 0));
const InstructionFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_instruction_free(ptr >>> 0));
class Instruction {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Instruction.prototype);
    obj.__wbg_ptr = ptr;
    InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    InstructionFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_instruction_free(ptr);
  }
  /**
  * Convenience method for converting to bytes
  * @returns {Uint8Array}
  */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v12 = getArrayU8FromWasm0(r0, r1).slice();
      wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
      return v12;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Size of an instruction in bytes
  * @returns {number}
  */
  static size() {
    const ret2 = wasm$1.instruction_size();
    return ret2 >>> 0;
  }
}
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ji_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmp_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmpb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmpf_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jne_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jneb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnef_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnei_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzf_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_k256_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ldc_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_log_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_logd_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lt_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lw_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcl_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcli_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcp_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcpi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_meq_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mint_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mldv_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mlog_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mod_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_modi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_move_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_movi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mroo_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mul_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_muli_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mathargs_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mulargs_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_noop_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_not_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_or_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ori_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_poph_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_popl_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_pshh_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_pshl_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_panicinstruction_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ret_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_retd_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_rvrt_free(ptr >>> 0));
const RegIdFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_regid_free(ptr >>> 0));
class RegId {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RegId.prototype);
    obj.__wbg_ptr = ptr;
    RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RegIdFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_regid_free(ptr);
  }
  /**
  * Construct a register ID from the given value.
  *
  * Returns `None` if the value is outside the 6-bit value range.
  * @param {number} u
  * @returns {RegId | undefined}
  */
  static new_checked(u2) {
    const ret2 = wasm$1.regid_new_checked(u2);
    return ret2 === 0 ? void 0 : RegId.__wrap(ret2);
  }
  /**
  * Received balance for this context.
  * @returns {RegId}
  */
  static bal() {
    const ret2 = wasm$1.regid_bal();
    return RegId.__wrap(ret2);
  }
  /**
  * Remaining gas in the context.
  * @returns {RegId}
  */
  static cgas() {
    const ret2 = wasm$1.regid_cgas();
    return RegId.__wrap(ret2);
  }
  /**
  * Error codes for particular operations.
  * @returns {RegId}
  */
  static err() {
    const ret2 = wasm$1.regid_err();
    return RegId.__wrap(ret2);
  }
  /**
  * Flags register.
  * @returns {RegId}
  */
  static flag() {
    const ret2 = wasm$1.regid_flag();
    return RegId.__wrap(ret2);
  }
  /**
  * Frame pointer. Memory address of beginning of current call frame.
  * @returns {RegId}
  */
  static fp() {
    const ret2 = wasm$1.regid_fp();
    return RegId.__wrap(ret2);
  }
  /**
  * Remaining gas globally.
  * @returns {RegId}
  */
  static ggas() {
    const ret2 = wasm$1.regid_ggas();
    return RegId.__wrap(ret2);
  }
  /**
  * Heap pointer. Memory address below the current bottom of the heap (points to free
  * memory).
  * @returns {RegId}
  */
  static hp() {
    const ret2 = wasm$1.regid_hp();
    return RegId.__wrap(ret2);
  }
  /**
  * Instructions start. Pointer to the start of the currently-executing code.
  * @returns {RegId}
  */
  static is() {
    const ret2 = wasm$1.regid_is();
    return RegId.__wrap(ret2);
  }
  /**
  * Contains overflow/underflow of addition, subtraction, and multiplication.
  * @returns {RegId}
  */
  static of() {
    const ret2 = wasm$1.regid_of();
    return RegId.__wrap(ret2);
  }
  /**
  * Contains one (1), for convenience.
  * @returns {RegId}
  */
  static one() {
    const ret2 = wasm$1.regid_one();
    return RegId.__wrap(ret2);
  }
  /**
  * The program counter. Memory address of the current instruction.
  * @returns {RegId}
  */
  static pc() {
    const ret2 = wasm$1.regid_pc();
    return RegId.__wrap(ret2);
  }
  /**
  * Return value or pointer.
  * @returns {RegId}
  */
  static ret() {
    const ret2 = wasm$1.regid_ret();
    return RegId.__wrap(ret2);
  }
  /**
  * Return value length in bytes.
  * @returns {RegId}
  */
  static retl() {
    const ret2 = wasm$1.regid_retl();
    return RegId.__wrap(ret2);
  }
  /**
  * Stack pointer. Memory address on top of current writable stack area (points to
  * free memory).
  * @returns {RegId}
  */
  static sp() {
    const ret2 = wasm$1.regid_sp();
    return RegId.__wrap(ret2);
  }
  /**
  * Stack start pointer. Memory address of bottom of current writable stack area.
  * @returns {RegId}
  */
  static spp() {
    const ret2 = wasm$1.regid_spp();
    return RegId.__wrap(ret2);
  }
  /**
  * Smallest writable register.
  * @returns {RegId}
  */
  static writable() {
    const ret2 = wasm$1.regid_writable();
    return RegId.__wrap(ret2);
  }
  /**
  * Contains zero (0), for convenience.
  * @returns {RegId}
  */
  static zero() {
    const ret2 = wasm$1.regid_zero();
    return RegId.__wrap(ret2);
  }
  /**
  * Construct a register ID from the given value.
  *
  * The given value will be masked to 6 bits.
  * @param {number} u
  */
  constructor(u2) {
    const ret2 = wasm$1.regid_new_typescript(u2);
    this.__wbg_ptr = ret2 >>> 0;
    return this;
  }
  /**
  * A const alternative to the `Into<u8>` implementation.
  * @returns {number}
  */
  to_u8() {
    const ptr = this.__destroy_into_raw();
    const ret2 = wasm$1.regid_to_u8(ptr);
    return ret2;
  }
}
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_s256_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sb_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_scwq_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sll_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_slli_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_smo_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srl_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srli_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srw_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srwq_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sub_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_subi_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sw_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sww_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_swwq_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_time_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_tr_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_tro_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdam_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdcm_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wddv_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdmd_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdml_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdmm_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdop_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqam_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqcm_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqdv_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqmd_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqml_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqmm_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqop_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_xor_free(ptr >>> 0));
typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm$1.__wbg_xori_free(ptr >>> 0));
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e2) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes2 = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance2 = await WebAssembly.instantiate(module, imports);
    if (instance2 instanceof WebAssembly.Instance) {
      return { instance: instance2, module };
    } else {
      return instance2;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance2, module) {
  wasm$1 = instance2.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm$1;
}
async function __wbg_init(input) {
  if (wasm$1 !== void 0) return wasm$1;
  const imports = __wbg_get_imports();
  const { instance: instance2, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance2, module);
}
function _loadWasmModule(sync, filepath, src2, imports) {
  var buf = null;
  var isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
  if (isNode2) {
    buf = Buffer.from(src2, "base64");
  } else {
    var raw = globalThis.atob(src2);
    var rawLength = raw.length;
    buf = new Uint8Array(new ArrayBuffer(rawLength));
    for (var i2 = 0; i2 < rawLength; i2++) {
      buf[i2] = raw.charCodeAt(i2);
    }
  }
  {
    var mod2 = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod2, imports) : mod2;
  }
}
function wasm(imports) {
  return _loadWasmModule(1, null, "AGFzbQEAAAABQAtgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38Bf2AAAX9gAn9/AGABfwBgBX9/f39/AX9gA39/fwBgAABgAn5/AX8CGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cABQP7AfkBAQMKBgEFBQUBBQEBAQEBAQECBQICAQEDAgICAgUCAwMDAwMDAwIBBQEFAAMDAwMDAwMDAwMDAQABAQUFAQEBAQEBAQEBAQIBBQUFAwIBAAABAQEFAgIBAQYABgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGAwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEDBgADAQEBBwICAAIABgEEAwEDBQgBCQkDAwMFAQEBBgYGBgQEBAQEBAQEBAQEBAQEBAQEBAQGBwcCAgIDBwcACAADBAUBcAEHBwUDAQARBgkBfwFBgIDAAAsHxEvBBQZtZW1vcnkCABZfX3diZ19jb21wYXJlYXJnc19mcmVlAHcaX193YmdfZ2V0X2NvbXBhcmVhcmdzX21vZGUAORpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQAoIl9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMAOiJfX3diZ19zZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzADsSY29tcGFyZWFyZ3NfdG9faW1tAEgUY29tcGFyZWFyZ3NfZnJvbV9pbW0AKRVfX3diZ19nZXRfbWF0aGFyZ3Nfb3AAORVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AAKhJfX3diZ19tdWxhcmdzX2ZyZWUAeB5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMAOR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMAPBJfX3diZ19kaXZhcmdzX2ZyZWUA1gEeX193YmdfZ2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAK0BIXBhbmljaW5zdHJ1Y3Rpb25fZXJyb3JfdHlwZXNjcmlwdABMF3BhbmljaW5zdHJ1Y3Rpb25fcmVhc29uAD4ccGFuaWNpbnN0cnVjdGlvbl9pbnN0cnVjdGlvbgA/DGdtX2Zyb21fYXJncwDJAQ1ndGZfZnJvbV9hcmdzAMEBB2dtX2FyZ3MAeQhndGZfYXJncwBaDndkY21fZnJvbV9hcmdzACYOd2RvcF9mcm9tX2FyZ3MAJg53ZG1sX2Zyb21fYXJncwAeDndkZHZfZnJvbV9hcmdzAL8BCXdkY21fYXJncwAZCXdxY21fYXJncwAaCXdkb3BfYXJncwAbCXdxb3BfYXJncwAcCXdkbWxfYXJncwAUCXdxbWxfYXJncwAVCXdkZHZfYXJncwBVCXdxZHZfYXJncwBWEF9fd2JnX2ltbTA2X2ZyZWUA1wEQX193YmdfaW1tMTJfZnJlZQDYARBfX3diZ19pbW0xOF9mcmVlANkBDl9fd2JnX2FkZF9mcmVlALgBD19fd2JnX25vb3BfZnJlZQBbEmFkZF9uZXdfdHlwZXNjcmlwdABPBmFkZF9yYQAWBmFkZF9yYgALBmFkZF9yYwAPA2FkZAC5AQNhbmQAewNkaXYAfAJlcQB9A2V4cAB+Amd0AH8CbHQAgAEEbWxvZwCBAQRtcm9vAIIBBG1vZF8AgwEFbW92ZV8ALANtdWwAhAEDbm90AC0Cb3IAhQEDc2xsAIYBA3NybACHAQNzdWIAiAEDeG9yAIkBBG1sZHYAXANyZXQArgEEcmV0ZAAuE2Fsb2NfbmV3X3R5cGVzY3JpcHQAVwdhbG9jX3JhAE4EYWxvYwCvAQNtY2wALwNtY3AAigEDbWVxAF0TYmhzaF9uZXdfdHlwZXNjcmlwdAAfBGJoc2gAMARiaGVpALABBGJ1cm4AMRNjYWxsX25ld190eXBlc2NyaXB0AE0HY2FsbF9yZAAXBGNhbGwAXgNjY3AAXwRjcm9vADIEY3NpegAzAmNiALEBA2xkYwCLAQNsb2cAYARsb2dkAGEEbWludAA0BHJ2cnQAsgEEc2N3cQCMAQNzcncAjQEEc3J3cQBiA3N3dwCOAQRzd3dxAGMCdHIAjwEDdHJvAGQEZWNrMQCQAQRlY3IxAJEBBGVkMTkAkgEEazI1NgCTAQRzMjU2AJQBBHRpbWUANRNub29wX25ld190eXBlc2NyaXB0AMYBBG5vb3AA2gEEZmxhZwCzAQNiYWwAlQEDam1wALQBA2puZQCWAQNzbW8AZRNhZGRpX25ld190eXBlc2NyaXB0AFAKYWRkaV9pbW0xMgAMBGFkZGkAlwEEYW5kaQCYAQRkaXZpAJkBBGV4cGkAmgEEbW9kaQCbAQRtdWxpAJwBA29yaQCdAQRzbGxpAJ4BBHNybGkAnwEEc3ViaQCgAQR4b3JpAKEBBGpuZWkAogECbGIAowECbHcApAECc2IApQECc3cApgEEbWNwaQCnARJndGZfbmV3X3R5cGVzY3JpcHQAwwEDZ3RmAKgBBG1jbGkAIBFnbV9uZXdfdHlwZXNjcmlwdAA2CGdtX2ltbTE4AAkCZ20AIQRtb3ZpACIEam56aQAjBGptcGYAJBNqbXBiX25ld190eXBlc2NyaXB0ABgEam1wYgAlBGpuemYAqQEEam56YgCqAQRqbmVmAGYKam5lYl9pbW0wNgAXBGpuZWIAZwJqaQBAE2NmZWlfbmV3X3R5cGVzY3JpcHQANwpjZmVpX2ltbTI0ACcEY2ZlaQBBBGNmc2kAQgNjZmUAtQEDY2ZzALYBBHBzaGwAQwRwc2hoAEQEcG9wbABFBHBvcGgARhN3ZGNtX25ld190eXBlc2NyaXB0AMABBHdkY20AaAR3cWNtAGkEd2RvcABqBHdxb3AAawR3ZG1sAGwEd3FtbABtBHdkZHYAbgR3cWR2AG8Ed2RtZABwBHdxbWQAcQR3ZGFtAHIEd3FhbQBzBHdkbW0AdAR3cW1tAHUEZWNhbAB2Fl9fd2JnX2luc3RydWN0aW9uX2ZyZWUAWRRpbnN0cnVjdGlvbl90b19ieXRlcwAKEGluc3RydWN0aW9uX3NpemUA7AERcmVnaWRfbmV3X2NoZWNrZWQAqwEJcmVnaWRfYmFsANsBCnJlZ2lkX2NnYXMA3AEJcmVnaWRfZXJyAN0BCnJlZ2lkX2ZsYWcA3gEIcmVnaWRfZnAA3wEKcmVnaWRfZ2dhcwDgAQhyZWdpZF9ocADhAQhyZWdpZF9pcwDiAQhyZWdpZF9vZgDjAQlyZWdpZF9vbmUA5AEIcmVnaWRfcGMA5QEJcmVnaWRfcmV0AOYBCnJlZ2lkX3JldGwA5wEIcmVnaWRfc3AA6AEJcmVnaWRfc3BwAOkBDnJlZ2lkX3dyaXRhYmxlAOoBCnJlZ2lkX3plcm8A6wEUcmVnaWRfbmV3X3R5cGVzY3JpcHQA0wELcmVnaWRfdG9fdTgA1AETbW92aV9uZXdfdHlwZXNjcmlwdAAYE21jbGlfbmV3X3R5cGVzY3JpcHQAGBNqbnppX25ld190eXBlc2NyaXB0ABgTam1wZl9uZXdfdHlwZXNjcmlwdAAYEm5vdF9uZXdfdHlwZXNjcmlwdAAfE3JldGRfbmV3X3R5cGVzY3JpcHQAHxNtb3ZlX25ld190eXBlc2NyaXB0AB8SbWNsX25ld190eXBlc2NyaXB0AB8TYnVybl9uZXdfdHlwZXNjcmlwdAAfE2Nyb29fbmV3X3R5cGVzY3JpcHQAHxNjc2l6X25ld190eXBlc2NyaXB0AB8TbWludF9uZXdfdHlwZXNjcmlwdAAfE3RpbWVfbmV3X3R5cGVzY3JpcHQAHxJyZXRfbmV3X3R5cGVzY3JpcHQAVxNiaGVpX25ld190eXBlc2NyaXB0AFcRY2JfbmV3X3R5cGVzY3JpcHQAVxNydnJ0X25ld190eXBlc2NyaXB0AFcTZmxhZ19uZXdfdHlwZXNjcmlwdABXEmptcF9uZXdfdHlwZXNjcmlwdABXEmNmZV9uZXdfdHlwZXNjcmlwdABXEmNmc19uZXdfdHlwZXNjcmlwdABXE21sZHZfbmV3X3R5cGVzY3JpcHQATRJtZXFfbmV3X3R5cGVzY3JpcHQATRJjY3BfbmV3X3R5cGVzY3JpcHQATRJsb2dfbmV3X3R5cGVzY3JpcHQATRNsb2dkX25ld190eXBlc2NyaXB0AE0Tc3J3cV9uZXdfdHlwZXNjcmlwdABNE3N3d3FfbmV3X3R5cGVzY3JpcHQATRJ0cm9fbmV3X3R5cGVzY3JpcHQATRJzbW9fbmV3X3R5cGVzY3JpcHQATRNqbmVmX25ld190eXBlc2NyaXB0AE0Td2RtZF9uZXdfdHlwZXNjcmlwdABNE3dxbWRfbmV3X3R5cGVzY3JpcHQATRN3ZGFtX25ld190eXBlc2NyaXB0AE0Td3FhbV9uZXdfdHlwZXNjcmlwdABNE3dkbW1fbmV3X3R5cGVzY3JpcHQATRN3cW1tX25ld190eXBlc2NyaXB0AE0TZWNhbF9uZXdfdHlwZXNjcmlwdABNEmFuZF9uZXdfdHlwZXNjcmlwdABPEmRpdl9uZXdfdHlwZXNjcmlwdABPEWVxX25ld190eXBlc2NyaXB0AE8SZXhwX25ld190eXBlc2NyaXB0AE8RZ3RfbmV3X3R5cGVzY3JpcHQATxFsdF9uZXdfdHlwZXNjcmlwdABPE21sb2dfbmV3X3R5cGVzY3JpcHQATxNtcm9vX25ld190eXBlc2NyaXB0AE8SbW9kX25ld190eXBlc2NyaXB0AE8SbXVsX25ld190eXBlc2NyaXB0AE8Rb3JfbmV3X3R5cGVzY3JpcHQATxJzbGxfbmV3X3R5cGVzY3JpcHQATxJzcmxfbmV3X3R5cGVzY3JpcHQATxJzdWJfbmV3X3R5cGVzY3JpcHQATxJ4b3JfbmV3X3R5cGVzY3JpcHQATxJtY3BfbmV3X3R5cGVzY3JpcHQATxJsZGNfbmV3X3R5cGVzY3JpcHQATxNzY3dxX25ld190eXBlc2NyaXB0AE8Sc3J3X25ld190eXBlc2NyaXB0AE8Sc3d3X25ld190eXBlc2NyaXB0AE8RdHJfbmV3X3R5cGVzY3JpcHQATxNlY2sxX25ld190eXBlc2NyaXB0AE8TZWNyMV9uZXdfdHlwZXNjcmlwdABPE2VkMTlfbmV3X3R5cGVzY3JpcHQATxNrMjU2X25ld190eXBlc2NyaXB0AE8TczI1Nl9uZXdfdHlwZXNjcmlwdABPEmJhbF9uZXdfdHlwZXNjcmlwdABPEmpuZV9uZXdfdHlwZXNjcmlwdABPE2FuZGlfbmV3X3R5cGVzY3JpcHQAUBNkaXZpX25ld190eXBlc2NyaXB0AFATZXhwaV9uZXdfdHlwZXNjcmlwdABQE21vZGlfbmV3X3R5cGVzY3JpcHQAUBNtdWxpX25ld190eXBlc2NyaXB0AFASb3JpX25ld190eXBlc2NyaXB0AFATc2xsaV9uZXdfdHlwZXNjcmlwdABQE3NybGlfbmV3X3R5cGVzY3JpcHQAUBNzdWJpX25ld190eXBlc2NyaXB0AFATeG9yaV9uZXdfdHlwZXNjcmlwdABQE2puZWlfbmV3X3R5cGVzY3JpcHQAUBFsYl9uZXdfdHlwZXNjcmlwdABQEWx3X25ld190eXBlc2NyaXB0AFARc2JfbmV3X3R5cGVzY3JpcHQAUBFzd19uZXdfdHlwZXNjcmlwdABQE21jcGlfbmV3X3R5cGVzY3JpcHQAUBNqbnpmX25ld190eXBlc2NyaXB0AFATam56Yl9uZXdfdHlwZXNjcmlwdABQDndxY21fZnJvbV9hcmdzACYOd3FvcF9mcm9tX2FyZ3MAJh9fX3diZ19zZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzADseX193Ymdfc2V0X211bGFyZ3NfaW5kaXJlY3RfbGhzADseX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzADsRamlfbmV3X3R5cGVzY3JpcHQANxNjZnNpX25ld190eXBlc2NyaXB0ADcTcHNobF9uZXdfdHlwZXNjcmlwdAA3E3BzaGhfbmV3X3R5cGVzY3JpcHQANxNwb3BsX25ld190eXBlc2NyaXB0ADcTcG9waF9uZXdfdHlwZXNjcmlwdAA3E3dkbWxfbmV3X3R5cGVzY3JpcHQAwAETd3FtbF9uZXdfdHlwZXNjcmlwdADAAQ53cW1sX2Zyb21fYXJncwAeE3dxb3BfbmV3X3R5cGVzY3JpcHQAwAETd2Rkdl9uZXdfdHlwZXNjcmlwdADAARN3cWNtX25ld190eXBlc2NyaXB0AMABE3dkb3BfbmV3X3R5cGVzY3JpcHQAwAETd3Fkdl9uZXdfdHlwZXNjcmlwdADAARBfX3diZ19yZWdpZF9mcmVlANcBDndxZHZfZnJvbV9hcmdzAL8BEF9fd2JnX2ltbTI0X2ZyZWUA2QEPX193YmdfbW92aV9mcmVlALgBD19fd2JnX21sZHZfZnJlZQC4AQ9fX3diZ19mbGFnX2ZyZWUAuAEPX193YmdfZWNhbF9mcmVlALgBDl9fd2JnX2d0Zl9mcmVlALgBDl9fd2JnX3Nyd19mcmVlALgBDl9fd2JnX2Rpdl9mcmVlALgBD19fd2JnX3Njd3FfZnJlZQC4AQ5fX3diZ19leHBfZnJlZQC4AQZqbXBfcmEATg5fX3diZ19qbXBfZnJlZQC4AQ5fX3diZ19tdWxfZnJlZQC4AQ5fX3diZ19zcmxfZnJlZQC4AQ9fX3diZ19zd3dxX2ZyZWUAuAEOX193YmdfbWNwX2ZyZWUAuAENX193Ymdfc3dfZnJlZQC4AQ9fX3diZ19jZmVpX2ZyZWUAuAEPX193YmdfbG9nZF9mcmVlALgBDV9fd2JnX29yX2ZyZWUAuAEOX193YmdfbWVxX2ZyZWUAuAEPX193Ymdfd3FhbV9mcmVlALgBD19fd2JnX2puemJfZnJlZQC4AQ5fX3diZ19sZGNfZnJlZQC4AQ9fX3diZ19tY3BpX2ZyZWUAuAEPX193Ymdfam1wZl9mcmVlALgBDV9fd2JnX2xiX2ZyZWUAuAEPX193Ymdfd3FjbV9mcmVlALgBD19fd2JnX3dxb3BfZnJlZQC4AQ9fX3diZ19tcm9vX2ZyZWUAuAEPX193Ymdfd2RtbF9mcmVlALgBDV9fd2JnX3RyX2ZyZWUAuAEPX193Ymdfam5laV9mcmVlALgBD19fd2JnX2NhbGxfZnJlZQC4AQ9fX3diZ19hbmRpX2ZyZWUAuAEPX193YmdfYmhzaF9mcmVlALgBDl9fd2JnX3N3d19mcmVlALgBD19fd2JnX3N1YmlfZnJlZQC4AQ1fX3diZ19lcV9mcmVlALgBD19fd2JnX3dkbW1fZnJlZQC4AQ9fX3diZ19zbGxpX2ZyZWUAuAEOX193Ymdfam5lX2ZyZWUAuAEPX193YmdfbW92ZV9mcmVlALgBD19fd2JnX2RpdmlfZnJlZQC4AQ9fX3diZ19lY3IxX2ZyZWUAuAEKY2ZzaV9pbW0yNAAnD19fd2JnX2Nmc2lfZnJlZQC4AQ9fX3diZ19jc2l6X2ZyZWUAuAEPX193YmdfcmV0ZF9mcmVlALgBHl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X2xocwA6B2ZsYWdfcmEATg9fX3diZ19iaGVpX2ZyZWUAuAEPX193YmdfbW9kaV9mcmVlALgBDV9fd2JnX2d0X2ZyZWUAuAEfX193YmdfZ2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwA6Dl9fd2JnX2NjcF9mcmVlALgBD19fd2JnX2VjazFfZnJlZQC4AQdiaGVpX3JhAE4OX193YmdfYW5kX2ZyZWUAuAEPX193YmdfazI1Nl9mcmVlALgBD19fd2JnX2Fsb2NfZnJlZQC4AQ1fX3diZ19sdF9mcmVlALgBDl9fd2JnX3Ntb19mcmVlALgBD19fd2JnX2puemZfZnJlZQC4AQ5fX3diZ19tY2xfZnJlZQC4AQZyZXRfcmEATg5fX3diZ19yZXRfZnJlZQC4AQ9fX3diZ19taW50X2ZyZWUAuAEPX193Ymdfd2RvcF9mcmVlALgBD19fd2JnX2Nyb29fZnJlZQC4AQ5fX3diZ190cm9fZnJlZQC4AQ9fX3diZ193cW1kX2ZyZWUAuAEPX193Ymdfd3Fkdl9mcmVlALgBD19fd2JnX2V4cGlfZnJlZQC4AQ9fX3diZ19zcndxX2ZyZWUAuAEPX193Ymdfd3FtbF9mcmVlALgBD19fd2JnX3dkbWRfZnJlZQC4AQ5fX3diZ19tb2RfZnJlZQC4AQ9fX3diZ19qbnppX2ZyZWUAuAEPX193YmdfYnVybl9mcmVlALgBB3J2cnRfcmEATg9fX3diZ19ydnJ0X2ZyZWUAuAEOX193Ymdfb3JpX2ZyZWUAuAEKcHNobF9pbW0yNAAnD19fd2JnX3BzaGxfZnJlZQC4AQ9fX3diZ19hZGRpX2ZyZWUAuAEOX193YmdfeG9yX2ZyZWUAuAENX193YmdfbHdfZnJlZQC4AQpwb3BsX2ltbTI0ACcPX193YmdfcG9wbF9mcmVlALgBDV9fd2JnX3NiX2ZyZWUAuAEPX193YmdfbXVsaV9mcmVlALgBDl9fd2JnX2xvZ19mcmVlALgBCGppX2ltbTI0ACcNX193YmdfamlfZnJlZQC4AQ9fX3diZ19tbG9nX2ZyZWUAuAEPX193YmdfbWNsaV9mcmVlALgBDl9fd2JnX3N1Yl9mcmVlALgBDl9fd2JnX3NsbF9mcmVlALgBDl9fd2JnX25vdF9mcmVlALgBD19fd2JnX2puZWJfZnJlZQC4AQ9fX3diZ19zcmxpX2ZyZWUAuAEPX193YmdfczI1Nl9mcmVlALgBDl9fd2JnX2JhbF9mcmVlALgBD19fd2JnX2ptcGJfZnJlZQC4AQZjZnNfcmEATg5fX3diZ19jZnNfZnJlZQC4AQZjZmVfcmEATg5fX3diZ19jZmVfZnJlZQC4AQ9fX3diZ193ZGFtX2ZyZWUAuAENX193YmdfZ21fZnJlZQC4AQ9fX3diZ193cW1tX2ZyZWUAuAEKcG9waF9pbW0yNAAnD19fd2JnX3BvcGhfZnJlZQC4AQ9fX3diZ193ZGR2X2ZyZWUAuAEPX193YmdfdGltZV9mcmVlALgBD19fd2JnX3hvcmlfZnJlZQC4AQVjYl9yYQBODV9fd2JnX2NiX2ZyZWUAuAEPX193Ymdfam5lZl9mcmVlALgBD19fd2JnX2VkMTlfZnJlZQC4AQ9fX3diZ193ZGNtX2ZyZWUAuAEKcHNoaF9pbW0yNAAnD19fd2JnX3BzaGhfZnJlZQC4ARNqbmViX25ld190eXBlc2NyaXB0AE0Kd3Fkdl9pbW0wNgAXCndxbWxfaW1tMDYAFwp3ZG1sX2ltbTA2ABcKd3FvcF9pbW0wNgAXCndkb3BfaW1tMDYAFwp3cWNtX2ltbTA2ABcKd2Rkdl9pbW0wNgAXCndkY21faW1tMDYAFwpqbmVmX2ltbTA2ABcHbW92aV9yYQAWB21sZHZfcmQAFwdtbGR2X3JjAA8HbWxkdl9yYgALB21sZHZfcmEAFgZndGZfcmIACwZndGZfcmEAFgZzcndfcmMADwZzcndfcmIACwZzcndfcmEAFgdlY2FsX3JjAA8HZWNhbF9yYgALB2VjYWxfcmEAFgdzY3dxX3JjAA8Hc2N3cV9yYgALB3Njd3FfcmEAFgZleHBfcmMADwZleHBfcmIACwZleHBfcmEAFgZtdWxfcmMADwZtdWxfcmIACwZtdWxfcmEAFgZzcmxfcmMADwZzcmxfcmIACwZzcmxfcmEAFgdzd3dxX3JkABcHc3d3cV9yYwAPB3N3d3FfcmIACwdzd3dxX3JhABYGbWNwX3JjAA8GbWNwX3JiAAsGbWNwX3JhABYIc3dfaW1tMTIADAVzd19yYgALBXN3X3JhABYJZ3RmX2ltbTEyAAwGZGl2X3JiAAsGZGl2X3JhABYHbG9nZF9yZAAXB2xvZ2RfcmMADwdsb2dkX3JiAAsHbG9nZF9yYQAWBW9yX3JjAA8Fb3JfcmIACwVvcl9yYQAWBm1lcV9yZAAXBm1lcV9yYwAPBm1lcV9yYgALBm1lcV9yYQAWB3dxYW1fcmQAFwd3cWFtX3JjAA8Hd3FhbV9yYgALB3dxYW1fcmEAFgpqbnpiX2ltbTEyAAwHam56Yl9yYgALB2puemJfcmEAFgZsZGNfcmMADwZsZGNfcmIACwZsZGNfcmEAFgptY3BpX2ltbTEyAAwHbWNwaV9yYgALB21jcGlfcmEAFgptb3ZpX2ltbTE4AAkHam1wZl9yYQAWCGxiX2ltbTEyAAwFbGJfcmIACwVsYl9yYQAWB3dxY21fcmMADwd3cWNtX3JiAAsHd3FjbV9yYQAWB3dxb3BfcmMADwd3cW9wX3JiAAsHd3FvcF9yYQAWB21yb29fcmMADwdtcm9vX3JiAAsHbXJvb19yYQAWB3dkbWxfcmMADwd3ZG1sX3JiAAsHd2RtbF9yYQAWBXRyX3JjAA8FdHJfcmIACwV0cl9yYQAWCmpuZWlfaW1tMTIADAdqbmVpX3JiAAsHam5laV9yYQAWB2VjYWxfcmQAFwZkaXZfcmMADwdjYWxsX3JiAAsHY2FsbF9yYQAWB2NhbGxfcmMADwdhbmRpX3JiAAsHYW5kaV9yYQAWB2Joc2hfcmIACwdiaHNoX3JhABYGc3d3X3JjAA8Gc3d3X3JiAAsGc3d3X3JhABYKc3ViaV9pbW0xMgAMB3N1YmlfcmIACwdzdWJpX3JhABYFZXFfcmMADwVlcV9yYgALBWVxX3JhABYHd2RtbV9yZAAXB3dkbW1fcmMADwd3ZG1tX3JiAAsHd2RtbV9yYQAWCnNsbGlfaW1tMTIADAdzbGxpX3JiAAsHc2xsaV9yYQAWBmpuZV9yYwAPBmpuZV9yYgALBmpuZV9yYQAWB21vdmVfcmIACwdtb3ZlX3JhABYKZGl2aV9pbW0xMgAMB2RpdmlfcmIACwdkaXZpX3JhABYHZWNyMV9yYwAPB2VjcjFfcmIACwdlY3IxX3JhABYHY3Npel9yYgALB2NzaXpfcmEAFgdyZXRkX3JiAAsHcmV0ZF9yYQAWCm1vZGlfaW1tMTIADAdtb2RpX3JiAAsHbW9kaV9yYQAWBWd0X3JjAA8FZ3RfcmIACwVndF9yYQAWE19fd2JnX21hdGhhcmdzX2ZyZWUAdwZjY3BfcmQAFwZjY3BfcmMADwZjY3BfcmIACwZjY3BfcmEAFgdlY2sxX3JjAA8HZWNrMV9yYgALB2VjazFfcmEAFgdrMjU2X3JjAA8HazI1Nl9yYgALB2syNTZfcmEAFgphbmRpX2ltbTEyAAwGYW5kX3JiAAsGYW5kX3JhABYFbHRfcmMADwVsdF9yYgALBWx0X3JhABYGc21vX3JkABcGc21vX3JjAA8Gc21vX3JiAAsGc21vX3JhABYKam56Zl9pbW0xMgAMB2puemZfcmIACwdqbnpmX3JhABYGbWNsX3JiAAsGbWNsX3JhABYHbWludF9yYgALB21pbnRfcmEAFgd3ZG9wX3JjAA8Hd2RvcF9yYgALB3dkb3BfcmEAFgdjcm9vX3JiAAsHY3Jvb19yYQAWBnRyb19yZAAXBnRyb19yYwAPBnRyb19yYgALBnRyb19yYQAWB3dxbWRfcmQAFwd3cW1kX3JjAA8Hd3FtZF9yYgALB3dxbWRfcmEAFgd3cWR2X3JjAA8Hd3Fkdl9yYgALB3dxZHZfcmEAFgpleHBpX2ltbTEyAAwHZXhwaV9yYgALB2V4cGlfcmEAFgdzcndxX3JkABcHc3J3cV9yYwAPB3Nyd3FfcmIACwdzcndxX3JhABYHd3FtbF9yYwAPB3dxbWxfcmIACwd3cW1sX3JhABYHd2RtZF9yZAAXB3dkbWRfcmMADwd3ZG1kX3JiAAsHd2RtZF9yYQAWBm1vZF9yYwAPBm1vZF9yYgALBm1vZF9yYQAWCmpuemlfaW1tMTgACQdqbnppX3JhABYHYnVybl9yYgALB2J1cm5fcmEAFglvcmlfaW1tMTIADAZvcmlfcmIACwZvcmlfcmEAFgZhbmRfcmMADwdhZGRpX3JiAAsHYWRkaV9yYQAWBnhvcl9yYwAPBnhvcl9yYgALBnhvcl9yYQAWCGx3X2ltbTEyAAwFbHdfcmIACwVsd19yYQAWCHNiX2ltbTEyAAwFc2JfcmIACwVzYl9yYQAWCm11bGlfaW1tMTIADAdtdWxpX3JiAAsHbXVsaV9yYQAWBmxvZ19yZAAXBmxvZ19yYwAPBmxvZ19yYgALBmxvZ19yYQAWB21sb2dfcmMADwdtbG9nX3JiAAsHbWxvZ19yYQAWCm1jbGlfaW1tMTgACQdtY2xpX3JhABYGc3ViX3JjAA8Gc3ViX3JiAAsGc3ViX3JhABYGc2xsX3JjAA8Gc2xsX3JiAAsGc2xsX3JhABYGbm90X3JiAAsGbm90X3JhABYHam5lYl9yYwAPB2puZWJfcmIACwdqbmViX3JhABYKc3JsaV9pbW0xMgAMB3NybGlfcmIACwdzcmxpX3JhABYHczI1Nl9yYwAPB3MyNTZfcmIACwdzMjU2X3JhABYGYmFsX3JjAA8GYmFsX3JiAAsGYmFsX3JhABYKam1wZl9pbW0xOAAJB2ptcGJfcmEAFgd3ZGFtX3JkABcHd2RhbV9yYwAPB3dkYW1fcmIACwd3ZGFtX3JhABYKam1wYl9pbW0xOAAJBWdtX3JhABYHd3FtbV9yZAAXB3dxbW1fcmMADwd3cW1tX3JiAAsHd3FtbV9yYQAWB3dkZHZfcmMADwd3ZGR2X3JiAAsHd2Rkdl9yYQAWB3RpbWVfcmIACwd0aW1lX3JhABYKeG9yaV9pbW0xMgAMB3hvcmlfcmIACwd4b3JpX3JhABYHam5lZl9yYwAPB2puZWZfcmIACwdqbmVmX3JhABYHZWQxOV9yYwAPB2VkMTlfcmIACwdlZDE5X3JhABYHd2RjbV9yYwAPB3dkY21fcmIACwd3ZGNtX3JhABYbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlALgBH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAzAETX193YmluZGdlbl9leHBvcnRfMADLAQkRAQBBAQsGAs8B0AHRAe0BygEK0IEB+QGJIwIIfwF+AkACQAJAAkACQAJAAkACQCAAQfUBTwRAIABBzf97Tw0FIABBC2oiAEF4cSEFQfiMwAAoAgAiCEUNBEEAIAVrIQQCf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQQYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QdyJwABqKAIAIgFFBEBBACEADAILQQAhACAFQRkgB0EBdmtBACAHQR9HG3QhAwNAAkAgASgCBEF4cSIGIAVJDQAgBiAFayIGIARPDQAgASECIAYiBA0AQQAhBCABIQAMBAsgAUEUaigCACIGIAAgBiABIANBHXZBBHFqQRBqKAIAIgFHGyAAIAYbIQAgA0EBdCEDIAENAAsMAQtB9IzAACgCACICQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAUEDdCIAQeyKwABqIgMgAEH0isAAaigCACIAKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H0jMAAIAJBfiABd3E2AgALIAAgAUEDdCIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAgLIAVB/IzAACgCAE0NAwJAAkAgAUUEQEH4jMAAKAIAIgBFDQYgAGhBAnRB3InAAGooAgAiASgCBEF4cSAFayEEIAEhAgNAAkAgASgCECIADQAgAUEUaigCACIADQAgAigCGCEHAkACQCACIAIoAgwiAEYEQCACQRRBECACQRRqIgAoAgAiAxtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAAgAkEQaiADGyEDA0AgAyEGIAEiAEEUaiIBIABBEGogASgCACIBGyEDIABBFEEQIAEbaigCACIBDQALIAZBADYCAAsgB0UNBCACIAIoAhxBAnRB3InAAGoiASgCAEcEQCAHQRBBFCAHKAIQIAJGG2ogADYCACAARQ0FDAQLIAEgADYCACAADQNB+IzAAEH4jMAAKAIAQX4gAigCHHdxNgIADAQLIAAoAgRBeHEgBWsiASAEIAEgBEkiARshBCAAIAIgARshAiAAIQEMAAsACwJAQQIgAHQiA0EAIANrciABIAB0cWgiAEEDdCIBQeyKwABqIgMgAUH0isAAaigCACIBKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H0jMAAIAJBfiAAd3E2AgALIAEgBUEDcjYCBCABIAVqIgYgAEEDdCIAIAVrIgRBAXI2AgQgACABaiAENgIAQfyMwAAoAgAiAgRAIAJBeHFB7IrAAGohAEGEjcAAKAIAIQMCf0H0jMAAKAIAIgVBASACQQN2dCICcUUEQEH0jMAAIAIgBXI2AgAgAAwBCyAAKAIICyECIAAgAzYCCCACIAM2AgwgAyAANgIMIAMgAjYCCAtBhI3AACAGNgIAQfyMwAAgBDYCACABQQhqDwsgACAHNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAJBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAAkAgBEEQTwRAIAIgBUEDcjYCBCACIAVqIgUgBEEBcjYCBCAEIAVqIAQ2AgBB/IzAACgCACIDRQ0BIANBeHFB7IrAAGohAEGEjcAAKAIAIQECf0H0jMAAKAIAIgZBASADQQN2dCIDcUUEQEH0jMAAIAMgBnI2AgAgAAwBCyAAKAIICyEDIAAgATYCCCADIAE2AgwgASAANgIMIAEgAzYCCAwBCyACIAQgBWoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwBC0GEjcAAIAU2AgBB/IzAACAENgIACyACQQhqDwsgACACckUEQEEAIQJBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRB3InAAGooAgAhAAsgAEUNAQsDQCAAIAIgACgCBEF4cSIDIAVrIgYgBEkiBxshCCAAKAIQIgFFBEAgAEEUaigCACEBCyACIAggAyAFSSIAGyECIAQgBiAEIAcbIAAbIQQgASIADQALCyACRQ0AIAVB/IzAACgCACIATSAEIAAgBWtPcQ0AIAIoAhghBwJAAkAgAiACKAIMIgBGBEAgAkEUQRAgAkEUaiIAKAIAIgMbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyAAIAJBEGogAxshAwNAIAMhBiABIgBBFGoiASAAQRBqIAEoAgAiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQMgAiACKAIcQQJ0QdyJwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNBAwDCyABIAA2AgAgAA0CQfiMwABB+IzAACgCAEF+IAIoAhx3cTYCAAwDCwJAAkACQAJAAkAgBUH8jMAAKAIAIgFLBEAgBUGAjcAAKAIAIgBPBEBBACEEIAVBr4AEaiIAQRB2QAAiAUF/RiIDDQcgAUEQdCICRQ0HQYyNwABBACAAQYCAfHEgAxsiBEGMjcAAKAIAaiIANgIAQZCNwABBkI3AACgCACIBIAAgACABSRs2AgACQAJAQYiNwAAoAgAiAwRAQdyKwAAhAANAIAAoAgAiASAAKAIEIgZqIAJGDQIgACgCCCIADQALDAILQZiNwAAoAgAiAEEAIAAgAk0bRQRAQZiNwAAgAjYCAAtBnI3AAEH/HzYCAEHgisAAIAQ2AgBB3IrAACACNgIAQfiKwABB7IrAADYCAEGAi8AAQfSKwAA2AgBB9IrAAEHsisAANgIAQYiLwABB/IrAADYCAEH8isAAQfSKwAA2AgBBkIvAAEGEi8AANgIAQYSLwABB/IrAADYCAEGYi8AAQYyLwAA2AgBBjIvAAEGEi8AANgIAQaCLwABBlIvAADYCAEGUi8AAQYyLwAA2AgBBqIvAAEGci8AANgIAQZyLwABBlIvAADYCAEGwi8AAQaSLwAA2AgBBpIvAAEGci8AANgIAQeiKwABBADYCAEG4i8AAQayLwAA2AgBBrIvAAEGki8AANgIAQbSLwABBrIvAADYCAEHAi8AAQbSLwAA2AgBBvIvAAEG0i8AANgIAQciLwABBvIvAADYCAEHEi8AAQbyLwAA2AgBB0IvAAEHEi8AANgIAQcyLwABBxIvAADYCAEHYi8AAQcyLwAA2AgBB1IvAAEHMi8AANgIAQeCLwABB1IvAADYCAEHci8AAQdSLwAA2AgBB6IvAAEHci8AANgIAQeSLwABB3IvAADYCAEHwi8AAQeSLwAA2AgBB7IvAAEHki8AANgIAQfiLwABB7IvAADYCAEGAjMAAQfSLwAA2AgBB9IvAAEHsi8AANgIAQYiMwABB/IvAADYCAEH8i8AAQfSLwAA2AgBBkIzAAEGEjMAANgIAQYSMwABB/IvAADYCAEGYjMAAQYyMwAA2AgBBjIzAAEGEjMAANgIAQaCMwABBlIzAADYCAEGUjMAAQYyMwAA2AgBBqIzAAEGcjMAANgIAQZyMwABBlIzAADYCAEGwjMAAQaSMwAA2AgBBpIzAAEGcjMAANgIAQbiMwABBrIzAADYCAEGsjMAAQaSMwAA2AgBBwIzAAEG0jMAANgIAQbSMwABBrIzAADYCAEHIjMAAQbyMwAA2AgBBvIzAAEG0jMAANgIAQdCMwABBxIzAADYCAEHEjMAAQbyMwAA2AgBB2IzAAEHMjMAANgIAQcyMwABBxIzAADYCAEHgjMAAQdSMwAA2AgBB1IzAAEHMjMAANgIAQeiMwABB3IzAADYCAEHcjMAAQdSMwAA2AgBB8IzAAEHkjMAANgIAQeSMwABB3IzAADYCAEGIjcAAIAI2AgBB7IzAAEHkjMAANgIAQYCNwAAgBEEoayIANgIAIAIgAEEBcjYCBCAAIAJqQSg2AgRBlI3AAEGAgIABNgIADAgLIAIgA00gASADS3INACAAKAIMRQ0DC0GYjcAAQZiNwAAoAgAiACACIAAgAkkbNgIAIAIgBGohAUHcisAAIQACQAJAA0AgASAAKAIARwRAIAAoAggiAA0BDAILCyAAKAIMRQ0BC0HcisAAIQADQAJAIAMgACgCACIBTwRAIAEgACgCBGoiBiADSw0BCyAAKAIIIQAMAQsLQYiNwAAgAjYCAEGAjcAAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQZSNwABBgICAATYCACADIAZBIGtBeHFBCGsiACAAIANBEGpJGyIBQRs2AgRB3IrAACkCACEJIAFBEGpB5IrAACkCADcCACABIAk3AghB4IrAACAENgIAQdyKwAAgAjYCAEHkisAAIAFBCGo2AgBB6IrAAEEANgIAIAFBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgASADRg0HIAEgASgCBEF+cTYCBCADIAEgA2siAEEBcjYCBCABIAA2AgAgAEGAAk8EQCADIAAQCAwICyAAQXhxQeyKwABqIQECf0H0jMAAKAIAIgJBASAAQQN2dCIAcUUEQEH0jMAAIAAgAnI2AgAgAQwBCyABKAIICyEAIAEgAzYCCCAAIAM2AgwgAyABNgIMIAMgADYCCAwHCyAAIAI2AgAgACAAKAIEIARqNgIEIAIgBUEDcjYCBCABIAIgBWoiA2shBSABQYiNwAAoAgBGDQMgAUGEjcAAKAIARg0EIAEoAgQiBEEDcUEBRgRAIAEgBEF4cSIAEAcgACAFaiEFIAAgAWoiASgCBCEECyABIARBfnE2AgQgAyAFQQFyNgIEIAMgBWogBTYCACAFQYACTwRAIAMgBRAIDAYLIAVBeHFB7IrAAGohAAJ/QfSMwAAoAgAiAUEBIAVBA3Z0IgRxRQRAQfSMwAAgASAEcjYCACAADAELIAAoAggLIQUgACADNgIIIAUgAzYCDCADIAA2AgwgAyAFNgIIDAULQYCNwAAgACAFayIBNgIAQYiNwABBiI3AACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQQMBgtBhI3AACgCACEAAkAgASAFayICQQ9NBEBBhI3AAEEANgIAQfyMwABBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQtB/IzAACACNgIAQYSNwAAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIECwwICyAAIAQgBmo2AgRBiI3AAEGIjcAAKAIAIgBBD2pBeHEiAUEIayICNgIAQYCNwABBgI3AACgCACAEaiIDIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgA2pBKDYCBEGUjcAAQYCAgAE2AgAMAwtBiI3AACADNgIAQYCNwABBgI3AACgCACAFaiIANgIAIAMgAEEBcjYCBAwBC0GEjcAAIAM2AgBB/IzAAEH8jMAAKAIAIAVqIgA2AgAgAyAAQQFyNgIEIAAgA2ogADYCAAsgAkEIag8LQQAhBEGAjcAAKAIAIgAgBU0NAEGAjcAAIAAgBWsiATYCAEGIjcAAQYiNwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQMAwsgBA8LIAAgBzYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAEQRBPBEAgAiAFQQNyNgIEIAIgBWoiASAEQQFyNgIEIAEgBGogBDYCACAEQYACTwRAIAEgBBAIDAILIARBeHFB7IrAAGohAAJ/QfSMwAAoAgAiA0EBIARBA3Z0IgRxRQRAQfSMwAAgAyAEcjYCACAADAELIAAoAggLIQQgACABNgIIIAQgATYCDCABIAA2AgwgASAENgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAEEIagvtCwELfyAAKAIEIQcgACgCACEFAkACQAJAIAEoAgAiCiABKAIIIgByBEACQCAARQ0AIAUgB2ohCSABQQxqKAIAQQFqIQYgBSECA0ACQCACIQAgBkEBayIGRQ0AIAAgCUYNAgJ/IAAsAAAiBEEATgRAIARB/wFxIQQgAEEBagwBCyAALQABQT9xIQggBEEfcSECIARBX00EQCACQQZ0IAhyIQQgAEECagwBCyAALQACQT9xIAhBBnRyIQggBEFwSQRAIAggAkEMdHIhBCAAQQNqDAELIAJBEnRBgIDwAHEgAC0AA0E/cSAIQQZ0cnIiBEGAgMQARg0DIABBBGoLIgIgAyAAa2ohAyAEQYCAxABHDQEMAgsLIAAgCUYNACAALAAAIgJBAE4gAkFgSXIgAkFwSXJFBEAgAkH/AXFBEnRBgIDwAHEgAC0AA0E/cSAALQACQT9xQQZ0IAAtAAFBP3FBDHRycnJBgIDEAEYNAQsCQAJAIANFDQAgAyAHTwRAQQAhACADIAdGDQEMAgtBACEAIAMgBWosAABBQEgNAQsgBSEACyADIAcgABshByAAIAUgABshBQsgCkUNAyABKAIEIQsgB0EQTwRAIAcgBSAFQQNqQXxxIgRrIgZqIgpBA3EhCEEAIQlBACEAIAQgBUcEQCAEIAVBf3NqQQNPBEBBACEDA0AgACADIAVqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEAIANBBGoiAw0ACwsgBSECA0AgACACLAAAQb9/SmohACACQQFqIQIgBkEBaiIGDQALCwJAIAhFDQAgBCAKQXxxaiICLAAAQb9/SiEJIAhBAUYNACAJIAIsAAFBv39KaiEJIAhBAkYNACAJIAIsAAJBv39KaiEJCyAKQQJ2IQggACAJaiEDA0AgBCEGIAhFDQRBwAEgCCAIQcABTxsiCUEDcSEKIAlBAnQhBEEAIQIgCUEETwRAIAYgBEHwB3FqIQwgBiEAA0AgAiAAKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIABBBGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAEEIaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiAAQQxqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIQIgAEEQaiIAIAxHDQALCyAIIAlrIQggBCAGaiEEIAJBCHZB/4H8B3EgAkH/gfwHcWpBgYAEbEEQdiADaiEDIApFDQALIAYgCUH8AXFBAnRqIgIoAgAiAEF/c0EHdiAAQQZ2ckGBgoQIcSEAIApBAUYNAiAAIAIoAgQiAEF/c0EHdiAAQQZ2ckGBgoQIcWohACAKQQJGDQIgACACKAIIIgBBf3NBB3YgAEEGdnJBgYKECHFqIQAMAgsgB0UEQEEAIQMMAwsgB0EDcSECAkAgB0EESQRAQQAhA0EAIQYMAQtBACEDIAUhACAHQXxxIgYhBANAIAMgACwAAEG/f0pqIABBAWosAABBv39KaiAAQQJqLAAAQb9/SmogAEEDaiwAAEG/f0pqIQMgAEEEaiEAIARBBGsiBA0ACwsgAkUNAiAFIAZqIQADQCADIAAsAABBv39KaiEDIABBAWohACACQQFrIgINAAsMAgsMAgsgAEEIdkH/gRxxIABB/4H8B3FqQYGABGxBEHYgA2ohAwsCQCADIAtJBEAgCyADayEDQQAhAAJAAkACQCABLQAgQQFrDgIAAQILIAMhAEEAIQMMAQsgA0EBdiEAIANBAWpBAXYhAwsgAEEBaiEAIAFBGGooAgAhAiABKAIQIQYgASgCFCEBA0AgAEEBayIARQ0CIAEgBiACKAIQEQMARQ0AC0EBDwsMAQtBASEAIAEgBSAHIAIoAgwRAAAEf0EBBUEAIQACfwNAIAMgACADRg0BGiAAQQFqIQAgASAGIAIoAhARAwBFDQALIABBAWsLIANJCw8LIAEoAhQgBSAHIAFBGGooAgAoAgwRAAALpgYCDX8BfiMAQTBrIgckAEEnIQICQCAAQpDOAFQEQCAAIQ8MAQsDQCAHQQlqIAJqIgZBBGsgAEKQzgCAIg9C8LEDfiAAfKciBEH//wNxQeQAbiIDQQF0QciGwABqLwAAOwAAIAZBAmsgA0Gcf2wgBGpB//8DcUEBdEHIhsAAai8AADsAACACQQRrIQIgAEL/wdcvViAPIQANAAsLIA+nIgRB4wBLBEAgAkECayICIAdBCWpqIA+nIgNB//8DcUHkAG4iBEGcf2wgA2pB//8DcUEBdEHIhsAAai8AADsAAAsCQCAEQQpPBEAgAkECayICIAdBCWpqIARBAXRByIbAAGovAAA7AAAMAQsgAkEBayICIAdBCWpqIARBMGo6AAALQScgAmshCEEBIQVBK0GAgMQAIAEoAhwiBEEBcSIMGyEJIARBHXRBH3VB6IjAAHEhCiAHQQlqIAJqIQsCQCABKAIARQRAIAEoAhQiAyABKAIYIgEgCSAKEEcNASADIAsgCCABKAIMEQAAIQUMAQsgASgCBCINIAggDGoiA00EQCABKAIUIgMgASgCGCIBIAkgChBHDQEgAyALIAggASgCDBEAACEFDAELIARBCHEEQCABKAIQIQQgAUEwNgIQIAEtACAhAyABQQE6ACAgASgCFCIOIAEoAhgiBiAJIAoQRw0BIAIgDWogDGtBJmshAgNAIAJBAWsiAgRAIA5BMCAGKAIQEQMARQ0BDAMLCyAOIAsgCCAGKAIMEQAADQEgASADOgAgIAEgBDYCEEEAIQUMAQsgDSADayEDAkACQAJAIAEtACAiAkEBaw4DAAEAAgsgAyECQQAhAwwBCyADQQF2IQIgA0EBakEBdiEDCyACQQFqIQIgAUEYaigCACEGIAEoAhAhBCABKAIUIQECQANAIAJBAWsiAkUNASABIAQgBigCEBEDAEUNAAsMAQsgASAGIAkgChBHDQAgASALIAggBigCDBEAAA0AQQAhAgNAIAIgA0YEQEEAIQUMAgsgAkEBaiECIAEgBCAGKAIQEQMARQ0ACyACQQFrIANJIQULIAdBMGokACAFC/wFAQV/IABBCGsiASAAQQRrKAIAIgNBeHEiAGohAgJAAkACQAJAIANBAXENACADQQNxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUGEjcAAKAIARgRAIAIoAgRBA3FBA0cNAUH8jMAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQBwsCQAJAIAIoAgQiA0ECcUUEQCACQYiNwAAoAgBGDQIgAkGEjcAAKAIARg0FIAIgA0F4cSICEAcgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFBhI3AACgCAEcNAUH8jMAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQCEEAIQFBnI3AAEGcjcAAKAIAQQFrIgA2AgAgAA0BQeSKwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtBnI3AAEH/HyABIAFB/x9NGzYCAA8LQYiNwAAgATYCAEGAjcAAQYCNwAAoAgAgAGoiADYCACABIABBAXI2AgRBhI3AACgCACABRgRAQfyMwABBADYCAEGEjcAAQQA2AgALIABBlI3AACgCACIDTQ0AQYiNwAAoAgAiAkUNAEEAIQECQEGAjcAAKAIAIgRBKUkNAEHcisAAIQADQCACIAAoAgAiBU8EQCAFIAAoAgRqIAJLDQILIAAoAggiAA0ACwtB5IrAACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0GcjcAAQf8fIAEgAUH/H00bNgIAIAMgBE8NAEGUjcAAQX82AgALDwsgAEF4cUHsisAAaiECAn9B9IzAACgCACIDQQEgAEEDdnQiAHFFBEBB9IzAACAAIANyNgIAIAIMAQsgAigCCAshACACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0GEjcAAIAE2AgBB/IzAAEH8jMAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAv7BAEBfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQYAEaw4mAQIDBAUGBwgsCQoLDA0sLCwsLCwsLCwsLCwsLCwsLCwODywsLBAAC0EBIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBAWsODkEBAgMEBQZCBwgJCgsMAAsCQCAAQcAEaw4MJygpKissLS4vMDEyAAsCQCAAQYECaw4KDQ4PEBESExQVFgALAkAgAEGABmsOCTM0NTY3QkI4OQALAkAgAEGACmsOBTw9Pj9AAAsgAEGACGsOAjk6QQtBAg8LQQMPC0EEDwtBBQ8LQQYPC0EHDwtBCQ8LQQoPC0ELDwtBDA8LQQ0PC0EODwtBgQIPC0GCAg8LQYMCDwtBhAIPC0GFAg8LQYYCDwtBhwIPC0GIAg8LQYkCDwtBigIPC0GABA8LQYEEDwtBggQPC0GDBA8LQYQEDwtBhQQPC0GGBA8LQYcEDwtBiQQPC0GKBA8LQYsEDwtBjAQPC0GNBA8LQaAEDwtBoQQPC0GlBA8LQcAEDwtBwQQPC0HCBA8LQcMEDwtBxAQPC0HFBA8LQcYEDwtBxwQPC0HIBA8LQckEDwtBygQPC0HLBA8LQYAGDwtBgQYPC0GCBg8LQYMGDwtBhAYPC0GHBg8LQYgGDwtBgAgPC0GBCA8LQYAKDwtBgQoPC0GCCg8LQYMKDwtBhAohAQsgAQ8LQeCCwABBGRDSAQAL+AMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQNxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEGEjcAAKAIARgRAIAIoAgRBA3FBA0cNAUH8jMAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAPCyAAIAMQBwsCQAJAAkAgAigCBCIDQQJxRQRAIAJBiI3AACgCAEYNAiACQYSNwAAoAgBGDQMgAiADQXhxIgIQByAAIAEgAmoiAUEBcjYCBCAAIAFqIAE2AgAgAEGEjcAAKAIARw0BQfyMwAAgATYCAA8LIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACyABQYACTwRAIAAgARAIDAMLIAFBeHFB7IrAAGohAgJ/QfSMwAAoAgAiA0EBIAFBA3Z0IgFxRQRAQfSMwAAgASADcjYCACACDAELIAIoAggLIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtBiI3AACAANgIAQYCNwABBgI3AACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQYSNwAAoAgBHDQFB/IzAAEEANgIAQYSNwABBADYCAA8LQYSNwAAgADYCAEH8jMAAQfyMwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwv7AgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgAEEUaiICKAIAIgQbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyACIABBEGogBBshBANAIAQhBSABIgJBFGoiASACQRBqIAEoAgAiARshBCACQRRBECABG2ooAgAiAQ0ACyAFQQA2AgALIANFDQIgACAAKAIcQQJ0QdyJwABqIgEoAgBHBEAgA0EQQRQgAygCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQfiMwABB+IzAACgCAEF+IAAoAhx3cTYCAAwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB9IzAAEH0jMAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAEUNACACQRRqIAA2AgAgACACNgIYCwusAgEEf0EfIQIgAEIANwIQIAFB////B00EQCABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQILIAAgAjYCHCACQQJ0QdyJwABqIQQCQEH4jMAAKAIAIgVBASACdCIDcUUEQEH4jMAAIAMgBXI2AgAgBCAANgIAIAAgBDYCGAwBCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEEA0AgAyAEQR12QQRxakEQaiIFKAIAIgJFDQIgBEEBdCEEIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAFIAA2AgAgACADNgIYCyAAIAA2AgwgACAANgIIC2kBA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQYAGcUEIdCAAQQh2QYD+A3EgAEEYdnJyELsBIAFBEGokAAt5AQN/IAEQxAECQCABKAIAIgJBf0cEQCABIAJBAWo2AgAgASgCBCgAACIDQRh0QRZ1QfyCwABqKAIAIQRBAUEEEMcBIgJFDQEgAiAEIANBgH5xcjYAACABIAEoAgBBAWs2AgAgAEEENgIEIAAgAjYCAA8LEM4BAAsAC2YBA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQYAGcUEIdCAAQQh2QYDgA3FyQQx2ELwBIAFBEGokAAtuAQJ/IwBBEGsiASQAIAFBCGogABBKIAEoAggiAC8AACAAQQJqLQAAQRB0chDVASEAIAEoAgwiAiACKAIAQQFrNgIAQQhBBBC6ASICIABBCHZBgB5xIABBGHZyOwEEIAJBADYCACABQRBqJAAgAgttAQF/IwBBMGsiASQAIAEgADoADyAAQf8BcUHAAE8EQCABQRxqQgE3AgAgAUECNgIUIAFB9IDAADYCECABQQI2AiwgASABQShqNgIYIAEgAUEPajYCKCABQRBqQYSBwAAQSQALIAFBMGokACAAC24BAX8jAEEwayIBJAAgASAAOwEOIABB//8DcUGAIE8EQCABQRxqQgE3AgAgAUECNgIUIAFBuIHAADYCECABQQM2AiwgASABQShqNgIYIAEgAUEOajYCKCABQRBqQciBwAAQSQALIAFBMGokACAAC10BA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQR52IABBDnZBPHFyELwBIAFBEGokAAsVACAAQYyCwABB/IHAAEGAgBAQ8gELFgAgAEHQgsAAQcCCwABBgICACBDyAQtMACADQf8BcSABQf8BcUEMdCAAQf8BcUESdHIiACACQf8BcUEGdHJyIgFBEHRBgID8B3EgAEEIdkGA/gNxIAFBgP4DcUEIdHJBCHZyC1UCAX8BfiMAQRBrIgIkACABEMQBIAJBCGogARBUIAIoAgxBADYCACABKQIAIQMgARAEIAAgA0IoiKdBAXE6AAEgACADQiCIp0EBcToAACACQRBqJAALEAAgACABIAIgA0HiABD0AQsQACAAIAEgAiADQeMAEPQBC08BA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDIARC8ASABQRBqJAALVQEDfyMAQRBrIgEkACABQQhqIAAQSiABKAIIIgBBAmotAAAhAiAALwAAIAEoAgwiAyADKAIAQQFrNgIAIAJBEHRyENUBQRh2QT9xELwBIAFBEGokAAtSAQF/IAAQUSECIAEQUyEAQQhBBBC6ASIBIABBEHRBgID8B3EgACACQf8BcUESdHIiAEGA/gNxQQh0IABBCHZBgP4DcXJBCHZyrUIghjcCACABCxAAIAAgASACIANB3gAQ9QELEAAgACABIAIgA0HfABD1AQsQACAAIAEgAiADQeAAEPUBCxAAIAAgASACIANB4QAQ9QELUQIBfwF+IwBBEGsiAiQAIAEQxAEgAkEIaiABEFQgAigCDEEANgIAIAEpAgAhAyABEAQgACADQiiIPAABIAAgA0IgiKdBAXE6AAAgAkEQaiQACz4BAX8jAEEQayIEJAAgABBRIAEQUSACEFEgBEEIaiADEBMgBC0ACEEBcSAELQAJQQFxEHoQrAEgBEEQaiQAC0kBAX8gABBRIQAgARBRIQFBCEEEELoBIgIgAUH/AXFBDHQgAEESdHIiAEGA4ANxQQh0IABBCHZBgP4DcXJBCHatQiCGNwIAIAILDAAgACABQcsAEPYBCwwAIAAgAUHMABD2AQsMACAAIAFBzQAQ9gELDAAgACABQc4AEPYBCwwAIAAgAUHPABD2AQsMACAAIAFB0AAQ9gELPAEBfyMAQRBrIgQkACAAEFEgARBRIAIQUSAEQQhqIAMQHSAELQAIQQFxIAQtAAkQvgEQrAEgBEEQaiQAC0gAIAAQxAEgACgCAEF/RgRAEM4BAAsgAC8ABCAAQQZqLQAAQRB0chDVASIAQYD+A3FBCHQgAEEIdkGA/gNxIABBGHZychC7AQsLACAAIAFBBxD3AQs/AQJ/AkAgABBRIgBBGHENACAAQQdxIgJBB0YNAEEIQQQQugEiASAAQQV2QQFxrUIghiACrUIohoQ3AgALIAELCwAgACABQQgQ9wELPwAgAkEWdEGAgIAGcSABQf8BcUEMdCIBIAJB/AFxQQZ0ckGA/gNxQQh0IAEgAEESdHJBCHZBgP4DcXJBCHZyCwsAIAAgAUEKEPgBCwsAIAAgAUEMEPgBCwsAIAAgAUEUEPgBCwsAIAAgAUEWEPgBCwsAIAAgAUEZEPgBCwsAIAAgAUEbEPgBCwsAIAAgAUEeEPgBCwsAIAAgAUEfEPgBCwsAIAAgAUEkEPgBCwsAIAAgAUEyEPgBCz8AIAAQUSEAIAEQUyIBQRB0QYCA/AdxIABB/wFxQRJ0IAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2chCsAQtAAQF/IAAQUyEAQQhBBBC6ASIBIABBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyrUIghjcCACABCzgAIAJBEHRBgID8B3EgAUH/AXFBDHQiASACckGA/gNxQQh0IAEgAEESdHJBCHZBgP4DcXJBCHZyCzwBAn8jAEEQayIBJAAgABDEASABQQhqIAAQSyABKAIILQABIAEoAgwiAiACKAIAQQFrNgIAIAFBEGokAAs8AQJ/IwBBEGsiASQAIAAQxAEgAUEIaiAAEEsgASgCCC0AACABKAIMIgIgAigCAEEBazYCACABQRBqJAALOQEBfyMAQRBrIgIkACAAEMQBIAJBCGogABBUIAIoAgwgAigCCCABQQBHOgAAQQA2AgAgAkEQaiQACzkBAX8jAEEQayICJAAgABDEASACQQhqIAAQVCACKAIMIAIoAgggAUEARzoAAUEANgIAIAJBEGokAAs4AQJ/IwBBEGsiASQAIAAQxAEgAUEIaiAAEFQgASgCDEEANgIAIAAtAAQgABAEIAFBEGokAEEBcQs3AQJ/IwBBEGsiASQAIAFBCGogABBKIAEoAggtAAQgASgCDCICIAIoAgBBAWs2AgAgAUEQaiQACzcBAn8jAEEQayIBJAAgAUEIaiAAEEogASgCCCgCACABKAIMIgIgAigCAEEBazYCACABQRBqJAALCgAgAEHVABD5AQsKACAAQdYAEPkBCwoAIABB1wAQ+QELCgAgAEHaABD5AQsKACAAQdsAEPkBCwoAIABB3AAQ+QELCgAgAEHdABD5AQs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAwANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALMQEBfyMAQRBrIgEkACABQQhqIAAQHSABLQAJIAEtAAhBBXRBIHFyELwBIAFBEGokAAuhAgEBfyMAQSBrIgIkACACQQE7ARwgAiABNgIYIAIgADYCFCACQbiGwAA2AhAgAkHoiMAANgIMIAJBDGoiACgCCCIBRQRAIwBBIGsiACQAIABBDGpCADcCACAAQQE2AgQgAEHoiMAANgIIIABBKzYCHCAAQZCIwAA2AhggACAAQRhqNgIAIABB2IjAABBJAAsgAUEMaigCACECAkACQCABKAIEDgIAAAELIAINAAsgAC0AECEBIAAtABEaQdiJwABB2InAACgCACIAQQFqNgIAAkAgAEEASA0AQaSNwAAtAABBAXENAEGkjcAAQQE6AABBoI3AAEGgjcAAKAIAQQFqNgIAQdSJwAAoAgBBAEgNAEGkjcAAQQA6AAAgAUUNAAALAAs1AQF/IAEQxAEgASgCACICQX9GBEAQzgEACyABIAJBAWo2AgAgACABNgIEIAAgAUEEajYCAAsxAQF/IAEoAgAiAkF/RwRAIAEgAkEBajYCACAAIAE2AgQgACABQQRqNgIADwsQzgEACzUBAX8gAEE2TwRAQeCCwABBGRDSAQALQQxBBBC6ASICIAA6AAggAiABNgIEIAJBADYCACACCzAAIAAQUSABEFEgAhBRIAMQURASIQBBCEEEELoBIgEgAK1C////B4NCIIY3AgAgAQstACAAEMQBIAAoAgBBf0YEQBDOAQALIAAvAAQgAEEGai0AAEEQdHIQyAEQvAELLAAgABBRIAEQUSACEFEQKyEAQQhBBBC6ASIBIACtQv///weDQiCGNwIAIAELLAAgABBRIAEQUSACEFIQOCEAQQhBBBC6ASIBIACtQv///weDQiCGNwIAIAELJQEBfwJAIAAEQCAAKAIADQEgAC0ABCAAEAQPCxDNAQALEM4BAAslAQF/AkAgAARAIAAoAgANASAALwEEIAAQBA8LEM0BAAsQzgEACyUBAX8CQCAABEAgACgCAA0BIAAoAgQgABAEDwsQzQEACxDOAQALKAAgASgCAEUEQCABQX82AgAgACABNgIEIAAgAUEEajYCAA8LEM4BAAspACADED0hAyAAEL0BIAEQvQEgAhC9ASADEMIBQQh0QeQAchDFARC7AQspACADED0hAyAAEL0BIAEQvQEgAhC9ASADEMIBQQh0QeUAchDFARC7AQslAQF/IAAQUSEAQQhBBBC6ASIBIABBAnRB/AFxrUIghjcCACABCyAAIABBAWsiAEEFTQRAIABBAWoPC0HggsAAQRkQ0gEACyABAX8gABDEASAAKAIABEAQzgEACyAAKAIEIAAQBBAECyMAIAIQBSECIAAQvQEgARC9ASACEDhBCHRBygByEMUBELsBCx4AAkAgAARAIAAoAgANASAAEAQPCxDNAQALEM4BAAsPACAAIAEgAiADQRIQ7gELDwAgACABIAIgA0EYEO4BCw8AIAAgASACIANBHBDuAQsPACAAIAEgAiADQR0Q7gELDwAgACABIAIgA0EiEO4BCw8AIAAgASACIANBIxDuAQsPACAAIAEgAiADQSgQ7gELDwAgACABIAIgA0EqEO4BCw8AIAAgASACIANBLBDuAQsPACAAIAEgAiADQTgQ7gELEAAgACABIAIgA0HTABDvAQsQACAAIAEgAiADQdQAEO8BCxAAIAAgASACIANB3gAQ7wELEAAgACABIAIgA0HfABDvAQsQACAAIAEgAiADQeAAEO8BCxAAIAAgASACIANB4QAQ7wELEAAgACABIAIgA0HiABDvAQsQACAAIAEgAiADQeMAEO8BCxAAIAAgASACIANB5AAQ7wELEAAgACABIAIgA0HlABDvAQsQACAAIAEgAiADQeYAEO4BCxAAIAAgASACIANB5wAQ7gELEAAgACABIAIgA0HoABDuAQsQACAAIAEgAiADQekAEO4BCxAAIAAgASACIANB6gAQ7gELEAAgACABIAIgA0HrABDuAQsQACAAIAEgAiADQewAEO4BCx0BAX8jAEEQayIBJAAgAUEIaiAAEB0gAUEQaiQACx0BAX8jAEEQayIBJAAgAUEIaiAAEBMgAUEQaiQACx8AIAEQWCEBIAAQvQEgARC3AUEIdEHMAHIQxQEQuwELGQAgACABIAJBIEEAIAQbQRBBACADG3IQEgsNACAAIAEgAkEBEPABCw0AIAAgASACQQIQ8AELDQAgACABIAJBAxDwAQsNACAAIAEgAkEEEPABCw0AIAAgASACQQUQ8AELDQAgACABIAJBBhDwAQsNACAAIAEgAkEHEPABCw0AIAAgASACQQgQ8AELDQAgACABIAJBCRDwAQsNACAAIAEgAkELEPABCw0AIAAgASACQQ0Q8AELDQAgACABIAJBDhDwAQsNACAAIAEgAkEPEPABCw0AIAAgASACQRAQ8AELDQAgACABIAJBERDwAQsNACAAIAEgAkEXEPABCw0AIAAgASACQSEQ8AELDQAgACABIAJBJhDwAQsNACAAIAEgAkEnEPABCw0AIAAgASACQSkQ8AELDQAgACABIAJBKxDwAQsNACAAIAEgAkEtEPABCw0AIAAgASACQS4Q8AELDQAgACABIAJBLxDwAQsNACAAIAEgAkEwEPABCw0AIAAgASACQTEQ8AELDQAgACABIAJBNRDwAQsNACAAIAEgAkE3EPABCw0AIAAgASACQTkQ8QELDQAgACABIAJBOhDxAQsNACAAIAEgAkE7EPEBCw0AIAAgASACQTwQ8QELDQAgACABIAJBPRDxAQsNACAAIAEgAkE+EPEBCw0AIAAgASACQT8Q8QELDgAgACABIAJBwAAQ8QELDgAgACABIAJBwQAQ8QELDgAgACABIAJBwgAQ8QELDgAgACABIAJBwwAQ8QELDgAgACABIAJBxAAQ8QELDgAgACABIAJBxQAQ8QELDgAgACABIAJBxgAQ8QELDgAgACABIAJBxwAQ8QELDgAgACABIAJByAAQ8QELDgAgACABIAJByQAQ8QELDgAgACABIAJBygAQ8QELDgAgACABIAJB0QAQ8QELDgAgACABIAJB0gAQ8QELGAEBfyAAQf8BcUE/TQR/IAAQvAEFQQALCx4BAX9BCEEEELoBIgEgAK1C////B4NCIIY3AgAgAQsbACAAEMQBIAAoAgBBf0YEQBDOAQALIAAtAAQLCQAgAEETEPMBCwkAIABBFRDzAQsJACAAQRoQ8wELCQAgAEEgEPMBCwkAIABBJRDzAQsJACAAQTQQ8wELCQAgAEE2EPMBCwoAIABB2AAQ8wELCgAgAEHZABDzAQsXACABQRB0QYCA/AdxIABBAnRB/AFxcgsXACAAEMQBIAAoAgAEQBDOAQALIAAQBAscACAAEL0BIAEQvQEgAhC9ARArQQh0EMUBELsBCxIAIAEgABDHASIABEAgAA8LAAsbAQF/QQhBBBC6ASIBIAA2AgQgAUEANgIAIAELGwEBf0EIQQQQugEiASAAOgAEIAFBADYCACABC24AIABB/wFxQcAATwRAIwBBMGsiACQAIABBIjYCDCAAQYCAwAA2AgggAEEcakIBNwIAIABBATYCFCAAQbCGwAA2AhAgAEEBNgIsIAAgAEEoajYCGCAAIABBCGo2AiggAEEQakG4gMAAEEkACyAACxQAIAAgASACQSBBACADGyAEchASCxgAIAAQUSABEFEgAhBRIAMQPRDCARCsAQsXACAAEFEgARBRIAIQUSADEFEQEhCsAQsTACAAEFEgARBRIAIQBRA4EKwBCxEAIAAgASACQSBBACADGxASCxMAIAAQUSABEFEgAhBSEDgQrAELDAAgAARADwsQzQEACxQBAX9BBEEBELoBIgEgADYAACABCxQBAX9BCEEEELoBIgBCADcCACAAC4EDAQV/QaWNwAAtAAAaAn8gAEEJTwRAAkBBzf97QRAgACAAQRBNGyIAayABTQ0AIABBECABQQtqQXhxIAFBC0kbIgRqQQxqEAEiAkUNACACQQhrIQECQCAAQQFrIgMgAnFFBEAgASEADAELIAJBBGsiBSgCACIGQXhxIAIgA2pBACAAa3FBCGsiAiAAQQAgAiABa0EQTRtqIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgMgAygCBEEBcjYCBCABIAIQBgwBCyABKAIAIQEgACADNgIEIAAgASACajYCAAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIARBEGpNDQAgACAEIAFBAXFyQQJyNgIEIAAgBGoiASACIARrIgRBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASAEEAYLIABBCGohAwsgAwwBCyABEAELCw0AIAAQ1QFBCnZBP3ELEAAgABBRIAEQWBC3ARCsAQsgACAAQsWAsKa9qOHJSzcDCCAAQpXM9oWR7LDtHzcDAAsLACABBEAgABAECwsLACAAIwBqJAAjAAsNAEHoiMAAQRsQ0gEACw4AQYOJwABBzwAQ0gEACwsAIAAxAAAgARADCwsAIAAzAQAgARADCwsAIAA1AgAgARADCwkAIAAgARAAAAsKACAAQT9xELwBCwoAIAAQUUH/AXELBwAgAEEIdAsHACAAED0aCwcAIAAQURoLBwAgABBSGgsHACAAEFMaCwoAQTMQxQEQuwELBwBBCxC8AQsHAEEKELwBCwcAQQgQvAELBwBBDxC8AQsHAEEGELwBCwcAQQkQvAELBwBBBxC8AQsHAEEMELwBCwcAQQIQvAELBwBBARC8AQsHAEEDELwBCwcAQQ0QvAELBwBBDhC8AQsHAEEFELwBCwcAQQQQvAELBwBBEBC8AQsHAEEAELwBCwQAQQQLAgALJAAgABC9ASABEL0BIAIQvQEgAxC9ARASQQh0IARyEMUBELsBCyMAIAAQvQEgARC9ASACEL0BIAMQDRASQQh0IARyEMUBELsBCx8AIAAQvQEgARC9ASACEL0BECtBCHQgA3IQxQEQuwELHgAgABC9ASABEL0BIAIQDhA4QQh0IANyEMUBELsBC2IBAX8jAEEwayIEJAAgBCAANgIMIAAgA08EQCAEQRxqQgE3AgAgBEECNgIUIAQgAjYCECAEQQQ2AiwgBCAEQShqNgIYIAQgBEEMajYCKCAEQRBqIAEQSQALIARBMGokACAACxsAIAAQvQEaIABBCnRBgPgDcSABchDFARC7AQtSAQJ/IwBBEGsiBSQAIAVBCGogAxATIAUtAAkhAyAFLQAIIQYgABC9ASABEL0BIAIQvQEgBkEBcSADQQFxEHpBCHQgBHIQxQEQuwEgBUEQaiQAC1ABAn8jAEEQayIFJAAgBUEIaiADEB0gBS0ACCEDIAUtAAkhBiAAEL0BIAEQvQEgAhC9ASADQQFxIAYQvgFBCHQgBHIQxQEQuwEgBUEQaiQAC0oAIAAQvQEaIAEQECIBQRB0QYCA/AdxIABBEnRBgIDwH3EgAXIiAEGA/gNxQQh0IABBCHZBgP4DcXJBCHZyQQh0IAJyEMUBELsBC0kBAX8jAEEQayIDJAAgABDEASABIAJPBEBB4ILAAEEZENIBAAsgA0EIaiAAEFQgAygCDCADKAIIIAE6AAFBADYCACADQRBqJAALQgAgABC9ARogARC9ARogAEESdEGAgPAHcSABQQx0QYDgP3FyIgBBCHZBgP4DcSAAQYDgA3FBCHRyIAJyEMUBELsBCzYAIAAQESIAQRB0QYCA/AdxIABBCHZBgP4DcSAAQYD+A3FBCHRyQQh2ckEIdCABchDFARC7AQsL3AkBAEGAgMAAC9IJQ2hlY2tSZWdJZCB3YXMgZ2l2ZW4gaW52YWxpZCBSZWdJZGZ1ZWwtYXNtL3NyYy9saWIucnMAAAAiABAAEwAAAG4AAAAiAAAAVmFsdWUgYGAgb3V0IG9mIHJhbmdlIGZvciA2LWJpdCBpbW1lZGlhdGUAAABIABAABwAAAE8AEAAiAAAAIgAQABMAAACpAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAxMi1iaXQgaW1tZWRpYXRlAEgAEAAHAAAAlAAQACMAAAAiABAAEwAAAK4DAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDE4LWJpdCBpbW1lZGlhdGUASAAQAAcAAADYABAAIwAAACIAEAATAAAAswMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMjQtYml0IGltbWVkaWF0ZQBIABAABwAAABwBEAAjAAAAIgAQABMAAAC4AwAAHAAAAGludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWQAAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAABHAAAASAAAAEkAAABKAAAASwAAAEwAAABQAAAAUQAAAFIAAABTAAAAVAAAAFUAAABWAAAAVwAAAFgAAABZAAAAWgAAAFsAAABcAAAAXQAAAF4AAABfAAAAYAAAAGEAAABwAAAAcQAAAHIAAABzAAAAdAAAAHUAAAB2AAAAdwAAAHgAAAB5AAAAkAAAAJEAAACSAAAAkwAAAJQAAACVAAAAlgAAAJcAAACYAAAAoAAAAKEAAACiAAAAowAAAKQAAAClAAAApgAAAKcAAACoAAAAqQAAAKoAAACrAAAArAAAAK0AAACwAAAAaAQQAAAAAAAFAAAAAAAAAAEAAAAGAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5ycwA7BBAAHAAAAIQCAAAeAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAA7CXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AgZ3YWxydXMGMC4yMC4zDHdhc20tYmluZGdlbgYwLjIuOTI=", imports);
}
async function initWasm() {
  return await __wbg_init(wasm());
}
initWasm();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$a = BigInt(1), _2n$6 = BigInt(2), _3n$3 = BigInt(3);
const _4n$1 = BigInt(4), _5n$2 = BigInt(5), _8n$3 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$7 ? result : b2 + result;
}
function pow$1(num, power, modulo) {
  if (modulo <= _0n$7 || power < _0n$7)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$a)
    return _0n$7;
  let res = _1n$a;
  while (power > _0n$7) {
    if (power & _1n$a)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$a;
  }
  return res;
}
function pow2$1(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$7) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert$1(number2, modulo) {
  if (number2 === _0n$7 || modulo <= _0n$7) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod$1(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$7, u2 = _1n$a;
  while (a2 !== _0n$7) {
    const q3 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q3;
    b2 = a2, a2 = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$a)
    throw new Error("invert: does not exist");
  return mod$1(x2, modulo);
}
function tonelliShanks$1(P2) {
  const legendreC = (P2 - _1n$a) / _2n$6;
  let Q2, S2, Z3;
  for (Q2 = P2 - _1n$a, S2 = 0; Q2 % _2n$6 === _0n$7; Q2 /= _2n$6, S2++)
    ;
  for (Z3 = _2n$6; Z3 < P2 && pow$1(Z3, legendreC, P2) !== P2 - _1n$a; Z3++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$a) / _4n$1;
    return function tonelliFast(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$a) / _2n$6;
  return function tonelliSlow(Fp2, n3) {
    if (Fp2.pow(n3, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z3), Q2);
    let x2 = Fp2.pow(n3, Q1div2);
    let b2 = Fp2.pow(n3, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$a << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt$1(P2) {
  if (P2 % _4n$1 === _3n$3) {
    const p1div4 = (P2 + _1n$a) / _4n$1;
    return function sqrt3mod4(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n$3 === _5n$2) {
    const c1 = (P2 - _5n$2) / _8n$3;
    return function sqrt5mod8(Fp2, n3) {
      const n22 = Fp2.mul(n3, _2n$6);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n3, v2);
      const i2 = Fp2.mul(Fp2.mul(nv, _2n$6), v2);
      const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks$1(P2);
}
const isNegativeLE = (num, modulo) => (mod$1(num, modulo) & _1n$a) === _1n$a;
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS$1.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject$1(field, opts);
}
function FpPow$1(f2, num, power) {
  if (power < _0n$7)
    throw new Error("Expected power > 0");
  if (power === _0n$7)
    return f2.ONE;
  if (power === _1n$a)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$7) {
    if (power & _1n$a)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$a;
  }
  return p2;
}
function FpInvertBatch$1(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = f2.mul(acc, tmp[i2]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength$1(n3, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n3.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field$1(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$7)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength$1(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt$1(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask$1(BITS),
    ZERO: _0n$7,
    ONE: _1n$a,
    create: (num) => mod$1(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$7 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$7,
    isOdd: (num) => (num & _1n$a) === _1n$a,
    neg: (num) => mod$1(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod$1(num * num, ORDER),
    add: (lhs, rhs) => mod$1(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod$1(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod$1(lhs * rhs, ORDER),
    pow: (num, power) => FpPow$1(f2, num, power),
    div: (lhs, rhs) => mod$1(lhs * invert$1(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert$1(num, ORDER),
    sqrt: redef.sqrt || ((n3) => sqrtP(f2, n3)),
    invertBatch: (lst) => FpInvertBatch$1(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE$1(num, BYTES) : numberToBytesBE$1(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE$1(bytes2) : bytesToNumberBE$1(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength$1(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength$1(fieldOrder) {
  const length2 = getFieldBytesLength$1(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField$1(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength$1(fieldOrder);
  const minLen = getMinHashLength$1(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE$1(key) : bytesToNumberLE$1(key);
  const reduced = mod$1(num, fieldOrder - _1n$a) + _1n$a;
  return isLE2 ? numberToBytesLE$1(reduced, fieldLen) : numberToBytesBE$1(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$6 = BigInt(0);
const _1n$9 = BigInt(1);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
const pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF$1(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW = (W2) => {
    if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
      throw new Error(`Wrong window size=${W2}, should be [1..${bits}]`);
  };
  const opts = (W2) => {
    validateW(W2);
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n3) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n3 > _0n$6) {
        if (n3 & _1n$9)
          p2 = p2.add(d2);
        d2 = d2.double();
        n3 >>= _1n$9;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n3) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n3 & mask2);
        n3 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n3 += _1n$9;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, n3, transform) {
      const W2 = pointWindowSizes.get(P2) || 1;
      let comp = pointPrecomputes.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1)
          pointPrecomputes.set(P2, transform(comp));
      }
      return this.wNAF(W2, comp, n3);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P2, W2) {
      validateW(W2);
      pointWindowSizes.set(P2, W2);
      pointPrecomputes.delete(P2);
    }
  };
}
function pippenger(c2, field, points, scalars) {
  if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)
    throw new Error("arrays of points and scalars must have equal length");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error(`wrong scalar at index ${i2}`);
  });
  points.forEach((p2, i2) => {
    if (!(p2 instanceof c2))
      throw new Error(`wrong point at index ${i2}`);
  });
  const wbits = bitLen$1(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(c2.ZERO);
  const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
  let sum = c2.ZERO;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(c2.ZERO);
    for (let j2 = 0; j2 < scalars.length; j2++) {
      const scalar = scalars[j2];
      const wbits2 = Number(scalar >> BigInt(i2) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j2]);
    }
    let resI = c2.ZERO;
    for (let j2 = buckets.length - 1, sumI = c2.ZERO; j2 > 0; j2--) {
      sumI = sumI.add(buckets[j2]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j2 = 0; j2 < windowSize; j2++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic$1(curve) {
  validateField$1(curve.Fp);
  validateObject$1(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength$1(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$2;
const DER$1 = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data2) => {
      const { Err: E2 } = DER$1;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data2.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data2.length / 2;
      const len = numberToHexUnpadded$1(dataLen);
      if (len.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded$1(len.length / 2 | 128) : "";
      return `${numberToHexUnpadded$1(tag)}${lenLen}${len}${data2}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data2) {
      const { Err: E2 } = DER$1;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data2.length < 2 || data2[pos++] !== tag)
        throw new E2("tlv.decode: wrong tlv");
      const first = data2[pos++];
      const isLong = !!(first & 128);
      let length2 = 0;
      if (!isLong)
        length2 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data2.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b2 of lengthBytes)
          length2 = length2 << 8 | b2;
        pos += lenLen;
        if (length2 < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v2 = data2.subarray(pos, pos + length2);
      if (v2.length !== length2)
        throw new E2("tlv.decode: wrong value length");
      return { v: v2, l: data2.subarray(pos + length2) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E2 } = DER$1;
      if (num < _0n$5)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded$1(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected assertion");
      return hex;
    },
    decode(data2) {
      const { Err: E2 } = DER$1;
      if (data2[0] & 128)
        throw new E2("Invalid signature integer: negative");
      if (data2[0] === 0 && !(data2[1] & 128))
        throw new E2("Invalid signature integer: unnecessary leading zero");
      return b2n$1(data2);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER$1;
    const data2 = typeof hex === "string" ? h2b$1(hex) : hex;
    abytes$1(data2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
    if (seqLeftBytes.length)
      throw new E2("Invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER$1;
    const seq2 = `${tlv.encode(2, int.encode(sig.r))}${tlv.encode(2, int.encode(sig.s))}`;
    return tlv.encode(48, seq2);
  }
};
const _0n$5 = BigInt(0), _1n$8 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(opts) {
  const CURVE = validatePointOpts$1(opts);
  const { Fp: Fp2 } = CURVE;
  const Fn = Field$1(CURVE.n, CURVE.nBitLength);
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange$1(num, _1n$8, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes$3(key))
        key = bytesToHex$1(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE$1(ensureBytes$1("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod$1(num, N2);
    aInRange("private key", num, _1n$8, N2);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { px: x2, py: y2, pz: z2 } = p2;
    if (Fp2.eql(z2, Fp2.ONE))
      return { x: x2, y: y2 };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(z2);
    const ax = Fp2.mul(x2, iz);
    const ay = Fp2.mul(y2, iz);
    const zz = Fp2.mul(z2, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (CURVE.allowInfinityPoint && !Fp2.is0(p2.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y: y2 } = p2.toAffine();
    if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp2.sqr(y2);
    const right = weierstrassEquation(x2);
    if (!Fp2.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes$1("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z22 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n$2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z22 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n$2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y22);
      let t2 = Fp2.mul(Z1, Z22);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y22);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z22);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y22, Z22);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, n3, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc2) {
      aInRange("scalar", sc2, _0n$5, CURVE.n);
      const I2 = Point.ZERO;
      if (sc2 === _0n$5)
        return I2;
      if (sc2 === _1n$8)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, sc2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n$5 || k2 > _0n$5) {
        if (k1 & _1n$8)
          k1p = k1p.add(d2);
        if (k2 & _1n$8)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$8;
        k2 >>= _1n$8;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", scalar, _1n$8, N2);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(scalar);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G3 = Point.BASE;
      const mul2 = (P2, a3) => a3 === _0n$5 || a3 === _1n$8 || !P2.equals(G3) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul2(this, a2).add(mul2(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$8)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$8)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex$1(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF$1(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts$2(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass$1(curveDef) {
  const CURVE = validateOpts$2(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function modN(a2) {
    return mod$1(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert$1(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints$1({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes$2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE$1(tail);
        if (!inRange$1(x2, _1n$8, Fp2.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$8) === _1n$8;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE$1(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$8;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from2, to2) => bytesToNumberBE$1(b2.slice(from2, to2));
  class Signature {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes$1("compactSignature", hex, l2 * 2);
      return new Signature(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s: s2 } = DER$1.toSig(ensureBytes$1("DER", hex));
      return new Signature(r2, s2);
    }
    assertValidity() {
      aInRange("r", this.r, _1n$8, CURVE_ORDER);
      aInRange("s", this.s, _1n$8, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes$1("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix2 = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix2 + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$2(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength$1(CURVE.n);
      return mapHashToField$1(CURVE.randomBytes(length2), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes$3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE$1(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask$1(CURVE.nBitLength);
  function int2octets(num) {
    aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n$5, ORDER_MASK);
    return numberToBytesBE$1(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes$1("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes$1("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes3(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes$1("extraEntropy", e2));
    }
    const seed2 = concatBytes$2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q3 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q3.x);
      if (r2 === _0n$5)
        return;
      const s2 = modN(ik2 * modN(m2 + r2 * d2));
      if (s2 === _0n$5)
        return;
      let recovery = (q3.x === r2 ? 0 : 2) | Number(q3.y & _1n$8);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r2, normS, recovery);
    }
    return { seed: seed2, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed: seed2, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg$1(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed2, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey2, opts = defaultVerOpts) {
    var _a2;
    const sg2 = signature;
    msgHash = ensureBytes$1("msgHash", msgHash);
    publicKey2 = ensureBytes$1("publicKey", publicKey2);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || isBytes$3(sg2)) {
        try {
          _sig = Signature.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER$1.Err))
            throw derError;
          _sig = Signature.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s3 } = sg2;
        _sig = new Signature(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s2);
    const u1 = modN(h2 * is2);
    const u2 = modN(r2 * is2);
    const R2 = (_a2 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$2(hash2, key, concatBytes$3(...msgs)),
    randomBytes: randomBytes$2
  };
}
function createCurve$1(curveDef, defHash) {
  const create3 = (hash2) => weierstrass$1({ ...curveDef, ...getHash$1(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n$7 = BigInt(1);
const _2n$5 = BigInt(2);
const divNearest$1 = (a2, b2) => (a2 + b2 / _2n$5) / b2;
function sqrtMod$1(y2) {
  const P2 = secp256k1P$1;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2$1(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2$1(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2$1(b9, _2n$5, P2) * b2 % P2;
  const b22 = pow2$1(b11, _11n, P2) * b11 % P2;
  const b44 = pow2$1(b22, _22n, P2) * b22 % P2;
  const b88 = pow2$1(b44, _44n, P2) * b44 % P2;
  const b176 = pow2$1(b88, _88n, P2) * b88 % P2;
  const b220 = pow2$1(b176, _44n, P2) * b44 % P2;
  const b223 = pow2$1(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2$1(b223, _23n, P2) * b22 % P2;
  const t2 = pow2$1(t1, _6n, P2) * b2 % P2;
  const root = pow2$1(t2, _2n$5, P2);
  if (!Fp$2.eql(Fp$2.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
const Fp$2 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 });
const secp256k1$1 = createCurve$1({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp$2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N$1,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n3 = secp256k1N$1;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest$1(b2 * k2, n3);
      const c2 = divNearest$1(-b1 * k2, n3);
      let k1 = mod$1(k2 - c1 * a1 - c2 * a2, n3);
      let k22 = mod$1(-c1 * b1 - c2 * b2, n3);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n3 - k1;
      if (k2neg)
        k22 = n3 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$3);
BigInt(0);
secp256k1$1.ProjectivePoint;
var byteToHex$1 = [];
for (var i$7 = 0; i$7 < 256; ++i$7) {
  byteToHex$1.push((i$7 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex$1[arr[offset2 + 0]] + byteToHex$1[arr[offset2 + 1]] + byteToHex$1[arr[offset2 + 2]] + byteToHex$1[arr[offset2 + 3]] + "-" + byteToHex$1[arr[offset2 + 4]] + byteToHex$1[arr[offset2 + 5]] + "-" + byteToHex$1[arr[offset2 + 6]] + byteToHex$1[arr[offset2 + 7]] + "-" + byteToHex$1[arr[offset2 + 8]] + byteToHex$1[arr[offset2 + 9]] + "-" + byteToHex$1[arr[offset2 + 10]] + byteToHex$1[arr[offset2 + 11]] + byteToHex$1[arr[offset2 + 12]] + byteToHex$1[arr[offset2 + 13]] + byteToHex$1[arr[offset2 + 14]] + byteToHex$1[arr[offset2 + 15]]).toLowerCase();
}
var getRandomValues$1;
var rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$1) {
    getRandomValues$1 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$1) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$1(rnds8$1);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4$1(options, buf, offset2) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng$1)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
var events = { exports: {} };
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning2) {
  if (console && console.warn) console.warn(warning2);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
  return value2 !== value2;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
  if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
  }
  this._maxListeners = n3;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type3) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
  var doError = type3 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err.context = er2;
    throw err;
  }
  var handler = events2[type3];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type3, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type3,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type3];
  }
  if (existing === void 0) {
    existing = events2[type3] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type3] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type3;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type3, listener) {
  return _addListener(this, type3, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type3, listener) {
  return _addListener(this, type3, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type3, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type: type3, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type3, listener) {
  checkListener(listener);
  this.on(type3, _onceWrap(this, type3, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type3, listener) {
  checkListener(listener);
  this.prependListener(type3, _onceWrap(this, type3, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type3, listener) {
  var list, events2, position2, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type3];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type3];
      if (events2.removeListener)
        this.emit("removeListener", type3, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position2 = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position2 = i2;
        break;
      }
    }
    if (position2 < 0)
      return this;
    if (position2 === 0)
      list.shift();
    else {
      spliceOne(list, position2);
    }
    if (list.length === 1)
      events2[type3] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type3, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type3) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type3] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type3];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type3];
  if (typeof listeners2 === "function") {
    this.removeListener(type3, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type3, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type3, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type3];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type3) {
  return _listeners(this, type3, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type3) {
  return _listeners(this, type3, false);
};
EventEmitter.listenerCount = function(emitter, type3) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type3);
  } else {
    return listenerCount.call(emitter, type3);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type3) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type3];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n3) {
  var copy2 = new Array(n3);
  for (var i2 = 0; i2 < n3; ++i2)
    copy2[i2] = arr[i2];
  return copy2;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret2 = new Array(arr.length);
  for (var i2 = 0; i2 < ret2.length; ++i2) {
    ret2[i2] = arr[i2].listener || arr[i2];
  }
  return ret2;
}
function once2(emitter, name) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
var EMPTY$1 = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
var Node = class {
  constructor(left, right, parent, hash5, data2, index = 0) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, "parent");
    __publicField(this, "hash");
    __publicField(this, "data");
    __publicField(this, "index");
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.hash = hash5;
    this.data = data2;
    this.index = index;
  }
};
var node_default = Node;
function hashLeaf(data2) {
  return hash$4("0x00".concat(data2.slice(2)));
}
function hashNode(left, right) {
  return hash$4("0x01".concat(left.slice(2)).concat(right.slice(2)));
}
function calcRoot(data2) {
  if (!data2.length) {
    return EMPTY$1;
  }
  const nodes = [];
  for (let i2 = 0; i2 < data2.length; i2 += 1) {
    const hashed = hashLeaf(data2[i2]);
    nodes.push(new node_default(-1, -1, -1, hashed, data2[i2]));
  }
  let pNodes = nodes;
  let size = nodes.length + 1 >> 1;
  let odd = nodes.length & 1;
  while (true) {
    let i2 = 0;
    for (; i2 < size - odd; i2 += 1) {
      const j2 = i2 << 1;
      const hashed = hashNode(pNodes[j2].hash, pNodes[j2 + 1].hash);
      nodes[i2] = new node_default(pNodes[j2].index, pNodes[j2 + 1].index, -1, hashed, "");
    }
    if (odd === 1) {
      nodes[i2] = pNodes[i2 << 1];
    }
    if (size === 1) {
      break;
    }
    odd = size & 1;
    size = size + 1 >> 1;
    pNodes = nodes;
  }
  return nodes[0].hash;
}
var leafPrefix = "0x00";
var nodePrefix = "0x01";
function hashLeaf2(key, data2) {
  const value2 = "0x00".concat(key.slice(2)).concat(hash$4(data2).slice(2));
  return [hash$4(value2), value2];
}
function hashNode2(left, right) {
  const value2 = "0x01".concat(left.slice(2)).concat(right.slice(2));
  return [hash$4(value2), value2];
}
function parseLeaf(data2) {
  const len = nodePrefix.length;
  return ["0x".concat(data2.slice(len, len + 64)), "0x".concat(data2.slice(len + 64))];
}
function parseNode(data2) {
  const len = nodePrefix.length;
  return ["0x".concat(data2.slice(len, len + 64)), "0x".concat(data2.slice(len + 64))];
}
function isLeaf(data2) {
  return data2.slice(0, 4) === leafPrefix;
}
var SparseCompactMerkleProof = class {
  constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {
    __publicField(this, "SideNodes");
    __publicField(this, "NonMembershipLeafData");
    __publicField(this, "BitMask");
    __publicField(this, "NumSideNodes");
    __publicField(this, "SiblingData");
    this.SideNodes = SideNodes;
    this.NonMembershipLeafData = NonMembershipLeafData;
    this.BitMask = Bitmask;
    this.NumSideNodes = NumSideNodes;
    this.SiblingData = SiblingData;
  }
};
var sparseCompactMerkleProof_default = SparseCompactMerkleProof;
var SparseMerkleProof = class {
  constructor(sideNodes, NonMembershipLeafData, SiblingData) {
    __publicField(this, "SideNodes");
    __publicField(this, "NonMembershipLeafData");
    __publicField(this, "SiblingData");
    this.SideNodes = sideNodes;
    this.NonMembershipLeafData = NonMembershipLeafData;
    this.SiblingData = SiblingData;
  }
};
var sparseMerkleProof_default = SparseMerkleProof;
var ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
var MAX_HEIGHT$1 = 256;
function getBitAtFromMSB(data2, position2) {
  const slicedData = data2.slice(2);
  const byte2 = "0x".concat(
    slicedData.slice(Math.floor(position2 / 8) * 2, Math.floor(position2 / 8) * 2 + 2)
  );
  const bits = Number(byte2) & 1 << 8 - 1 - position2 % 8;
  if (bits > 0) {
    return 1;
  }
  return 0;
}
function reverseSideNodes(sideNodes) {
  let left = 0;
  let right = sideNodes.length - 1;
  const reversedSideNodes = sideNodes;
  while (left < right) {
    [reversedSideNodes[left], reversedSideNodes[right]] = [
      reversedSideNodes[right],
      reversedSideNodes[left]
    ];
    left += 1;
    right -= 1;
  }
  return reversedSideNodes;
}
function countCommonPrefix(data1, data2) {
  let count2 = 0;
  for (let i2 = 0; i2 < MAX_HEIGHT$1; i2 += 1) {
    if (getBitAtFromMSB(data1, i2) === getBitAtFromMSB(data2, i2)) {
      count2 += 1;
    } else {
      break;
    }
  }
  return count2;
}
function compactProof(proof) {
  const bitMask2 = [];
  const compactedSideNodes = [];
  let node2;
  for (let i2 = 0; i2 < proof.SideNodes.length; i2 += 1) {
    node2 = proof.SideNodes[i2];
    if (node2 === ZERO) {
      bitMask2.push(0);
    } else {
      compactedSideNodes.push(node2);
      bitMask2.push(1);
    }
  }
  const compactedProof = new sparseCompactMerkleProof_default(
    compactedSideNodes,
    proof.NonMembershipLeafData,
    bitMask2,
    proof.SideNodes.length,
    proof.SiblingData
  );
  return compactedProof;
}
var SparseMerkleTree = class {
  constructor() {
    __publicField(this, "ms");
    __publicField(this, "root");
    const ms = {};
    this.ms = ms;
    this.root = ZERO;
    this.ms[this.root] = ZERO;
  }
  get(key) {
    return this.ms[key];
  }
  set(key, value2) {
    this.ms[key] = value2;
  }
  setRoot(root) {
    this.root = root;
  }
  sideNodesForRoot(key, root) {
    const sideNodes = [];
    if (root === ZERO) {
      return [sideNodes, ZERO, "", ""];
    }
    let currentData = this.get(root);
    if (isLeaf(currentData)) {
      return [sideNodes, root, currentData, ""];
    }
    let leftNode;
    let rightNode;
    let nodeHash = "";
    let sideNode = "";
    for (let i2 = 0; i2 < MAX_HEIGHT$1; i2 += 1) {
      [leftNode, rightNode] = parseNode(currentData);
      if (getBitAtFromMSB(key, i2) === 1) {
        sideNode = leftNode;
        nodeHash = rightNode;
      } else {
        sideNode = rightNode;
        nodeHash = leftNode;
      }
      sideNodes.push(sideNode);
      if (nodeHash === ZERO) {
        currentData = "";
        break;
      }
      currentData = this.get(nodeHash);
      if (isLeaf(currentData)) {
        break;
      }
    }
    const siblingData = this.get(sideNode);
    return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];
  }
  deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {
    if (oldLeafHash === ZERO) {
      return this.root;
    }
    const [actualPath] = parseLeaf(oldLeafData);
    if (actualPath !== key) {
      return this.root;
    }
    let currentHash = "";
    let currentData = "";
    let sideNode = "";
    let sideNodeValue = "";
    let nonPlaceholderReached = false;
    for (let i2 = 0; i2 < sideNodes.length; i2 += 1) {
      if (sideNodes[i2] === "") {
        continue;
      }
      sideNode = sideNodes[i2];
      if (currentData === "") {
        sideNodeValue = this.get(sideNode);
        if (isLeaf(sideNodeValue)) {
          currentHash = sideNode;
          currentData = sideNode;
          continue;
        } else {
          currentData = ZERO;
          nonPlaceholderReached = true;
        }
      }
      if (!nonPlaceholderReached && sideNode === ZERO) {
        continue;
      } else if (!nonPlaceholderReached) {
        nonPlaceholderReached = true;
      }
      if (getBitAtFromMSB(key, sideNodes.length - 1 - i2) === 1) {
        [currentHash, currentData] = hashNode2(sideNode, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, sideNode);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    if (currentHash === "") {
      currentHash = ZERO;
    }
    return currentHash;
  }
  updateWithSideNodes(key, value2, sideNodes, oldLeafHash, oldLeafData) {
    let currentHash;
    let currentData;
    this.set(hash$4(value2), value2);
    [currentHash, currentData] = hashLeaf2(key, value2);
    this.set(currentHash, currentData);
    currentData = currentHash;
    let commonPrefixCount;
    if (oldLeafHash === ZERO) {
      commonPrefixCount = MAX_HEIGHT$1;
    } else {
      const [actualPath] = parseLeaf(oldLeafData);
      commonPrefixCount = countCommonPrefix(key, actualPath);
    }
    if (commonPrefixCount !== MAX_HEIGHT$1) {
      if (getBitAtFromMSB(key, commonPrefixCount) === 1) {
        [currentHash, currentData] = hashNode2(oldLeafHash, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, oldLeafHash);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    for (let i2 = 0; i2 < MAX_HEIGHT$1; i2 += 1) {
      let sideNode;
      const offsetOfSideNodes = MAX_HEIGHT$1 - sideNodes.length;
      if (i2 - offsetOfSideNodes < 0 || sideNodes[i2 - offsetOfSideNodes] === "") {
        if (commonPrefixCount !== MAX_HEIGHT$1 && commonPrefixCount > MAX_HEIGHT$1 - 1 - i2) {
          sideNode = ZERO;
        } else {
          continue;
        }
      } else {
        sideNode = sideNodes[i2 - offsetOfSideNodes];
      }
      if (getBitAtFromMSB(key, MAX_HEIGHT$1 - 1 - i2) === 1) {
        [currentHash, currentData] = hashNode2(sideNode, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, sideNode);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    return currentHash;
  }
  update(key, value2) {
    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
    const newRoot = this.updateWithSideNodes(key, value2, sideNodes, oldLeafHash, oldLeafData);
    this.setRoot(newRoot);
  }
  delete(key) {
    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
    const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);
    this.setRoot(newRoot);
  }
  prove(key) {
    const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);
    const nonEmptySideNodes = [];
    for (let i2 = 0; i2 < sideNodes.length; i2 += 1) {
      if (sideNodes[i2] !== "") {
        nonEmptySideNodes.push(sideNodes[i2]);
      }
    }
    let nonMembershipLeafData = "";
    if (leafHash !== ZERO) {
      const [actualPath] = parseLeaf(leafData);
      if (actualPath !== key) {
        nonMembershipLeafData = leafData;
      }
    }
    const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);
    return proof;
  }
  proveCompacted(key) {
    const proof = this.prove(key);
    const compactedProof = compactProof(proof);
    return compactedProof;
  }
};
var __defProp$1 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField2 = (obj, key, value2) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet2 = (obj, member, value2, setter) => {
  __accessCheck2(obj, member, "write to private field");
  member.set(obj, value2);
  return value2;
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1];
    max = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId;
    max = coinQuantityLike.max ?? void 0;
  }
  const bnAmount = bn$1(amount);
  return {
    assetId: hexlify(assetId),
    amount: bnAmount.lt(1) ? bn$1(1) : bnAmount,
    max: max ? bn$1(max) : void 0
  };
};
var addAmountToCoinQuantities = (params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};
var TransactionStatusSubscriptionFragmentDoc = gql`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  type: __typename
  ... on SqueezedOutStatus {
    reason
  }
}
    `;
var SubmittedStatusFragmentDoc = gql`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `;
var ReceiptFragmentDoc = gql`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var SuccessStatusFragmentDoc = gql`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  block {
    id
  }
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${ReceiptFragmentDoc}`;
var FailureStatusFragmentDoc = gql`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  block {
    id
  }
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var SqueezedOutStatusFragmentDoc = gql`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `;
var TransactionStatusFragmentDoc = gql`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusFragmentDoc}
${FailureStatusFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
var TransactionFragmentDoc = gql`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentDoc}`;
var InputEstimatePredicatesFragmentDoc = gql`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentDoc = gql`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentDoc}`;
var DryRunFailureStatusFragmentDoc = gql`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `;
var DryRunSuccessStatusFragmentDoc = gql`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `;
var DryRunTransactionStatusFragmentDoc = gql`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${DryRunFailureStatusFragmentDoc}
${DryRunSuccessStatusFragmentDoc}`;
var DryRunTransactionExecutionStatusFragmentDoc = gql`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${DryRunTransactionStatusFragmentDoc}
${ReceiptFragmentDoc}`;
var CoinFragmentDoc = gql`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  owner
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentDoc = gql`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentDoc = gql`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
var MessageProofFragmentDoc = gql`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
var BalanceFragmentDoc = gql`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
var BlockFragmentDoc = gql`
    fragment blockFragment on Block {
  id
  height
  header {
    time
  }
  transactions {
    id
  }
}
    `;
var TxParametersFragmentDoc = gql`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `;
var PredicateParametersFragmentDoc = gql`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentDoc = gql`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentDoc = gql`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentDoc = gql`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentDoc = gql`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentDoc = gql`
    fragment GasCostsFragment on GasCosts {
  version
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  alocDependentCost {
    ...DependentCostFragment
  }
  cfe {
    ...DependentCostFragment
  }
  cfeiDependentCost {
    ...DependentCostFragment
  }
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  croo {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentDoc}`;
var ConsensusParametersFragmentDoc = gql`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentDoc}
${PredicateParametersFragmentDoc}
${ScriptParametersFragmentDoc}
${ContractParametersFragmentDoc}
${FeeParametersFragmentDoc}
${GasCostsFragmentDoc}`;
var ChainInfoFragmentDoc = gql`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentDoc}
${ConsensusParametersFragmentDoc}`;
var ContractBalanceFragmentDoc = gql`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentDoc = gql`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentDoc = gql`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
}
    `;
var RelayedTransactionStatusFragmentDoc = gql`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `;
var GetVersionDocument = gql`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = gql`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentDoc}`;
var GetChainDocument = gql`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentDoc}`;
var GetTransactionDocument = gql`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc}`;
var GetTransactionWithReceiptsDocument = gql`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc}`;
var GetTransactionsDocument = gql`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${TransactionFragmentDoc}
${PageInfoFragmentDoc}`;
var GetTransactionsByOwnerDocument = gql`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${TransactionFragmentDoc}`;
var EstimatePredicatesDocument = gql`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentDoc}`;
var GetBlockDocument = gql`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentDoc}`;
var GetBlockWithTransactionsDocument = gql`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentDoc}
${TransactionFragmentDoc}`;
var GetBlocksDocument = gql`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${BlockFragmentDoc}`;
var GetCoinDocument = gql`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentDoc}`;
var GetCoinsDocument = gql`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CoinFragmentDoc}`;
var GetCoinsToSpendDocument = gql`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentDoc}
${MessageCoinFragmentDoc}`;
var GetContractDocument = gql`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = gql`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentDoc}`;
var GetBalanceDocument = gql`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentDoc}`;
var GetLatestGasPriceDocument = gql`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `;
var EstimateGasPriceDocument = gql`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `;
var GetBalancesDocument = gql`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${BalanceFragmentDoc}`;
var GetMessagesDocument = gql`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${MessageFragmentDoc}`;
var GetMessageProofDocument = gql`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentDoc}`;
var GetMessageStatusDocument = gql`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var GetRelayedTransactionStatusDocument = gql`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${RelayedTransactionStatusFragmentDoc}`;
var DryRunDocument = gql`
    mutation dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${DryRunTransactionExecutionStatusFragmentDoc}`;
var SubmitDocument = gql`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = gql`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var GetMessageByNonceDocument = gql`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${MessageFragmentDoc}`;
var SubmitAndAwaitDocument = gql`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
var StatusChangeDocument = gql`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getLatestGasPrice(variables, options) {
      return requester(GetLatestGasPriceDocument, variables, options);
    },
    estimateGasPrice(variables, options) {
      return requester(EstimateGasPriceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    getRelayedTransactionStatus(variables, options) {
      return requester(GetRelayedTransactionStatusDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    getMessageByNonce(variables, options) {
      return requester(GetMessageByNonceDocument, variables, options);
    },
    submitAndAwait(variables, options) {
      return requester(SubmitAndAwaitDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}
var _FuelGraphqlSubscriber = class {
  constructor(options) {
    __publicField(this, "stream");
    __publicField(this, "events", []);
    __publicField(this, "parsingLeftover", "");
    this.options = options;
  }
  async setStream() {
    const { url: url2, query, variables, fetchFn } = this.options;
    const response = await fetchFn(`${url2}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: print$2(query),
        variables
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    });
    this.stream = response.body.getReader();
  }
  async next() {
    if (!this.stream) {
      await this.setStream();
    }
    while (true) {
      if (this.events.length > 0) {
        const { data: data2, errors: errors2 } = this.events.shift();
        if (Array.isArray(errors2)) {
          throw new FuelError(
            FuelError.CODES.INVALID_REQUEST,
            errors2.map((err) => err.message).join("\n\n")
          );
        }
        return { value: data2, done: false };
      }
      const { value: value2, done } = await this.stream.read();
      if (done) {
        return { value: value2, done };
      }
      const decoded = _FuelGraphqlSubscriber.textDecoder.decode(value2).replace(":keep-alive-text\n\n", "");
      if (decoded === "") {
        continue;
      }
      const text = `${this.parsingLeftover}${decoded}`;
      const regex2 = /data:.*\n\n/g;
      const matches = [...text.matchAll(regex2)].flatMap((match2) => match2);
      matches.forEach((match2) => {
        try {
          this.events.push(JSON.parse(match2.replace(/^data:/, "")));
        } catch (e2) {
          throw new FuelError(
            ErrorCode$1.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${text}`
          );
        }
      });
      this.parsingLeftover = text.replace(matches.join(), "");
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  async return() {
    await this.stream.cancel();
    this.stream.releaseLock();
    return { done: true, value: void 0 };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
__publicField2(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());
var cache$2 = {};
var DEFAULT_TTL_IN_MS = 30 * 1e3;
var MemoryCache = class {
  constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
    __publicField(this, "ttl");
    this.ttl = ttlInMs;
    if (typeof ttlInMs !== "number" || this.ttl <= 0) {
      throw new FuelError(
        ErrorCode$1.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  get(value2, isAutoExpiring = true) {
    const key = hexlify(value2);
    if (cache$2[key]) {
      if (!isAutoExpiring || cache$2[key].expires > Date.now()) {
        return cache$2[key].value;
      }
      this.del(value2);
    }
    return void 0;
  }
  set(value2) {
    const expiresAt = Date.now() + this.ttl;
    const key = hexlify(value2);
    cache$2[key] = {
      expires: expiresAt,
      value: value2
    };
    return expiresAt;
  }
  getAllData() {
    return Object.keys(cache$2).reduce((list, key) => {
      const data2 = this.get(key, false);
      if (data2) {
        list.push(data2);
      }
      return list;
    }, []);
  }
  getActiveData() {
    return Object.keys(cache$2).reduce((list, key) => {
      const data2 = this.get(key);
      if (data2) {
        list.push(data2);
      }
      return list;
    }, []);
  }
  del(value2) {
    const key = hexlify(value2);
    delete cache$2[key];
  }
};
var inputify = (value2) => {
  const { type: type3 } = value2;
  switch (value2.type) {
    case InputType.Coin: {
      const predicate = arrayify$1(value2.predicate ?? "0x");
      const predicateData = arrayify$1(value2.predicateData ?? "0x");
      return {
        type: InputType.Coin,
        txID: hexlify(arrayify$1(value2.id).slice(0, BYTES_32)),
        outputIndex: toNumber(arrayify$1(value2.id).slice(BYTES_32, UTXO_ID_LEN)),
        owner: hexlify(value2.owner),
        amount: bn$1(value2.amount),
        assetId: hexlify(value2.assetId),
        txPointer: {
          blockHeight: toNumber(arrayify$1(value2.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify$1(value2.txPointer).slice(8, 16))
        },
        witnessIndex: value2.witnessIndex,
        predicateGasUsed: bn$1(value2.predicateGasUsed),
        predicateLength: bn$1(predicate.length),
        predicateDataLength: bn$1(predicateData.length),
        predicate: hexlify(predicate),
        predicateData: hexlify(predicateData)
      };
    }
    case InputType.Contract: {
      return {
        type: InputType.Contract,
        txID: ZeroBytes32,
        outputIndex: 0,
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32,
        txPointer: {
          blockHeight: toNumber(arrayify$1(value2.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify$1(value2.txPointer).slice(8, 16))
        },
        contractID: hexlify(value2.contractId)
      };
    }
    case InputType.Message: {
      const predicate = arrayify$1(value2.predicate ?? "0x");
      const predicateData = arrayify$1(value2.predicateData ?? "0x");
      const data2 = arrayify$1(value2.data ?? "0x");
      return {
        type: InputType.Message,
        sender: hexlify(value2.sender),
        recipient: hexlify(value2.recipient),
        amount: bn$1(value2.amount),
        nonce: hexlify(value2.nonce),
        witnessIndex: value2.witnessIndex,
        predicateGasUsed: bn$1(value2.predicateGasUsed),
        predicateLength: bn$1(predicate.length),
        predicateDataLength: bn$1(predicateData.length),
        predicate: hexlify(predicate),
        predicateData: hexlify(predicateData),
        data: hexlify(data2),
        dataLength: data2.length
      };
    }
    default: {
      throw new FuelError(
        ErrorCode$1.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type3}.`
      );
    }
  }
};
var outputify = (value2) => {
  const { type: type3 } = value2;
  switch (type3) {
    case OutputType.Coin: {
      return {
        type: OutputType.Coin,
        to: hexlify(value2.to),
        amount: bn$1(value2.amount),
        assetId: hexlify(value2.assetId)
      };
    }
    case OutputType.Contract: {
      return {
        type: OutputType.Contract,
        inputIndex: value2.inputIndex,
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32
      };
    }
    case OutputType.Change: {
      return {
        type: OutputType.Change,
        to: hexlify(value2.to),
        amount: bn$1(0),
        assetId: hexlify(value2.assetId)
      };
    }
    case OutputType.Variable: {
      return {
        type: OutputType.Variable,
        to: ZeroBytes32,
        amount: bn$1(0),
        assetId: ZeroBytes32
      };
    }
    case OutputType.ContractCreated: {
      return {
        type: OutputType.ContractCreated,
        contractId: hexlify(value2.contractId),
        stateRoot: hexlify(value2.stateRoot)
      };
    }
    default: {
      throw new FuelError(
        ErrorCode$1.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type3}.`
      );
    }
  }
};
var isCoin = (resource) => "id" in resource;
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
);
var hexOrZero = (hex) => hex || ZeroBytes32;
function assembleReceiptByType(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL": {
      const callReceipt = {
        type: ReceiptType.Call,
        from: hexOrZero(receipt.id || receipt.contractId),
        to: hexOrZero(receipt == null ? void 0 : receipt.to),
        amount: bn$1(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: bn$1(receipt.gas),
        param1: bn$1(receipt.param1),
        param2: bn$1(receipt.param2),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN": {
      const returnReceipt = {
        type: ReceiptType.Return,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: bn$1(receipt.val),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA": {
      const returnDataReceipt = {
        type: ReceiptType.ReturnData,
        id: hexOrZero(receipt.id || receipt.contractId),
        ptr: bn$1(receipt.ptr),
        len: bn$1(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC": {
      const panicReceipt = {
        type: ReceiptType.Panic,
        id: hexOrZero(receipt.id),
        reason: bn$1(receipt.reason),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT": {
      const revertReceipt = {
        type: ReceiptType.Revert,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: bn$1(receipt.ra),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG": {
      const logReceipt = {
        type: ReceiptType.Log,
        id: hexOrZero(receipt.id || receipt.contractId),
        val0: bn$1(receipt.ra),
        val1: bn$1(receipt.rb),
        val2: bn$1(receipt.rc),
        val3: bn$1(receipt.rd),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA": {
      const logDataReceipt = {
        type: ReceiptType.LogData,
        id: hexOrZero(receipt.id || receipt.contractId),
        val0: bn$1(receipt.ra),
        val1: bn$1(receipt.rb),
        ptr: bn$1(receipt.ptr),
        len: bn$1(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER": {
      const transferReceipt = {
        type: ReceiptType.Transfer,
        from: hexOrZero(receipt.id || receipt.contractId),
        to: hexOrZero(receipt.toAddress || (receipt == null ? void 0 : receipt.to)),
        amount: bn$1(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT": {
      const transferOutReceipt = {
        type: ReceiptType.TransferOut,
        from: hexOrZero(receipt.id || receipt.contractId),
        to: hexOrZero(receipt.toAddress || receipt.to),
        amount: bn$1(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT": {
      const scriptResultReceipt = {
        type: ReceiptType.ScriptResult,
        result: bn$1(receipt.result),
        gasUsed: bn$1(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT": {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = bn$1(receipt.amount);
      const data2 = receipt.data ? arrayify$1(receipt.data) : Uint8Array.from([]);
      const digest9 = hexOrZero(receipt.digest);
      const messageId = ReceiptMessageOutCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data: data2
      });
      const receiptMessageOut = {
        type: ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        data: data2,
        digest: digest9,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT": {
      const contractId2 = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptMintCoder.getAssetId(contractId2, subId);
      const mintReceipt = {
        type: ReceiptType.Mint,
        subId,
        contractId: contractId2,
        assetId,
        val: bn$1(receipt.val),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN": {
      const contractId2 = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptBurnCoder.getAssetId(contractId2, subId);
      const burnReceipt = {
        type: ReceiptType.Burn,
        subId,
        contractId: contractId2,
        assetId,
        val: bn$1(receipt.val),
        pc: bn$1(receipt.pc),
        is: bn$1(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new FuelError(ErrorCode$1.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === ReceiptType.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev2, receipt) => prev2.add(receipt.gasUsed), bn$1(0));
  return gasUsed;
};
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base2 = bn$1(gasDependentCost.base);
  let dependentValue = bn$1(0);
  if ("unitsPerGas" in gasDependentCost) {
    dependentValue = bn$1(byteSize).div(bn$1(gasDependentCost.unitsPerGas));
  } else {
    dependentValue = bn$1(byteSize).mul(bn$1(gasDependentCost.gasPerUnit));
  }
  return base2.add(dependentValue);
}
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const chargeableInputs = inputs.filter((input) => {
    const isCoinOrMessage = "owner" in input || "sender" in input;
    if (isCoinOrMessage) {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return true;
      }
      if (!witnessCache.includes(input.witnessIndex)) {
        witnessCache.push(input.witnessIndex);
        return true;
      }
    }
    return false;
  });
  const vmInitializationCost = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const totalGas = chargeableInputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        vmInitializationCost.add(resolveGasDependentCosts(arrayify$1(input.predicate).length, gasCosts.contractRoot)).add(bn$1(input.predicateGasUsed))
      );
    }
    return total.add(gasCosts.ecr1);
  }, bn$1(0));
  return totalGas;
}
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = bn$1(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
function getMaxGas(params) {
  const {
    gasPerByte,
    witnessesLength,
    witnessLimit,
    minGas,
    gasLimit = bn$1(0),
    maxGasPerTx
  } = params;
  let remainingAllowedWitnessGas = bn$1(0);
  if ((witnessLimit == null ? void 0 : witnessLimit.gt(0)) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = bn$1(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);
  return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;
}
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = bn$1(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}
var calculateGasFee = (params) => {
  const { gas, gasPrice, priceFactor, tip } = params;
  return gas.mul(gasPrice).div(priceFactor).add(bn$1(tip));
};
function normalize(object) {
  Object.keys(object).forEach((key) => {
    var _a2;
    switch ((_a2 = object[key]) == null ? void 0 : _a2.constructor.name) {
      case "Uint8Array":
        object[key] = hexlify(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
    }
  });
  return object;
}
function normalizeJSON(root) {
  return normalize(clone$1(root));
}
var assemblePanicError = (statusReason, metadata) => {
  let errorMessage = `The transaction reverted with reason: "${statusReason}".`;
  if (PANIC_REASONS.includes(statusReason)) {
    errorMessage = `${errorMessage}

You can read more about this error at:

${PANIC_DOC_URL}#variant.${statusReason}`;
  }
  return new FuelError(ErrorCode$1.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason: statusReason
  });
};
var stringify$2 = (obj) => JSON.stringify(obj, null, 2);
var assembleRevertError = (receipts, logs, metadata) => {
  let errorMessage = "The transaction reverted with an unknown reason.";
  const revertReceipt = receipts.find(({ type: type3 }) => type3 === ReceiptType.Revert);
  let reason = "";
  if (revertReceipt) {
    const reasonHex = bn$1(revertReceipt.val).toHex();
    switch (reasonHex) {
      case FAILED_REQUIRE_SIGNAL: {
        reason = "require";
        errorMessage = `The transaction reverted because a "require" statement has thrown ${logs.length ? stringify$2(logs[0]) : "an error."}.`;
        break;
      }
      case FAILED_ASSERT_EQ_SIGNAL: {
        const sufix = logs.length >= 2 ? ` comparing ${stringify$2(logs[1])} and ${stringify$2(logs[0])}.` : ".";
        reason = "assert_eq";
        errorMessage = `The transaction reverted because of an "assert_eq" statement${sufix}`;
        break;
      }
      case FAILED_ASSERT_NE_SIGNAL: {
        const sufix = logs.length >= 2 ? ` comparing ${stringify$2(logs[1])} and ${stringify$2(logs[0])}.` : ".";
        reason = "assert_ne";
        errorMessage = `The transaction reverted because of an "assert_ne" statement${sufix}`;
        break;
      }
      case FAILED_ASSERT_SIGNAL:
        reason = "assert";
        errorMessage = `The transaction reverted because an "assert" statement failed to evaluate to true.`;
        break;
      case FAILED_TRANSFER_TO_ADDRESS_SIGNAL:
        reason = "MissingOutputChange";
        errorMessage = `The transaction reverted because it's missing an "OutputChange".`;
        break;
      default:
        throw new FuelError(
          ErrorCode$1.UNKNOWN,
          `The transaction reverted with an unknown reason: ${revertReceipt.val}`,
          {
            ...metadata,
            reason: "unknown"
          }
        );
    }
  }
  return new FuelError(ErrorCode$1.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason
  });
};
var extractTxError = (params) => {
  const { receipts, statusReason, logs } = params;
  const isPanic = receipts.some(({ type: type3 }) => type3 === ReceiptType.Panic);
  const isRevert = receipts.some(({ type: type3 }) => type3 === ReceiptType.Revert);
  const metadata = {
    logs,
    receipts,
    panic: isPanic,
    revert: isRevert,
    reason: ""
  };
  if (isPanic) {
    return assemblePanicError(statusReason, metadata);
  }
  return assembleRevertError(receipts, logs, metadata);
};
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    __publicField(this, "name", "NoWitnessAtIndexError");
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
};
var isRequestInputCoin = (input) => input.type === InputType.Coin;
var isRequestInputMessage = (input) => input.type === InputType.Message;
var isRequestInputResource = (input) => isRequestInputCoin(input) || isRequestInputMessage(input);
var getRequestInputResourceOwner = (input) => isRequestInputCoin(input) ? input.owner : input.recipient;
var isRequestInputResourceFromOwner = (input, owner) => getRequestInputResourceOwner(input) === owner.toB256();
var getAssetAmountInRequestInputs = (inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource).reduce((acc, input) => {
  if (isRequestInputCoin(input) && input.assetId === assetId) {
    return acc.add(input.amount);
  }
  if (isRequestInputMessage(input) && assetId === baseAsset) {
    return acc.add(input.amount);
  }
  return acc;
}, bn$1(0));
var cacheRequestInputsResourcesFromOwner = (inputs, owner) => inputs.reduce(
  (acc, input) => {
    if (isRequestInputCoin(input) && input.owner === owner.toB256()) {
      acc.utxos.push(input.id);
    } else if (isRequestInputMessage(input) && input.recipient === owner.toB256()) {
      acc.messages.push(input.nonce);
    }
    return acc;
  },
  {
    utxos: [],
    messages: []
  }
);
var witnessify = (value2) => {
  const data2 = arrayify$1(value2);
  return {
    data: hexlify(data2),
    dataLength: data2.length
  };
};
var BaseTransactionRequest = class {
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    tip,
    maturity,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses
  } = {}) {
    /** Gas price for transaction */
    __publicField(this, "tip");
    /** Block until which tx cannot be included */
    __publicField(this, "maturity");
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    __publicField(this, "maxFee");
    /** The maximum amount of witness data allowed for the transaction */
    __publicField(this, "witnessLimit");
    /** List of inputs */
    __publicField(this, "inputs", []);
    /** List of outputs */
    __publicField(this, "outputs", []);
    /** List of witnesses */
    __publicField(this, "witnesses", []);
    this.tip = tip ? bn$1(tip) : void 0;
    this.maturity = maturity && maturity > 0 ? maturity : void 0;
    this.witnessLimit = isDefined(witnessLimit) ? bn$1(witnessLimit) : void 0;
    this.maxFee = bn$1(maxFee);
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    const { tip, witnessLimit, maturity } = req;
    if (bn$1(tip).gt(0)) {
      policyTypes += PolicyType.Tip;
      policies.push({ data: bn$1(tip), type: PolicyType.Tip });
    }
    if (isDefined(witnessLimit) && bn$1(witnessLimit).gte(0)) {
      policyTypes += PolicyType.WitnessLimit;
      policies.push({ data: bn$1(witnessLimit), type: PolicyType.WitnessLimit });
    }
    if (maturity && maturity > 0) {
      policyTypes += PolicyType.Maturity;
      policies.push({ data: maturity, type: PolicyType.Maturity });
    }
    policyTypes += PolicyType.MaxFee;
    policies.push({ data: req.maxFee, type: PolicyType.MaxFee });
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    var _a2, _b2, _c2;
    const inputs = ((_a2 = this.inputs) == null ? void 0 : _a2.map(inputify)) ?? [];
    const outputs = ((_b2 = this.outputs) == null ? void 0 : _b2.map(outputify)) ?? [];
    const witnesses = ((_c2 = this.witnesses) == null ? void 0 : _c2.map(witnessify)) ?? [];
    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output2) {
    this.outputs.push(output2);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes a witness to the list and returns the index
   *
   * @param signature - The signature to add to the witness.
   * @returns The index of the created witness.
   */
  addWitness(signature) {
    this.witnesses.push(signature);
    return this.witnesses.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   *
   * @returns The index of the created witness.
   */
  addEmptyWitness() {
    this.addWitness(concat([ZeroBytes32, ZeroBytes32]));
    return this.witnesses.length - 1;
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = Address.fromAddressOrString(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Helper function to add an external signature to the transaction.
   *
   * @param account - The account/s to sign to the transaction.
   * @returns The transaction with the signature witness added.
   */
  async addAccountWitnesses(account) {
    const accounts = Array.isArray(account) ? account : [account];
    await Promise.all(
      accounts.map(async (acc) => {
        this.addWitness(await acc.signTransaction(this));
      })
    );
    return this;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output2) => output2.type === OutputType.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output2) => output2.type === OutputType.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = addressify(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case InputType.Coin:
          return hexlify(input.owner) === ownerAddress.toB256();
        case InputType.Message:
          return hexlify(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found == null ? void 0 : found.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   */
  addCoinInput(coin) {
    const { assetId, owner, amount, id: id2, predicate, predicateData } = coin;
    let witnessIndex;
    if (coin.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      id: id2,
      type: InputType.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * asset against the message
   *
   * @param message - Message resource.
   */
  addMessageInput(message) {
    const { recipient, sender, amount, predicate, nonce, assetId, predicateData } = message;
    let witnessIndex;
    if (message.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      nonce,
      type: InputType.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      amount,
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(recipient, assetId);
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to2, amount, assetId) {
    this.pushOutput({
      type: OutputType.Coin,
      to: addressify(to2).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to2, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to2).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to2, assetId) {
    const changeOutput = this.getChangeOutputs().find(
      (output2) => hexlify(output2.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: OutputType.Change,
        to: addressify(to2).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new Error("Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { consensusParameters } = chainInfo;
    const {
      gasCosts,
      feeParameters: { gasPerByte }
    } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      maxGasPerTx
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   * @param baseAssetId - The base asset to fund the transaction.
   */
  fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {
    const findAssetInput = (assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      let usedQuantity = quantity;
      if (assetId === baseAssetId) {
        usedQuantity = bn$1("1000000000000000000");
      }
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = hexlify(randomBytes2(UTXO_ID_LEN));
        assetInput.amount = usedQuantity;
      } else {
        this.addResources([
          {
            id: hexlify(randomBytes2(UTXO_ID_LEN)),
            amount: usedQuantity,
            assetId,
            owner: resourcesOwner || Address.fromRandom(),
            blockCreated: bn$1(1),
            txCreatedIdx: bn$1(1)
          }
        ]);
      }
    };
    updateAssetInput(baseAssetId, bn$1(1e11));
    quantities.forEach((q3) => updateAssetInput(q3.assetId, q3.amount));
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: bn$1(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  removeWitness(index) {
    this.witnesses.splice(index, 1);
    this.adjustWitnessIndexes(index);
  }
  adjustWitnessIndexes(removedIndex) {
    this.inputs.filter(isRequestInputResource).forEach((input) => {
      if (input.witnessIndex > removedIndex) {
        input.witnessIndex -= 1;
      }
    });
  }
  updatePredicateGasUsed(inputs) {
    const inputsToExtractGasUsed = inputs.filter(isRequestInputResource);
    this.inputs.filter(isRequestInputResource).forEach((i2) => {
      const owner = getRequestInputResourceOwner(i2);
      const correspondingInput = inputsToExtractGasUsed.find(
        (x2) => isRequestInputResourceFromOwner(x2, Address.fromString(String(owner)))
      );
      if (correspondingInput && "predicateGasUsed" in correspondingInput && bn$1(correspondingInput.predicateGasUsed).gt(0)) {
        i2.predicateGasUsed = correspondingInput.predicateGasUsed;
      }
    });
  }
};
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === TransactionType.Script) {
    transaction.receiptsRoot = ZeroBytes32;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = clone$1(input);
    switch (inputClone.type) {
      case InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = bn$1(0);
        return inputClone;
      }
      case InputType.Message: {
        inputClone.predicateGasUsed = bn$1(0);
        return inputClone;
      }
      case InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = ZeroBytes32;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = ZeroBytes32;
        inputClone.stateRoot = ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output2) => {
    const outputClone = clone$1(output2);
    switch (outputClone.type) {
      case OutputType.Contract: {
        outputClone.balanceRoot = ZeroBytes32;
        outputClone.stateRoot = ZeroBytes32;
        return outputClone;
      }
      case OutputType.Change: {
        outputClone.amount = bn$1(0);
        return outputClone;
      }
      case OutputType.Variable: {
        outputClone.to = ZeroBytes32;
        outputClone.amount = bn$1(0);
        outputClone.assetId = ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = uint64ToBytesBE(chainId);
  const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
  return sha256$2(concatenatedData);
}
var getStorageValue = (value2) => {
  const v2 = new Uint8Array(32);
  v2.set(arrayify$1(value2));
  return v2;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value2;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value2 = storageSlot[1];
  } else {
    key = storageSlot.key;
    value2 = storageSlot.value;
  }
  return {
    key: hexlify(key),
    value: hexlify(getStorageValue(value2))
  };
};
var CreateTransactionRequest = class extends BaseTransactionRequest {
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }) {
    super(rest);
    /** Type of the transaction */
    __publicField(this, "type", TransactionType.Create);
    /** Witness index of contract bytecode to create */
    __publicField(this, "bytecodeWitnessIndex");
    /** Salt */
    __publicField(this, "salt");
    /** List of storage slots to initialize */
    __publicField(this, "storageSlots");
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = hexlify(salt ?? ZeroBytes32);
    this.storageSlots = [...storageSlots ?? []];
  }
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    var _a2;
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = ((_a2 = this.storageSlots) == null ? void 0 : _a2.map(storageSlotify)) ?? [];
    return {
      type: TransactionType.Create,
      ...baseTransaction,
      bytecodeWitnessIndex,
      storageSlotsCount: bn$1(storageSlots.length),
      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output2) => output2.type === OutputType.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId2, stateRoot) {
    this.pushOutput({
      type: OutputType.ContractCreated,
      contractId: contractId2,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: bn$1(arrayify$1(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify$1("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify$1("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    /** Type of the transaction */
    __publicField(this, "type", TransactionType.Script);
    /** Gas limit for transaction */
    __publicField(this, "gasLimit");
    /** Script to execute */
    __publicField(this, "script");
    /** Script input data (parameters) */
    __publicField(this, "scriptData");
    __publicField(this, "abis");
    this.gasLimit = bn$1(gasLimit);
    this.script = arrayify$1(script ?? returnZeroScript.bytes);
    this.scriptData = arrayify$1(scriptData ?? returnZeroScript.encodeScriptData());
    this.abis = rest.abis;
  }
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = arrayify$1(this.script ?? "0x");
    const scriptData = arrayify$1(this.scriptData ?? "0x");
    return {
      type: TransactionType.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: bn$1(script.length),
      scriptDataLength: bn$1(scriptData.length),
      receiptsRoot: ZeroBytes32,
      script: hexlify(script),
      scriptData: hexlify(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output2) => output2.type === OutputType.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output2) => output2.type === OutputType.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data2) {
    this.scriptData = script.encodeScriptData(data2);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: OutputType.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  /**
   * Calculates the maximum gas for the transaction.
   *
   * @param chainInfo - The chain information.
   * @param minGas - The minimum gas.
   * @returns the maximum gas.
   */
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit,
      maxGasPerTx
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = addressify(contract);
    if (this.getContractInputs().find((i2) => i2.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: InputType.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: OutputType.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
    return obj;
  }
  const { type: type3 } = obj;
  switch (obj.type) {
    case TransactionType.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case TransactionType.Create: {
      return CreateTransactionRequest.from(obj);
    }
    default: {
      throw new FuelError(
        ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${type3}.`
      );
    }
  }
};
var calculateTXFeeForSummary = (params) => {
  var _a2;
  const {
    gasPrice,
    rawPayload,
    tip,
    totalFee,
    consensusParameters: { gasCosts, feeParams, maxGasPerTx }
  } = params;
  if (totalFee) {
    return totalFee;
  }
  const gasPerByte = bn$1(feeParams.gasPerByte);
  const gasPriceFactor = bn$1(feeParams.gasPriceFactor);
  const transactionBytes = arrayify$1(rawPayload);
  const [transaction] = new TransactionCoder().decode(transactionBytes, 0);
  const { type: type3, witnesses, inputs, policies } = transaction;
  let metadataGas = bn$1(0);
  let gasLimit = bn$1(0);
  if (type3 !== TransactionType.Create && type3 !== TransactionType.Script) {
    return bn$1(0);
  }
  if (type3 === TransactionType.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = bn$1(arrayify$1(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: bn$1(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const witnessLimit = (_a2 = policies.find((policy) => policy.type === PolicyType.WitnessLimit)) == null ? void 0 : _a2.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit,
    maxGasPerTx
  });
  const maxFee = calculateGasFee({
    gasPrice,
    gas: maxGas,
    priceFactor: gasPriceFactor,
    tip
  });
  return maxFee;
};
var getFunctionCall = ({ abi, receipt }) => {
  var _a2;
  const abiInterface = new Interface(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  const encodedArgs = receipt.param2.toHex();
  let argumentsProvided;
  const data2 = functionFragment.decodeArguments(encodedArgs);
  if (data2) {
    argumentsProvided = inputs.reduce((prev2, input, index) => {
      const value2 = data2[index];
      const name = input.name;
      if (name) {
        return {
          ...prev2,
          // reparse to remove bn
          [name]: JSON.parse(JSON.stringify(value2))
        };
      }
      return prev2;
    }, {});
  }
  const call2 = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...((_a2 = receipt.amount) == null ? void 0 : _a2.isZero()) ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call2;
};
function getInputsByTypes(inputs, types2) {
  return inputs.filter((i2) => types2.includes(i2.type));
}
function getInputsByType(inputs, type3) {
  return inputs.filter((i2) => i2.type === type3);
}
function getInputsCoin(inputs) {
  return getInputsByType(inputs, InputType.Coin);
}
function getInputsMessage(inputs) {
  return getInputsByType(inputs, InputType.Message);
}
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [InputType.Coin, InputType.Message]);
}
function getInputsContract(inputs) {
  return getInputsByType(inputs, InputType.Contract);
}
function getInputFromAssetId(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  const messageInputs = getInputsMessage(inputs);
  const coinInput = coinInputs.find((i2) => i2.assetId === assetId);
  const messageInput = messageInputs.find(
    (_2) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
  );
  return coinInput || messageInput;
}
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs == null ? void 0 : inputs[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== InputType.Contract) {
    throw new FuelError(
      ErrorCode$1.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
function getInputAccountAddress(input) {
  if (input.type === InputType.Coin) {
    return input.owner.toString();
  }
  if (input.type === InputType.Message) {
    return input.recipient.toString();
  }
  return "";
}
function getOutputsByType(outputs, type3) {
  return outputs.filter((o2) => o2.type === type3);
}
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, OutputType.ContractCreated);
}
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, OutputType.Coin);
}
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, OutputType.Change);
}
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, OutputType.Contract);
}
function getReceiptsByType(receipts, type3) {
  return (receipts ?? []).filter((r2) => r2.type === type3);
}
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case TransactionType.Mint:
      return "Mint";
    case TransactionType.Create:
      return "Create";
    case TransactionType.Script:
      return "Script";
    default:
      throw new FuelError(
        ErrorCode$1.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${transactionType}.`
      );
  }
}
function isType(transactionType, type3) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type3;
}
function isTypeMint(transactionType) {
  return isType(
    transactionType,
    "Mint"
    /* Mint */
  );
}
function isTypeCreate(transactionType) {
  return isType(
    transactionType,
    "Create"
    /* Create */
  );
}
function isTypeScript(transactionType) {
  return isType(
    transactionType,
    "Script"
    /* Script */
  );
}
function isTypeUpgrade(transactionType) {
  return isType(
    transactionType,
    "Upgrade"
    /* Upgrade */
  );
}
function isTypeUpload(transactionType) {
  return isType(
    transactionType,
    "Upload"
    /* Upload */
  );
}
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, ReceiptType.Call);
}
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, ReceiptType.MessageOut);
}
var mergeAssets = (op1, op2) => {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const filteredAssets = assets2.filter(
    (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
  );
  const mergedAssets = assets1.map((asset1) => {
    const matchingAsset = assets2.find((asset2) => asset2.assetId === asset1.assetId);
    if (!matchingAsset) {
      return asset1;
    }
    const mergedAmount = bn$1(asset1.amount).add(matchingAsset.amount);
    return { ...asset1, amount: mergedAmount };
  });
  return mergedAssets.concat(filteredAssets);
};
function isSameOperation(a2, b2) {
  var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
  return a2.name === b2.name && ((_a2 = a2.from) == null ? void 0 : _a2.address) === ((_b2 = b2.from) == null ? void 0 : _b2.address) && ((_c2 = a2.to) == null ? void 0 : _c2.address) === ((_d2 = b2.to) == null ? void 0 : _d2.address) && ((_e3 = a2.from) == null ? void 0 : _e3.type) === ((_f2 = b2.from) == null ? void 0 : _f2.type) && ((_g2 = a2.to) == null ? void 0 : _g2.type) === ((_h2 = b2.to) == null ? void 0 : _h2.type);
}
function addOperation(operations, toAdd) {
  var _a2, _b2, _c2;
  const allOperations = [...operations];
  const index = allOperations.findIndex((op) => isSameOperation(op, toAdd));
  if (allOperations[index]) {
    const existentOperation = { ...allOperations[index] };
    if ((_a2 = toAdd.assetsSent) == null ? void 0 : _a2.length) {
      existentOperation.assetsSent = ((_b2 = existentOperation.assetsSent) == null ? void 0 : _b2.length) ? mergeAssets(existentOperation, toAdd) : toAdd.assetsSent;
    }
    if ((_c2 = toAdd.calls) == null ? void 0 : _c2.length) {
      existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
    }
    allOperations[index] = existentOperation;
  } else {
    allOperations.push(toAdd);
  }
  return allOperations;
}
function getWithdrawFromFuelOperations({
  inputs,
  receipts,
  baseAssetId
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const input = getInputFromAssetId(inputs, baseAssetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel",
          from: {
            type: 1,
            address: inputAddress
          },
          to: {
            type: 1,
            address: receipt.recipient.toString(),
            chain: "ethereum"
            /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId: baseAssetId
            }
          ]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output2) => {
    const contractInput = getInputContractFromIndex(inputs, output2.inputIndex);
    if (contractInput) {
      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
        var _a2;
        if (receipt.to === contractInput.contractID) {
          const input = getInputFromAssetId(inputs, receipt.assetId);
          if (input) {
            const inputAddress = getInputAccountAddress(input);
            const calls = [];
            const abi = abiMap == null ? void 0 : abiMap[contractInput.contractID];
            if (abi) {
              calls.push(
                getFunctionCall({
                  abi,
                  receipt,
                  rawPayload,
                  maxInputs
                })
              );
            }
            const newContractCallOps = addOperation(prevContractCallOps, {
              name: "Contract call",
              from: {
                type: 1,
                address: inputAddress
              },
              to: {
                type: 0,
                address: receipt.to
              },
              // if no amount is forwarded to the contract, skip showing assetsSent
              assetsSent: ((_a2 = receipt.amount) == null ? void 0 : _a2.isZero()) ? void 0 : [
                {
                  amount: receipt.amount,
                  assetId: receipt.assetId
                }
              ],
              calls
            });
            return newContractCallOps;
          }
        }
        return prevContractCallOps;
      }, prevOutputCallOps);
      return newCallOps;
    }
    return prevOutputCallOps;
  }, []);
  return contractCallOperations;
}
function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
  const { to: toAddress, assetId, amount } = receipt;
  let { from: fromAddress } = receipt;
  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 : 1;
  if (ZeroBytes32 === fromAddress) {
    const change = changeOutputs.find((output2) => output2.assetId === assetId);
    fromAddress = (change == null ? void 0 : change.to) || fromAddress;
  }
  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 : 1;
  return {
    name: "Transfer asset",
    from: {
      type: fromType,
      address: fromAddress
    },
    to: {
      type: toType,
      address: toAddress
    },
    assetsSent: [
      {
        assetId: assetId.toString(),
        amount
      }
    ]
  };
}
function getTransferOperations({
  inputs,
  outputs,
  receipts
}) {
  let operations = [];
  const coinOutputs = getOutputsCoin(outputs);
  const contractInputs = getInputsContract(inputs);
  const changeOutputs = getOutputsChange(outputs);
  coinOutputs.forEach((output2) => {
    const { amount, assetId, to: to2 } = output2;
    const changeOutput = changeOutputs.find((change) => change.assetId === assetId);
    if (changeOutput) {
      operations = addOperation(operations, {
        name: "Transfer asset",
        from: {
          type: 1,
          address: changeOutput.to
        },
        to: {
          type: 1,
          address: to2
        },
        assetsSent: [
          {
            assetId,
            amount
          }
        ]
      });
    }
  });
  const transferReceipts = getReceiptsByType(
    receipts,
    ReceiptType.Transfer
  );
  const transferOutReceipts = getReceiptsByType(
    receipts,
    ReceiptType.TransferOut
  );
  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
    operations = addOperation(operations, operation);
  });
  return operations;
}
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev2, output2) => {
    const operations = addOperation(prev2, {
      name: "Pay network fee to block producer",
      from: {
        type: 1,
        address: "Network"
      },
      to: {
        type: 1,
        address: output2.to.toString()
      },
      assetsSent: [
        {
          assetId: output2.assetId.toString(),
          amount: output2.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev2, contractCreatedOutput) => {
    const operations = addOperation(prev2, {
      name: "Contract created",
      from: {
        type: 1,
        address: fromAddress
      },
      to: {
        type: 0,
        address: (contractCreatedOutput == null ? void 0 : contractCreatedOutput.contractId) || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs,
  baseAssetId
}) {
  if (isTypeCreate(transactionType)) {
    return [
      ...getContractCreatedOperations({ inputs, outputs }),
      ...getTransferOperations({ inputs, outputs, receipts })
    ];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs
      }),
      ...getWithdrawFromFuelOperations({ inputs, receipts, baseAssetId })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}
var processGqlReceipt = (gqlReceipt) => {
  const receipt = assembleReceiptByType(gqlReceipt);
  switch (receipt.type) {
    case ReceiptType.ReturnData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    case ReceiptType.LogData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    default:
      return receipt;
  }
};
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure";
    case "SuccessStatus":
      return "success";
    case "SubmittedStatus":
      return "submitted";
    case "SqueezedOutStatus":
      return "squeezedout";
    default:
      throw new FuelError(
        ErrorCode$1.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let totalFee;
  let totalGas;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus == null ? void 0 : gqlTransactionStatus.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusSuccess = true;
        totalFee = bn$1(gqlTransactionStatus.totalFee);
        totalGas = bn$1(gqlTransactionStatus.totalGas);
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusFailure = true;
        totalFee = bn$1(gqlTransactionStatus.totalFee);
        totalGas = bn$1(gqlTransactionStatus.totalGas);
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    totalFee,
    totalGas,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};
function assembleTransactionSummary(params) {
  var _a2, _b2;
  const {
    id: id2,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts,
    maxGasPerTx,
    gasPrice,
    baseAssetId
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = hexlify(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs,
    baseAssetId
  });
  const typeName = getTransactionTypeName(transaction.type);
  const tip = bn$1((_b2 = (_a2 = transaction.policies) == null ? void 0 : _a2.find((policy) => policy.type === PolicyType.Tip)) == null ? void 0 : _b2.data);
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus(gqlTransactionStatus);
  const fee = calculateTXFeeForSummary({
    totalFee,
    gasPrice,
    rawPayload,
    tip,
    consensusParameters: {
      gasCosts,
      maxGasPerTx,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = DateTime.fromTai64(time);
  }
  const transactionSummary = {
    id: id2,
    tip,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isTypeUpgrade: isTypeUpgrade(transaction.type),
    isTypeUpload: isTypeUpload(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}
function getDecodedLogs(receipts, mainAbi, externalAbis = {}) {
  return receipts.reduce((logs, receipt) => {
    if (receipt.type === ReceiptType.LogData || receipt.type === ReceiptType.Log) {
      const interfaceToUse = new Interface(externalAbis[receipt.id] || mainAbi);
      const data2 = receipt.type === ReceiptType.Log ? new BigNumberCoder("u64").encode(receipt.val0) : receipt.data;
      const [decodedLog] = interfaceToUse.decodeLog(data2, receipt.val1.toString());
      logs.push(decodedLog);
    }
    return logs;
  }, []);
}
var TransactionResponse = class {
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  constructor(id2, provider, abis) {
    /** Transaction ID */
    __publicField(this, "id");
    /** Current provider */
    __publicField(this, "provider");
    /** Gas used on the transaction */
    __publicField(this, "gasUsed", bn$1(0));
    /** The graphql Transaction with receipts object. */
    __publicField(this, "gqlTransaction");
    __publicField(this, "abis");
    this.id = id2;
    this.provider = provider;
    this.abis = abis;
  }
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id2, provider, abis) {
    const response = new TransactionResponse(id2, provider, abis);
    await response.fetch();
    return response;
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Decode the raw payload of the transaction.
   *
   * @param transactionWithReceipts - The transaction with receipts object.
   * @returns The decoded transaction.
   */
  decodeTransaction(transactionWithReceipts) {
    var _a2;
    return (_a2 = new TransactionCoder().decode(
      arrayify$1(transactionWithReceipts.rawPayload),
      0
    )) == null ? void 0 : _a2[0];
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    let transaction = this.gqlTransaction;
    if (!transaction) {
      transaction = await this.fetch();
    }
    const decodedTransaction = this.decodeTransaction(
      transaction
    );
    let txReceipts = [];
    if ((transaction == null ? void 0 : transaction.status) && "receipts" in transaction.status) {
      txReceipts = transaction.status.receipts;
    }
    const receipts = txReceipts.map(processGqlReceipt) || [];
    const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = this.provider.getGasConfig();
    const gasPrice = await this.provider.getLatestGasPrice();
    const maxInputs = this.provider.getChain().consensusParameters.txParameters.maxInputs;
    const baseAssetId = this.provider.getBaseAssetId();
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: arrayify$1(transaction.rawPayload),
      gqlTransactionStatus: transaction.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    });
    return transactionSummary;
  }
  async waitForStatusChange() {
    var _a2, _b2;
    const status = (_b2 = (_a2 = this.gqlTransaction) == null ? void 0 : _a2.status) == null ? void 0 : _b2.type;
    if (status && status !== "SubmittedStatus") {
      return;
    }
    const subscription = this.provider.operations.statusChange({
      transactionId: this.id
    });
    for await (const { statusChange } of subscription) {
      if (statusChange.type === "SqueezedOutStatus") {
        throw new FuelError(
          ErrorCode$1.TRANSACTION_SQUEEZED_OUT,
          `Transaction Squeezed Out with reason: ${statusChange.reason}`
        );
      }
      if (statusChange.type !== "SubmittedStatus") {
        break;
      }
    }
    await this.fetch();
  }
  /**
   * Assembles the result of a transaction by retrieving the transaction summary,
   * decoding logs (if available), and handling transaction failure.
   *
   * This method can be used to obtain the result of a transaction that has just
   * been submitted or one that has already been processed.
   *
   * @template TTransactionType - The type of the transaction.
   * @param contractsAbiMap - The map of contract ABIs.
   * @returns - The assembled transaction result.
   * @throws If the transaction status is a failure.
   */
  async assembleResult(contractsAbiMap) {
    var _a2;
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      gqlTransaction: this.gqlTransaction,
      ...transactionSummary
    };
    let logs = [];
    if (this.abis) {
      logs = getDecodedLogs(
        transactionSummary.receipts,
        this.abis.main,
        this.abis.otherContractsAbis
      );
      transactionResult.logs = logs;
    }
    const { gqlTransaction, receipts } = transactionResult;
    if (((_a2 = gqlTransaction.status) == null ? void 0 : _a2.type) === "FailureStatus") {
      const { reason } = gqlTransaction.status;
      throw extractTxError({
        receipts,
        statusReason: reason,
        logs
      });
    }
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForStatusChange();
    return this.assembleResult(contractsAbiMap);
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    return this.waitForResult(contractsAbiMap);
  }
};
function getWaitDelay(options, retryAttemptNum) {
  const duration2 = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration2 * retryAttemptNum;
    case "fixed":
      return duration2;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration2;
  }
}
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    var _a2;
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (((_a2 = error.cause) == null ? void 0 : _a2.code) !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await sleep(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}
var MAX_RETRIES = 10;
var RESOURCES_PAGE_SIZE_LIMIT = 512;
var BLOCKS_PAGE_SIZE_LIMIT = 5;
var DEFAULT_UTXOS_CACHE_TTL = 2e4;
var processGqlChain = (chain) => {
  const { name, daHeight, consensusParameters, latestBlock } = chain;
  const {
    contractParams,
    feeParams,
    predicateParams,
    scriptParams,
    txParams,
    gasCosts,
    baseAssetId,
    chainId,
    version: version2
  } = consensusParameters;
  return {
    name,
    baseChainHeight: bn$1(daHeight),
    consensusParameters: {
      version: version2,
      chainId: bn$1(chainId),
      baseAssetId,
      feeParameters: {
        version: feeParams.version,
        gasPerByte: bn$1(feeParams.gasPerByte),
        gasPriceFactor: bn$1(feeParams.gasPriceFactor)
      },
      contractParameters: {
        version: contractParams.version,
        contractMaxSize: bn$1(contractParams.contractMaxSize),
        maxStorageSlots: bn$1(contractParams.maxStorageSlots)
      },
      txParameters: {
        version: txParams.version,
        maxInputs: bn$1(txParams.maxInputs),
        maxOutputs: bn$1(txParams.maxOutputs),
        maxWitnesses: bn$1(txParams.maxWitnesses),
        maxGasPerTx: bn$1(txParams.maxGasPerTx),
        maxSize: bn$1(txParams.maxSize),
        maxBytecodeSubsections: bn$1(txParams.maxBytecodeSubsections)
      },
      predicateParameters: {
        version: predicateParams.version,
        maxPredicateLength: bn$1(predicateParams.maxPredicateLength),
        maxPredicateDataLength: bn$1(predicateParams.maxPredicateDataLength),
        maxGasPerPredicate: bn$1(predicateParams.maxGasPerPredicate),
        maxMessageDataLength: bn$1(predicateParams.maxMessageDataLength)
      },
      scriptParameters: {
        version: scriptParams.version,
        maxScriptLength: bn$1(scriptParams.maxScriptLength),
        maxScriptDataLength: bn$1(scriptParams.maxScriptDataLength)
      },
      gasCosts
    },
    latestBlock: {
      id: latestBlock.id,
      height: bn$1(latestBlock.height),
      time: latestBlock.header.time,
      transactions: latestBlock.transactions.map((i2) => ({
        id: i2.id
      }))
    }
  };
};
var _cacheInputs, cacheInputs_fn;
var _Provider = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url2, options = {}) {
    this.url = url2;
    __privateAdd2(this, _cacheInputs);
    __publicField2(this, "operations");
    __publicField2(this, "cache");
    __publicField2(this, "options", {
      timeout: void 0,
      cacheUtxo: void 0,
      fetch: void 0,
      retryOptions: void 0
    });
    this.options = { ...this.options, ...options };
    this.url = url2;
    this.operations = this.createOperations();
    const { cacheUtxo } = this.options;
    if (isDefined(cacheUtxo)) {
      if (cacheUtxo !== -1) {
        this.cache = new MemoryCache(cacheUtxo);
      } else {
        this.cache = void 0;
      }
    } else {
      this.cache = new MemoryCache(DEFAULT_UTXOS_CACHE_TTL);
    }
  }
  /** @hidden */
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  /**
   * @hidden
   */
  static getFetchFn(options) {
    const { retryOptions, timeout } = options;
    return autoRetryFetch(async (...args) => {
      const url2 = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      let fullRequest = { ...request, signal };
      if (options.requestMiddleware) {
        fullRequest = await options.requestMiddleware(fullRequest);
      }
      return options.fetch ? options.fetch(url2, fullRequest, options) : fetch(url2, fullRequest);
    }, retryOptions);
  }
  /**
   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   *
   * @returns A promise that resolves to a Provider instance.
   */
  static async create(url2, options = {}) {
    const provider = new _Provider(url2, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  /**
   * Returns the cached chainInfo for the current URL.
   *
   * @returns the chain information configuration.
   */
  getChain() {
    const chain = _Provider.chainInfoCache[this.url];
    if (!chain) {
      throw new FuelError(
        ErrorCode$1.CHAIN_INFO_CACHE_EMPTY,
        "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return chain;
  }
  /**
   * Returns the cached nodeInfo for the current URL.
   *
   * @returns the node information configuration.
   */
  getNode() {
    const node2 = _Provider.nodeInfoCache[this.url];
    if (!node2) {
      throw new FuelError(
        ErrorCode$1.NODE_INFO_CACHE_EMPTY,
        "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return node2;
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  getGasConfig() {
    const {
      txParameters: { maxGasPerTx },
      predicateParameters: { maxGasPerPredicate },
      feeParameters: { gasPriceFactor, gasPerByte },
      gasCosts
    } = this.getChain().consensusParameters;
    return {
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   *
   * @param url - The URL to connect to.
   * @param options - Additional options for the provider.
   */
  async connect(url2, options) {
    this.url = url2;
    this.options = options ?? this.options;
    this.operations = this.createOperations();
    await this.fetchChainAndNodeInfo();
  }
  /**
   * Return the chain and node information.
   *
   * @returns A promise that resolves to the Chain and NodeInfo.
   */
  async fetchChainAndNodeInfo() {
    const chain = await this.fetchChain();
    const nodeInfo = await this.fetchNode();
    _Provider.ensureClientVersionIsSupported(nodeInfo);
    return {
      chain,
      nodeInfo
    };
  }
  /**
   * @hidden
   */
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      console.warn(
        `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion},
which is not supported by the version of the TS SDK that you are using.
Things may not work as expected.
Supported fuel-core version: ${supportedVersion}.`
      );
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   * @hidden
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new distExports.GraphQLClient(this.url, {
      fetch: (url2, requestInit) => fetchFn(url2, requestInit, this.options),
      responseMiddleware: (response) => {
        if ("response" in response) {
          const graphQlResponse = response.response;
          if (Array.isArray(graphQlResponse == null ? void 0 : graphQlResponse.errors)) {
            throw new FuelError(
              FuelError.CODES.INVALID_REQUEST,
              graphQlResponse.errors.map((err) => err.message).join("\n\n")
            );
          }
        }
      }
    });
    const executeQuery = (query, vars) => {
      const opDefinition = query.definitions.find((x2) => x2.kind === "OperationDefinition");
      const isSubscription = (opDefinition == null ? void 0 : opDefinition.operation) === "subscription";
      if (isSubscription) {
        return new FuelGraphqlSubscriber({
          url: this.url,
          query,
          fetchFn: (url2, requestInit) => fetchFn(url2, requestInit, this.options),
          variables: vars
        });
      }
      return gqlClient.request(query, vars);
    };
    return getSdk(executeQuery);
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * Returns the latest block number.
   *
   * @returns A promise that resolves to the latest block number.
   */
  async getBlockNumber() {
    const { chain } = await this.operations.getChain();
    return bn$1(chain.latestBlock.height, 10);
  }
  /**
   * Returns the node information for the current provider network.
   *
   * @returns a promise that resolves to the node information.
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: bn$1(nodeInfo.maxDepth),
      maxTx: bn$1(nodeInfo.maxTx),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace
    };
    _Provider.nodeInfoCache[this.url] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Returns the chain information for the current provider network.
   *
   * @returns a promise that resolves to the chain information.
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.url] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID for the current provider network.
   *
   * @returns A promise that resolves to the chain ID number.
   */
  getChainId() {
    const {
      consensusParameters: { chainId }
    } = this.getChain();
    return chainId.toNumber();
  }
  /**
   * Returns the base asset ID for the current provider network.
   *
   * @returns the base asset ID.
   */
  getBaseAssetId() {
    const {
      consensusParameters: { baseAssetId }
    } = this.getChain();
    return baseAssetId;
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response object.
   */
  // #region Provider-sendTransaction
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    let abis;
    if (transactionRequest.type === TransactionType.Script) {
      abis = transactionRequest.abis;
    }
    const {
      submit: { id: transactionId }
    } = await this.operations.submit({ encodedTransaction });
    __privateMethod2(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
    return new TransactionResponse(transactionId, this, abis);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider call parameters (optional).
   * @returns A promise that resolves to the call result object.
   */
  async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions: encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;
    const receipts = rawReceipts.map(processGqlReceipt);
    return { receipts, dryRunStatus };
  }
  /**
   * Verifies whether enough gas is available to complete transaction.
   *
   * @template T - The type of the transaction request object.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimated transaction request object.
   */
  async estimatePredicates(transactionRequest) {
    const shouldEstimatePredicates = Boolean(
      transactionRequest.inputs.find(
        (input) => "predicate" in input && input.predicate && !equalBytes$1(arrayify$1(input.predicate), arrayify$1("0x")) && new BN(input.predicateGasUsed).isZero()
      )
    );
    if (!shouldEstimatePredicates) {
      return transactionRequest;
    }
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const {
      estimatePredicates: { inputs }
    } = response;
    if (inputs) {
      inputs.forEach((input, index) => {
        if ("predicateGasUsed" in input && bn$1(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimate transaction dependencies.
   */
  async estimateTxDependencies(transactionRequest) {
    if (transactionRequest.type === TransactionType.Create) {
      return {
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    }
    let receipts = [];
    const missingContractIds = [];
    let outputVariables = 0;
    let dryRunStatus;
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const {
        dryRun: [{ receipts: rawReceipts, status }]
      } = await this.operations.dryRun({
        encodedTransactions: [hexlify(transactionRequest.toTransactionBytes())],
        utxoValidation: false
      });
      receipts = rawReceipts.map(processGqlReceipt);
      dryRunStatus = status;
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
      if (hasMissingOutputs) {
        outputVariables += missingOutputVariables.length;
        transactionRequest.addVariableOutputs(missingOutputVariables.length);
        missingOutputContractIds.forEach(({ contractId: contractId2 }) => {
          transactionRequest.addContractInputAndOutput(Address.fromString(contractId2));
          missingContractIds.push(contractId2);
        });
        const { maxFee } = await this.estimateTxGasAndFee({
          transactionRequest
        });
        transactionRequest.maxFee = maxFee;
      } else {
        break;
      }
    }
    return {
      receipts,
      outputVariables,
      missingContractIds,
      dryRunStatus
    };
  }
  /**
   * Dry runs multiple transactions and checks for missing dependencies in batches.
   *
   * Transactions are dry run in batches. After each dry run, transactions requiring
   * further modifications are identified. The method iteratively updates these transactions
   * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @returns A promise that resolves to an array of results for each transaction.
   */
  async estimateMultipleTxDependencies(transactionRequests) {
    const results = transactionRequests.map(() => ({
      receipts: [],
      outputVariables: 0,
      missingContractIds: [],
      dryRunStatus: void 0
    }));
    const allRequests = clone$1(transactionRequests);
    const serializedTransactionsMap = /* @__PURE__ */ new Map();
    allRequests.forEach((req, index) => {
      if (req.type === TransactionType.Script) {
        serializedTransactionsMap.set(index, hexlify(req.toTransactionBytes()));
      }
    });
    let transactionsToProcess = Array.from(serializedTransactionsMap.keys());
    let attempt = 0;
    while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES) {
      const encodedTransactions = transactionsToProcess.map(
        (index) => serializedTransactionsMap.get(index)
      );
      const dryRunResults = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: false
      });
      const nextRoundTransactions = [];
      for (let i2 = 0; i2 < dryRunResults.dryRun.length; i2++) {
        const requestIdx = transactionsToProcess[i2];
        const { receipts: rawReceipts, status } = dryRunResults.dryRun[i2];
        const result = results[requestIdx];
        result.receipts = rawReceipts.map(processGqlReceipt);
        result.dryRunStatus = status;
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(
          result.receipts
        );
        const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;
        const request = allRequests[requestIdx];
        if (hasMissingOutputs && (request == null ? void 0 : request.type) === TransactionType.Script) {
          result.outputVariables += missingOutputVariables.length;
          request.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId: contractId2 }) => {
            request.addContractInputAndOutput(Address.fromString(contractId2));
            result.missingContractIds.push(contractId2);
          });
          const { maxFee } = await this.estimateTxGasAndFee({
            transactionRequest: request
          });
          request.maxFee = maxFee;
          serializedTransactionsMap.set(requestIdx, hexlify(request.toTransactionBytes()));
          nextRoundTransactions.push(requestIdx);
        }
      }
      transactionsToProcess = nextRoundTransactions;
      attempt += 1;
    }
    return results;
  }
  /**
   * Dry runs multiple transactions.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @param sendTransactionParams - The provider call parameters (optional).
   *
   * @returns A promise that resolves to an array of results for each transaction call.
   */
  async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {
    if (estimateTxDependencies) {
      return this.estimateMultipleTxDependencies(transactionRequests);
    }
    const encodedTransactions = transactionRequests.map((tx) => hexlify(tx.toTransactionBytes()));
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: utxoValidation || false
    });
    const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {
      const receipts = rawReceipts.map(processGqlReceipt);
      return { receipts, dryRunStatus: status };
    });
    return results;
  }
  /**
   * Estimates the transaction gas and fee based on the provided transaction request.
   * @param transactionRequest - The transaction request object.
   * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
   */
  async estimateTxGasAndFee(params) {
    const { transactionRequest } = params;
    let { gasPrice } = params;
    const chainInfo = this.getChain();
    const { gasPriceFactor, maxGasPerTx } = this.getGasConfig();
    const minGas = transactionRequest.calculateMinGas(chainInfo);
    if (!gasPrice) {
      gasPrice = await this.estimateGasPrice(10);
    }
    const minFee = calculateGasFee({
      gasPrice: bn$1(gasPrice),
      gas: minGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    let gasLimit = bn$1(0);
    if (transactionRequest.type === TransactionType.Script) {
      gasLimit = transactionRequest.gasLimit;
      if (transactionRequest.gasLimit.eq(0)) {
        transactionRequest.gasLimit = minGas;
        transactionRequest.gasLimit = maxGasPerTx.sub(
          transactionRequest.calculateMaxGas(chainInfo, minGas)
        );
        gasLimit = transactionRequest.gasLimit;
      }
    }
    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
    const maxFee = calculateGasFee({
      gasPrice: bn$1(gasPrice),
      gas: maxGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    return {
      minGas,
      minFee,
      maxGas,
      maxFee,
      gasPrice,
      gasLimit
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransactions = [hexlify(transactionRequest.toTransactionBytes())];
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: true
    });
    const callResult = dryRunStatuses.map((dryRunStatus) => {
      const { id: id2, receipts, status } = dryRunStatus;
      const processedReceipts = receipts.map(processGqlReceipt);
      return { id: id2, receipts: processedReceipts, status };
    });
    return { receipts: callResult[0].receipts };
  }
  /**
   * @hidden
   *
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback } = {}) {
    const txRequestClone = clone$1(transactionRequestify(transactionRequestLike));
    const isScriptTransaction = txRequestClone.type === TransactionType.Script;
    const updateMaxFee = txRequestClone.maxFee.eq(0);
    if (isScriptTransaction) {
      txRequestClone.gasLimit = bn$1(0);
    }
    const signedRequest = clone$1(txRequestClone);
    let addedSignatures = 0;
    if (signatureCallback && isScriptTransaction) {
      const lengthBefore = signedRequest.witnesses.length;
      await signatureCallback(signedRequest);
      addedSignatures = signedRequest.witnesses.length - lengthBefore;
    }
    await this.estimatePredicates(signedRequest);
    txRequestClone.updatePredicateGasUsed(signedRequest.inputs);
    let { maxFee, maxGas, minFee, minGas, gasPrice, gasLimit } = await this.estimateTxGasAndFee({
      transactionRequest: signedRequest
    });
    let receipts = [];
    let dryRunStatus;
    let missingContractIds = [];
    let outputVariables = 0;
    let gasUsed = bn$1(0);
    txRequestClone.maxFee = maxFee;
    if (isScriptTransaction) {
      txRequestClone.gasLimit = gasLimit;
      if (signatureCallback) {
        await signatureCallback(txRequestClone);
      }
      ({ receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone));
      if (dryRunStatus && "reason" in dryRunStatus) {
        throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus);
      }
      gasUsed = getGasUsedFromReceipts(receipts);
      txRequestClone.gasLimit = gasUsed;
      ({ maxFee, maxGas, minFee, minGas, gasPrice } = await this.estimateTxGasAndFee({
        transactionRequest: txRequestClone,
        gasPrice
      }));
    }
    return {
      receipts,
      gasUsed,
      gasPrice,
      minGas,
      maxGas,
      minFee,
      maxFee,
      outputVariables,
      missingContractIds,
      addedSignatures,
      estimatedPredicates: txRequestClone.inputs,
      dryRunStatus,
      updateMaxFee
    };
  }
  /**
   * Returns coins for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get (optional).
   * @param paginationArgs - Pagination arguments (optional).
   *
   * @returns A promise that resolves to the coins.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = Address.fromAddressOrString(owner);
    const {
      coins: { edges, pageInfo }
    } = await this.operations.getCoins({
      ...this.validatePaginationArgs({
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT,
        inputArgs: paginationArgs
      }),
      filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify(assetId) }
    });
    const coins = edges.map(({ node: node2 }) => ({
      id: node2.utxoId,
      assetId: node2.assetId,
      amount: bn$1(node2.amount),
      owner: Address.fromAddressOrString(node2.owner),
      blockCreated: bn$1(node2.blockCreated),
      txCreatedIdx: bn$1(node2.txCreatedIdx)
    }));
    return {
      coins,
      pageInfo
    };
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The coin quantities to get.
   * @param excludedIds - IDs of excluded resources from the selection (optional).
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, excludedIds) {
    var _a2, _b2, _c2;
    const ownerAddress = Address.fromAddressOrString(owner);
    const excludeInput = {
      messages: ((_a2 = excludedIds == null ? void 0 : excludedIds.messages) == null ? void 0 : _a2.map((nonce) => hexlify(nonce))) || [],
      utxos: ((_b2 = excludedIds == null ? void 0 : excludedIds.utxos) == null ? void 0 : _b2.map((id2) => hexlify(id2))) || []
    };
    if (this.cache) {
      const uniqueUtxos = new Set(
        excludeInput.utxos.concat((_c2 = this.cache) == null ? void 0 : _c2.getActiveData().map((id2) => hexlify(id2)))
      );
      excludeInput.utxos = Array.from(uniqueUtxos);
    }
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: hexlify(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.type) {
        case "MessageCoin":
          return {
            amount: bn$1(coin.amount),
            assetId: coin.assetId,
            daHeight: bn$1(coin.daHeight),
            sender: Address.fromAddressOrString(coin.sender),
            recipient: Address.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: bn$1(coin.amount),
            assetId: coin.assetId,
            owner: Address.fromAddressOrString(coin.owner),
            blockCreated: bn$1(coin.blockCreated),
            txCreatedIdx: bn$1(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v2) => !!v2);
    return coins;
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block or null.
   */
  async getBlock(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { height: bn$1(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { height: (await this.getBlockNumber()).toString(10) };
    } else if (idOrHeight.length === 66) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockId: bn$1(idOrHeight).toString(10) };
    }
    const { block: block2 } = await this.operations.getBlock(variables);
    if (!block2) {
      return null;
    }
    return {
      id: block2.id,
      height: bn$1(block2.height),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const {
      blocks: { edges, pageInfo }
    } = await this.operations.getBlocks({
      ...this.validatePaginationArgs({
        paginationLimit: BLOCKS_PAGE_SIZE_LIMIT,
        inputArgs: params
      })
    });
    const blocks = edges.map(({ node: block2 }) => ({
      id: block2.id,
      height: bn$1(block2.height),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id)
    }));
    return { blocks, pageInfo };
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: bn$1(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
    if (!block2) {
      return null;
    }
    return {
      id: block2.id,
      height: bn$1(block2.height, 10),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id),
      transactions: block2.transactions.map(
        (tx) => {
          var _a2;
          return (_a2 = new TransactionCoder().decode(arrayify$1(tx.rawPayload), 0)) == null ? void 0 : _a2[0];
        }
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    var _a2;
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    return (_a2 = new TransactionCoder().decode(
      arrayify$1(transaction.rawPayload),
      0
    )) == null ? void 0 : _a2[0];
  }
  /**
   * Retrieves transactions based on the provided pagination arguments.
   * @param paginationArgs - The pagination arguments for retrieving transactions.
   * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
   */
  async getTransactions(paginationArgs) {
    const {
      transactions: { edges, pageInfo }
    } = await this.operations.getTransactions(paginationArgs);
    const coder = new TransactionCoder();
    const transactions = edges.map(
      ({ node: { rawPayload } }) => coder.decode(arrayify$1(rawPayload), 0)[0]
    );
    return { transactions, pageInfo };
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId2) {
    const { contract } = await this.operations.getContract({ contractId: contractId2 });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId2, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: Address.fromAddressOrString(contractId2).toB256(),
      asset: hexlify(assetId)
    });
    return bn$1(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: Address.fromAddressOrString(owner).toB256(),
      assetId: hexlify(assetId)
    });
    return bn$1(balance.amount, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner) {
    const {
      balances: { edges }
    } = await this.operations.getBalances({
      /**
       * The query parameters for this method were designed to support pagination,
       * but the current Fuel-Core implementation does not support pagination yet.
       */
      first: 1e4,
      filter: { owner: Address.fromAddressOrString(owner).toB256() }
    });
    const balances = edges.map(({ node: node2 }) => ({
      assetId: node2.assetId,
      amount: bn$1(node2.amount)
    }));
    return { balances };
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const {
      messages: { edges, pageInfo }
    } = await this.operations.getMessages({
      ...this.validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT
      }),
      owner: Address.fromAddressOrString(address).toB256()
    });
    const messages = edges.map(({ node: node2 }) => ({
      messageId: InputMessageCoder.getMessageId({
        sender: node2.sender,
        recipient: node2.recipient,
        nonce: node2.nonce,
        amount: bn$1(node2.amount),
        data: node2.data
      }),
      sender: Address.fromAddressOrString(node2.sender),
      recipient: Address.fromAddressOrString(node2.recipient),
      nonce: node2.nonce,
      amount: bn$1(node2.amount),
      data: InputMessageCoder.decodeData(node2.data),
      daHeight: bn$1(node2.daHeight)
    }));
    return {
      messages,
      pageInfo
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id (optional).
   * @param commitBlockHeight - The commit block height (optional).
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new FuelError(
        ErrorCode$1.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Conver BN into a number string required on the query
        // This should problably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data: data2
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: bn$1(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: bn$1(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: bn$1(messageBlockHeader.daHeight),
        transactionsCount: Number(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: bn$1(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),
        messageOutboxRoot: messageBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),
        eventInboxRoot: messageBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: bn$1(commitBlockHeader.daHeight),
        transactionsCount: Number(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: bn$1(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),
        messageOutboxRoot: commitBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),
        eventInboxRoot: commitBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)
      },
      sender: Address.fromAddressOrString(sender),
      recipient: Address.fromAddressOrString(recipient),
      nonce,
      amount: bn$1(amount),
      data: data2
    };
  }
  /**
   * Get the latest gas price from the node.
   *
   * @returns A promise that resolves to the latest gas price.
   */
  async getLatestGasPrice() {
    const { latestGasPrice } = await this.operations.getLatestGasPrice();
    return bn$1(latestGasPrice.gasPrice);
  }
  /**
   * Returns the estimate gas price for the given block horizon.
   *
   * @param blockHorizon - The block horizon to estimate gas price for.
   * @returns A promise that resolves to the estimated gas price.
   */
  async estimateGasPrice(blockHorizon) {
    const { estimateGasPrice } = await this.operations.estimateGasPrice({
      blockHorizon: String(blockHorizon)
    });
    return bn$1(estimateGasPrice.gasPrice);
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce.
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: bn$1(amount).toString(10),
      startTimestamp: startTime ? DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
    });
    return bn$1(latestBlockHeight);
  }
  /**
   * Get the transaction response for the given transaction ID.
   *
   * @param transactionId - The transaction ID to get the response for.
   * @returns A promise that resolves to the transaction response.
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionResponse(transactionId) {
    return new TransactionResponse(transactionId, this);
  }
  /**
   * Returns Message for given nonce.
   *
   * @param nonce - The nonce of the message to retrieve.
   * @returns A promise that resolves to the Message object or null.
   */
  async getMessageByNonce(nonce) {
    const { message } = await this.operations.getMessageByNonce({ nonce });
    if (!message) {
      return null;
    }
    return message;
  }
  /**
   * Get the relayed transaction for the given transaction ID.
   *
   * @param relayedTransactionId - The relayed transaction ID to get the response for.
   * @returns A promise that resolves to the relayed transaction.
   */
  async getRelayedTransactionStatus(relayedTransactionId) {
    const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({
      relayedTransactionId
    });
    if (!relayedTransactionStatus) {
      return null;
    }
    return relayedTransactionStatus;
  }
  /**
   * @hidden
   */
  validatePaginationArgs(params) {
    const { paginationLimit, inputArgs = {} } = params;
    const { first, last, after, before } = inputArgs;
    if (after && before) {
      throw new FuelError(
        ErrorCode$1.INVALID_INPUT_PARAMETERS,
        'Pagination arguments "after" and "before" cannot be used together'
      );
    }
    if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {
      throw new FuelError(
        ErrorCode$1.INVALID_INPUT_PARAMETERS,
        `Pagination limit for this query cannot exceed ${paginationLimit} items`
      );
    }
    if (first && before) {
      throw new FuelError(
        ErrorCode$1.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "first" with "before" is not supported'
      );
    }
    if (last && after) {
      throw new FuelError(
        ErrorCode$1.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "last" with "after" is not supported'
      );
    }
    if (!first && !last) {
      inputArgs.first = paginationLimit;
    }
    return inputArgs;
  }
  /**
   * @hidden
   */
  extractDryRunError(transactionRequest, receipts, dryRunStatus) {
    const status = dryRunStatus;
    let logs = [];
    if (transactionRequest.abis) {
      logs = getDecodedLogs(
        receipts,
        transactionRequest.abis.main,
        transactionRequest.abis.otherContractsAbis
      );
    }
    return extractTxError({
      logs,
      receipts,
      statusReason: status.reason
    });
  }
};
var Provider = _Provider;
_cacheInputs = /* @__PURE__ */ new WeakSet();
cacheInputs_fn = function(inputs) {
  if (!this.cache) {
    return;
  }
  inputs.forEach((input) => {
    var _a2;
    if (input.type === InputType.Coin) {
      (_a2 = this.cache) == null ? void 0 : _a2.set(input.id);
    }
  });
};
__publicField2(Provider, "chainInfoCache", {});
__publicField2(Provider, "nodeInfoCache", {});
var CHAIN_IDS = {
  eth: {
    sepolia: 11155111,
    foundry: 31337
  },
  fuel: {
    devnet: 0,
    testnet: 0
  }
};
var DELIMITER_PATH = "/";
var trimRegex = /^\/|\/$/g;
var trimPath = (path = "") => path.replace(trimRegex, "");
function urlJoin(baseUrl2, ...paths) {
  const hasBaseUrl = baseUrl2 !== null && baseUrl2 !== void 0;
  const rootPath = (baseUrl2 == null ? void 0 : baseUrl2[0]) === "/" && baseUrl2.length > 1;
  const allPaths = [baseUrl2, ...paths].filter(Boolean).map(trimPath);
  if (rootPath && hasBaseUrl) {
    allPaths.unshift("");
  }
  return allPaths.join(DELIMITER_PATH);
}
function resolveIconPaths(assets2, basePath = "./") {
  return assets2.map((asset) => ({
    ...asset,
    icon: urlJoin(basePath, asset.icon)
  }));
}
var fuelAssetsBaseUrl = "https://cdn.fuel.network/assets/";
var rawAssets = [
  {
    name: "Ethereum",
    symbol: "ETH",
    icon: "eth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.sepolia,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.foundry,
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.devnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.testnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      }
    ]
  }
];
resolveIconPaths(rawAssets, fuelAssetsBaseUrl);
var mergeQuantities = (...coinQuantities) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  coinQuantities.forEach((arr) => arr.forEach(addToMap));
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};
var formatTransferToContractScriptData = (params) => {
  const { assetId, amountToTransfer, hexlifiedContractId } = params;
  const numberCoder = new BigNumberCoder("u64");
  const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...arrayify$1(hexlifiedContractId),
    ...encoded,
    ...arrayify$1(assetId)
  ]);
  return scriptData;
};
var assembleTransferToContractScript = async (params) => {
  const scriptData = formatTransferToContractScriptData(params);
  await initWasm();
  const gtf2 = gtf(16, 0, GTFArgs.ScriptData);
  const addi2 = addi(17, 16, 32);
  const lw2 = lw(18, 17, 0);
  const addi22 = addi(19, 17, 8);
  const tr2 = tr(16, 18, 19);
  const ret2 = ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return { script, scriptData };
};
var MAX_FUNDING_ATTEMPTS = 2;
var Account = class extends AbstractAccount {
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   * @param connector - A FuelConnector instance (optional).
   */
  constructor(address, provider, connector) {
    super();
    /**
     * The address associated with the account.
     */
    __publicField(this, "address");
    /**
     * The provider used to interact with the network.
     */
    __publicField(this, "_provider");
    /**
     * The connector for use with external wallets
     */
    __publicField(this, "_connector");
    this._provider = provider;
    this._connector = connector;
    this.address = Address.fromDynamicInput(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new FuelError(ErrorCode$1.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - Quantities of resources to be obtained.
   * @param excludedIds - IDs of resources to be excluded from the query (optional).
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve (optional).
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId, paginationArgs) {
    return this.provider.getCoins(this.address, assetId, paginationArgs);
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages(paginationArgs) {
    return this.provider.getMessages(this.address, paginationArgs);
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for (optional).
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId) {
    const assetIdToFetch = assetId ?? this.provider.getBaseAssetId();
    const amount = await this.provider.getBalance(this.address, assetIdToFetch);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    return this.provider.getBalances(this.address);
  }
  /**
   * Funds a transaction request by adding the necessary resources.
   *
   * @typeParam T - The type of the TransactionRequest.
   * @param request - The transaction request to fund.
   * @param params - The estimated transaction parameters.
   * @returns A promise that resolves to the funded transaction request.
   */
  async fund(request, params) {
    var _a2;
    const { addedSignatures, estimatedPredicates, requiredQuantities, updateMaxFee } = params;
    const fee = request.maxFee;
    const baseAssetId = this.provider.getBaseAssetId();
    const requiredInBaseAsset = ((_a2 = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)) == null ? void 0 : _a2.amount) || bn$1(0);
    const requiredQuantitiesWithFee = addAmountToCoinQuantities({
      amount: bn$1(fee),
      assetId: baseAssetId,
      coinQuantities: requiredQuantities
    });
    const quantitiesDict = {};
    requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: bn$1(0)
      };
    });
    request.inputs.filter(isRequestInputResource).forEach((input) => {
      const isCoin2 = isRequestInputCoin(input);
      const assetId = isCoin2 ? String(input.assetId) : baseAssetId;
      if (quantitiesDict[assetId]) {
        quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);
      }
    });
    let missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    let needsToBeFunded = missingQuantities.length > 0;
    let fundingAttempts = 0;
    while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS) {
      const resources = await this.getResourcesToSpend(
        missingQuantities,
        cacheRequestInputsResourcesFromOwner(request.inputs, this.address)
      );
      request.addResources(resources);
      request.updatePredicateGasUsed(estimatedPredicates);
      const requestToReestimate2 = clone$1(request);
      if (addedSignatures) {
        Array.from({ length: addedSignatures }).forEach(
          () => requestToReestimate2.addEmptyWitness()
        );
      }
      if (!updateMaxFee) {
        break;
      }
      const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({
        transactionRequest: requestToReestimate2
      });
      const totalBaseAssetOnInputs = getAssetAmountInRequestInputs(
        request.inputs,
        baseAssetId,
        baseAssetId
      );
      const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);
      if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {
        needsToBeFunded = false;
      } else {
        missingQuantities = [
          {
            amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),
            assetId: baseAssetId
          }
        ];
      }
      fundingAttempts += 1;
    }
    request.updatePredicateGasUsed(estimatedPredicates);
    const requestToReestimate = clone$1(request);
    if (addedSignatures) {
      Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());
    }
    if (!updateMaxFee) {
      return request;
    }
    const { maxFee } = await this.provider.estimateTxGasAndFee({
      transactionRequest: requestToReestimate
    });
    request.maxFee = maxFee;
    return request;
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addTransfer(request, { destination, amount, assetId });
    request = await this.estimateAndFundTransaction(request, txParams);
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId, txParams = {}) {
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Transfers multiple amounts of a token to multiple recipients.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @param txParams - Optional transaction parameters.
   * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
   */
  async batchTransfer(transferParams, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addBatchTransfer(request, transferParams);
    request = await this.estimateAndFundTransaction(request, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Adds a transfer to the given transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - The object representing the transfer to be made.
   * @returns The updated transaction request with the added transfer.
   */
  addTransfer(request, transferParams) {
    const { destination, amount, assetId } = transferParams;
    this.validateTransferAmount(amount);
    request.addCoinOutput(
      Address.fromAddressOrString(destination),
      amount,
      assetId ?? this.provider.getBaseAssetId()
    );
    return request;
  }
  /**
   * Adds multiple transfers to a script transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The updated script transaction request.
   */
  addBatchTransfer(request, transferParams) {
    const baseAssetId = this.provider.getBaseAssetId();
    transferParams.forEach(({ destination, amount, assetId }) => {
      this.addTransfer(request, {
        destination,
        amount,
        assetId: assetId ?? baseAssetId
      });
    });
    return request;
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId2, amount, assetId, txParams = {}) {
    if (bn$1(amount).lte(0)) {
      throw new FuelError(
        ErrorCode$1.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
    const contractAddress = Address.fromAddressOrString(contractId2);
    const assetIdToTransfer = assetId ?? this.provider.getBaseAssetId();
    const { script, scriptData } = await assembleTransferToContractScript({
      hexlifiedContractId: contractAddress.toB256(),
      amountToTransfer: bn$1(amount),
      assetId: assetIdToTransfer
    });
    let request = new ScriptTransactionRequest({
      ...txParams,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractAddress);
    const txCost = await this.getTransactionCost(request, {
      quantities: [{ amount: bn$1(amount), assetId: String(assetIdToTransfer) }]
    });
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    await this.fund(request, txCost);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientAddress = Address.fromAddressOrString(recipient);
    const recipientDataArray = arrayify$1(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = arrayify$1(
      "0x".concat(bn$1(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...arrayify$1(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, ...txParams };
    const baseAssetId = this.provider.getBaseAssetId();
    let request = new ScriptTransactionRequest(params);
    const quantities = [{ amount: bn$1(amount), assetId: baseAssetId }];
    const txCost = await this.getTransactionCost(request, { quantities });
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    await this.fund(request, txCost);
    return this.sendTransaction(request);
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [] } = {}) {
    const txRequestClone = clone$1(transactionRequestify(transactionRequestLike));
    const baseAssetId = this.provider.getBaseAssetId();
    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
    const requiredQuantities = mergeQuantities(coinOutputsQuantities, quantities);
    const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: bn$1("100000000000000000") }];
    const resources = this.generateFakeResources(
      mergeQuantities(requiredQuantities, transactionFeeForDryRun)
    );
    txRequestClone.addResources(resources);
    const txCost = await this.provider.getTransactionCost(txRequestClone, {
      signatureCallback
    });
    return {
      ...txCost,
      requiredQuantities
    };
  }
  /**
   * Sign a message from the account via the connector.
   *
   * @param message - the message to sign.
   * @returns a promise that resolves to the signature.
   *
   * @hidden
   */
  async signMessage(message) {
    if (!this._connector) {
      throw new FuelError(ErrorCode$1.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Signs a transaction from the account via the connector..
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature of the transaction.
   */
  async signTransaction(transactionRequestLike) {
    if (!this._connector) {
      throw new FuelError(
        ErrorCode$1.MISSING_CONNECTOR,
        "A connector is required to sign transactions."
      );
    }
    return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    if (this._connector) {
      return this.provider.getTransactionResponse(
        await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
      );
    }
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(coins) {
    return coins.map((coin) => ({
      id: hexlify(randomBytes2(UTXO_ID_LEN)),
      owner: this.address,
      blockCreated: bn$1(1),
      txCreatedIdx: bn$1(1),
      ...coin
    }));
  }
  /** @hidden * */
  validateTransferAmount(amount) {
    if (bn$1(amount).lte(0)) {
      throw new FuelError(
        ErrorCode$1.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
  }
  /** @hidden * */
  async estimateAndFundTransaction(transactionRequest, txParams) {
    let request = transactionRequest;
    const txCost = await this.getTransactionCost(request);
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    request = await this.fund(request, txCost);
    return request;
  }
  /** @hidden * */
  validateGasLimitAndMaxFee({
    gasUsed,
    maxFee,
    transactionRequest,
    txParams: { gasLimit: setGasLimit, maxFee: setMaxFee }
  }) {
    const request = transactionRequestify(transactionRequest);
    if (!isDefined(setGasLimit)) {
      request.gasLimit = gasUsed;
    } else if (gasUsed.gt(setGasLimit)) {
      throw new FuelError(
        ErrorCode$1.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
    if (!isDefined(setMaxFee)) {
      request.maxFee = maxFee;
    } else if (maxFee.gt(setMaxFee)) {
      throw new FuelError(
        ErrorCode$1.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
      );
    }
    return request;
  }
};
var Signer = class {
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    __publicField(this, "address");
    __publicField(this, "publicKey");
    __publicField(this, "compressedPublicKey");
    __publicField(this, "privateKey");
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = toBytes$2(privateKey, 32);
    this.privateKey = hexlify(privateKeyBytes);
    this.publicKey = hexlify(secp256k1$1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = hexlify(secp256k1$1.getPublicKey(privateKeyBytes, true));
    this.address = Address.fromPublicKey(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data2) {
    const signature = secp256k1$1.sign(arrayify$1(data2), arrayify$1(this.privateKey));
    const r2 = toBytes$2(`0x${signature.r.toString(16)}`, 32);
    const s2 = toBytes$2(`0x${signature.s.toString(16)}`, 32);
    s2[0] |= (signature.recovery || 0) << 7;
    return hexlify(concat([r2, s2]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = secp256k1$1.ProjectivePoint.fromHex(arrayify$1(this.compressedPublicKey));
    const p1 = secp256k1$1.ProjectivePoint.fromHex(arrayify$1(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data2, signature) {
    const signedMessageBytes = arrayify$1(signature);
    const r2 = signedMessageBytes.slice(0, 32);
    const s2 = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s2[0] & 128) >> 7;
    s2[0] &= 127;
    const sig = new secp256k1$1.Signature(BigInt(hexlify(r2)), BigInt(hexlify(s2))).addRecoveryBit(
      recoveryParam
    );
    const publicKey2 = sig.recoverPublicKey(arrayify$1(data2)).toRawBytes(false).slice(1);
    return hexlify(publicKey2);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data2, signature) {
    return Address.fromPublicKey(Signer.recoverPublicKey(data2, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? hash$4(concat([randomBytes2(32), arrayify$1(entropy)])) : randomBytes2(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey2) {
    const point = secp256k1$1.ProjectivePoint.fromHex(arrayify$1(publicKey2));
    return hexlify(point.toRawBytes(false).slice(1));
  }
};
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = bufferFromString2(removeHexPrefix(privateKey), "hex");
  const ownerAddress = Address.fromAddressOrString(address);
  const salt = randomBytes2(DEFAULT_KEY_SIZE);
  const key = scrypt2({
    password: bufferFromString2(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = randomBytes2(DEFAULT_IV_SIZE);
  const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
  const data2 = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = keccak2562(data2);
  const mac = stringFromBuffer2(macHashUint8Array, "hex");
  const keystore = {
    id: v4$1(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: stringFromBuffer2(iv, "hex") },
      ciphertext: stringFromBuffer2(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: stringFromBuffer2(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n: n3, r: r2, p: p2, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
  const ivBuffer = bufferFromString2(iv, "hex");
  const saltBuffer = bufferFromString2(salt, "hex");
  const passwordBuffer = bufferFromString2(password);
  const key = scrypt2({
    password: passwordBuffer,
    salt: saltBuffer,
    n: n3,
    p: p2,
    r: r2,
    dklen
  });
  const data2 = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = keccak2562(data2);
  const macHash = stringFromBuffer2(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new FuelError(
      ErrorCode$1.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer2 = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
  const privateKey = hexlify(buffer2);
  return privateKey;
}
var BaseWalletUnlocked = class extends Account {
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    /**
     * A function that returns the wallet's signer.
     */
    __publicField(this, "signer");
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign(hashMessage(message));
    return hexlify(signedMessage);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = this.provider.getChainId();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return hexlify(signature);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = false } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { estimateTxDependencies: false }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.dryRun(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  /**
   * Encrypts an unlocked wallet with a password.
   *
   * @param password - the password to encrypt the wallet with.
   * @returns - the encrypted wallet.
   */
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
__publicField2(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2 += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify$1(sha256$2(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = arrayify$1(new Uint8Array(size));
  let offset2 = 0;
  for (let i2 = 0; i2 < words.length; i2 += 1) {
    const index = wordlist.indexOf(words[i2].normalize("NFKD"));
    if (index === -1) {
      throw new FuelError(
        ErrorCode$1.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i2]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2 += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify$1(sha256$2(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new FuelError(
      ErrorCode$1.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new FuelError(
      ErrorCode$1.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new FuelError(
      ErrorCode$1.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new FuelError(ErrorCode$1.INVALID_MNEMONIC, errorMsg);
  }
}
var Mnemonic = class {
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    __publicField(this, "wordlist");
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return hexlify(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = arrayify$1(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i2) => wordlist[i2]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes(getPhrase(phrase));
    const salt = toUtf8Bytes(`mnemonic${passphrase}`);
    return pbkdf22(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed2 = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed2);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i2 = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i2 < words.length) {
      if (Mnemonic.binarySearch(words[i2]) === false) {
        return false;
      }
      i2 += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed2) {
    const seedArray = arrayify$1(seed2);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new FuelError(
        ErrorCode$1.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return arrayify$1(computeHmac2("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed2, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed2);
    const prefix2 = arrayify$1(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = concat([
      prefix2,
      depth,
      fingerprint,
      index,
      chainCode,
      concat(["0x00", privateKey])
    ]);
    const checksum = dataSlice(sha256$2(sha256$2(extendedKey)), 0, 4);
    return encodeBase58(concat([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? sha256$2(concat([randomBytes2(size), arrayify$1(extraEntropy)])) : randomBytes2(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = hexlify("0x0488ade4");
var MainnetPUB = hexlify("0x0488b21e");
var TestnetPRV2 = hexlify("0x04358394");
var TestnetPUB = hexlify("0x043587cf");
function base58check(data2) {
  return encodeBase58(concat([data2, dataSlice(sha256$2(sha256$2(data2)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    hexlify(extendedKey.slice(0, 4))
  );
}
function parsePath$1(path, depth = 0) {
  const components = path.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new FuelError(ErrorCode$1.HD_WALLET_ERROR, `invalid path - ${path}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p2) => ~p2.indexOf(`'`) ? parseInt(p2, 10) + HARDENED_INDEX : parseInt(p2, 10)
  );
}
var HDWallet = class {
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config2) {
    __publicField(this, "depth", 0);
    __publicField(this, "index", 0);
    __publicField(this, "fingerprint", hexlify("0x00000000"));
    __publicField(this, "parentFingerprint", hexlify("0x00000000"));
    __publicField(this, "privateKey");
    __publicField(this, "publicKey");
    __publicField(this, "chainCode");
    if (config2.privateKey) {
      const signer = new Signer(config2.privateKey);
      this.publicKey = hexlify(signer.compressedPublicKey);
      this.privateKey = hexlify(config2.privateKey);
    } else {
      if (!config2.publicKey) {
        throw new FuelError(
          ErrorCode$1.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = hexlify(config2.publicKey);
    }
    this.parentFingerprint = config2.parentFingerprint || this.parentFingerprint;
    this.fingerprint = dataSlice(ripemd1602(sha256$2(this.publicKey)), 0, 4);
    this.depth = config2.depth || this.depth;
    this.index = config2.index || this.index;
    this.chainCode = config2.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && arrayify$1(this.privateKey);
    const publicKey2 = arrayify$1(this.publicKey);
    const chainCode = arrayify$1(this.chainCode);
    const data2 = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new FuelError(
          ErrorCode$1.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data2.set(privateKey, 1);
    } else {
      data2.set(arrayify$1(this.publicKey));
    }
    data2.set(toBytes$2(index, 4), 33);
    const bytes2 = arrayify$1(computeHmac2("sha512", chainCode, data2));
    const IL = bytes2.slice(0, 32);
    const IR = bytes2.slice(32);
    if (privateKey) {
      const N2 = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki2 = bn$1(IL).add(privateKey).mod(N2).toBytes(32);
      return new HDWallet({
        privateKey: ki2,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer(hexlify(IL));
    const Ki2 = signer.addPoint(publicKey2);
    return new HDWallet({
      publicKey: Ki2,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path) {
    const paths = parsePath$1(path, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new FuelError(
        ErrorCode$1.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix2 = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = hexlify(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = toHex$1(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = arrayify$1(concat([prefix2, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed2) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed2);
    return new HDWallet({
      chainCode: arrayify$1(masterKey.slice(32)),
      privateKey: arrayify$1(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = hexlify(toBytes$2(decodeBase58(extendedKey)));
    const bytes2 = arrayify$1(decoded);
    const validChecksum = base58check(bytes2.slice(0, 78)) === extendedKey;
    if (bytes2.length !== 82 || !isValidExtendedKey(bytes2)) {
      throw new FuelError(ErrorCode$1.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new FuelError(ErrorCode$1.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new FuelError(
        ErrorCode$1.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes2)) {
      if (key[0] !== 3) {
        throw new FuelError(ErrorCode$1.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new FuelError(ErrorCode$1.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions == null ? void 0 : generateOptions.entropy);
    return new WalletUnlocked(privateKey, generateOptions == null ? void 0 : generateOptions.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed2, path, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed2);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path, passphrase, provider) {
    const seed2 = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed2);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
__publicField2(Wallet, "generate", WalletUnlocked.generate);
__publicField2(Wallet, "fromSeed", WalletUnlocked.fromSeed);
__publicField2(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
__publicField2(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
__publicField2(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);
var MemoryStorage = class {
  constructor() {
    __publicField(this, "storage", /* @__PURE__ */ new Map());
  }
  async getItem(key) {
    const item = await this.storage.get(key);
    return item;
  }
  async setItem(key, value2) {
    await this.storage.set(key, value2);
  }
  async removeItem(key) {
    await this.storage.delete(key);
  }
  async clear() {
    await this.storage.clear();
  }
};
var _secret;
var MnemonicVault = class {
  constructor(options) {
    __privateAdd2(this, _secret, void 0);
    __publicField2(this, "pathKey", "{}");
    __publicField2(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
    __publicField2(this, "numberOfAccounts", 0);
    __privateSet2(this, _secret, options.secret || mnemonic_default.generate());
    this.rootPath = options.rootPath || this.rootPath;
    this.numberOfAccounts = options.numberOfAccounts || 1;
  }
  getDerivePath(index) {
    if (this.rootPath.includes(this.pathKey)) {
      return this.rootPath.replace(this.pathKey, String(index));
    }
    return `${this.rootPath}/${index}`;
  }
  serialize() {
    return {
      secret: __privateGet2(this, _secret),
      rootPath: this.rootPath,
      numberOfAccounts: this.numberOfAccounts
    };
  }
  getAccounts() {
    const accounts = [];
    let numberOfAccounts = 0;
    do {
      const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
      accounts.push({
        publicKey: wallet.publicKey,
        address: wallet.address
      });
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    return accounts;
  }
  addAccount() {
    this.numberOfAccounts += 1;
    const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(this.numberOfAccounts - 1));
    return {
      publicKey: wallet.publicKey,
      address: wallet.address
    };
  }
  exportAccount(address) {
    let numberOfAccounts = 0;
    const ownerAddress = Address.fromAddressOrString(address);
    do {
      const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
      if (wallet.address.equals(ownerAddress)) {
        return wallet.privateKey;
      }
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    throw new FuelError(
      ErrorCode$1.WALLET_MANAGER_ERROR,
      `Account with address '${address}' not found in derived wallets.`
    );
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_secret = /* @__PURE__ */ new WeakMap();
__publicField2(MnemonicVault, "type", "mnemonic");
var _privateKeys;
var PrivateKeyVault = class {
  /**
   * If privateKey vault is initialized with a secretKey, it creates
   * one account with the fallowing secret
   */
  constructor(options = {}) {
    __privateAdd2(this, _privateKeys, []);
    if (options.secret) {
      __privateSet2(this, _privateKeys, [options.secret]);
    } else {
      __privateSet2(this, _privateKeys, options.accounts || [Wallet.generate().privateKey]);
    }
  }
  serialize() {
    return {
      accounts: __privateGet2(this, _privateKeys)
    };
  }
  getPublicAccount(privateKey) {
    const wallet = Wallet.fromPrivateKey(privateKey);
    return {
      address: wallet.address,
      publicKey: wallet.publicKey
    };
  }
  getAccounts() {
    return __privateGet2(this, _privateKeys).map((pk2) => this.getPublicAccount(pk2));
  }
  addAccount() {
    const wallet = Wallet.generate();
    __privateGet2(this, _privateKeys).push(wallet.privateKey);
    return this.getPublicAccount(wallet.privateKey);
  }
  exportAccount(address) {
    const ownerAddress = Address.fromAddressOrString(address);
    const privateKey = __privateGet2(this, _privateKeys).find(
      (pk2) => Wallet.fromPrivateKey(pk2).address.equals(ownerAddress)
    );
    if (!privateKey) {
      throw new FuelError(
        ErrorCode$1.WALLET_MANAGER_ERROR,
        `No private key found for address '${address}'.`
      );
    }
    return privateKey;
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_privateKeys = /* @__PURE__ */ new WeakMap();
__publicField2(PrivateKeyVault, "type", "privateKey");
var ERROR_MESSAGES = {
  invalid_vault_type: "The provided Vault type is invalid.",
  address_not_found: "No private key found for address the specified wallet address.",
  vault_not_found: "The specified vault was not found.",
  wallet_not_unlocked: "The wallet is currently locked.",
  passphrase_not_match: "The provided passphrase did not match the expected value."
};
function assert$9(condition, message) {
  if (!condition) {
    throw new FuelError(ErrorCode$1.WALLET_MANAGER_ERROR, message);
  }
}
var _vaults, _passphrase, _isLocked, _serializeVaults, serializeVaults_fn, _deserializeVaults, deserializeVaults_fn;
var _WalletManager = class extends eventsExports.EventEmitter {
  constructor(options) {
    super();
    __privateAdd2(this, _serializeVaults);
    __privateAdd2(this, _deserializeVaults);
    __publicField2(this, "storage", new MemoryStorage());
    __publicField2(this, "STORAGE_KEY", "WalletManager");
    __privateAdd2(this, _vaults, []);
    __privateAdd2(this, _passphrase, "");
    __privateAdd2(this, _isLocked, true);
    this.storage = (options == null ? void 0 : options.storage) || this.storage;
  }
  get isLocked() {
    return __privateGet2(this, _isLocked);
  }
  /**
   * Return the vault serialized object containing all the privateKeys,
   * the format of the return depends on the Vault type.
   */
  exportVault(vaultId) {
    assert$9(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet2(this, _vaults).find((_2, idx) => idx === vaultId);
    assert$9(vaultState, ERROR_MESSAGES.vault_not_found);
    return vaultState.vault.serialize();
  }
  /**
   * List all vaults on the Wallet Manager, this function not return secret's
   */
  getVaults() {
    return __privateGet2(this, _vaults).map((v2, idx) => ({
      title: v2.title,
      type: v2.type,
      vaultId: idx
    }));
  }
  /**
   * List all accounts on the Wallet Manager not vault information is revealed
   */
  getAccounts() {
    return __privateGet2(this, _vaults).flatMap(
      (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))
    );
  }
  /**
   * Create a Wallet instance for the specific account
   */
  getWallet(address) {
    const ownerAddress = Address.fromAddressOrString(address);
    const vaultState = __privateGet2(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a2) => a2.address.equals(ownerAddress))
    );
    assert$9(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.getWallet(ownerAddress);
  }
  /**
   * Export specific account privateKey
   */
  exportPrivateKey(address) {
    const ownerAddress = Address.fromAddressOrString(address);
    assert$9(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet2(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a2) => a2.address.equals(ownerAddress))
    );
    assert$9(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.exportAccount(ownerAddress);
  }
  /**
   * Add account to a selected vault or on the first vault as default.
   * If not vaults are adds it will return error
   */
  async addAccount(options) {
    await this.loadState();
    const vaultState = __privateGet2(this, _vaults)[(options == null ? void 0 : options.vaultId) || 0];
    await assert$9(vaultState, ERROR_MESSAGES.vault_not_found);
    const account = vaultState.vault.addAccount();
    await this.saveState();
    return account;
  }
  /**
   * Remove vault by index, by remove the vault you also remove all accounts
   * created by the vault.
   */
  async removeVault(index) {
    __privateGet2(this, _vaults).splice(index, 1);
    await this.saveState();
  }
  /**
   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
   * didn't found it will throw.
   */
  async addVault(vaultConfig) {
    await this.loadState();
    const Vault2 = this.getVaultClass(vaultConfig.type);
    const vault = new Vault2(vaultConfig);
    __privateSet2(this, _vaults, __privateGet2(this, _vaults).concat({
      title: vaultConfig.title,
      type: vaultConfig.type,
      vault
    }));
    await this.saveState();
  }
  /**
   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
   * secrets.
   */
  lock() {
    __privateSet2(this, _isLocked, true);
    __privateSet2(this, _vaults, []);
    __privateSet2(this, _passphrase, "");
    this.emit("lock");
  }
  /**
   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
   * Vaults with secrets are not unlocked or instantiated on this moment.
   */
  async unlock(passphrase) {
    __privateSet2(this, _passphrase, passphrase);
    __privateSet2(this, _isLocked, false);
    try {
      await this.loadState();
      this.emit("unlock");
    } catch (err) {
      await this.lock();
      throw err;
    }
  }
  /**
   * Update WalletManager encryption passphrase
   */
  async updatePassphrase(oldpass, newpass) {
    const isLocked = __privateGet2(this, _isLocked);
    await this.unlock(oldpass);
    __privateSet2(this, _passphrase, newpass);
    await this.saveState();
    await this.loadState();
    if (isLocked) {
      await this.lock();
    }
  }
  /**
   * Retrieve and decrypt WalletManager state from storage
   */
  async loadState() {
    await assert$9(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const data2 = await this.storage.getItem(this.STORAGE_KEY);
    if (data2) {
      const state2 = await decrypt2(__privateGet2(this, _passphrase), JSON.parse(data2));
      __privateSet2(this, _vaults, __privateMethod2(this, _deserializeVaults, deserializeVaults_fn).call(this, state2.vaults));
    }
  }
  /**
   * Store encrypted WalletManager state on storage
   */
  async saveState() {
    await assert$9(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const encryptedData = await encrypt2(__privateGet2(this, _passphrase), {
      vaults: __privateMethod2(this, _serializeVaults, serializeVaults_fn).call(this, __privateGet2(this, _vaults))
    });
    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));
    this.emit("update");
  }
  /**
   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
   */
  getVaultClass(type3) {
    const VaultClass = _WalletManager.Vaults.find((v2) => v2.type === type3);
    assert$9(VaultClass, ERROR_MESSAGES.invalid_vault_type);
    return VaultClass;
  }
};
var WalletManager = _WalletManager;
_vaults = /* @__PURE__ */ new WeakMap();
_passphrase = /* @__PURE__ */ new WeakMap();
_isLocked = /* @__PURE__ */ new WeakMap();
_serializeVaults = /* @__PURE__ */ new WeakSet();
serializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type: type3, vault }) => ({
    title,
    type: type3,
    data: vault.serialize()
  }));
};
_deserializeVaults = /* @__PURE__ */ new WeakSet();
deserializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type: type3, data: vaultConfig }) => {
    const VaultClass = this.getVaultClass(type3);
    return {
      title,
      type: type3,
      vault: new VaultClass(vaultConfig)
    };
  });
};
__publicField2(WalletManager, "Vaults", [MnemonicVault, PrivateKeyVault]);
var Vault = class {
  constructor(_options) {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
  serialize() {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
  getAccounts() {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
  addAccount() {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
  exportAccount(_address) {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
  getWallet(_address) {
    throw new FuelError(ErrorCode$1.NOT_IMPLEMENTED, "Not implemented.");
  }
};
__publicField2(Vault, "type");
var getPredicateRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes2 = arrayify$1(bytecode);
  const chunks = chunkAndPadBytes(bytes2, chunkSize);
  const codeRoot = calcRoot(chunks.map((c2) => hexlify(c2)));
  const predicateRoot = hash$4(concat(["0x4655454C", codeRoot]));
  return predicateRoot;
};
var Predicate = class extends Account {
  /**
   * Creates an instance of the Predicate class.
   *
   * @param bytecode - The bytecode of the predicate.
   * @param abi - The JSON ABI of the predicate.
   * @param provider - The provider used to interact with the blockchain.
   * @param inputData - The predicate input data (optional).
   * @param configurableConstants - Optional configurable constants for the predicate.
   */
  constructor({
    bytecode,
    abi,
    provider,
    inputData,
    configurableConstants
  }) {
    const { predicateBytes, predicateInterface } = Predicate.processPredicateData(
      bytecode,
      abi,
      configurableConstants
    );
    const address = Address.fromB256(getPredicateRoot(predicateBytes));
    super(address, provider);
    __publicField(this, "bytes");
    __publicField(this, "predicateData", []);
    __publicField(this, "interface");
    this.bytes = predicateBytes;
    this.interface = predicateInterface;
    if (inputData !== void 0 && inputData.length > 0) {
      this.predicateData = inputData;
    }
  }
  /**
   * Populates the transaction data with predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns The transaction request with predicate data.
   */
  populateTransactionPredicateData(transactionRequestLike) {
    const request = transactionRequestify(transactionRequestLike);
    const placeholderIndex = this.getIndexFromPlaceholderWitness(request);
    if (placeholderIndex !== -1) {
      request.removeWitness(placeholderIndex);
    }
    request.inputs.filter(isRequestInputResource).forEach((input) => {
      if (isRequestInputResourceFromOwner(input, this.address)) {
        input.predicate = hexlify(this.bytes);
        input.predicateData = hexlify(this.getPredicateData());
        input.witnessIndex = 0;
      }
    });
    return request;
  }
  /**
   * Sends a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the transaction response.
   */
  sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    return super.sendTransaction(transactionRequest, { estimateTxDependencies: false });
  }
  /**
   * Simulates a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the call result.
   */
  simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    return super.simulateTransaction(transactionRequest, { estimateTxDependencies: false });
  }
  getPredicateData() {
    var _a2;
    if (!this.predicateData.length) {
      return new Uint8Array();
    }
    const mainFn = (_a2 = this.interface) == null ? void 0 : _a2.functions.main;
    return (mainFn == null ? void 0 : mainFn.encodeArguments(this.predicateData)) || new Uint8Array();
  }
  /**
   * Processes the predicate data and returns the altered bytecode and interface.
   *
   * @param bytes - The bytes of the predicate.
   * @param jsonAbi - The JSON ABI of the predicate.
   * @param configurableConstants - Optional configurable constants for the predicate.
   * @returns An object containing the new predicate bytes and interface.
   */
  static processPredicateData(bytes2, jsonAbi, configurableConstants) {
    let predicateBytes = arrayify$1(bytes2);
    let abiInterface;
    if (jsonAbi) {
      abiInterface = new Interface(jsonAbi);
      if (abiInterface.functions.main === void 0) {
        throw new FuelError(
          ErrorCode$1.ABI_MAIN_METHOD_MISSING,
          'Cannot use ABI without "main" function.'
        );
      }
    }
    if (configurableConstants && Object.keys(configurableConstants).length) {
      predicateBytes = Predicate.setConfigurableConstants(
        predicateBytes,
        configurableConstants,
        abiInterface
      );
    }
    return {
      predicateBytes,
      predicateInterface: abiInterface
    };
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    const resources = await this.provider.getResourcesToSpend(
      this.address,
      quantities,
      excludedIds
    );
    return resources.map((resource) => ({
      ...resource,
      predicate: hexlify(this.bytes),
      predicateData: hexlify(this.getPredicateData())
    }));
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(coins) {
    return super.generateFakeResources(coins).map((coin) => ({
      ...coin,
      predicate: hexlify(this.bytes),
      predicateData: hexlify(this.getPredicateData())
    }));
  }
  /**
   * Sets the configurable constants for the predicate.
   *
   * @param bytes - The bytes of the predicate.
   * @param configurableConstants - Configurable constants to be set.
   * @param abiInterface - The ABI interface of the predicate.
   * @returns The mutated bytes with the configurable constants set.
   */
  static setConfigurableConstants(bytes2, configurableConstants, abiInterface) {
    const mutatedBytes = bytes2;
    try {
      if (!abiInterface) {
        throw new Error(
          "Cannot validate configurable constants because the Predicate was instantiated without a JSON ABI"
        );
      }
      if (Object.keys(abiInterface.configurables).length === 0) {
        throw new Error("Predicate has no configurable constants to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value2]) => {
        if (!(abiInterface == null ? void 0 : abiInterface.configurables[key])) {
          throw new Error(`No configurable constant named '${key}' found in the Predicate`);
        }
        const { offset: offset2 } = abiInterface.configurables[key];
        const encoded = abiInterface.encodeConfigurable(key, value2);
        mutatedBytes.set(encoded, offset2);
      });
    } catch (err) {
      throw new FuelError(
        ErrorCode$1.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${err.message}.`
      );
    }
    return mutatedBytes;
  }
  /**
   * Returns the index of the witness placeholder that was added to this predicate.
   * If no witness placeholder was added, it returns -1.
   * @param request - The transaction request.
   * @returns The index of the witness placeholder, or -1 if there is no witness placeholder.
   */
  getIndexFromPlaceholderWitness(request) {
    var _a2;
    const predicateInputs = request.inputs.filter(isRequestInputResource).filter((input) => isRequestInputResourceFromOwner(input, this.address));
    let index = -1;
    const hasEmptyPredicateInputs = predicateInputs.find((input) => !input.predicate);
    if (hasEmptyPredicateInputs) {
      index = hasEmptyPredicateInputs.witnessIndex;
      const allInputsAreEmpty = predicateInputs.every((input) => !input.predicate);
      if (!allInputsAreEmpty) {
        const wasFilledInputAddedFirst = !!((_a2 = predicateInputs[0]) == null ? void 0 : _a2.predicate);
        if (wasFilledInputAddedFirst) {
          index = -1;
        }
      }
    }
    return index;
  }
};
var FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {
  FuelConnectorMethods2["ping"] = "ping";
  FuelConnectorMethods2["version"] = "version";
  FuelConnectorMethods2["connect"] = "connect";
  FuelConnectorMethods2["disconnect"] = "disconnect";
  FuelConnectorMethods2["isConnected"] = "isConnected";
  FuelConnectorMethods2["accounts"] = "accounts";
  FuelConnectorMethods2["currentAccount"] = "currentAccount";
  FuelConnectorMethods2["signMessage"] = "signMessage";
  FuelConnectorMethods2["sendTransaction"] = "sendTransaction";
  FuelConnectorMethods2["assets"] = "assets";
  FuelConnectorMethods2["addAsset"] = "addAsset";
  FuelConnectorMethods2["addAssets"] = "addAssets";
  FuelConnectorMethods2["networks"] = "networks";
  FuelConnectorMethods2["currentNetwork"] = "currentNetwork";
  FuelConnectorMethods2["addNetwork"] = "addNetwork";
  FuelConnectorMethods2["selectNetwork"] = "selectNetwork";
  FuelConnectorMethods2["addABI"] = "addABI";
  FuelConnectorMethods2["getABI"] = "getABI";
  FuelConnectorMethods2["hasABI"] = "hasABI";
  return FuelConnectorMethods2;
})(FuelConnectorMethods || {});
var FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {
  FuelConnectorEventTypes2["connectors"] = "connectors";
  FuelConnectorEventTypes2["currentConnector"] = "currentConnector";
  FuelConnectorEventTypes2["connection"] = "connection";
  FuelConnectorEventTypes2["accounts"] = "accounts";
  FuelConnectorEventTypes2["currentAccount"] = "currentAccount";
  FuelConnectorEventTypes2["networks"] = "networks";
  FuelConnectorEventTypes2["currentNetwork"] = "currentNetwork";
  FuelConnectorEventTypes2["assets"] = "assets";
  FuelConnectorEventTypes2["abis"] = "abis";
  return FuelConnectorEventTypes2;
})(FuelConnectorEventTypes || {});
var FuelConnectorEventType = "FuelConnector";
var LocalStorage = class {
  constructor(localStorage2) {
    __publicField(this, "storage");
    this.storage = localStorage2;
  }
  async setItem(key, value2) {
    this.storage.setItem(key, value2);
  }
  async getItem(key) {
    return this.storage.getItem(key);
  }
  async removeItem(key) {
    this.storage.removeItem(key);
  }
  async clear() {
    this.storage.clear();
  }
};
var FuelConnector = class extends eventsExports.EventEmitter {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "");
    __publicField(this, "metadata", {});
    __publicField(this, "connected", false);
    __publicField(this, "installed", false);
    __publicField(this, "events", FuelConnectorEventTypes);
  }
  /**
   * Should return true if the connector is loaded
   * in less then one second.
   *
   * @returns Always true.
   */
  async ping() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current version of the connector
   * and the network version that is compatible.
   *
   * @returns boolean - connection status.
   */
  async version() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return true if the connector is connected
   * to any of the accounts available.
   *
   * @returns The connection status.
   */
  async isConnected() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the accounts authorized for the
   * current connection.
   *
   * @returns The accounts addresses strings
   */
  async accounts() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the connection process and return
   * true if the account authorize the connection.
   *
   * and return false if the user reject the connection.
   *
   * @emits accounts
   * @returns boolean - connection status.
   */
  async connect() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should disconnect the current connection and
   * return false if the disconnection was successful.
   *
   * @emits assets connection
   * @returns The connection status.
   */
  async disconnect() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the sign message process and return
   * the signed message.
   *
   * @param address - The address to sign the message
   * @param message - The message to sign all text will be treated as text utf-8
   *
   * @returns Message signature
   */
  async signMessage(_address, _message) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the sign transaction process and return
   * the signed transaction.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to sign
   *
   * @returns Transaction signature
   */
  async signTransaction(_address, _transaction) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the send transaction process and return
   * the transaction id submitted to the network.
   *
   * If the network is not available for the connection
   * it should throw an error to avoid the transaction
   * to be sent to the wrong network and lost.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to send
   *
   * @returns The transaction id
   */
  async sendTransaction(_address, _transaction) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current account selected inside the connector, if the account
   * is authorized for the connection.
   *
   * If the account is not authorized it should return null.
   *
   * @returns The current account selected otherwise null.
   */
  async currentAccount() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the assets metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param assets - The assets to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAssets(_assets) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the asset metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param asset - The asset to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAsset(_asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the assets added to the connector. If a connection is already established.
   *
   * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
   */
  async assets() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the add network process and return true if the network was added successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param networkUrl - The URL of the network to be added.
   * @returns Return true if the network was added successfully
   */
  async addNetwork(_networkUrl) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the select network process and return true if the network has change successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param network - The network to be selected.
   * @returns Return true if the network was added successfully
   */
  async selectNetwork(_network) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the networks available from the connector. If the connection is already established.
   *
   * @returns Return all the networks added to the connector.
   */
  async networks() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current network selected inside the connector. Even if the connection is not established.
   *
   * @returns Return the current network selected inside the connector.
   */
  async currentNetwork() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the ABI to the connector and return true if the ABI was added successfully.
   *
   * @param contractId - The contract id to add the ABI.
   * @param abi - The JSON ABI that represents a contract.
   * @returns Return true if the ABI was added successfully.
   */
  async addABI(_contractId, _abi2) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the ABI.
   * @returns The ABI if it exists, otherwise return null.
   */
  async getABI(_id) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the abi
   * @returns Returns true if the abi exists or false if not.
   */
  async hasABI(_id) {
    throw new Error("Method not implemented.");
  }
  /**
   * Event listener for the connector.
   *
   * @param eventName - The event name to listen
   * @param listener - The listener function
   */
  on(eventName, listener) {
    super.on(eventName, listener);
    return this;
  }
};
function cacheFor(fn2, { cache: cache2, cacheTime, key }) {
  return async (...args) => {
    var _a2, _b2, _c2;
    if (cache2[key] && ((_a2 = cache2[key]) == null ? void 0 : _a2.value)) {
      return (_b2 = cache2[key]) == null ? void 0 : _b2.value;
    }
    clearTimeout((_c2 = cache2[key]) == null ? void 0 : _c2.timeout);
    const result = await fn2(...args);
    cache2[key] = {
      timeout: Number(
        setTimeout(() => {
          cache2[key] = null;
        }, cacheTime)
      ),
      value: result
    };
    return result;
  };
}
function deferPromise() {
  const defer = {};
  defer.promise = new Promise((resolve, reject) => {
    defer.reject = reject;
    defer.resolve = resolve;
  });
  return defer;
}
async function withTimeout(promise, timeout = 1050) {
  const timeoutPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error("Promise timed out"));
    }, timeout);
  });
  return Promise.race([timeoutPromise, promise]);
}
var HAS_CONNECTOR_TIMEOUT = 2e3;
var PING_CACHE_TIME = 5e3;
var { warn } = console;
var _Fuel = class extends FuelConnector {
  constructor(config2 = _Fuel.defaultConfig) {
    super();
    __publicField(this, "_storage", null);
    __publicField(this, "_connectors", []);
    __publicField(this, "_targetObject", null);
    __publicField(this, "_unsubscribes", []);
    __publicField(this, "_targetUnsubscribe");
    __publicField(this, "_pingCache", {});
    __publicField(this, "_currentConnector");
    /**
     * Setup a listener for the FuelConnector event and add the connector
     * to the list of new connectors.
     */
    __publicField(this, "setupConnectorListener", () => {
      const { _targetObject: targetObject } = this;
      const eventName = FuelConnectorEventType;
      if (targetObject == null ? void 0 : targetObject.on) {
        targetObject.on(eventName, this.addConnector);
        return () => {
          var _a2;
          (_a2 = targetObject.off) == null ? void 0 : _a2.call(targetObject, eventName, this.addConnector);
        };
      }
      if (targetObject == null ? void 0 : targetObject.addEventListener) {
        const handler = (e2) => {
          this.addConnector(e2.detail);
        };
        targetObject.addEventListener(eventName, handler);
        return () => {
          var _a2;
          (_a2 = targetObject.removeEventListener) == null ? void 0 : _a2.call(targetObject, eventName, handler);
        };
      }
      return () => {
      };
    });
    /**
     * Add a new connector to the list of connectors.
     */
    __publicField(this, "addConnector", async (connector) => {
      if (!this.getConnector(connector)) {
        this._connectors.push(connector);
      }
      await this.fetchConnectorStatus(connector);
      this.emit(this.events.connectors, this._connectors);
      if (!this._currentConnector) {
        await this.selectConnector(connector.name, {
          emitEvents: false
        });
      }
    });
    __publicField(this, "triggerConnectorEvents", async () => {
      const [isConnected, networks, currentNetwork] = await Promise.all([
        this.isConnected(),
        this.networks(),
        this.currentNetwork()
      ]);
      this.emit(this.events.connection, isConnected);
      this.emit(this.events.networks, networks);
      this.emit(this.events.currentNetwork, currentNetwork);
      if (isConnected) {
        const [accounts, currentAccount] = await Promise.all([
          this.accounts(),
          this.currentAccount()
        ]);
        this.emit(this.events.accounts, accounts);
        this.emit(this.events.currentAccount, currentAccount);
      }
    });
    /**
     * Get a connector from the list of connectors.
     */
    __publicField(this, "getConnector", (connector) => this._connectors.find((c2) => {
      const connectorName = typeof connector === "string" ? connector : connector.name;
      return c2.name === connectorName || c2 === connector;
    }) || null);
    this.setMaxListeners(1e3);
    this._connectors = config2.connectors ?? [];
    this._targetObject = this.getTargetObject(config2.targetObject);
    this._storage = config2.storage === void 0 ? this.getStorage() : config2.storage;
    this.setupMethods();
    this.setDefaultConnector();
    this._targetUnsubscribe = this.setupConnectorListener();
  }
  /**
   * Return the target object to listen for global events.
   */
  getTargetObject(targetObject) {
    if (targetObject) {
      return targetObject;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof document !== "undefined") {
      return document;
    }
    return null;
  }
  /**
   * Return the storage used.
   */
  getStorage() {
    if (typeof window !== "undefined") {
      return new LocalStorage(window.localStorage);
    }
    return void 0;
  }
  /**
   * Setup the default connector from the storage.
   */
  async setDefaultConnector() {
    var _a2, _b2;
    const connectorName = await ((_a2 = this._storage) == null ? void 0 : _a2.getItem(_Fuel.STORAGE_KEY)) || ((_b2 = this._connectors[0]) == null ? void 0 : _b2.name);
    if (connectorName) {
      return this.selectConnector(connectorName, {
        emitEvents: false
      });
    }
    return void 0;
  }
  /**
   * Start listener for all the events of the current
   * connector and emit them to the Fuel instance
   */
  setupConnectorEvents(events2) {
    if (!this._currentConnector) {
      return;
    }
    const currentConnector = this._currentConnector;
    this._unsubscribes.map((unSub) => unSub());
    this._unsubscribes = events2.map((event) => {
      const handler = (...args) => this.emit(event, ...args);
      currentConnector.on(event, handler);
      return () => currentConnector.off(event, handler);
    });
  }
  /**
   * Call method from the current connector.
   */
  async callMethod(method, ...args) {
    const hasConnector = await this.hasConnector();
    await this.pingConnector();
    if (!this._currentConnector || !hasConnector) {
      throw new Error(
        `No connector selected for calling ${method}. Use hasConnector before executing other methods.`
      );
    }
    if (typeof this._currentConnector[method] === "function") {
      return this._currentConnector[method](...args);
    }
    return void 0;
  }
  /**
   * Create a method for each method proxy that is available on the Common interface
   * and call the method from the current connector.
   */
  setupMethods() {
    Object.values(FuelConnectorMethods).forEach((method) => {
      this[method] = async (...args) => this.callMethod(method, ...args);
    });
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status.
   */
  async fetchConnectorStatus(connector) {
    const requestTimestamp = Date.now();
    const [isConnected, ping] = await Promise.allSettled([
      withTimeout(connector.isConnected()),
      withTimeout(this.pingConnector(connector))
    ]);
    const isStale2 = requestTimestamp < (connector._latestUpdate || 0);
    if (!isStale2) {
      connector._latestUpdate = Date.now();
      connector.installed = ping.status === "fulfilled" && ping.value;
      connector.connected = isConnected.status === "fulfilled" && isConnected.value;
    }
    return {
      installed: connector.installed,
      connected: connector.connected
    };
  }
  /**
   * Fetch the status of all connectors and set the installed and connected
   * status.
   */
  async fetchConnectorsStatus() {
    return Promise.all(
      this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))
    );
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status. If no connector is provided it will ping the current connector.
   */
  async pingConnector(connector) {
    const curConnector = connector || this._currentConnector;
    if (!curConnector) {
      return false;
    }
    try {
      return await cacheFor(async () => withTimeout(curConnector.ping()), {
        key: curConnector.name,
        cache: this._pingCache,
        cacheTime: PING_CACHE_TIME
      })();
    } catch {
      throw new Error("Current connector is not available.");
    }
  }
  /**
   * Return the list of connectors with the status of installed and connected.
   */
  async connectors() {
    await this.fetchConnectorsStatus();
    return this._connectors;
  }
  /**
   * Set the current connector to be used.
   */
  async selectConnector(connectorName, options = {
    emitEvents: true
  }) {
    var _a2, _b2;
    const connector = this.getConnector(connectorName);
    if (!connector) {
      return false;
    }
    if (((_a2 = this._currentConnector) == null ? void 0 : _a2.name) === connectorName) {
      return true;
    }
    const { installed } = await this.fetchConnectorStatus(connector);
    if (installed) {
      this._currentConnector = connector;
      this.emit(this.events.currentConnector, connector);
      this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));
      await ((_b2 = this._storage) == null ? void 0 : _b2.setItem(_Fuel.STORAGE_KEY, connector.name));
      if (options.emitEvents) {
        this.triggerConnectorEvents();
      }
      return true;
    }
    return false;
  }
  /**
   * Return the current selected connector.
   */
  currentConnector() {
    return this._currentConnector;
  }
  /**
   * Return true if any connector is available.
   */
  async hasConnector() {
    if (this._currentConnector) {
      return true;
    }
    const defer = deferPromise();
    this.once(this.events.currentConnector, () => {
      defer.resolve(true);
    });
    return withTimeout(defer.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);
  }
  async hasWallet() {
    return this.hasConnector();
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   *
   * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.
   */
  async getProvider(providerOrNetwork) {
    warn(
      "getProvider is deprecated and is going to be removed in the future, use getWallet instead."
    );
    return this._getProvider(providerOrNetwork);
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   */
  async _getProvider(providerOrNetwork) {
    let provider;
    if (providerOrNetwork && "getTransactionResponse" in providerOrNetwork) {
      provider = providerOrNetwork;
    } else if (providerOrNetwork && "chainId" in providerOrNetwork && "url" in providerOrNetwork) {
      provider = await Provider.create(providerOrNetwork.url);
    } else if (!providerOrNetwork) {
      const currentNetwork = await this.currentNetwork();
      provider = await Provider.create(currentNetwork.url);
    } else {
      throw new FuelError(ErrorCode$1.INVALID_PROVIDER, "Provider is not valid.");
    }
    return provider;
  }
  /**
   * Return a Fuel Wallet Locked instance with extends features to work with
   * connectors.
   */
  async getWallet(address, providerOrNetwork) {
    const provider = await this._getProvider(providerOrNetwork);
    return new Account(address, provider, this);
  }
  /**
   * Remove all open listeners this is useful when you want to
   * remove the Fuel instance and avoid memory leaks.
   */
  unsubscribe() {
    this._unsubscribes.map((unSub) => unSub());
    this._targetUnsubscribe();
    this.removeAllListeners();
  }
  /**
   * Clean all the data from the storage.
   */
  async clean() {
    var _a2;
    await ((_a2 = this._storage) == null ? void 0 : _a2.removeItem(_Fuel.STORAGE_KEY));
  }
  /**
   * Removes all listeners and cleans the storage.
   */
  async destroy() {
    this.unsubscribe();
    await this.clean();
  }
};
var Fuel = _Fuel;
__publicField2(Fuel, "STORAGE_KEY", "fuel-current-connector");
__publicField2(Fuel, "defaultConfig", {});
function assert$8(condition, message) {
  if (!condition) {
    throw new FuelError(ErrorCode$1.TRANSACTION_ERROR, message);
  }
}
function getAbisFromAllCalls(functionScopes) {
  return functionScopes.reduce((acc, funcScope, i2) => {
    const { program, externalAbis } = funcScope.getCallConfig();
    if (i2 === 0) {
      acc.main = program.interface.jsonAbi;
      acc.otherContractsAbis = {};
    } else {
      acc.otherContractsAbis[program.id.toB256()] = program.interface.jsonAbi;
    }
    acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };
    return acc;
  }, {});
}
var getResultLogs = (receipts, mainCallConfig, functionScopes) => {
  if (!mainCallConfig) {
    return [];
  }
  const { main, otherContractsAbis } = getAbisFromAllCalls(functionScopes);
  return getDecodedLogs(receipts, main, otherContractsAbis);
};
var InstructionSet = (_q = class {
  constructor(...args) {
    __privateAdd(this, _operations);
    __privateSet(this, _operations, args || []);
  }
  entries() {
    return __privateGet(this, _operations);
  }
  push(...args) {
    __privateGet(this, _operations).push(...args);
  }
  concat(ops) {
    return __privateGet(this, _operations).concat(ops);
  }
  extend(ops) {
    __privateGet(this, _operations).push(...ops);
  }
  toBytes() {
    return concat(
      __privateGet(this, _operations).reduce((instructions, line2) => {
        instructions.push(line2.to_bytes());
        return instructions;
      }, [])
    );
  }
  toHex() {
    return hexlify(this.toBytes());
  }
  toString() {
    return `Program:
${JSON.stringify(__privateGet(this, _operations), null, 2)}`;
  }
  byteLength() {
    return this.toBytes().byteLength;
  }
}, _operations = new WeakMap(), _q);
var calculateScriptDataBaseOffset = (maxInputs) => SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });
function callResultToScriptResult(callResult) {
  const receipts = [...callResult.receipts];
  let scriptResultReceipt;
  let returnReceipt;
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.ScriptResult) {
      scriptResultReceipt = receipt;
    } else if (receipt.type === ReceiptType.Return || receipt.type === ReceiptType.ReturnData || receipt.type === ReceiptType.Revert) {
      returnReceipt = receipt;
    }
  });
  if (!scriptResultReceipt || !returnReceipt) {
    throw new FuelError(ErrorCode$1.SCRIPT_REVERTED, `Transaction reverted.`);
  }
  const scriptResult = {
    code: scriptResultReceipt.result,
    gasUsed: scriptResultReceipt.gasUsed,
    receipts,
    scriptResultReceipt,
    returnReceipt,
    callResult
  };
  return scriptResult;
}
function decodeCallResult(callResult, decoder, logs = []) {
  var _a2;
  try {
    const scriptResult = callResultToScriptResult(callResult);
    return decoder(scriptResult);
  } catch (error) {
    if (error.code === ErrorCode$1.SCRIPT_REVERTED) {
      const statusReason = (_a2 = callResult == null ? void 0 : callResult.dryRunStatus) == null ? void 0 : _a2.reason;
      throw extractTxError({
        logs,
        receipts: callResult.receipts,
        statusReason
      });
    }
    throw error;
  }
}
function callResultToInvocationResult(callResult, call2, logs) {
  return decodeCallResult(
    callResult,
    (scriptResult) => {
      if (scriptResult.returnReceipt.type === ReceiptType.Revert) {
        throw new FuelError(
          ErrorCode$1.SCRIPT_REVERTED,
          `Script Reverted. Logs: ${JSON.stringify(logs)}`
        );
      }
      if (scriptResult.returnReceipt.type !== ReceiptType.Return && scriptResult.returnReceipt.type !== ReceiptType.ReturnData) {
        const { type: type3 } = scriptResult.returnReceipt;
        throw new FuelError(
          ErrorCode$1.SCRIPT_REVERTED,
          `Script Return Type [${type3}] Invalid. Logs: ${JSON.stringify({
            logs,
            receipt: scriptResult.returnReceipt
          })}`
        );
      }
      let value2;
      if (scriptResult.returnReceipt.type === ReceiptType.Return) {
        value2 = scriptResult.returnReceipt.val;
      }
      if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {
        const decoded = call2.func.decodeOutput(scriptResult.returnReceipt.data);
        value2 = decoded[0];
      }
      return value2;
    },
    logs
  );
}
var ScriptRequest = class {
  /**
   * Creates an instance of the ScriptRequest class.
   *
   * @param bytes - The bytes of the script.
   * @param scriptDataEncoder - The script data encoder function.
   * @param scriptResultDecoder - The script result decoder function.
   */
  constructor(bytes2, scriptDataEncoder, scriptResultDecoder2) {
    /**
     * The bytes of the script.
     */
    __publicField(this, "bytes");
    /**
     * A function to encode the script data.
     */
    __publicField(this, "scriptDataEncoder");
    /**
     * A function to decode the script result.
     */
    __publicField(this, "scriptResultDecoder");
    this.bytes = arrayify$1(bytes2);
    this.scriptDataEncoder = scriptDataEncoder;
    this.scriptResultDecoder = scriptResultDecoder2;
  }
  /**
   * Gets the script data offset for the given bytes.
   *
   * @param byteLength - The byte length of the script.
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  static getScriptDataOffsetWithScriptBytes(byteLength2, maxInputs) {
    const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;
    return scriptDataBaseOffset + byteLength2;
  }
  /**
   * Gets the script data offset.
   *
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  getScriptDataOffset(maxInputs) {
    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
  }
  /**
   * Encodes the data for a script call.
   *
   * @param data - The script data.
   * @returns The encoded data.
   */
  encodeScriptData(data2) {
    const callScript = this.scriptDataEncoder(data2);
    if (ArrayBuffer.isView(callScript)) {
      return callScript;
    }
    this.bytes = arrayify$1(callScript.script);
    return callScript.data;
  }
  /**
   * Decodes the result of a script call.
   *
   * @param callResult - The CallResult from the script call.
   * @param logs - Optional logs associated with the decoding.
   * @returns The decoded result.
   */
  decodeCallResult(callResult, logs = []) {
    return decodeCallResult(callResult, this.scriptResultDecoder, logs);
  }
};
var DEFAULT_OPCODE_PARAMS = {
  assetIdOffset: 0,
  amountOffset: 0,
  gasForwardedOffset: 0,
  callDataOffset: 0
};
var SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;
var getSingleCallInstructions = ({
  callDataOffset,
  gasForwardedOffset,
  amountOffset,
  assetIdOffset
}) => {
  const inst = new InstructionSet(
    movi(16, callDataOffset),
    movi(17, amountOffset),
    lw(17, 17, 0),
    movi(18, assetIdOffset)
  );
  if (gasForwardedOffset) {
    inst.push(
      movi(19, gasForwardedOffset),
      lw(19, 19, 0),
      call(16, 17, 18, 19)
    );
  } else {
    inst.push(call(16, 17, 18, RegId.cgas().to_u8()));
  }
  return inst;
};
function getInstructions(offsets) {
  if (!offsets.length) {
    return new Uint8Array();
  }
  const multiCallInstructions = new InstructionSet();
  for (let i2 = 0; i2 < offsets.length; i2 += 1) {
    multiCallInstructions.extend(getSingleCallInstructions(offsets[i2]).entries());
  }
  multiCallInstructions.push(ret(1));
  return multiCallInstructions.toBytes();
}
var isReturnType = (type3) => type3 === ReceiptType.Return || type3 === ReceiptType.ReturnData;
var getMainCallReceipt = (receipts, contractId2) => receipts.find(
  ({ type: type3, from: from2, to: to2 }) => type3 === ReceiptType.Call && from2 === SCRIPT_WRAPPER_CONTRACT_ID && to2 === contractId2
);
var scriptResultDecoder = (contractId2) => (result) => {
  if (toNumber(result.code) !== 0) {
    throw new FuelError(ErrorCode$1.SCRIPT_REVERTED, `Transaction reverted.`);
  }
  const mainCallResult = getMainCallReceipt(
    result.receipts,
    contractId2.toB256()
  );
  const mainCallInstructionStart = bn$1(mainCallResult == null ? void 0 : mainCallResult.is);
  const receipts = result.receipts;
  return receipts.filter(({ type: type3 }) => isReturnType(type3)).flatMap((receipt) => {
    if (!mainCallInstructionStart.eq(bn$1(receipt.is))) {
      return [];
    }
    if (receipt.type === ReceiptType.Return) {
      return [new BigNumberCoder("u64").encode(receipt.val)];
    }
    if (receipt.type === ReceiptType.ReturnData) {
      const encodedScriptReturn = arrayify$1(receipt.data);
      return [encodedScriptReturn];
    }
    return [new Uint8Array()];
  });
};
var decodeContractCallScriptResult = (callResult, contractId2, logs = []) => decodeCallResult(callResult, scriptResultDecoder(contractId2), logs);
var getCallInstructionsLength = (contractCalls) => contractCalls.reduce(
  (sum, call2) => {
    const offset2 = { ...DEFAULT_OPCODE_PARAMS };
    if (call2.gas) {
      offset2.gasForwardedOffset = 1;
    }
    return sum + getSingleCallInstructions(offset2).byteLength();
  },
  Instruction.size()
  // placeholder for single RET instruction which is added later
);
var getContractCallScript = (functionScopes, maxInputs) => new ScriptRequest(
  // Script to call the contract, start with stub size matching length of calls
  getInstructions(new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS)),
  (contractCalls) => {
    var _a2;
    const TOTAL_CALLS = contractCalls.length;
    if (TOTAL_CALLS === 0) {
      return { data: new Uint8Array(), script: new Uint8Array() };
    }
    const callInstructionsLength = getCallInstructionsLength(contractCalls);
    const paddingLength = (8 - callInstructionsLength % 8) % 8;
    const paddedInstructionsLength = callInstructionsLength + paddingLength;
    const dataOffset = calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;
    const paramOffsets = [];
    let segmentOffset = dataOffset;
    const scriptData = [];
    for (let i2 = 0; i2 < TOTAL_CALLS; i2 += 1) {
      const call2 = contractCalls[i2];
      const amountOffset = segmentOffset;
      const assetIdOffset = amountOffset + WORD_SIZE;
      const callDataOffset = assetIdOffset + ASSET_ID_LEN;
      const encodedSelectorOffset = callDataOffset + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
      const encodedArgsOffset = encodedSelectorOffset + call2.fnSelectorBytes.byteLength;
      const encodedArgs = arrayify$1(call2.data);
      let gasForwardedOffset = 0;
      scriptData.push(new BigNumberCoder("u64").encode(call2.amount || 0));
      scriptData.push(new B256Coder().encode(((_a2 = call2.assetId) == null ? void 0 : _a2.toString()) || ZeroBytes32));
      scriptData.push(call2.contractId.toBytes());
      scriptData.push(new BigNumberCoder("u64").encode(encodedSelectorOffset));
      scriptData.push(new BigNumberCoder("u64").encode(encodedArgsOffset));
      scriptData.push(call2.fnSelectorBytes);
      scriptData.push(encodedArgs);
      if (call2.gas) {
        scriptData.push(new BigNumberCoder("u64").encode(call2.gas));
        gasForwardedOffset = encodedArgsOffset + encodedArgs.byteLength;
      }
      const callParamOffsets = {
        amountOffset,
        assetIdOffset,
        gasForwardedOffset,
        callDataOffset
      };
      paramOffsets.push(callParamOffsets);
      segmentOffset = dataOffset + concat(scriptData).byteLength;
    }
    const script = getInstructions(paramOffsets);
    const finalScriptData = concat(scriptData);
    return { data: finalScriptData, script };
  },
  () => [new Uint8Array()]
);
var extractInvocationResult = (functionScopes, receipts, isMultiCall, logs) => {
  var _a2;
  const mainCallConfig = (_a2 = functionScopes[0]) == null ? void 0 : _a2.getCallConfig();
  if (functionScopes.length === 1 && mainCallConfig && "bytes" in mainCallConfig.program) {
    return callResultToInvocationResult({ receipts }, mainCallConfig, logs);
  }
  const encodedResults = decodeContractCallScriptResult(
    { receipts },
    (mainCallConfig == null ? void 0 : mainCallConfig.program).id,
    logs
  );
  const decodedResults = encodedResults.map((encodedResult, i2) => {
    var _a3;
    const { func } = functionScopes[i2].getCallConfig();
    return (_a3 = func.decodeOutput(encodedResult)) == null ? void 0 : _a3[0];
  });
  return isMultiCall ? decodedResults : decodedResults == null ? void 0 : decodedResults[0];
};
var buildFunctionResult = async (params) => {
  var _a2;
  const { funcScope, isMultiCall, program, transactionResponse } = params;
  const txResult = await transactionResponse.waitForResult();
  const { receipts } = txResult;
  const functionScopes = Array.isArray(funcScope) ? funcScope : [funcScope];
  const mainCallConfig = (_a2 = functionScopes[0]) == null ? void 0 : _a2.getCallConfig();
  const logs = getResultLogs(receipts, mainCallConfig, functionScopes);
  const value2 = extractInvocationResult(functionScopes, receipts, isMultiCall, logs);
  const gasUsed = getGasUsedFromReceipts(receipts);
  const submitResult = {
    isMultiCall,
    functionScopes,
    value: value2,
    program,
    transactionResult: txResult,
    transactionResponse,
    transactionId: transactionResponse.id,
    logs,
    gasUsed
  };
  return submitResult;
};
var buildDryRunResult = (params) => {
  var _a2;
  const { funcScopes, callResult, isMultiCall } = params;
  const { receipts } = callResult;
  const functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];
  const mainCallConfig = (_a2 = functionScopes[0]) == null ? void 0 : _a2.getCallConfig();
  const logs = getResultLogs(receipts, mainCallConfig, functionScopes);
  const value2 = extractInvocationResult(functionScopes, receipts, isMultiCall, logs);
  const gasUsed = getGasUsedFromReceipts(receipts);
  const submitResult = {
    functionScopes,
    callResult,
    isMultiCall,
    gasUsed,
    value: value2
  };
  return submitResult;
};
function createContractCall(funcScope) {
  const { program, args, forward, func, callParameters, externalAbis } = funcScope.getCallConfig();
  const data2 = func.encodeArguments(args);
  return {
    contractId: program.id,
    fnSelectorBytes: func.selectorBytes,
    data: data2,
    assetId: forward == null ? void 0 : forward.assetId,
    amount: forward == null ? void 0 : forward.amount,
    gas: callParameters == null ? void 0 : callParameters.gasLimit,
    externalContractsAbis: externalAbis
  };
}
var BaseInvocationScope = class {
  /**
   * Constructs an instance of BaseInvocationScope.
   *
   * @param program - The abstract program to be invoked.
   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
   */
  constructor(program, isMultiCall) {
    __publicField(this, "transactionRequest");
    __publicField(this, "program");
    __publicField(this, "functionInvocationScopes", []);
    __publicField(this, "txParameters");
    __publicField(this, "requiredCoins", []);
    __publicField(this, "isMultiCall", false);
    __publicField(this, "hasCallParamsGasLimit", false);
    // flag to check if any of the callParams has gasLimit set
    __publicField(this, "externalAbis", {});
    __publicField(this, "addSignersCallback");
    this.program = program;
    this.isMultiCall = isMultiCall;
    this.transactionRequest = new ScriptTransactionRequest();
  }
  /**
   * Getter for the contract calls.
   *
   * @returns An array of contract calls.
   */
  get calls() {
    const provider = this.getProvider();
    const consensusParams = provider.getChain();
    if (!consensusParams) {
      throw new FuelError(
        FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
        "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``"
      );
    }
    return this.functionInvocationScopes.map((funcScope) => createContractCall(funcScope));
  }
  /**
   * Updates the script request with the current contract calls.
   */
  updateScriptRequest() {
    const provider = this.getProvider();
    const {
      consensusParameters: {
        txParameters: { maxInputs }
      }
    } = provider.getChain();
    const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);
    this.transactionRequest.setScript(contractCallScript, this.calls);
  }
  /**
   * Updates the transaction request with the current input/output.
   */
  updateContractInputAndOutput() {
    const calls = this.calls;
    calls.forEach((c2) => {
      if (c2.contractId) {
        this.transactionRequest.addContractInputAndOutput(c2.contractId);
      }
      if (c2.externalContractsAbis) {
        Object.keys(c2.externalContractsAbis).forEach(
          (contractId2) => this.transactionRequest.addContractInputAndOutput(Address.fromB256(contractId2))
        );
      }
    });
  }
  /**
   * Gets the required coins for the transaction.
   *
   * @returns An array of required coin quantities.
   */
  getRequiredCoins() {
    const forwardingAssets = this.calls.map((call2) => ({
      assetId: String(call2.assetId),
      amount: bn$1(call2.amount || 0)
    })).filter(({ assetId, amount }) => assetId && !bn$1(amount).isZero());
    return forwardingAssets;
  }
  /**
   * Updates the required coins for the transaction.
   */
  updateRequiredCoins() {
    const assets = this.getRequiredCoins();
    const reduceForwardCoins = (requiredCoins, { assetId, amount }) => {
      var _a2;
      const currentAmount = ((_a2 = requiredCoins.get(assetId)) == null ? void 0 : _a2.amount) || bn$1(0);
      return requiredCoins.set(assetId, {
        assetId: String(assetId),
        amount: currentAmount.add(amount)
      });
    };
    this.requiredCoins = Array.from(
      assets.reduce(reduceForwardCoins, /* @__PURE__ */ new Map()).values()
    );
  }
  /**
   * Adds a single call to the invocation scope.
   *
   * @param funcScope - The function scope to add.
   * @returns The current instance of the class.
   */
  addCall(funcScope) {
    this.addCalls([funcScope]);
    return this;
  }
  /**
   * Adds multiple calls to the invocation scope.
   *
   * @param funcScopes - An array of function scopes to add.
   * @returns The current instance of the class.
   */
  addCalls(funcScopes) {
    this.functionInvocationScopes.push(...funcScopes);
    this.updateContractInputAndOutput();
    this.updateRequiredCoins();
    return this;
  }
  /**
   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
   */
  async prepareTransaction() {
    await initWasm();
    this.updateScriptRequest();
    this.updateRequiredCoins();
    this.checkGasLimitTotal();
    if (this.transactionRequest.type === TransactionType.Script) {
      this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);
    }
  }
  /**
   * Checks if the total gas limit is within the acceptable range.
   */
  checkGasLimitTotal() {
    const gasLimitOnCalls = this.calls.reduce((total, call2) => total.add(call2.gas || 0), bn$1(0));
    if (this.transactionRequest.gasLimit.eq(0)) {
      this.transactionRequest.gasLimit = gasLimitOnCalls;
    } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {
      throw new FuelError(
        ErrorCode$1.TRANSACTION_ERROR,
        "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
      );
    }
  }
  /**
   * Gets the transaction cost for dry running the transaction.
   *
   * @param options - Optional transaction cost options.
   * @returns The transaction cost details.
   */
  async getTransactionCost() {
    const request = clone$1(await this.getTransactionRequest());
    const account = this.program.account ?? Wallet.generate({ provider: this.getProvider() });
    return account.getTransactionCost(request, {
      quantities: this.getRequiredCoins(),
      signatureCallback: this.addSignersCallback
    });
  }
  /**
   * Funds the transaction with the required coins.
   *
   * @returns The current instance of the class.
   */
  async fundWithRequiredCoins() {
    var _a2;
    let transactionRequest = await this.getTransactionRequest();
    transactionRequest = clone$1(transactionRequest);
    const txCost = await this.getTransactionCost();
    const { gasUsed, missingContractIds, outputVariables, maxFee } = txCost;
    this.setDefaultTxParams(transactionRequest, gasUsed, maxFee);
    transactionRequest.inputs = transactionRequest.inputs.filter((i2) => i2.type !== InputType.Coin);
    missingContractIds.forEach((contractId2) => {
      transactionRequest.addContractInputAndOutput(Address.fromString(contractId2));
    });
    transactionRequest.addVariableOutputs(outputVariables);
    await ((_a2 = this.program.account) == null ? void 0 : _a2.fund(transactionRequest, txCost));
    if (this.addSignersCallback) {
      await this.addSignersCallback(transactionRequest);
    }
    return transactionRequest;
  }
  /**
   * Sets the transaction parameters.
   *
   * @param txParams - The transaction parameters to set.
   * @returns The current instance of the class.
   */
  txParams(txParams) {
    var _a2;
    this.txParameters = txParams;
    const request = this.transactionRequest;
    request.tip = bn$1(txParams.tip || request.tip);
    request.gasLimit = bn$1(txParams.gasLimit || request.gasLimit);
    request.maxFee = txParams.maxFee ? bn$1(txParams.maxFee) : request.maxFee;
    request.witnessLimit = txParams.witnessLimit ? bn$1(txParams.witnessLimit) : request.witnessLimit;
    request.maturity = txParams.maturity || request.maturity;
    request.addVariableOutputs(((_a2 = this.txParameters) == null ? void 0 : _a2.variableOutputs) || 0);
    return this;
  }
  /**
   * Adds contracts to the invocation scope.
   *
   * @param contracts - An array of contracts to add.
   * @returns The current instance of the class.
   */
  addContracts(contracts) {
    contracts.forEach((contract) => {
      this.transactionRequest.addContractInputAndOutput(contract.id);
      this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;
    });
    return this;
  }
  /**
   * Adds an asset transfer to an Account on the contract call transaction request.
   *
   * @param transferParams - The object representing the transfer to be made.
   * @returns The current instance of the class.
   */
  addTransfer(transferParams) {
    const { amount, destination, assetId } = transferParams;
    const baseAssetId = this.getProvider().getBaseAssetId();
    this.transactionRequest = this.transactionRequest.addCoinOutput(
      Address.fromAddressOrString(destination),
      amount,
      assetId || baseAssetId
    );
    return this;
  }
  /**
   * Adds multiple transfers to the contract call transaction request.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The current instance of the class.
   */
  addBatchTransfer(transferParams) {
    const baseAssetId = this.getProvider().getBaseAssetId();
    transferParams.forEach(({ destination, amount, assetId }) => {
      this.transactionRequest = this.transactionRequest.addCoinOutput(
        Address.fromAddressOrString(destination),
        amount,
        assetId || baseAssetId
      );
    });
    return this;
  }
  addSigners(signers) {
    this.addSignersCallback = async (transactionRequest) => transactionRequest.addAccountWitnesses(signers);
    return this;
  }
  /**
   * Prepares and returns the transaction request object.
   *
   * @returns The prepared transaction request.
   */
  async getTransactionRequest() {
    await this.prepareTransaction();
    return this.transactionRequest;
  }
  /**
   * Submits the contract call transaction and returns a promise that resolves to an object
   * containing the transaction ID and a function to wait for the result. The promise will resolve
   * as soon as the transaction is submitted to the node.
   *
   * @returns A promise that resolves to an object containing:
   * - `transactionId`: The ID of the submitted transaction.
   * - `waitForResult`: A function that waits for the transaction result.
   * @template T - The type of the return value.
   */
  async call() {
    assert$8(this.program.account, "Wallet is required!");
    const transactionRequest = await this.fundWithRequiredCoins();
    const response = await this.program.account.sendTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
    const transactionId = response.id;
    return {
      transactionId,
      waitForResult: async () => buildFunctionResult({
        funcScope: this.functionInvocationScopes,
        isMultiCall: this.isMultiCall,
        program: this.program,
        transactionResponse: response
      })
    };
  }
  /**
   * Simulates a transaction.
   *
   * @returns The result of the invocation call.
   */
  async simulate() {
    assert$8(this.program.account, "Wallet is required!");
    if (!("populateTransactionWitnessesSignature" in this.program.account)) {
      throw new FuelError(
        ErrorCode$1.ABI_MAIN_METHOD_MISSING,
        "An unlocked wallet is required to simulate a contract call."
      );
    }
    const transactionRequest = await this.fundWithRequiredCoins();
    const callResult = await this.program.account.simulateTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
    return buildDryRunResult({
      funcScopes: this.functionInvocationScopes,
      callResult,
      isMultiCall: this.isMultiCall
    });
  }
  /**
   * Executes a transaction in dry run mode.
   *
   * @returns The result of the invocation call.
   */
  async dryRun() {
    const { receipts } = await this.getTransactionCost();
    const callResult = {
      receipts
    };
    return buildDryRunResult({
      funcScopes: this.functionInvocationScopes,
      callResult,
      isMultiCall: this.isMultiCall
    });
  }
  async get() {
    const { receipts } = await this.getTransactionCost();
    const callResult = {
      receipts
    };
    return buildDryRunResult({
      funcScopes: this.functionInvocationScopes,
      callResult,
      isMultiCall: this.isMultiCall
    });
  }
  getProvider() {
    const provider = this.program.provider;
    return provider;
  }
  /**
   * Obtains the ID of a transaction.
   *
   * @param chainId - the chainId to use to hash the transaction with
   * @returns the ID of the transaction.
   */
  async getTransactionId(chainId) {
    const chainIdToHash = chainId ?? await this.getProvider().getChainId();
    const transactionRequest = await this.getTransactionRequest();
    return transactionRequest.getTransactionId(chainIdToHash);
  }
  /**
   * In case the gasLimit is *not* set by the user, this method sets a default value.
   */
  setDefaultTxParams(transactionRequest, gasUsed, maxFee) {
    var _a2, _b2;
    const gasLimitSpecified = isDefined((_a2 = this.txParameters) == null ? void 0 : _a2.gasLimit) || this.hasCallParamsGasLimit;
    const maxFeeSpecified = isDefined((_b2 = this.txParameters) == null ? void 0 : _b2.maxFee);
    const { gasLimit: setGasLimit, maxFee: setMaxFee } = transactionRequest;
    if (!gasLimitSpecified) {
      transactionRequest.gasLimit = gasUsed;
    } else if (setGasLimit.lt(gasUsed)) {
      throw new FuelError(
        ErrorCode$1.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
    if (!maxFeeSpecified) {
      transactionRequest.maxFee = maxFee;
    } else if (maxFee.gt(setMaxFee)) {
      throw new FuelError(
        ErrorCode$1.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
      );
    }
  }
};
var FunctionInvocationScope = class extends BaseInvocationScope {
  /**
   * Constructs an instance of FunctionInvocationScope.
   *
   * @param program - The program.
   * @param func - The function fragment.
   * @param args - The arguments.
   */
  constructor(program, func, args) {
    super(program, false);
    __publicField(this, "func");
    __publicField(this, "callParameters");
    __publicField(this, "forward");
    __publicField(this, "args");
    this.func = func;
    this.args = args || [];
    this.setArguments(...args);
    super.addCall(this);
  }
  /**
   * Gets the call configuration.
   *
   * @returns The call configuration.
   */
  getCallConfig() {
    return {
      func: this.func,
      program: this.program,
      callParameters: this.callParameters,
      txParameters: this.txParameters,
      forward: this.forward,
      args: this.args,
      externalAbis: this.externalAbis
    };
  }
  /**
   * Sets the arguments for the function invocation.
   *
   * @param args - The arguments.
   * @returns The instance of FunctionInvocationScope.
   */
  setArguments(...args) {
    this.args = args || [];
    return this;
  }
  /**
   * Sets the call parameters for the function invocation.
   *
   * @param callParams - The call parameters.
   * @returns The instance of FunctionInvocationScope.
   * @throws If the function is not payable and forward is set.
   */
  callParams(callParams) {
    if (!this.hasCallParamsGasLimit && (callParams == null ? void 0 : callParams.gasLimit) !== void 0) {
      this.hasCallParamsGasLimit = true;
    }
    this.callParameters = callParams;
    if (callParams == null ? void 0 : callParams.forward) {
      if (!this.func.attributes.find((attr) => attr.name === "payable")) {
        throw new FuelError(
          ErrorCode$1.TRANSACTION_ERROR,
          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
        );
      }
      this.forward = coinQuantityfy(callParams.forward);
    }
    this.setArguments(...this.args);
    this.updateRequiredCoins();
    return this;
  }
};
var MultiCallInvocationScope = class extends BaseInvocationScope {
  /**
   * Constructs an instance of MultiCallInvocationScope.
   *
   * @param contract - The contract.
   * @param funcScopes - An array of function invocation scopes.
   */
  constructor(contract, funcScopes) {
    super(contract, true);
    this.addCalls(funcScopes);
  }
  /**
   * Adds a single function invocation scope to the multi-call invocation scope.
   *
   * @param funcScope - The function invocation scope.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCall(funcScope) {
    return super.addCalls([funcScope]);
  }
  /**
   * Adds multiple function invocation scopes to the multi-call invocation scope.
   *
   * @param funcScopes - An array of function invocation scopes.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCalls(funcScopes) {
    return super.addCalls(funcScopes);
  }
};
var Contract = class {
  /**
   * Creates an instance of the Contract class.
   *
   * @param id - The contract's address.
   * @param abi - The contract's ABI (JSON ABI or Interface instance).
   * @param accountOrProvider - The account or provider for interaction.
   */
  constructor(id2, abi, accountOrProvider) {
    /**
     * The unique contract identifier.
     */
    __publicField(this, "id");
    /**
     * The provider for interacting with the contract.
     */
    __publicField(this, "provider");
    /**
     * The contract's ABI interface.
     */
    __publicField(this, "interface");
    /**
     * The account associated with the contract, if available.
     */
    __publicField(this, "account");
    /**
     * A collection of functions available on the contract.
     */
    __publicField(this, "functions", {});
    this.interface = abi instanceof Interface ? abi : new Interface(abi);
    this.id = Address.fromAddressOrString(id2);
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
    Object.keys(this.interface.functions).forEach((name) => {
      const fragment = this.interface.getFunction(name);
      Object.defineProperty(this.functions, fragment.name, {
        value: this.buildFunction(fragment),
        writable: false
      });
    });
  }
  /**
   * Build a function invocation scope for the provided function fragment.
   *
   * @param func - The function fragment to build a scope for.
   * @returns A function that creates a FunctionInvocationScope.
   */
  buildFunction(func) {
    return (() => {
      const funcInvocationScopeCreator = (...args) => new FunctionInvocationScope(this, func, args);
      Object.defineProperty(funcInvocationScopeCreator, "isReadOnly", {
        value: () => func.isReadOnly(),
        writable: false
      });
      return funcInvocationScopeCreator;
    })();
  }
  /**
   * Create a multi-call invocation scope for the provided function invocation scopes.
   *
   * @param calls - An array of FunctionInvocationScopes to execute in a batch.
   * @returns A MultiCallInvocationScope instance.
   */
  multiCall(calls) {
    return new MultiCallInvocationScope(this, calls);
  }
  /**
   * Get the balance for a given asset ID for this contract.
   *
   * @param assetId - The specified asset ID.
   * @returns The balance of the contract for the specified asset.
   */
  // #region contract-balance-1
  getBalance(assetId) {
    return this.provider.getContractBalance(this.id, assetId);
  }
  // #endregion contract-balance-1
};
var ScriptInvocationScope = class extends FunctionInvocationScope {
  constructor() {
    super(...arguments);
    __publicField(this, "scriptRequest");
  }
  updateScriptRequest() {
    if (!this.scriptRequest) {
      this.buildScriptRequest();
    }
    this.transactionRequest.setScript(this.scriptRequest, this.args);
  }
  buildScriptRequest() {
    const programBytes = this.program.bytes;
    const chainInfoCache = this.program.provider.getChain();
    if (!chainInfoCache) {
      throw new FuelError(
        FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
        "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()`"
      );
    }
    this.scriptRequest = new ScriptRequest(
      programBytes,
      (args) => this.func.encodeArguments(args),
      () => []
    );
  }
};
var Script = class extends AbstractScript {
  /**
   * Create a new instance of the Script class.
   *
   * @param bytecode - The compiled bytecode of the script.
   * @param abi - The ABI interface for the script.
   * @param account - The account associated with the script.
   */
  constructor(bytecode, abi, account) {
    super();
    /**
     * The compiled bytecode of the script.
     */
    __publicField(this, "bytes");
    /**
     * The ABI interface for the script.
     */
    __publicField(this, "interface");
    /**
     * The account associated with the script.
     */
    __publicField(this, "account");
    /**
     * The script request object.
     */
    __publicField(this, "script");
    /**
     * The provider used for interacting with the network.
     */
    __publicField(this, "provider");
    /**
     * Functions that can be invoked within the script.
     */
    __publicField(this, "functions");
    this.bytes = arrayify$1(bytecode);
    this.interface = new Interface(abi);
    this.provider = account.provider;
    this.account = account;
    this.functions = {
      main: (...args) => new ScriptInvocationScope(this, this.interface.getFunction("main"), args)
    };
  }
  /**
   * Set the configurable constants of the script.
   *
   * @param configurables - An object containing the configurable constants and their values.
   * @throws Will throw an error if the script has no configurable constants to be set or if an invalid constant is provided.
   * @returns This instance of the `Script`.
   */
  setConfigurableConstants(configurables) {
    try {
      if (!Object.keys(this.interface.configurables).length) {
        throw new Error(`The script does not have configurable constants to be set`);
      }
      Object.entries(configurables).forEach(([key, value2]) => {
        if (!this.interface.configurables[key]) {
          throw new Error(`The script does not have a configurable constant named: '${key}'`);
        }
        const { offset: offset2 } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value2);
        this.bytes.set(encoded, offset2);
      });
    } catch (err) {
      throw new FuelError(
        ErrorCode$1.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${err.message}.`
      );
    }
    return this;
  }
};
new ScriptRequest(
  /*
    Opcode::RET(REG_ZERO)
    Opcode::NOOP
  */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  "0x24000000",
  () => new Uint8Array(0),
  () => void 0
);
var __defProp2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var util_exports = {};
__export(util_exports, {
  MAX_CONTRACT_SIZE: () => MAX_CONTRACT_SIZE,
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
var MAX_CONTRACT_SIZE = 102400;
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes2 = arrayify$1(bytecode);
  const chunks = chunkAndPadBytes(bytes2, chunkSize);
  return calcRoot(chunks.map((c2) => hexlify(c2)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new SparseMerkleTree();
  storageSlots.forEach(({ key, value: value2 }) => tree.update(sha256$2(key), value2));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot(arrayify$1(bytecode));
  const contractId2 = sha256$2(concat(["0x4655454C", salt, root, stateRoot]));
  return contractId2;
};
var hexlifyWithPrefix = (value2) => hexlify(value2.startsWith("0x") ? value2 : `0x${value2}`);
var ContractFactory = class {
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(bytecode, abi, accountOrProvider = null) {
    __publicField(this, "bytecode");
    __publicField(this, "interface");
    __publicField(this, "provider");
    __publicField(this, "account");
    this.bytecode = arrayify$1(bytecode);
    if (abi instanceof Interface) {
      this.interface = abi;
    } else {
      this.interface = new Interface(abi);
    }
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(provider) {
    return new ContractFactory(this.bytecode, this.interface, provider);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(deployContractOptions) {
    var _a2;
    const storageSlots = (_a2 = deployContractOptions == null ? void 0 : deployContractOptions.storageSlots) == null ? void 0 : _a2.map(({ key, value: value2 }) => ({
      key: hexlifyWithPrefix(key),
      value: hexlifyWithPrefix(value2)
    })).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
    const options = {
      salt: randomBytes2(32),
      ...deployContractOptions,
      storageSlots: storageSlots || []
    };
    if (!this.provider) {
      throw new FuelError(
        ErrorCode$1.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    }
    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
    const contractId2 = getContractId(this.bytecode, options.salt, stateRoot);
    const transactionRequest = new CreateTransactionRequest({
      bytecodeWitnessIndex: 0,
      witnesses: [this.bytecode],
      ...options
    });
    transactionRequest.addContractCreatedOutput(contractId2, stateRoot);
    return {
      contractId: contractId2,
      transactionRequest
    };
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployContract(deployContractOptions = {}) {
    if (this.bytecode.length > MAX_CONTRACT_SIZE) {
      throw new FuelError(
        ErrorCode$1.CONTRACT_SIZE_EXCEEDS_LIMIT,
        "Contract bytecode is too large. Max contract size is 100KB"
      );
    }
    const { contractId: contractId2, transactionRequest } = await this.prepareDeploy(deployContractOptions);
    const account = this.getAccount();
    const transactionResponse = await account.sendTransaction(transactionRequest);
    const waitForResult = async () => {
      const transactionResult = await transactionResponse.waitForResult();
      const contract = new Contract(contractId2, this.interface, account);
      return { contract, transactionResult };
    };
    return { waitForResult, contractId: contractId2, transactionId: transactionResponse.id };
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(configurableConstants) {
    try {
      const hasConfigurable = Object.keys(this.interface.configurables).length;
      if (!hasConfigurable) {
        throw new Error("Contract does not have configurables to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value2]) => {
        if (!this.interface.configurables[key]) {
          throw new Error(`Contract does not have a configurable named: '${key}'`);
        }
        const { offset: offset2 } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value2);
        const bytes2 = arrayify$1(this.bytecode);
        bytes2.set(encoded, offset2);
        this.bytecode = bytes2;
      });
    } catch (err) {
      throw new FuelError(
        ErrorCode$1.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${err.message}.`
      );
    }
  }
  getAccount() {
    if (!this.account) {
      throw new FuelError(ErrorCode$1.ACCOUNT_REQUIRED, "Account not assigned to contract.");
    }
    return this.account;
  }
  async prepareDeploy(deployContractOptions) {
    const { configurableConstants } = deployContractOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const { contractId: contractId2, transactionRequest } = this.createTransactionRequest(deployContractOptions);
    const account = this.getAccount();
    const txCost = await account.getTransactionCost(transactionRequest);
    const { maxFee: setMaxFee } = deployContractOptions;
    if (isDefined(setMaxFee)) {
      if (txCost.maxFee.gt(setMaxFee)) {
        throw new FuelError(
          ErrorCode$1.MAX_FEE_TOO_LOW,
          `Max fee '${deployContractOptions.maxFee}' is lower than the required: '${txCost.maxFee}'.`
        );
      }
    } else {
      transactionRequest.maxFee = txCost.maxFee;
    }
    await account.fund(transactionRequest, txCost);
    return {
      contractId: contractId2,
      transactionRequest
    };
  }
};
var LOCAL_NETWORK_URL = "http://127.0.0.1:4000/v1/graphql";
typeof process !== "undefined" ? ((_r2 = process == null ? void 0 : process.env) == null ? void 0 : _r2.FUEL_NETWORK_URL) || LOCAL_NETWORK_URL : LOCAL_NETWORK_URL;
var define_process_env_default$2 = { GITHUB_STATE: "/home/runner/work/_temp/_runner_file_commands/save_state_f718650a-ff98-4302-80d8-5fcdb4473af9", DEPLOYMENT_BASEPATH: "/opt/runner", DOTNET_NOLOGO: "1", STATS_TRP: "true", USER: "runner", npm_config_user_agent: "pnpm/8.15.7 npm/? node/v18.20.4 linux x64", CI: "true", VITE_APP_WC_PROJECT_ID: "e64002d84b020b9ae5eda323dd191093", npm_package_scripts_fuels_build: "fuels build", GITHUB_ENV: "/home/runner/work/_temp/_runner_file_commands/set_env_f718650a-ff98-4302-80d8-5fcdb4473af9", PIPX_HOME: "/opt/pipx", RUNNER_ENVIRONMENT: "github-hosted", npm_package_dependencies__fuels_connectors: "0.25.0", npm_package_devDependencies_vite: "^5.3.4", npm_node_execpath: "/usr/local/bin/node", JAVA_HOME_8_X64: "/usr/lib/jvm/temurin-8-jdk-amd64", SHLVL: "1", npm_package_scripts_fuels_typegen: "fuels typegen -i ./sway-programs/contract/out/debug/test-contract-abi.json -o ./src/sway-api/contracts", HOME: "/home/runner", VITE_PUBLIC_TESTNET_COUNTER_CONTRACT_ID: "0xd9377acd88d5ea4c498770b5210dad7ea87992652e2867d2713efc542caebb22", npm_package_devDependencies__typescript_eslint_parser: "^7.15.0", GITHUB_EVENT_PATH: "/home/runner/work/_temp/_github_workflow/event.json", RUNNER_TEMP: "/home/runner/work/_temp", npm_package_scripts_build_all: "NODE_ENV=production run-s build", npm_package_devDependencies_vite_plugin_static_copy: "^1.0.1", GITHUB_REPOSITORY_OWNER: "FuelLabs", JAVA_HOME_11_X64: "/usr/lib/jvm/temurin-11-jdk-amd64", PIPX_BIN_DIR: "/opt/pipx_bin", npm_config_auto_install_peers: "true", ANDROID_NDK_LATEST_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_RETENTION_DAYS: "90", GRADLE_HOME: "/usr/share/gradle-8.10", JAVA_HOME_21_X64: "/usr/lib/jvm/temurin-21-jdk-amd64", STATS_RDCL: "true", AZURE_EXTENSION_DIR: "/opt/az/azcliextensions", GITHUB_HEAD_REF: "rishabh/counter", GITHUB_REPOSITORY_OWNER_ID: "55993183", POWERSHELL_DISTRIBUTION_CHANNEL: "GitHub-Actions-ubuntu22", NFT_DIST: "/home/runner/work/sway-examples/sway-examples/dist/nft/", SYSTEMD_EXEC_PID: "471", npm_package_scripts_fuels_run: "run-s fuels:build fuels:typegen fuels:deploy", npm_package_scripts_fuels_deploy: "fuels deploy", npm_package_dependencies_dotenv: "^16.4.5", npm_package_devDependencies_eslint_plugin_react_hooks: "^4.6.2", GITHUB_GRAPHQL_URL: "https://api.github.com/graphql", NFT_BASE_URL: "/nft/", npm_package_dependencies_react_router_dom: "^6.25.1", npm_package_devDependencies_tailwindcss: "^3.4.6", npm_package_devDependencies_typescript: "^5.2.2", GOROOT_1_20_X64: "/opt/hostedtoolcache/go/1.20.14/x64", NVM_DIR: "/home/runner/.nvm", npm_package_devDependencies__types_react_dom: "^18.3.0", DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "1", GOROOT_1_21_X64: "/opt/hostedtoolcache/go/1.21.13/x64", ImageVersion: "20240901.1.0", JAVA_HOME_17_X64: "/usr/lib/jvm/temurin-17-jdk-amd64", npm_package_scripts_fuels_node: "fuels node", npm_package_scripts_dev: "vite", GITHUB_API_URL: "https://api.github.com", GOROOT_1_22_X64: "/opt/hostedtoolcache/go/1.22.6/x64", RUNNER_OS: "Linux", SWIFT_PATH: "/usr/share/swift/usr/bin", npm_package_type: "module", npm_package_dependencies_fuels: "0.93.0", npm_package_devDependencies__vitejs_plugin_react: "^4.3.1", CHROMEWEBDRIVER: "/usr/local/share/chromedriver-linux64", GITHUB_WORKFLOW: "Deploy PR preview", JOURNAL_STREAM: "8:18384", RUNNER_USER: "runner", STATS_V3PS: "true", _: "/home/runner/setup-pnpm/node_modules/.bin/pnpm", npm_package_private: "true", npm_package_dependencies__emotion_react: "^11.11.4", npm_package_devDependencies_autoprefixer: "^10.4.19", VITE_PUBLIC_DAPP_ENVIRONMENT: "testnet", npm_package_scripts_lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0", npm_package_devDependencies__typescript_eslint_eslint_plugin: "^7.15.0", npm_config_registry: "https://registry.npmjs.org/", ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE: "/opt/actionarchivecache", GITHUB_RUN_ID: "10743692800", STATS_D: "false", STATS_VMFE: "true", BOOTSTRAP_HASKELL_NONINTERACTIVE: "1", GITHUB_BASE_REF: "master", GITHUB_REF_TYPE: "branch", GITHUB_WORKFLOW_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", ImageOS: "ubuntu22", npm_package_devDependencies_eslint_plugin_react_refresh: "^0.4.7", GITHUB_ACTION_REPOSITORY: "", GITHUB_WORKFLOW_REF: "FuelLabs/sway-examples/.github/workflows/preview.yml@refs/pull/4/merge", PERFLOG_LOCATION_SETTING: "RUNNER_PERFLOG", npm_config_node_gyp: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node_modules/node-gyp/bin/node-gyp.js", PATH: "/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin", ANT_HOME: "/usr/share/ant", DOTNET_MULTILEVEL_LOOKUP: "0", INVOCATION_ID: "3b7e075b7e964240a53b54fd8e14c923", NODE: "/usr/local/bin/node", RUNNER_TOOL_CACHE: "/opt/hostedtoolcache", RUNNER_TRACKING_ID: "github_f78c3bd0-5916-4b6d-b102-cb79e51f2dec", TURBO_HASH: "aa8c12d69faaf243", npm_package_name: "counter-dapp", npm_package_dependencies__mui_material: "^5.16.5", AGENT_TOOLSDIRECTORY: "/opt/hostedtoolcache", GITHUB_ACTION: "__run", GITHUB_RUN_NUMBER: "76", GITHUB_TRIGGERING_ACTOR: "rishabhkeshan", RUNNER_ARCH: "X64", XDG_RUNTIME_DIR: "/run/user/1001", npm_package_dependencies_react_hot_toast: "^2.4.1", npm_config_frozen_lockfile: "", LANG: "C.UTF-8", VCPKG_INSTALLATION_ROOT: "/usr/local/share/vcpkg", npm_package_dependencies_react_dom: "^18.3.1", npm_package_devDependencies_eslint: "^8.57.0", CONDA: "/usr/share/miniconda", GITHUB_REF_NAME: "4/merge", GITHUB_REPOSITORY: "FuelLabs/sway-examples", RUNNER_NAME: "GitHub Actions 22", STATS_D_D: "false", STATS_VMD: "true", VITE_BASE_URL: "/sway-examples/pr-preview/pr-4", XDG_CONFIG_HOME: "/home/runner/.config", npm_lifecycle_script: "pnpm run fuels:build && tsc -b && vite build", ANDROID_NDK_ROOT: "/usr/local/lib/android/sdk/ndk/27.0.12077973", DEBIAN_FRONTEND: "noninteractive", GITHUB_ACTION_REF: "", STATS_UE: "true", GITHUB_ACTIONS: "true", GITHUB_REPOSITORY_ID: "820020030", NODE_PATH: "/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/run-s/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules", npm_package_version: "0.0.0", npm_package_devDependencies__types_react: "^18.3.3", npm_lifecycle_event: "build", GITHUB_REF_PROTECTED: "false", npm_package_scripts_fuels_dev: "fuels dev", npm_package_scripts_build: "pnpm run fuels:build && tsc -b && vite build", npm_package_dependencies_app_commons: "workspace:*", ACCEPT_EULA: "Y", GITHUB_JOB: "deploy-preview", GITHUB_WORKSPACE: "/home/runner/work/sway-examples/sway-examples", RUNNER_PERFLOG: "/home/runner/perflog", TURBO_INVOCATION_DIR: "/home/runner/work/sway-examples/sway-examples", npm_config_node_version: "20.11.0", COUNTER_DIST: "/home/runner/work/sway-examples/sway-examples/dist/counter/", GITHUB_RUN_ATTEMPT: "1", GITHUB_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", npm_package_dependencies__fuels_react: "^0.25.0", npm_package_dependencies__tanstack_react_query: "^5.29.2", ANDROID_SDK_ROOT: "/usr/local/lib/android/sdk", COUNTER_BASE_URL: "/counter/", GITHUB_ACTOR: "rishabhkeshan", GITHUB_REF: "refs/pull/4/merge", npm_config_save_exact: "true", LEIN_HOME: "/usr/local/lib/lein", npm_package_dependencies__mui_icons_material: "^5.16.5", GITHUB_ACTOR_ID: "58903797", GITHUB_PATH: "/home/runner/work/_temp/_runner_file_commands/add_path_f718650a-ff98-4302-80d8-5fcdb4473af9", JAVA_HOME: "/usr/lib/jvm/temurin-11-jdk-amd64", PWD: "/home/runner/work/sway-examples/sway-examples/counter", RUNNER_WORKSPACE: "/home/runner/work/sway-examples", VITE_PINATA_JWT: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJkODEwNDc5Zi1lYjk5LTQyNmMtOGMzMy02ZmU1Yjk1ZTVjYTIiLCJlbWFpbCI6Im1kYXVlcjMzM0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJpZCI6IkZSQTEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX0seyJpZCI6Ik5ZQzEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNjY0NzllYmFiMDFlOTEwMWJhYmUiLCJzY29wZWRLZXlTZWNyZXQiOiJmMDhiODk1NjVmNDQ0NjE5ZWZiMmM1NGNjOTEwN2E1ZWQ5NTI5OTgwYmZiMTAzOGYwZjc1NGVjNTkxNTE3OGY1IiwiaWF0IjoxNzE3MDE0NzQ1fQ.GvOu2LjeyyP4zE9_d9v8XUNV_Wgh595QTEy2kZa6Psk", npm_package_dependencies__emotion_styled: "^11.11.0", npm_package_dependencies__wagmi_connectors: "5.0.26", npm_package_dependencies_vite_plugin_vercel: "^8.0.0", npm_execpath: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/pnpm.cjs", ANDROID_HOME: "/usr/local/lib/android/sdk", GECKOWEBDRIVER: "/usr/local/share/gecko_driver", GHCUP_INSTALL_BASE_PREFIX: "/usr/local", GITHUB_EVENT_NAME: "pull_request", GITHUB_OUTPUT: "/home/runner/work/_temp/_runner_file_commands/set_output_f718650a-ff98-4302-80d8-5fcdb4473af9", GITHUB_SERVER_URL: "https://github.com", HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS: "3650", HOMEBREW_NO_AUTO_UPDATE: "1", LEIN_JAR: "/usr/local/lib/lein/self-installs/leiningen-2.11.2-standalone.jar", STATS_TIS: "mining", VITE_PUBLIC_GATEWAY_URL: "https://fuchsia-bizarre-butterfly-560.mypinata.cloud", EDGEWEBDRIVER: "/usr/local/share/edge_driver", PNPM_SCRIPT_SRC_DIR: "/home/runner/work/sway-examples/sway-examples/counter", STATS_EXT: "true", npm_package_dependencies__wagmi_core: "2.12.2", npm_package_devDependencies_postcss: "^8.4.39", npm_command: "run-script", ANDROID_NDK: "/usr/local/lib/android/sdk/ndk/27.0.12077973", CHROME_BIN: "/usr/bin/google-chrome", SGX_AESM_ADDR: "1", npm_package_scripts_preview: "vite preview", PNPM_HOME: "/home/runner/setup-pnpm/node_modules/.bin", SELENIUM_JAR_PATH: "/usr/share/java/selenium-server.jar", STATS_EXTP: "https://provjobdsettingscdn.blob.core.windows.net/settings/provjobdsettings-0.5.181+6/provjobd.data", NODE_ENV: "production", npm_package_dependencies_react_use: "^17.5.0", npm_package_devDependencies_npm_run_all: "^4.1.5", ANDROID_NDK_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_STEP_SUMMARY: "/home/runner/work/_temp/_runner_file_commands/step_summary_f718650a-ff98-4302-80d8-5fcdb4473af9", INIT_CWD: "/home/runner/work/sway-examples/sway-examples/counter", npm_package_dependencies_react: "^18.3.1" };
var zn = Object.create;
var zt$1 = Object.defineProperty;
var Yn = Object.getOwnPropertyDescriptor;
var Vn = Object.getOwnPropertyNames;
var Bn = Object.getPrototypeOf, Hn = Object.prototype.hasOwnProperty;
((e2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e2, { get: (t2, r2) => (typeof require < "u" ? require : t2)[r2] }) : e2)(function(e2) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e2 + '" is not supported');
});
var Gn = (e2, t2) => () => (e2 && (t2 = e2(e2 = 0)), t2);
var Jn = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var Zn = (e2, t2, r2, n3) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function") for (let o2 of Vn(t2)) !Hn.call(e2, o2) && o2 !== r2 && zt$1(e2, o2, { get: () => t2[o2], enumerable: !(n3 = Yn(t2, o2)) || n3.enumerable });
  return e2;
};
var Xn = (e2, t2, r2) => (r2 = e2 != null ? zn(Bn(e2)) : {}, Zn(!e2 || !e2.__esModule ? zt$1(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var a$2 = Gn(() => {
});
var sr = Jn((ls, ar) => {
  a$2();
  ar.exports = function(t2, r2, n3, o2) {
    var i2 = n3 ? n3.call(o2, t2, r2) : void 0;
    if (i2 !== void 0) return !!i2;
    if (t2 === r2) return true;
    if (typeof t2 != "object" || !t2 || typeof r2 != "object" || !r2) return false;
    var s2 = Object.keys(t2), l2 = Object.keys(r2);
    if (s2.length !== l2.length) return false;
    for (var u2 = Object.prototype.hasOwnProperty.bind(r2), d2 = 0; d2 < s2.length; d2++) {
      var m2 = s2[d2];
      if (!u2(m2)) return false;
      var y2 = t2[m2], v2 = r2[m2];
      if (i2 = n3 ? n3.call(o2, y2, v2, m2) : void 0, i2 === false || i2 === void 0 && y2 !== v2) return false;
    }
    return true;
  };
});
a$2();
a$2();
a$2();
function ro(e2) {
  return { get(r2, n3) {
    return Reflect.get(r2, n3 === e2 ? "data" : n3);
  } };
}
function S$3(e2, t2, r2) {
  let n3 = useQuery(t2);
  return reactExports.useMemo(() => new Proxy(n3, ro(e2)), [e2, n3]);
}
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
var Yt$1 = () => {
  let { fuel: e2 } = b$4(), { mutate: t2, mutateAsync: r2, ...n3 } = useMutation({ mutationFn: async (o2) => (o2 && await e2.selectConnector(o2), e2.connect()) });
  return { connect: t2, connectAsync: r2, ...n3 };
};
a$2();
a$2();
a$2();
var c$7 = { base: ["fuel"], account: () => c$7.base.concat("account"), accounts: () => c$7.base.concat("accounts"), assets: () => c$7.base.concat("assets"), contract: (e2, t2, r2) => {
  let n3 = c$7.base.concat("contract").concat(e2);
  return typeof r2 < "u" && n3.push(r2), typeof t2 < "u" && n3.push(t2), n3;
}, chain: () => c$7.base.concat("chain"), isConnected: () => c$7.base.concat("isConnected"), provider: () => c$7.base.concat("provider"), balance: (e2, t2) => {
  let r2 = c$7.base.concat("balance");
  return e2 && r2.push(e2), t2 && r2.push(t2), r2;
}, wallet: (e2) => {
  let t2 = c$7.base.concat("wallet");
  return e2 && t2.push(e2), t2;
}, transaction: (e2) => {
  let t2 = c$7.base.concat("transaction");
  return e2 && t2.push(e2), t2;
}, transactionReceipts: (e2) => c$7.transaction(e2).concat("receipts"), transactionResult: (e2) => c$7.transaction(e2).concat("result"), nodeInfo: (e2) => {
  let t2 = c$7.base.concat("nodeInfo");
  return e2 && t2.push(e2), t2;
}, connectorList: () => c$7.base.concat("connectorList"), currentConnector: () => c$7.base.concat("currentConnector"), currentNetwork: () => c$7.base.concat("currentNetwork") };
a$2();
a$2();
var Bt = () => {
  let { fuel: e2 } = b$4();
  return S$3("connectors", { queryKey: c$7.connectorList(), queryFn: async () => e2.connectors(), initialData: [] });
};
a$2();
a$2();
function Wt({ fuelConfig: e2 }) {
  let { fuel: t2 } = b$4(), r2 = useQueryClient();
  function n3() {
    r2.invalidateQueries({ queryKey: c$7.account() }), r2.invalidateQueries({ queryKey: c$7.isConnected() }), r2.invalidateQueries({ queryKey: c$7.wallet() }), r2.invalidateQueries({ queryKey: c$7.balance() }), r2.invalidateQueries({ queryKey: c$7.provider() }), r2.invalidateQueries({ queryKey: c$7.nodeInfo() }), r2.invalidateQueries({ queryKey: c$7.accounts() });
  }
  function o2() {
    r2.invalidateQueries({ queryKey: c$7.connectorList() });
  }
  function i2() {
    r2.invalidateQueries({ queryKey: c$7.account() }), r2.invalidateQueries({ queryKey: c$7.wallet() }), r2.invalidateQueries({ queryKey: c$7.balance() });
  }
  function s2() {
    r2.invalidateQueries({ queryKey: c$7.isConnected() }), r2.invalidateQueries({ queryKey: c$7.account() }), r2.invalidateQueries({ queryKey: c$7.wallet() }), r2.invalidateQueries({ queryKey: c$7.balance() }), r2.invalidateQueries({ queryKey: c$7.provider() }), r2.invalidateQueries({ queryKey: c$7.nodeInfo() }), r2.invalidateQueries({ queryKey: c$7.accounts() }), r2.invalidateQueries({ queryKey: c$7.connectorList() });
  }
  function l2() {
    r2.invalidateQueries({ queryKey: c$7.currentNetwork() }), r2.invalidateQueries({ queryKey: c$7.provider() }), r2.invalidateQueries({ queryKey: c$7.transactionReceipts() }), r2.invalidateQueries({ queryKey: c$7.chain() }), r2.invalidateQueries({ queryKey: c$7.nodeInfo() });
  }
  function u2() {
    r2.invalidateQueries({ queryKey: c$7.account() }), r2.invalidateQueries({ queryKey: c$7.accounts() });
  }
  function d2() {
    r2.invalidateQueries({ queryKey: c$7.assets() });
  }
  return reactExports.useEffect(() => (t2.on(t2.events.currentAccount, i2), t2.on(t2.events.currentConnector, n3), t2.on(t2.events.connectors, o2), t2.on(t2.events.connection, s2), t2.on(t2.events.accounts, u2), t2.on(t2.events.currentNetwork, l2), t2.on(t2.events.assets, d2), () => {
    t2.off(t2.events.currentConnector, n3), t2.off(t2.events.currentAccount, i2), t2.off(t2.events.connectors, o2), t2.off(t2.events.connection, s2), t2.off(t2.events.accounts, u2), t2.off(t2.events.currentNetwork, l2), t2.off(t2.events.assets, d2);
  }), [t2, r2]), reactExports.useEffect(() => {
    r2.invalidateQueries({ queryKey: c$7.connectorList() });
  }, [e2 == null ? void 0 : e2.connectors, r2]), null;
}
var Gt$1 = reactExports.createContext(null), b$4 = () => {
  let e2 = reactExports.useContext(Gt$1);
  if (!e2) throw new Error("useFuel must be used within a FuelHooksProvider");
  return e2;
}, lt$2 = ({ children: e2, fuelConfig: t2 }) => {
  let r2 = reactExports.useMemo(() => new Fuel(t2), [t2]);
  return jsxRuntimeExports.jsxs(Gt$1.Provider, { value: { fuel: r2 }, children: [jsxRuntimeExports.jsx(Wt, { fuelConfig: t2 }), e2] });
};
var Jt = reactExports.createContext(null);
var re$3 = () => {
  let e2 = reactExports.useContext(Jt);
  if (!e2) throw new Error("useConnectUI must be used within a FuelUIProvider");
  return e2;
};
function Zt$2({ fuelConfig: e2, children: t2, theme: r2 }) {
  let { fuel: n3 } = b$4(), { isPending: o2, isError: i2, connect: s2 } = Yt$1(), { connectors: l2, isLoading: u2 } = Bt(), [d2, m2] = reactExports.useState(null), [y2, v2] = reactExports.useState(false), [x2, E2] = reactExports.useState(null), P2 = () => {
    v2(false), m2(null);
  }, Q2 = () => {
    v2(true);
  }, I2 = () => {
    m2(null);
  };
  reactExports.useEffect(() => {
    (d2 == null ? void 0 : d2.installed) && I2();
  }, [d2 == null ? void 0 : d2.installed, I2]);
  let N2 = reactExports.useCallback(async (C2) => {
    if (!n3) return m2(C2);
    if (C2.installed) {
      P2();
      try {
        await s2(C2.name);
      } catch (R2) {
        E2(R2);
      }
    } else m2(C2);
  }, [n3, s2, P2]), A2 = reactExports.useMemo(() => {
    let C2 = (e2.connectors || []).length > l2.length;
    return u2 || C2;
  }, [l2, u2, e2]);
  return jsxRuntimeExports.jsx(Jt.Provider, { value: { fuelConfig: e2, theme: r2 || "light", isLoading: A2, isConnecting: o2, isError: i2, connectors: l2, error: x2, setError: E2, connect: Q2, cancel: P2, dialog: { connector: d2, isOpen: y2, connect: N2, back: I2 } }, children: t2 });
}
a$2();
a$2();
a$2();
function Xt$1({ size: e2, ...t2 }) {
  return jsxRuntimeExports.jsxs("svg", { width: e2, height: e2, viewBox: "0 0 490 496", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...t2, children: [jsxRuntimeExports.jsx("title", { children: "FuelWallet Development Icon" }), jsxRuntimeExports.jsx("rect", { x: "42.509", y: "28.3438", width: "396.739", height: "425.143", fill: "#00F58C" }), jsxRuntimeExports.jsx("path", { d: "M32.5836 0C14.5545 0 0 14.7327 0 32.9826V496H405.427C419.129 496 432.307 490.492 442.01 480.67L474.856 447.422C484.559 437.6 490 424.261 490 410.391V0H32.5836ZM319.936 63.7752L160.558 225.105C156.624 229.086 151.248 231.343 145.676 231.343C137.546 231.343 130.072 226.565 126.598 219.132L64.8394 87.0024C59.7913 76.1852 67.593 63.7752 79.3939 63.7752H319.936ZM63.0037 432.225V275.275C63.0037 266.914 69.6909 260.145 77.9516 260.145H233.002L63.0037 432.225ZM245.852 231.343H194.518L348.979 74.9906C356.06 67.8234 365.697 63.7752 375.728 63.7752H427.062L272.601 220.127C265.521 227.295 255.883 231.343 245.852 231.343Z", fill: "#080808" })] });
}
a$2();
function er({ size: e2, ...t2 }) {
  return jsxRuntimeExports.jsxs("svg", { width: e2, height: e2, viewBox: "0 0 491 496", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...t2, children: [jsxRuntimeExports.jsx("title", { children: "Fuel Wallet Icon" }), jsxRuntimeExports.jsx("rect", { x: "42.5535", y: "28.3438", width: "397.154", height: "425.143", fill: "#080808" }), jsxRuntimeExports.jsx("path", { d: "M32.6178 0C14.5697 0 0 14.7327 0 32.9826V496H405.852C419.568 496 432.759 490.492 442.473 480.67L475.353 447.422C485.066 437.6 490.513 424.261 490.513 410.391V0H32.6178ZM320.271 63.7752L160.726 225.105C156.788 229.086 151.407 231.343 145.828 231.343C137.69 231.343 130.208 226.565 126.73 219.132L64.9074 87.0024C59.8539 76.1852 67.6638 63.7752 79.4771 63.7752H320.271ZM63.0697 432.225V275.275C63.0697 266.914 69.7639 260.145 78.0332 260.145H233.246L63.0697 432.225ZM246.11 231.343H194.722L349.345 74.9906C356.433 67.8234 366.08 63.7752 376.121 63.7752H427.509L272.887 220.127C265.799 227.295 256.151 231.343 246.11 231.343Z", fill: "#00F58C" })] });
}
a$2();
function rr({ theme: e2, size: t2, ...r2 }) {
  return jsxRuntimeExports.jsxs("svg", { width: t2, height: t2, viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...r2, children: [jsxRuntimeExports.jsx("title", { children: "Fuelet Icon" }), jsxRuntimeExports.jsx("path", { d: "M20 40C14.9355 40 10.3145 38.114 6.7905 35.0105L18.146 26.907C18.845 26.4085 19.8065 26.9645 19.722 27.8195L19.2745 32.3605C19.182 33.295 20.3125 33.8295 20.9765 33.1655L27.071 27.071C31.062 23.08 30.9745 16.5555 26.8085 12.6755C22.8405 8.98 16.5935 9.264 12.7595 13.0985L6.853 19.0045C6.187 19.671 6.7275 20.8045 7.6645 20.7065L12.209 20.231C13.0655 20.1415 13.6275 21.105 13.127 21.8065L4.9895 33.2095C1.886 29.6855 0 25.0645 0 20C0 8.9545 8.9545 0 20 0C31.0455 0 40 8.9545 40 20C40 31.0455 31.0455 40 20 40Z", fill: e2 === "dark" ? "white" : "#28282F" })] });
}
a$2();
var nr = (e2, t2) => {
  let { image: r2 } = e2;
  return typeof r2 == "object" ? t2 === "dark" ? r2.dark : r2.light : r2;
};
function Le$1({ connectorName: e2, connectorMetadata: t2, ...r2 }) {
  switch (e2) {
    case "Fuelet Wallet":
      return jsxRuntimeExports.jsx(rr, { ...r2 });
    case "Fuel Wallet":
      return jsxRuntimeExports.jsx(er, { ...r2 });
    case "Fuel Wallet Development":
      return jsxRuntimeExports.jsx(Xt$1, { ...r2 });
    default:
      return t2.image ? jsxRuntimeExports.jsx("img", { height: `${r2.size}px`, width: `${r2.size}px`, src: nr(t2, r2.theme), alt: `${e2} icon` }) : null;
  }
}
a$2();
a$2();
a$2();
var O$2 = function() {
  return O$2 = Object.assign || function(t2) {
    for (var r2, n3 = 1, o2 = arguments.length; n3 < o2; n3++) {
      r2 = arguments[n3];
      for (var i2 in r2) Object.prototype.hasOwnProperty.call(r2, i2) && (t2[i2] = r2[i2]);
    }
    return t2;
  }, O$2.apply(this, arguments);
};
function G$3(e2, t2, r2) {
  if (r2 || arguments.length === 2) for (var n3 = 0, o2 = t2.length, i2; n3 < o2; n3++) (i2 || !(n3 in t2)) && (i2 || (i2 = Array.prototype.slice.call(t2, 0, n3)), i2[n3] = t2[n3]);
  return e2.concat(i2 || Array.prototype.slice.call(t2));
}
a$2();
a$2();
Xn(sr());
a$2();
var k$3 = "-ms-", ne$2 = "-moz-", T$2 = "-webkit-", qe$1 = "comm", J$2 = "rule", le$2 = "decl";
var cr = "@import";
var Me$1 = "@keyframes";
var ur = "@layer";
a$2();
var mt$2 = Math.abs, Ee$2 = String.fromCharCode, Ae$2 = Object.assign;
function lr(e2, t2) {
  return _$3(e2, 0) ^ 45 ? (((t2 << 2 ^ _$3(e2, 0)) << 2 ^ _$3(e2, 1)) << 2 ^ _$3(e2, 2)) << 2 ^ _$3(e2, 3) : 0;
}
function Ue$1(e2) {
  return e2.trim();
}
function U$3(e2, t2) {
  return (e2 = t2.exec(e2)) ? e2[0] : e2;
}
function h$8(e2, t2, r2) {
  return e2.replace(t2, r2);
}
function pe$2(e2, t2, r2) {
  return e2.indexOf(t2, r2);
}
function _$3(e2, t2) {
  return e2.charCodeAt(t2) | 0;
}
function z$3(e2, t2, r2) {
  return e2.slice(t2, r2);
}
function K$3(e2) {
  return e2.length;
}
function $e$1(e2) {
  return e2.length;
}
function oe$2(e2, t2) {
  return t2.push(e2), e2;
}
function pr(e2, t2) {
  return e2.map(t2).join("");
}
function yt$2(e2, t2) {
  return e2.filter(function(r2) {
    return !U$3(r2, t2);
  });
}
a$2();
a$2();
var je$1 = 1, fe$2 = 1, fr = 0, q$4 = 0, D$2 = 0, de$2 = "";
function ke$2(e2, t2, r2, n3, o2, i2, s2, l2) {
  return { value: e2, root: t2, parent: r2, type: n3, props: o2, children: i2, line: je$1, column: fe$2, length: s2, return: "", siblings: l2 };
}
function V$3(e2, t2) {
  return Ae$2(ke$2("", null, null, "", null, null, 0, e2.siblings), e2, { length: -e2.length }, t2);
}
function ie$1(e2) {
  for (; e2.root; ) e2 = V$3(e2.root, { children: [e2] });
  oe$2(e2, e2.siblings);
}
function dr() {
  return D$2;
}
function mr() {
  return D$2 = q$4 > 0 ? _$3(de$2, --q$4) : 0, fe$2--, D$2 === 10 && (fe$2 = 1, je$1--), D$2;
}
function M$2() {
  return D$2 = q$4 < fr ? _$3(de$2, q$4++) : 0, fe$2++, D$2 === 10 && (fe$2 = 1, je$1++), D$2;
}
function Z$3() {
  return _$3(de$2, q$4);
}
function Pe$1() {
  return q$4;
}
function ze$1(e2, t2) {
  return z$3(de$2, e2, t2);
}
function ht$1(e2) {
  switch (e2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function yr(e2) {
  return je$1 = fe$2 = 1, fr = K$3(de$2 = e2), q$4 = 0, [];
}
function hr(e2) {
  return de$2 = "", e2;
}
function Ye$1(e2) {
  return Ue$1(ze$1(q$4 - 1, gt$2(e2 === 91 ? e2 + 2 : e2 === 40 ? e2 + 1 : e2)));
}
function gr(e2) {
  for (; (D$2 = Z$3()) && D$2 < 33; ) M$2();
  return ht$1(e2) > 2 || ht$1(D$2) > 3 ? "" : " ";
}
function vr(e2, t2) {
  for (; --t2 && M$2() && !(D$2 < 48 || D$2 > 102 || D$2 > 57 && D$2 < 65 || D$2 > 70 && D$2 < 97); ) ;
  return ze$1(e2, Pe$1() + (t2 < 6 && Z$3() == 32 && M$2() == 32));
}
function gt$2(e2) {
  for (; M$2(); ) switch (D$2) {
    case e2:
      return q$4;
    case 34:
    case 39:
      e2 !== 34 && e2 !== 39 && gt$2(D$2);
      break;
    case 40:
      e2 === 41 && gt$2(e2);
      break;
    case 92:
      M$2();
      break;
  }
  return q$4;
}
function br(e2, t2) {
  for (; M$2() && e2 + D$2 !== 47 + 10; ) if (e2 + D$2 === 42 + 42 && Z$3() === 47) break;
  return "/*" + ze$1(t2, q$4 - 1) + "*" + Ee$2(e2 === 47 ? e2 : M$2());
}
function xr(e2) {
  for (; !ht$1(Z$3()); ) M$2();
  return ze$1(e2, q$4);
}
function Cr(e2) {
  return hr(Ve$1("", null, null, null, [""], e2 = yr(e2), 0, [0], e2));
}
function Ve$1(e2, t2, r2, n3, o2, i2, s2, l2, u2) {
  for (var d2 = 0, m2 = 0, y2 = s2, v2 = 0, x2 = 0, E2 = 0, P2 = 1, Q2 = 1, I2 = 1, N2 = 0, A2 = "", C2 = o2, R2 = i2, w2 = n3, g2 = A2; Q2; ) switch (E2 = N2, N2 = M$2()) {
    case 40:
      if (E2 != 108 && _$3(g2, y2 - 1) == 58) {
        pe$2(g2 += h$8(Ye$1(N2), "&", "&\f"), "&\f", mt$2(d2 ? l2[d2 - 1] : 0)) != -1 && (I2 = -1);
        break;
      }
    case 34:
    case 39:
    case 91:
      g2 += Ye$1(N2);
      break;
    case 9:
    case 10:
    case 13:
    case 32:
      g2 += gr(E2);
      break;
    case 92:
      g2 += vr(Pe$1() - 1, 7);
      continue;
    case 47:
      switch (Z$3()) {
        case 42:
        case 47:
          oe$2(To(br(M$2(), Pe$1()), t2, r2, u2), u2);
          break;
        default:
          g2 += "/";
      }
      break;
    case 123 * P2:
      l2[d2++] = K$3(g2) * I2;
    case 125 * P2:
    case 59:
    case 0:
      switch (N2) {
        case 0:
        case 125:
          Q2 = 0;
        case 59 + m2:
          I2 == -1 && (g2 = h$8(g2, /\f/g, "")), x2 > 0 && K$3(g2) - y2 && oe$2(x2 > 32 ? Tr(g2 + ";", n3, r2, y2 - 1, u2) : Tr(h$8(g2, " ", "") + ";", n3, r2, y2 - 2, u2), u2);
          break;
        case 59:
          g2 += ";";
        default:
          if (oe$2(w2 = wr(g2, t2, r2, d2, m2, o2, l2, A2, C2 = [], R2 = [], y2, i2), i2), N2 === 123) if (m2 === 0) Ve$1(g2, t2, w2, w2, C2, i2, y2, l2, R2);
          else switch (v2 === 99 && _$3(g2, 3) === 110 ? 100 : v2) {
            case 100:
            case 108:
            case 109:
            case 115:
              Ve$1(e2, w2, w2, n3 && oe$2(wr(e2, w2, w2, 0, 0, o2, l2, A2, o2, C2 = [], y2, R2), R2), o2, R2, y2, l2, n3 ? C2 : R2);
              break;
            default:
              Ve$1(g2, w2, w2, w2, [""], R2, 0, l2, R2);
          }
      }
      d2 = m2 = x2 = 0, P2 = I2 = 1, A2 = g2 = "", y2 = s2;
      break;
    case 58:
      y2 = 1 + K$3(g2), x2 = E2;
    default:
      if (P2 < 1) {
        if (N2 == 123) --P2;
        else if (N2 == 125 && P2++ == 0 && mr() == 125) continue;
      }
      switch (g2 += Ee$2(N2), N2 * P2) {
        case 38:
          I2 = m2 > 0 ? 1 : (g2 += "\f", -1);
          break;
        case 44:
          l2[d2++] = (K$3(g2) - 1) * I2, I2 = 1;
          break;
        case 64:
          Z$3() === 45 && (g2 += Ye$1(M$2())), v2 = Z$3(), m2 = y2 = K$3(A2 = g2 += xr(Pe$1())), N2++;
          break;
        case 45:
          E2 === 45 && K$3(g2) == 2 && (P2 = 0);
      }
  }
  return i2;
}
function wr(e2, t2, r2, n3, o2, i2, s2, l2, u2, d2, m2, y2) {
  for (var v2 = o2 - 1, x2 = o2 === 0 ? i2 : [""], E2 = $e$1(x2), P2 = 0, Q2 = 0, I2 = 0; P2 < n3; ++P2) for (var N2 = 0, A2 = z$3(e2, v2 + 1, v2 = mt$2(Q2 = s2[P2])), C2 = e2; N2 < E2; ++N2) (C2 = Ue$1(Q2 > 0 ? x2[N2] + " " + A2 : h$8(A2, /&\f/g, x2[N2]))) && (u2[I2++] = C2);
  return ke$2(e2, t2, r2, o2 === 0 ? J$2 : l2, u2, d2, m2, y2);
}
function To(e2, t2, r2, n3) {
  return ke$2(e2, t2, r2, qe$1, Ee$2(dr()), z$3(e2, 2, -2), 0, n3);
}
function Tr(e2, t2, r2, n3, o2) {
  return ke$2(e2, t2, r2, le$2, z$3(e2, 0, n3), z$3(e2, n3 + 1, -1), n3, o2);
}
a$2();
function vt$1(e2, t2, r2) {
  switch (lr(e2, t2)) {
    case 5103:
      return T$2 + "print-" + e2 + e2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return T$2 + e2 + e2;
    case 4789:
      return ne$2 + e2 + e2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return T$2 + e2 + ne$2 + e2 + k$3 + e2 + e2;
    case 5936:
      switch (_$3(e2, t2 + 11)) {
        case 114:
          return T$2 + e2 + k$3 + h$8(e2, /[svh]\w+-[tblr]{2}/, "tb") + e2;
        case 108:
          return T$2 + e2 + k$3 + h$8(e2, /[svh]\w+-[tblr]{2}/, "tb-rl") + e2;
        case 45:
          return T$2 + e2 + k$3 + h$8(e2, /[svh]\w+-[tblr]{2}/, "lr") + e2;
      }
    case 6828:
    case 4268:
    case 2903:
      return T$2 + e2 + k$3 + e2 + e2;
    case 6165:
      return T$2 + e2 + k$3 + "flex-" + e2 + e2;
    case 5187:
      return T$2 + e2 + h$8(e2, /(\w+).+(:[^]+)/, T$2 + "box-$1$2" + k$3 + "flex-$1$2") + e2;
    case 5443:
      return T$2 + e2 + k$3 + "flex-item-" + h$8(e2, /flex-|-self/g, "") + (U$3(e2, /flex-|baseline/) ? "" : k$3 + "grid-row-" + h$8(e2, /flex-|-self/g, "")) + e2;
    case 4675:
      return T$2 + e2 + k$3 + "flex-line-pack" + h$8(e2, /align-content|flex-|-self/g, "") + e2;
    case 5548:
      return T$2 + e2 + k$3 + h$8(e2, "shrink", "negative") + e2;
    case 5292:
      return T$2 + e2 + k$3 + h$8(e2, "basis", "preferred-size") + e2;
    case 6060:
      return T$2 + "box-" + h$8(e2, "-grow", "") + T$2 + e2 + k$3 + h$8(e2, "grow", "positive") + e2;
    case 4554:
      return T$2 + h$8(e2, /([^-])(transform)/g, "$1" + T$2 + "$2") + e2;
    case 6187:
      return h$8(h$8(h$8(e2, /(zoom-|grab)/, T$2 + "$1"), /(image-set)/, T$2 + "$1"), e2, "") + e2;
    case 5495:
    case 3959:
      return h$8(e2, /(image-set\([^]*)/, T$2 + "$1$`$1");
    case 4968:
      return h$8(h$8(e2, /(.+:)(flex-)?(.*)/, T$2 + "box-pack:$3" + k$3 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + T$2 + e2 + e2;
    case 4200:
      if (!U$3(e2, /flex-|baseline/)) return k$3 + "grid-column-align" + z$3(e2, t2) + e2;
      break;
    case 2592:
    case 3360:
      return k$3 + h$8(e2, "template-", "") + e2;
    case 4384:
    case 3616:
      return r2 && r2.some(function(n3, o2) {
        return t2 = o2, U$3(n3.props, /grid-\w+-end/);
      }) ? ~pe$2(e2 + (r2 = r2[t2].value), "span", 0) ? e2 : k$3 + h$8(e2, "-start", "") + e2 + k$3 + "grid-row-span:" + (~pe$2(r2, "span", 0) ? U$3(r2, /\d+/) : +U$3(r2, /\d+/) - +U$3(e2, /\d+/)) + ";" : k$3 + h$8(e2, "-start", "") + e2;
    case 4896:
    case 4128:
      return r2 && r2.some(function(n3) {
        return U$3(n3.props, /grid-\w+-start/);
      }) ? e2 : k$3 + h$8(h$8(e2, "-end", "-span"), "span ", "") + e2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return h$8(e2, /(.+)-inline(.+)/, T$2 + "$1$2") + e2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (K$3(e2) - 1 - t2 > 6) switch (_$3(e2, t2 + 1)) {
        case 109:
          if (_$3(e2, t2 + 4) !== 45) break;
        case 102:
          return h$8(e2, /(.+:)(.+)-([^]+)/, "$1" + T$2 + "$2-$3$1" + ne$2 + (_$3(e2, t2 + 3) == 108 ? "$3" : "$2-$3")) + e2;
        case 115:
          return ~pe$2(e2, "stretch", 0) ? vt$1(h$8(e2, "stretch", "fill-available"), t2, r2) + e2 : e2;
      }
      break;
    case 5152:
    case 5920:
      return h$8(e2, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(n3, o2, i2, s2, l2, u2, d2) {
        return k$3 + o2 + ":" + i2 + d2 + (s2 ? k$3 + o2 + "-span:" + (l2 ? u2 : +u2 - +i2) + d2 : "") + e2;
      });
    case 4949:
      if (_$3(e2, t2 + 6) === 121) return h$8(e2, ":", ":" + T$2) + e2;
      break;
    case 6444:
      switch (_$3(e2, _$3(e2, 14) === 45 ? 18 : 11)) {
        case 120:
          return h$8(e2, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + T$2 + (_$3(e2, 14) === 45 ? "inline-" : "") + "box$3$1" + T$2 + "$2$3$1" + k$3 + "$2box$3") + e2;
        case 100:
          return h$8(e2, ":", ":" + k$3) + e2;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return h$8(e2, "scroll-", "scroll-snap-") + e2;
  }
  return e2;
}
a$2();
function me$1(e2, t2) {
  for (var r2 = "", n3 = 0; n3 < e2.length; n3++) r2 += t2(e2[n3], n3, e2, t2) || "";
  return r2;
}
function Sr(e2, t2, r2, n3) {
  switch (e2.type) {
    case ur:
      if (e2.children.length) break;
    case cr:
    case le$2:
      return e2.return = e2.return || e2.value;
    case qe$1:
      return "";
    case Me$1:
      return e2.return = e2.value + "{" + me$1(e2.children, n3) + "}";
    case J$2:
      if (!K$3(e2.value = e2.props.join(","))) return "";
  }
  return K$3(r2 = me$1(e2.children, n3)) ? e2.return = e2.value + "{" + r2 + "}" : "";
}
a$2();
function Er(e2) {
  var t2 = $e$1(e2);
  return function(r2, n3, o2, i2) {
    for (var s2 = "", l2 = 0; l2 < t2; l2++) s2 += e2[l2](r2, n3, o2, i2) || "";
    return s2;
  };
}
function Ar(e2) {
  return function(t2) {
    t2.root || (t2 = t2.return) && e2(t2);
  };
}
function kr(e2, t2, r2, n3) {
  if (e2.length > -1 && !e2.return) switch (e2.type) {
    case le$2:
      e2.return = vt$1(e2.value, e2.length, r2);
      return;
    case Me$1:
      return me$1([V$3(e2, { value: h$8(e2.value, "@", "@" + T$2) })], n3);
    case J$2:
      if (e2.length) return pr(r2 = e2.props, function(o2) {
        switch (U$3(o2, n3 = /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            ie$1(V$3(e2, { props: [h$8(o2, /:(read-\w+)/, ":" + ne$2 + "$1")] })), ie$1(V$3(e2, { props: [o2] })), Ae$2(e2, { props: yt$2(r2, n3) });
            break;
          case "::placeholder":
            ie$1(V$3(e2, { props: [h$8(o2, /:(plac\w+)/, ":" + T$2 + "input-$1")] })), ie$1(V$3(e2, { props: [h$8(o2, /:(plac\w+)/, ":" + ne$2 + "$1")] })), ie$1(V$3(e2, { props: [h$8(o2, /:(plac\w+)/, k$3 + "input-$1")] })), ie$1(V$3(e2, { props: [o2] })), Ae$2(e2, { props: yt$2(r2, n3) });
            break;
        }
        return "";
      });
  }
}
a$2();
var Pr = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 };
var H$1 = typeof process < "u" && define_process_env_default$2 !== void 0 && (define_process_env_default$2.REACT_APP_SC_ATTR || define_process_env_default$2.SC_ATTR) || "data-styled", jr = "active", Xe$1 = "data-styled-version", ye$2 = "6.1.12", Rt$1 = `/*!sc*/
`, Ie$2 = typeof window < "u" && "HTMLElement" in window, Po = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && define_process_env_default$2 !== void 0 && define_process_env_default$2.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && define_process_env_default$2.REACT_APP_SC_DISABLE_SPEEDY !== "" ? define_process_env_default$2.REACT_APP_SC_DISABLE_SPEEDY !== "false" && define_process_env_default$2.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && define_process_env_default$2 !== void 0 && define_process_env_default$2.SC_DISABLE_SPEEDY !== void 0 && define_process_env_default$2.SC_DISABLE_SPEEDY !== "" ? define_process_env_default$2.SC_DISABLE_SPEEDY !== "false" && define_process_env_default$2.SC_DISABLE_SPEEDY : false);
var tt$1 = Object.freeze([]), he$2 = Object.freeze({});
function No(e2, t2, r2) {
  return r2 === void 0 && (r2 = he$2), e2.theme !== r2.theme && e2.theme || t2 || r2.theme;
}
var Ct$1 = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), Ro = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, _o = /(^-|-$)/g;
function Rr(e2) {
  return e2.replace(Ro, "-").replace(_o, "");
}
var Fo = /(a)(d)/gi, He$1 = 52, _r = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function St$1(e2) {
  var t2, r2 = "";
  for (t2 = Math.abs(e2); t2 > He$1; t2 = t2 / He$1 | 0) r2 = _r(t2 % He$1) + r2;
  return (_r(t2 % He$1) + r2).replace(Fo, "$1-$2");
}
var xt$1, zr = 5381, ae$1 = function(e2, t2) {
  for (var r2 = t2.length; r2; ) e2 = 33 * e2 ^ t2.charCodeAt(--r2);
  return e2;
}, Yr = function(e2) {
  return ae$1(zr, e2);
};
function Vr(e2) {
  return St$1(Yr(e2) >>> 0);
}
function Br(e2) {
  return e2.displayName || e2.name || "Component";
}
function wt$2(e2) {
  return typeof e2 == "string" && true;
}
var Hr = typeof Symbol == "function" && Symbol.for, Wr = Hr ? Symbol.for("react.memo") : 60115, Do = Hr ? Symbol.for("react.forward_ref") : 60112, Oo = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, Qo = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, Gr = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Ko = ((xt$1 = {})[Do] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, xt$1[Wr] = Gr, xt$1);
function Fr(e2) {
  return ("type" in (t2 = e2) && t2.type.$$typeof) === Wr ? Gr : "$$typeof" in e2 ? Ko[e2.$$typeof] : Oo;
  var t2;
}
var Lo = Object.defineProperty, qo = Object.getOwnPropertyNames, Dr = Object.getOwnPropertySymbols, Mo = Object.getOwnPropertyDescriptor, Uo = Object.getPrototypeOf, Or = Object.prototype;
function Jr(e2, t2, r2) {
  if (typeof t2 != "string") {
    if (Or) {
      var n3 = Uo(t2);
      n3 && n3 !== Or && Jr(e2, n3, r2);
    }
    var o2 = qo(t2);
    Dr && (o2 = o2.concat(Dr(t2)));
    for (var i2 = Fr(e2), s2 = Fr(t2), l2 = 0; l2 < o2.length; ++l2) {
      var u2 = o2[l2];
      if (!(u2 in Qo || r2 && r2[u2] || s2 && u2 in s2 || i2 && u2 in i2)) {
        var d2 = Mo(t2, u2);
        try {
          Lo(e2, u2, d2);
        } catch {
        }
      }
    }
  }
  return e2;
}
function ge$3(e2) {
  return typeof e2 == "function";
}
function _t$4(e2) {
  return typeof e2 == "object" && "styledComponentId" in e2;
}
function se$2(e2, t2) {
  return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
}
function Ne$1(e2, t2) {
  if (e2.length === 0) return "";
  for (var r2 = e2[0], n3 = 1; n3 < e2.length; n3++) r2 += e2[n3];
  return r2;
}
function ve$2(e2) {
  return e2 !== null && typeof e2 == "object" && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function Et$1(e2, t2, r2) {
  if (r2 === void 0 && (r2 = false), !r2 && !ve$2(e2) && !Array.isArray(e2)) return t2;
  if (Array.isArray(t2)) for (var n3 = 0; n3 < t2.length; n3++) e2[n3] = Et$1(e2[n3], t2[n3]);
  else if (ve$2(t2)) for (var n3 in t2) e2[n3] = Et$1(e2[n3], t2[n3]);
  return e2;
}
function Ft(e2, t2) {
  Object.defineProperty(e2, "toString", { value: t2 });
}
function $$3(e2) {
  for (var t2 = [], r2 = 1; r2 < arguments.length; r2++) t2[r2 - 1] = arguments[r2];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e2, " for more information.").concat(t2.length > 0 ? " Args: ".concat(t2.join(", ")) : ""));
}
var zo = function() {
  function e2(t2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t2;
  }
  return e2.prototype.indexOfGroup = function(t2) {
    for (var r2 = 0, n3 = 0; n3 < t2; n3++) r2 += this.groupSizes[n3];
    return r2;
  }, e2.prototype.insertRules = function(t2, r2) {
    if (t2 >= this.groupSizes.length) {
      for (var n3 = this.groupSizes, o2 = n3.length, i2 = o2; t2 >= i2; ) if ((i2 <<= 1) < 0) throw $$3(16, "".concat(t2));
      this.groupSizes = new Uint32Array(i2), this.groupSizes.set(n3), this.length = i2;
      for (var s2 = o2; s2 < i2; s2++) this.groupSizes[s2] = 0;
    }
    for (var l2 = this.indexOfGroup(t2 + 1), u2 = (s2 = 0, r2.length); s2 < u2; s2++) this.tag.insertRule(l2, r2[s2]) && (this.groupSizes[t2]++, l2++);
  }, e2.prototype.clearGroup = function(t2) {
    if (t2 < this.length) {
      var r2 = this.groupSizes[t2], n3 = this.indexOfGroup(t2), o2 = n3 + r2;
      this.groupSizes[t2] = 0;
      for (var i2 = n3; i2 < o2; i2++) this.tag.deleteRule(n3);
    }
  }, e2.prototype.getGroup = function(t2) {
    var r2 = "";
    if (t2 >= this.length || this.groupSizes[t2] === 0) return r2;
    for (var n3 = this.groupSizes[t2], o2 = this.indexOfGroup(t2), i2 = o2 + n3, s2 = o2; s2 < i2; s2++) r2 += "".concat(this.tag.getRule(s2)).concat(Rt$1);
    return r2;
  }, e2;
}(), Je$1 = /* @__PURE__ */ new Map(), et$2 = /* @__PURE__ */ new Map(), Ze$1 = 1, We$1 = function(e2) {
  if (Je$1.has(e2)) return Je$1.get(e2);
  for (; et$2.has(Ze$1); ) Ze$1++;
  var t2 = Ze$1++;
  return Je$1.set(e2, t2), et$2.set(t2, e2), t2;
}, Vo = function(e2, t2) {
  Ze$1 = t2 + 1, Je$1.set(e2, t2), et$2.set(t2, e2);
}, Bo = "style[".concat(H$1, "][").concat(Xe$1, '="').concat(ye$2, '"]'), Ho = new RegExp("^".concat(H$1, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Wo = function(e2, t2, r2) {
  for (var n3, o2 = r2.split(","), i2 = 0, s2 = o2.length; i2 < s2; i2++) (n3 = o2[i2]) && e2.registerName(t2, n3);
}, Go = function(e2, t2) {
  for (var r2, n3 = ((r2 = t2.textContent) !== null && r2 !== void 0 ? r2 : "").split(Rt$1), o2 = [], i2 = 0, s2 = n3.length; i2 < s2; i2++) {
    var l2 = n3[i2].trim();
    if (l2) {
      var u2 = l2.match(Ho);
      if (u2) {
        var d2 = 0 | parseInt(u2[1], 10), m2 = u2[2];
        d2 !== 0 && (Vo(m2, d2), Wo(e2, m2, u2[3]), e2.getTag().insertRules(d2, o2)), o2.length = 0;
      } else o2.push(l2);
    }
  }
}, Qr = function(e2) {
  for (var t2 = document.querySelectorAll(Bo), r2 = 0, n3 = t2.length; r2 < n3; r2++) {
    var o2 = t2[r2];
    o2 && o2.getAttribute(H$1) !== jr && (Go(e2, o2), o2.parentNode && o2.parentNode.removeChild(o2));
  }
};
function At$1() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var Zr = function(e2) {
  var t2 = document.head, r2 = e2 || t2, n3 = document.createElement("style"), o2 = function(l2) {
    var u2 = Array.from(l2.querySelectorAll("style[".concat(H$1, "]")));
    return u2[u2.length - 1];
  }(r2), i2 = o2 !== void 0 ? o2.nextSibling : null;
  n3.setAttribute(H$1, jr), n3.setAttribute(Xe$1, ye$2);
  var s2 = At$1();
  return s2 && n3.setAttribute("nonce", s2), r2.insertBefore(n3, i2), n3;
}, Jo = function() {
  function e2(t2) {
    this.element = Zr(t2), this.element.appendChild(document.createTextNode("")), this.sheet = function(r2) {
      if (r2.sheet) return r2.sheet;
      for (var n3 = document.styleSheets, o2 = 0, i2 = n3.length; o2 < i2; o2++) {
        var s2 = n3[o2];
        if (s2.ownerNode === r2) return s2;
      }
      throw $$3(17);
    }(this.element), this.length = 0;
  }
  return e2.prototype.insertRule = function(t2, r2) {
    try {
      return this.sheet.insertRule(r2, t2), this.length++, true;
    } catch {
      return false;
    }
  }, e2.prototype.deleteRule = function(t2) {
    this.sheet.deleteRule(t2), this.length--;
  }, e2.prototype.getRule = function(t2) {
    var r2 = this.sheet.cssRules[t2];
    return r2 && r2.cssText ? r2.cssText : "";
  }, e2;
}(), Zo = function() {
  function e2(t2) {
    this.element = Zr(t2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e2.prototype.insertRule = function(t2, r2) {
    if (t2 <= this.length && t2 >= 0) {
      var n3 = document.createTextNode(r2);
      return this.element.insertBefore(n3, this.nodes[t2] || null), this.length++, true;
    }
    return false;
  }, e2.prototype.deleteRule = function(t2) {
    this.element.removeChild(this.nodes[t2]), this.length--;
  }, e2.prototype.getRule = function(t2) {
    return t2 < this.length ? this.nodes[t2].textContent : "";
  }, e2;
}(), Xo = function() {
  function e2(t2) {
    this.rules = [], this.length = 0;
  }
  return e2.prototype.insertRule = function(t2, r2) {
    return t2 <= this.length && (this.rules.splice(t2, 0, r2), this.length++, true);
  }, e2.prototype.deleteRule = function(t2) {
    this.rules.splice(t2, 1), this.length--;
  }, e2.prototype.getRule = function(t2) {
    return t2 < this.length ? this.rules[t2] : "";
  }, e2;
}(), Kr = Ie$2, ei = { isServer: !Ie$2, useCSSOMInjection: !Po }, Re$3 = function() {
  function e2(t2, r2, n3) {
    t2 === void 0 && (t2 = he$2), r2 === void 0 && (r2 = {});
    var o2 = this;
    this.options = O$2(O$2({}, ei), t2), this.gs = r2, this.names = new Map(n3), this.server = !!t2.isServer, !this.server && Ie$2 && Kr && (Kr = false, Qr(this)), Ft(this, function() {
      return function(i2) {
        for (var s2 = i2.getTag(), l2 = s2.length, u2 = "", d2 = function(y2) {
          var v2 = function(I2) {
            return et$2.get(I2);
          }(y2);
          if (v2 === void 0) return "continue";
          var x2 = i2.names.get(v2), E2 = s2.getGroup(y2);
          if (x2 === void 0 || !x2.size || E2.length === 0) return "continue";
          var P2 = "".concat(H$1, ".g").concat(y2, '[id="').concat(v2, '"]'), Q2 = "";
          x2 !== void 0 && x2.forEach(function(I2) {
            I2.length > 0 && (Q2 += "".concat(I2, ","));
          }), u2 += "".concat(E2).concat(P2, '{content:"').concat(Q2, '"}').concat(Rt$1);
        }, m2 = 0; m2 < l2; m2++) d2(m2);
        return u2;
      }(o2);
    });
  }
  return e2.registerId = function(t2) {
    return We$1(t2);
  }, e2.prototype.rehydrate = function() {
    !this.server && Ie$2 && Qr(this);
  }, e2.prototype.reconstructWithOptions = function(t2, r2) {
    return r2 === void 0 && (r2 = true), new e2(O$2(O$2({}, this.options), t2), this.gs, r2 && this.names || void 0);
  }, e2.prototype.allocateGSInstance = function(t2) {
    return this.gs[t2] = (this.gs[t2] || 0) + 1;
  }, e2.prototype.getTag = function() {
    return this.tag || (this.tag = (t2 = function(r2) {
      var n3 = r2.useCSSOMInjection, o2 = r2.target;
      return r2.isServer ? new Xo(o2) : n3 ? new Jo(o2) : new Zo(o2);
    }(this.options), new zo(t2)));
    var t2;
  }, e2.prototype.hasNameForId = function(t2, r2) {
    return this.names.has(t2) && this.names.get(t2).has(r2);
  }, e2.prototype.registerName = function(t2, r2) {
    if (We$1(t2), this.names.has(t2)) this.names.get(t2).add(r2);
    else {
      var n3 = /* @__PURE__ */ new Set();
      n3.add(r2), this.names.set(t2, n3);
    }
  }, e2.prototype.insertRules = function(t2, r2, n3) {
    this.registerName(t2, r2), this.getTag().insertRules(We$1(t2), n3);
  }, e2.prototype.clearNames = function(t2) {
    this.names.has(t2) && this.names.get(t2).clear();
  }, e2.prototype.clearRules = function(t2) {
    this.getTag().clearGroup(We$1(t2)), this.clearNames(t2);
  }, e2.prototype.clearTag = function() {
    this.tag = void 0;
  }, e2;
}(), ti = /&/g, ri = /^\s*\/\/.*$/gm;
function Xr(e2, t2) {
  return e2.map(function(r2) {
    return r2.type === "rule" && (r2.value = "".concat(t2, " ").concat(r2.value), r2.value = r2.value.replaceAll(",", ",".concat(t2, " ")), r2.props = r2.props.map(function(n3) {
      return "".concat(t2, " ").concat(n3);
    })), Array.isArray(r2.children) && r2.type !== "@keyframes" && (r2.children = Xr(r2.children, t2)), r2;
  });
}
function en$2(e2) {
  var t2, r2, n3, o2 = he$2, i2 = o2.options, s2 = i2 === void 0 ? he$2 : i2, l2 = o2.plugins, u2 = l2 === void 0 ? tt$1 : l2, d2 = function(v2, x2, E2) {
    return E2.startsWith(r2) && E2.endsWith(r2) && E2.replaceAll(r2, "").length > 0 ? ".".concat(t2) : v2;
  }, m2 = u2.slice();
  m2.push(function(v2) {
    v2.type === J$2 && v2.value.includes("&") && (v2.props[0] = v2.props[0].replace(ti, r2).replace(n3, d2));
  }), s2.prefix && m2.push(kr), m2.push(Sr);
  var y2 = function(v2, x2, E2, P2) {
    x2 === void 0 && (x2 = ""), E2 === void 0 && (E2 = ""), P2 === void 0 && (P2 = "&"), t2 = P2, r2 = x2, n3 = new RegExp("\\".concat(r2, "\\b"), "g");
    var Q2 = v2.replace(ri, ""), I2 = Cr(E2 || x2 ? "".concat(E2, " ").concat(x2, " { ").concat(Q2, " }") : Q2);
    s2.namespace && (I2 = Xr(I2, s2.namespace));
    var N2 = [];
    return me$1(I2, Er(m2.concat(Ar(function(A2) {
      return N2.push(A2);
    })))), N2;
  };
  return y2.hash = u2.length ? u2.reduce(function(v2, x2) {
    return x2.name || $$3(15), ae$1(v2, x2.name);
  }, zr).toString() : "", y2;
}
var ni = new Re$3(), kt = en$2(), Dt$1 = React.createContext({ shouldForwardProp: void 0, styleSheet: ni, stylis: kt });
Dt$1.Consumer;
React.createContext(void 0);
function Pt() {
  return reactExports.useContext(Dt$1);
}
var It$1 = function() {
  function e2(t2, r2) {
    var n3 = this;
    this.inject = function(o2, i2) {
      i2 === void 0 && (i2 = kt);
      var s2 = n3.name + i2.hash;
      o2.hasNameForId(n3.id, s2) || o2.insertRules(n3.id, s2, i2(n3.rules, s2, "@keyframes"));
    }, this.name = t2, this.id = "sc-keyframes-".concat(t2), this.rules = r2, Ft(this, function() {
      throw $$3(12, String(n3.name));
    });
  }
  return e2.prototype.getName = function(t2) {
    return t2 === void 0 && (t2 = kt), this.name + t2.hash;
  }, e2;
}(), ai = function(e2) {
  return e2 >= "A" && e2 <= "Z";
};
function Lr(e2) {
  for (var t2 = "", r2 = 0; r2 < e2.length; r2++) {
    var n3 = e2[r2];
    if (r2 === 1 && n3 === "-" && e2[0] === "-") return e2;
    ai(n3) ? t2 += "-" + n3.toLowerCase() : t2 += n3;
  }
  return t2.startsWith("ms-") ? "-" + t2 : t2;
}
var tn$1 = function(e2) {
  return e2 == null || e2 === false || e2 === "";
}, rn$1 = function(e2) {
  var t2, r2, n3 = [];
  for (var o2 in e2) {
    var i2 = e2[o2];
    e2.hasOwnProperty(o2) && !tn$1(i2) && (Array.isArray(i2) && i2.isCss || ge$3(i2) ? n3.push("".concat(Lr(o2), ":"), i2, ";") : ve$2(i2) ? n3.push.apply(n3, G$3(G$3(["".concat(o2, " {")], rn$1(i2), false), ["}"], false)) : n3.push("".concat(Lr(o2), ": ").concat((t2 = o2, (r2 = i2) == null || typeof r2 == "boolean" || r2 === "" ? "" : typeof r2 != "number" || r2 === 0 || t2 in Pr || t2.startsWith("--") ? String(r2).trim() : "".concat(r2, "px")), ";")));
  }
  return n3;
};
function X$2(e2, t2, r2, n3) {
  if (tn$1(e2)) return [];
  if (_t$4(e2)) return [".".concat(e2.styledComponentId)];
  if (ge$3(e2)) {
    if (!ge$3(i2 = e2) || i2.prototype && i2.prototype.isReactComponent || !t2) return [e2];
    var o2 = e2(t2);
    return X$2(o2, t2, r2, n3);
  }
  var i2;
  return e2 instanceof It$1 ? r2 ? (e2.inject(r2, n3), [e2.getName(n3)]) : [e2] : ve$2(e2) ? rn$1(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(tt$1, e2.map(function(s2) {
    return X$2(s2, t2, r2, n3);
  })) : [e2.toString()];
}
function nn$1(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var r2 = e2[t2];
    if (ge$3(r2) && !_t$4(r2)) return false;
  }
  return true;
}
var si = Yr(ye$2), ci = function() {
  function e2(t2, r2, n3) {
    this.rules = t2, this.staticRulesId = "", this.isStatic = (n3 === void 0 || n3.isStatic) && nn$1(t2), this.componentId = r2, this.baseHash = ae$1(si, r2), this.baseStyle = n3, Re$3.registerId(r2);
  }
  return e2.prototype.generateAndInjectStyles = function(t2, r2, n3) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t2, r2, n3) : "";
    if (this.isStatic && !n3.hash) if (this.staticRulesId && r2.hasNameForId(this.componentId, this.staticRulesId)) o2 = se$2(o2, this.staticRulesId);
    else {
      var i2 = Ne$1(X$2(this.rules, t2, r2, n3)), s2 = St$1(ae$1(this.baseHash, i2) >>> 0);
      if (!r2.hasNameForId(this.componentId, s2)) {
        var l2 = n3(i2, ".".concat(s2), void 0, this.componentId);
        r2.insertRules(this.componentId, s2, l2);
      }
      o2 = se$2(o2, s2), this.staticRulesId = s2;
    }
    else {
      for (var u2 = ae$1(this.baseHash, n3.hash), d2 = "", m2 = 0; m2 < this.rules.length; m2++) {
        var y2 = this.rules[m2];
        if (typeof y2 == "string") d2 += y2;
        else if (y2) {
          var v2 = Ne$1(X$2(y2, t2, r2, n3));
          u2 = ae$1(u2, v2 + m2), d2 += v2;
        }
      }
      if (d2) {
        var x2 = St$1(u2 >>> 0);
        r2.hasNameForId(this.componentId, x2) || r2.insertRules(this.componentId, x2, n3(d2, ".".concat(x2), void 0, this.componentId)), o2 = se$2(o2, x2);
      }
    }
    return o2;
  }, e2;
}(), on$1 = React.createContext(void 0);
on$1.Consumer;
var Tt$1 = {};
function ui(e2, t2, r2) {
  var n3 = _t$4(e2), o2 = e2, i2 = !wt$2(e2), s2 = t2.attrs, l2 = s2 === void 0 ? tt$1 : s2, u2 = t2.componentId, d2 = u2 === void 0 ? function(C2, R2) {
    var w2 = typeof C2 != "string" ? "sc" : Rr(C2);
    Tt$1[w2] = (Tt$1[w2] || 0) + 1;
    var g2 = "".concat(w2, "-").concat(Vr(ye$2 + w2 + Tt$1[w2]));
    return R2 ? "".concat(R2, "-").concat(g2) : g2;
  }(t2.displayName, t2.parentComponentId) : u2, m2 = t2.displayName, y2 = m2 === void 0 ? function(C2) {
    return wt$2(C2) ? "styled.".concat(C2) : "Styled(".concat(Br(C2), ")");
  }(e2) : m2, v2 = t2.displayName && t2.componentId ? "".concat(Rr(t2.displayName), "-").concat(t2.componentId) : t2.componentId || d2, x2 = n3 && o2.attrs ? o2.attrs.concat(l2).filter(Boolean) : l2, E2 = t2.shouldForwardProp;
  if (n3 && o2.shouldForwardProp) {
    var P2 = o2.shouldForwardProp;
    if (t2.shouldForwardProp) {
      var Q2 = t2.shouldForwardProp;
      E2 = function(C2, R2) {
        return P2(C2, R2) && Q2(C2, R2);
      };
    } else E2 = P2;
  }
  var I2 = new ci(r2, v2, n3 ? o2.componentStyle : void 0);
  function N2(C2, R2) {
    return function(w2, g2, ee2) {
      var ce2 = w2.attrs, Ln = w2.componentStyle, qn = w2.defaultProps, Mn = w2.foldedComponentIds, $t3 = w2.styledComponentId, Un = w2.target, $n = React.useContext(on$1), jn2 = Pt(), at2 = w2.shouldForwardProp || jn2.shouldForwardProp;
      var jt2 = No(g2, $n, qn) || he$2, Y3 = function(Fe2, Se2, De2) {
        for (var ue2, te2 = O$2(O$2({}, Se2), { className: void 0, theme: De2 }), ut2 = 0; ut2 < Fe2.length; ut2 += 1) {
          var Oe2 = ge$3(ue2 = Fe2[ut2]) ? ue2(te2) : ue2;
          for (var W2 in Oe2) te2[W2] = W2 === "className" ? se$2(te2[W2], Oe2[W2]) : W2 === "style" ? O$2(O$2({}, te2[W2]), Oe2[W2]) : Oe2[W2];
        }
        return Se2.className && (te2.className = se$2(te2.className, Se2.className)), te2;
      }(ce2, g2, jt2), Te2 = Y3.as || Un, Ce2 = {};
      for (var L2 in Y3) Y3[L2] === void 0 || L2[0] === "$" || L2 === "as" || L2 === "theme" && Y3.theme === jt2 || (L2 === "forwardedAs" ? Ce2.as = Y3.forwardedAs : at2 && !at2(L2, Te2) || (Ce2[L2] = Y3[L2], at2 || true));
      var st2 = function(Fe2, Se2) {
        var De2 = Pt(), ue2 = Fe2.generateAndInjectStyles(Se2, De2.styleSheet, De2.stylis);
        return ue2;
      }(Ln, Y3);
      var ct2 = se$2(Mn, $t3);
      return st2 && (ct2 += " " + st2), Y3.className && (ct2 += " " + Y3.className), Ce2[wt$2(Te2) && !Ct$1.has(Te2) ? "class" : "className"] = ct2, Ce2.ref = ee2, reactExports.createElement(Te2, Ce2);
    }(A2, C2, R2);
  }
  N2.displayName = y2;
  var A2 = React.forwardRef(N2);
  return A2.attrs = x2, A2.componentStyle = I2, A2.displayName = y2, A2.shouldForwardProp = E2, A2.foldedComponentIds = n3 ? se$2(o2.foldedComponentIds, o2.styledComponentId) : "", A2.styledComponentId = v2, A2.target = n3 ? o2.target : e2, Object.defineProperty(A2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(C2) {
    this._foldedDefaultProps = n3 ? function(R2) {
      for (var w2 = [], g2 = 1; g2 < arguments.length; g2++) w2[g2 - 1] = arguments[g2];
      for (var ee2 = 0, ce2 = w2; ee2 < ce2.length; ee2++) Et$1(R2, ce2[ee2], true);
      return R2;
    }({}, o2.defaultProps, C2) : C2;
  } }), Ft(A2, function() {
    return ".".concat(A2.styledComponentId);
  }), i2 && Jr(A2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), A2;
}
function Mr(e2, t2) {
  for (var r2 = [e2[0]], n3 = 0, o2 = t2.length; n3 < o2; n3 += 1) r2.push(t2[n3], e2[n3 + 1]);
  return r2;
}
var Ur = function(e2) {
  return Object.assign(e2, { isCss: true });
};
function an(e2) {
  for (var t2 = [], r2 = 1; r2 < arguments.length; r2++) t2[r2 - 1] = arguments[r2];
  if (ge$3(e2) || ve$2(e2)) return Ur(X$2(Mr(tt$1, G$3([e2], t2, true))));
  var n3 = e2;
  return t2.length === 0 && n3.length === 1 && typeof n3[0] == "string" ? X$2(n3) : Ur(X$2(Mr(n3, t2)));
}
function Nt$1(e2, t2, r2) {
  if (r2 === void 0 && (r2 = he$2), !t2) throw $$3(1, t2);
  var n3 = function(o2) {
    for (var i2 = [], s2 = 1; s2 < arguments.length; s2++) i2[s2 - 1] = arguments[s2];
    return e2(t2, r2, an.apply(void 0, G$3([o2], i2, false)));
  };
  return n3.attrs = function(o2) {
    return Nt$1(e2, t2, O$2(O$2({}, r2), { attrs: Array.prototype.concat(r2.attrs, o2).filter(Boolean) }));
  }, n3.withConfig = function(o2) {
    return Nt$1(e2, t2, O$2(O$2({}, r2), o2));
  }, n3;
}
var sn = function(e2) {
  return Nt$1(ui, e2);
}, F$3 = sn;
Ct$1.forEach(function(e2) {
  F$3[e2] = sn(e2);
});
function rt$2(e2) {
  for (var t2 = [], r2 = 1; r2 < arguments.length; r2++) t2[r2 - 1] = arguments[r2];
  var n3 = Ne$1(an.apply(void 0, G$3([e2], t2, false))), o2 = Vr(n3);
  return new It$1(o2, n3);
}
var cn = F$3.h2`
  text-align: center;
  font-size: 1.2em;
  font-weight: 500;
  color: var(--fuel-color-bold);
  margin: 0 0 0.8em 0;
`, un = F$3.p`
  text-align: center;
  margin: 0 1.2em;
  line-height: 1.2em;
`, ln = F$3.div`
  display: flex;
  justify-content: center;
  height: 6.2em;
  width: 100%;
  margin-top: 1.4em;
  margin-bottom: 1.2em;
`, pn = F$3.a`
  display: flex;
  box-sizing: border-box;
  text-decoration: none;
  justify-content: center;
  align-items: center;
  margin: 1.4em 1em 0;
  padding: 0.6em 0;
  font-size: 1.1em;
  color: var(--fuel-color-bold);
  border-radius: var(--fuel-border-radius);
  background-color: var(--fuel-button-background);

  &:visited {
    color: var(--fuel-color-bold);
  }

  &:hover {
    background-color: var(--fuel-button-background-hover);
  }
`, fn = F$3.div`
  display: flex;
  flex-direction: column;
`;
function mn({ className: e2, connector: t2, theme: r2 }) {
  let { install: { action: n3, link: o2, description: i2 } } = t2.metadata, { setError: s2, dialog: { connect: l2 } } = re$3(), [u2, d2] = reactExports.useState(!t2.installed);
  return reactExports.useEffect(() => {
    (async () => {
      try {
        await t2.ping(), t2.installed = true, l2(t2);
      } catch (y2) {
        d2(false), s2(y2);
      }
    })();
  }, [t2, l2, s2]), jsxRuntimeExports.jsxs("div", { className: e2, children: [jsxRuntimeExports.jsx(ln, { children: jsxRuntimeExports.jsx(Le$1, { connectorMetadata: t2.metadata, connectorName: t2.name, size: 100, theme: r2 }) }), jsxRuntimeExports.jsxs(fn, { children: [jsxRuntimeExports.jsx(cn, { children: t2.name }), jsxRuntimeExports.jsx(un, { children: u2 ? "Loading..." : i2 })] }), !u2 && jsxRuntimeExports.jsx(pn, { href: o2, target: "_blank", children: n3 || "Install" })] });
}
a$2();
a$2();
a$2();
a$2();
a$2();
function hn({ size: e2, ...t2 }) {
  return jsxRuntimeExports.jsxs("svg", { fill: "none", xmlns: "http://www.w3.org/2000/svg", width: e2, height: e2, viewBox: "0 0 16 16", ...t2, children: [jsxRuntimeExports.jsx("title", { children: "Back Icon" }), jsxRuntimeExports.jsx("path", { fill: "currentColor", fillRule: "evenodd", d: "M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z", clipRule: "evenodd" })] });
}
a$2();
function vn({ size: e2, ...t2 }) {
  return jsxRuntimeExports.jsxs("svg", { fill: "none", xmlns: "http://www.w3.org/2000/svg", width: e2, height: e2, viewBox: "0 0 16 16", ...t2, children: [jsxRuntimeExports.jsx("title", { children: "Close Icon" }), jsxRuntimeExports.jsx("path", { fill: "currentColor", fillRule: "evenodd", d: "M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z", clipRule: "evenodd" })] });
}
var yi = rt$2`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`, hi = rt$2`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`, gi = rt$2`
  0%{
    background-position: -468px 0
  }
  100%{
    background-position: 468px 0
  }
`, bn = F$3(Overlay)`
  background-color: var(--fuel-overlay-background);
  position: fixed;
  inset: 0;
  animation: ${yi} 150ms cubic-bezier(0.16, 1, 0.3, 1);
`, xn = F$3(Content)`
  overflow: hidden;
  color: var(--fuel-color);
  user-select: none;
  max-height: calc(100% - 20px);
  box-sizing: border-box;
  background-color: var(--fuel-dialog-background);
  position: fixed;
  left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 36px;
  padding: 14px 0px;
  padding-bottom: 18px;
  animation: ${hi} 150ms cubic-bezier(0.16, 1, 0.3, 1);
  box-shadow:
    hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
    hsl(206 22% 7% / 20%) 0px 10px 20px -15px;

  &:focus {
    outline: none;
  }

  @media (min-width: 431px) {
    top: 50%;
    width: 360px;
    max-width: calc(100% - 20px);
  }

  @media (max-width: 430px) {
    top: auto;
    bottom: -246px;
    width: 100vw;
    max-width: 100%;
    border-radius: 36px 36px 0 0;
  }
`, wn = F$3(Title)`
  padding: 8px 14px 12px;
  margin: 0;
  font-weight: normal;
  text-align: center;
  font-size: 16px;
  letter-spacing: var(--fuel-letter-spacing);
  font-weight: 700;
`, Tn = F$3.div`
  height: 1px;
  width: 100%;
  background-color: var(--fuel-border-color);
  margin: 10px 0;
  padding: 0;
  box-sizing: border-box;
`, Cn = F$3.div`
  margin-top: 20px;
  position: relative;
`, Sn = F$3(hn)`
  fill: var(--fuel-color);
  padding: 7px;
  font-family: inherit;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 20px;
  left: 28px;
  cursor: pointer;
  font-weight: 700;

  &[data-connector='false'] {
    display: none;
  }

  &:hover,
  &:active {
    background-color: var(--fuel-connector-hover);
    opacity: 1;
  }
`, En = F$3(vn)`
  fill: var(--fuel-color);
  padding: 7px;
  font-family: inherit;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 18px;
  right: 28px;
  cursor: pointer;
  font-weight: 700;

  &:hover,
  &:active {
    background-color: var(--fuel-connector-hover);
    opacity: 1;
  }
`, An$1 = F$3.div`
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  z-index: 9999;
  font-size: var(--fuel-font-size);

  & * {
    font-family: var(--fuel-font-family);
  }
`, Ot$1 = F$3.div`
  animation-duration: 1s;
  animation-fill-mode: forwards;
  animation-iteration-count: infinite;
  animation-name: ${gi};
  animation-timing-function: linear;
  background: #d1d5d9;
  background: var(--fuel-loader-background);
  background-size: 1000px 104px;
  height: fit-content;
  position: relative;
  overflow: hidden;
  color: transparent !important;
  pointer-events: none !important;
`;
a$2();
var nt$1 = F$3.div`
  display: flex;
  align-items: center;
  background-color: var(--fuel-connector-background);
  box-sizing: border-box;
  cursor: pointer;
  width: 100%;
  color: var(--fuel-font-color);
  gap: var(--fuel-items-gap);
  padding: 0.8em;
  border-radius: 16px;
  letter-spacing: var(--fuel-letter-spacing);
  font-weight: 500;
  transition: background-color opacity 50ms cubic-bezier(0.16, 1, 0.3, 1);

  &:active {
    opacity: 0.8;
  }
  &:hover {
    background-color: var(--fuel-connector-hover);
  }
`, kn = F$3.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--fuel-items-gap);
  padding: 0px 14px;
`, ot$1 = F$3.div`
  font-size: var(--fuel-font-size);
`;
F$3.img`
  object-fit: cover;
`;
function Pn({ items: e2 }) {
  return Array.from({ length: e2 }).map((r2, n3) => jsxRuntimeExports.jsxs(nt$1, { children: [jsxRuntimeExports.jsx(Ot$1, { children: jsxRuntimeExports.jsx("div", { style: { height: 32, width: 32 } }) }), jsxRuntimeExports.jsx(Ot$1, { children: jsxRuntimeExports.jsx(ot$1, { style: { width: 180 }, children: "Fuel Wallet" }) })] }, n3));
}
function Nn() {
  var _a2;
  let { fuelConfig: e2, connectors: t2, isLoading: r2, theme: n3, dialog: { connect: o2 } } = re$3();
  return jsxRuntimeExports.jsxs(kn, { children: [t2.map((i2, s2) => jsxRuntimeExports.jsxs(nt$1, { tabIndex: s2 + 1, "aria-label": `Connect to ${i2.name}`, "data-installed": i2.installed, "data-connected": i2.connected, onClick: (l2) => {
    l2.preventDefault(), o2(i2);
  }, children: [jsxRuntimeExports.jsx(Le$1, { connectorMetadata: i2.metadata, connectorName: i2.name, size: 32, theme: n3 }), jsxRuntimeExports.jsx(ot$1, { children: i2.name })] }, i2.name)), r2 && jsxRuntimeExports.jsx(Pn, { items: ((_a2 = e2.connectors) == null ? void 0 : _a2.length) || 2 })] });
}
a$2();
var bi = { "--fuel-font-family": '"Inter", "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;', "--fuel-font-size": "16px", "--fuel-letter-spacing": "-0.64px", "--fuel-border-radius": "6px", "--fuel-items-gap": "8px", "--fuel-border": "1px solid var(--fuel-border-color)" }, xi = { "--fuel-color": "#141414", "--fuel-color-bold": "#000000", "--fuel-dialog-background": "white", "--fuel-overlay-background": "rgba(71,88,107,0.24)", "--fuel-connector-background": "rgb(250 250 250)", "--fuel-connector-hover": "rgb(241 243 244)", "--fuel-border-color": "hsl(210deg 9.52% 83.53%)", "--fuel-border-hover": "hsla(0, 0%, 78.04%, 1)", "--fuel-button-background": "rgb(250 250 250)", "--fuel-button-background-hover": "rgb(203 205 207)", "--fuel-loader-background": "linear-gradient(to right, hsl(0, 0%, 92%) 8%, hsl(0, 0%, 85%) 18%, hsl(0, 0%, 92%) 33%)" }, wi = { "--fuel-color": "#e4e7e7", "--fuel-color-bold": "#ffffff", "--fuel-dialog-background": "rgb(25 26 26)", "--fuel-overlay-background": "rgba(20, 20, 20, 0.8)", "--fuel-connector-background": "rgba(255, 255, 255, 0.02)", "--fuel-connector-hover": "rgba(255, 255, 255, 0.05)", "--fuel-border-color": "rgba(255, 255, 255, 0.05)", "--fuel-border-hover": "hsla(0, 0%, 50%, 1)", "--fuel-button-background": "hsla(0, 0%, 30%, 1)", "--fuel-button-background-hover": "hsla(0, 0%, 40%, 1)", "--fuel-loader-background": "linear-gradient(to right, hsl(0, 0%, 20%) 8%, hsl(0, 0%, 25%) 18%, hsl(0, 0%, 20%) 33%)" }, Rn = (e2, t2) => ({ ...bi, ...e2 === "dark" ? wi : xi, ...t2 });
function _n() {
  let [e2, t2] = reactExports.useState(false), r2 = reactExports.useRef(null), { theme: n3, cancel: o2, dialog: { isOpen: i2, connector: s2, back: l2 } } = re$3();
  reactExports.useEffect(() => {
    t2(true);
  }, []);
  let u2 = (d2) => {
    d2 || o2();
  };
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(An$1, { ref: r2, style: e2 ? { display: i2 ? "block" : "none", ...Rn(n3) } : void 0 }), jsxRuntimeExports.jsx(Root, { open: i2, onOpenChange: u2, children: jsxRuntimeExports.jsxs(Portal$1, { container: r2.current, children: [jsxRuntimeExports.jsx(bn, {}), jsxRuntimeExports.jsxs(xn, { "data-connector": !!s2, children: [jsxRuntimeExports.jsx(wn, { children: "Connect Wallet" }), jsxRuntimeExports.jsx(Tn, {}), jsxRuntimeExports.jsx(Close, { asChild: true, children: jsxRuntimeExports.jsx(En, { size: 32 }) }), jsxRuntimeExports.jsx(Sn, { size: 32, onClick: l2, "data-connector": !!s2 }), jsxRuntimeExports.jsx(Cn, { children: s2 ? jsxRuntimeExports.jsx(mn, { connector: s2 }) : jsxRuntimeExports.jsx(Nn, {}) })] })] }) })] });
}
function eu({ theme: e2, children: t2, fuelConfig: r2, ui: n3 = true }) {
  return n3 ? jsxRuntimeExports.jsx(lt$2, { fuelConfig: r2, children: jsxRuntimeExports.jsxs(Zt$2, { theme: e2, fuelConfig: r2, children: [jsxRuntimeExports.jsx(_n, {}), t2] }) }) : jsxRuntimeExports.jsx(lt$2, { fuelConfig: r2, children: t2 });
}
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
var we$1 = () => {
  let { fuel: e2 } = b$4();
  return S$3("provider", { queryKey: c$7.provider(), queryFn: async () => await e2.getProvider() || null, initialData: null });
};
var Wu = ({ address: e2, assetId: t2 }) => {
  let { provider: r2 } = we$1(), n3 = S$3("balance", { queryKey: c$7.balance(e2, t2), queryFn: async () => {
    try {
      if (!r2) throw new Error("Provider is needed");
      let o2 = t2 || r2.getBaseAssetId();
      return await r2.getBalance(Address.fromString(e2 || ""), o2) || null;
    } catch {
      return null;
    }
  }, initialData: null, enabled: !!r2 });
  return reactExports.useEffect(() => {
    let o2 = () => {
      n3.refetch();
    };
    return window.addEventListener("focus", o2), () => {
      window.removeEventListener("focus", o2);
    };
  }, [n3]), n3;
};
a$2();
a$2();
a$2();
var fl = () => {
  let { fuel: e2 } = b$4(), { mutate: t2, mutateAsync: r2, ...n3 } = useMutation({ mutationFn: async () => e2 == null ? void 0 : e2.disconnect() });
  return { disconnect: t2, disconnectAsync: r2, ...n3 };
};
a$2();
var vl = () => {
  let { fuel: e2 } = b$4();
  return S$3("isConnected", { queryKey: c$7.isConnected(), queryFn: async () => {
    try {
      return await e2.isConnected() || false;
    } catch {
      return false;
    }
  }, initialData: false });
};
a$2();
var Sl = () => {
  let { fuel: e2 } = b$4();
  return S$3("network", { queryKey: c$7.currentNetwork(), queryFn: async () => e2.currentNetwork(), initialData: null });
};
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
a$2();
var wp = (e2) => {
  let { fuel: t2 } = b$4();
  return S$3("wallet", { queryKey: c$7.wallet(e2), queryFn: async () => {
    try {
      let r2 = e2 || await t2.currentAccount() || "";
      return await Address.fromString(r2), await t2.getWallet(r2) || null;
    } catch {
      return null;
    }
  }, initialData: null });
};
a$2();
const Button$1 = ({ children, className, onClick, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      ...props,
      className: `bg-fuel-green text-white px-4 py-2 rounded-md ${className}`,
      onClick,
      children
    }
  );
};
let e$5 = { data: "" }, t$5 = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e$5, l$4 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a$1 = /\/\*[^]*?\*\/|  +/g, n$7 = /\n+/g, o$3 = (e2, t2) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n3 in e2) {
    let c2 = e2[n3];
    "@" == n3[0] ? "i" == n3[1] ? r2 = n3 + " " + c2 + ";" : l2 += "f" == n3[1] ? o$3(c2, n3) : n3 + "{" + o$3(c2, "k" == n3[1] ? "" : t2) + "}" : "object" == typeof c2 ? l2 += o$3(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n3.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n3) : null != c2 && (n3 = /^--/.test(n3) ? n3 : n3.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o$3.p ? o$3.p(n3, c2) : n3 + ":" + c2 + ";");
  }
  return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
}, c$6 = {}, s$3 = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2) t2 += r2 + s$3(e2[r2]);
    return t2;
  }
  return e2;
}, i$6 = (e2, t2, r2, i2, p2) => {
  let u2 = s$3(e2), d2 = c$6[u2] || (c$6[u2] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; ) r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u2));
  if (!c$6[d2]) {
    let t3 = u2 !== e2 ? e2 : ((e3) => {
      let t4, r3, o2 = [{}];
      for (; t4 = l$4.exec(e3.replace(a$1, "")); ) t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n$7, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n$7, " ").trim();
      return o2[0];
    })(e2);
    c$6[d2] = o$3(p2 ? { ["@keyframes " + d2]: t3 } : t3, r2 ? "" : "." + d2);
  }
  let f2 = r2 && c$6.g ? c$6.g : null;
  return r2 && (c$6.g = c$6[d2]), ((e3, t3, r3, l2) => {
    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c$6[d2], t2, i2, f2), d2;
}, p$3 = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
  let n3 = t2[a2];
  if (n3 && n3.call) {
    let e4 = n3(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n3 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o$3(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n3 ? "" : n3);
}, "");
function u$3(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i$6(l2.unshift ? l2.raw ? p$3(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t$5(r2.target), r2.g, r2.o, r2.k);
}
let d$3, f$7, g$3;
u$3.bind({ g: 1 });
let h$7 = u$3.bind({ k: 1 });
function m$3(e2, t2, r2, l2) {
  o$3.p = t2, d$3 = e2, f$7 = r2, g$3 = l2;
}
function j$1(e2, t2) {
  let r2 = this || {};
  return function() {
    let l2 = arguments;
    function a2(n3, o2) {
      let c2 = Object.assign({}, n3), s2 = c2.className || a2.className;
      r2.p = Object.assign({ theme: f$7 && f$7() }, c2), r2.o = / *go\d+/.test(s2), c2.className = u$3.apply(r2, l2) + (s2 ? " " + s2 : "");
      let i2 = e2;
      return e2[0] && (i2 = c2.as || e2, delete c2.as), g$3 && i2[0] && g$3(c2), d$3(i2, c2);
    }
    return a2;
  };
}
var W$1 = (e2) => typeof e2 == "function", T$1 = (e2, t2) => W$1(e2) ? e2(t2) : e2;
var U$2 = /* @__PURE__ */ (() => {
  let e2 = 0;
  return () => (++e2).toString();
})(), b$3 = /* @__PURE__ */ (() => {
  let e2;
  return () => {
    if (e2 === void 0 && typeof window < "u") {
      let t2 = matchMedia("(prefers-reduced-motion: reduce)");
      e2 = !t2 || t2.matches;
    }
    return e2;
  };
})();
var Q$2 = 20;
var S$2 = /* @__PURE__ */ new Map(), X$1 = 1e3, $$2 = (e2) => {
  if (S$2.has(e2)) return;
  let t2 = setTimeout(() => {
    S$2.delete(e2), u$2({ type: 4, toastId: e2 });
  }, X$1);
  S$2.set(e2, t2);
}, J$1 = (e2) => {
  let t2 = S$2.get(e2);
  t2 && clearTimeout(t2);
}, v$3 = (e2, t2) => {
  switch (t2.type) {
    case 0:
      return { ...e2, toasts: [t2.toast, ...e2.toasts].slice(0, Q$2) };
    case 1:
      return t2.toast.id && J$1(t2.toast.id), { ...e2, toasts: e2.toasts.map((r2) => r2.id === t2.toast.id ? { ...r2, ...t2.toast } : r2) };
    case 2:
      let { toast: o2 } = t2;
      return e2.toasts.find((r2) => r2.id === o2.id) ? v$3(e2, { type: 1, toast: o2 }) : v$3(e2, { type: 0, toast: o2 });
    case 3:
      let { toastId: s2 } = t2;
      return s2 ? $$2(s2) : e2.toasts.forEach((r2) => {
        $$2(r2.id);
      }), { ...e2, toasts: e2.toasts.map((r2) => r2.id === s2 || s2 === void 0 ? { ...r2, visible: false } : r2) };
    case 4:
      return t2.toastId === void 0 ? { ...e2, toasts: [] } : { ...e2, toasts: e2.toasts.filter((r2) => r2.id !== t2.toastId) };
    case 5:
      return { ...e2, pausedAt: t2.time };
    case 6:
      let a2 = t2.time - (e2.pausedAt || 0);
      return { ...e2, pausedAt: void 0, toasts: e2.toasts.map((r2) => ({ ...r2, pauseDuration: r2.pauseDuration + a2 })) };
  }
}, A$1 = [], P$1 = { toasts: [], pausedAt: void 0 }, u$2 = (e2) => {
  P$1 = v$3(P$1, e2), A$1.forEach((t2) => {
    t2(P$1);
  });
}, Y$2 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I$1 = (e2 = {}) => {
  let [t2, o2] = reactExports.useState(P$1);
  reactExports.useEffect(() => (A$1.push(o2), () => {
    let a2 = A$1.indexOf(o2);
    a2 > -1 && A$1.splice(a2, 1);
  }), [t2]);
  let s2 = t2.toasts.map((a2) => {
    var r2, c2;
    return { ...e2, ...e2[a2.type], ...a2, duration: a2.duration || ((r2 = e2[a2.type]) == null ? void 0 : r2.duration) || (e2 == null ? void 0 : e2.duration) || Y$2[a2.type], style: { ...e2.style, ...(c2 = e2[a2.type]) == null ? void 0 : c2.style, ...a2.style } };
  });
  return { ...t2, toasts: s2 };
};
var G$2 = (e2, t2 = "blank", o2) => ({ createdAt: Date.now(), visible: true, type: t2, ariaProps: { role: "status", "aria-live": "polite" }, message: e2, pauseDuration: 0, ...o2, id: (o2 == null ? void 0 : o2.id) || U$2() }), h$6 = (e2) => (t2, o2) => {
  let s2 = G$2(t2, e2, o2);
  return u$2({ type: 2, toast: s2 }), s2.id;
}, n$6 = (e2, t2) => h$6("blank")(e2, t2);
n$6.error = h$6("error");
n$6.success = h$6("success");
n$6.loading = h$6("loading");
n$6.custom = h$6("custom");
n$6.dismiss = (e2) => {
  u$2({ type: 3, toastId: e2 });
};
n$6.remove = (e2) => u$2({ type: 4, toastId: e2 });
n$6.promise = (e2, t2, o2) => {
  let s2 = n$6.loading(t2.loading, { ...o2, ...o2 == null ? void 0 : o2.loading });
  return e2.then((a2) => (n$6.success(T$1(t2.success, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.success }), a2)).catch((a2) => {
    n$6.error(T$1(t2.error, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.error });
  }), e2;
};
var Z$2 = (e2, t2) => {
  u$2({ type: 1, toast: { id: e2, height: t2 } });
}, ee$1 = () => {
  u$2({ type: 5, time: Date.now() });
}, D$1 = (e2) => {
  let { toasts: t2, pausedAt: o2 } = I$1(e2);
  reactExports.useEffect(() => {
    if (o2) return;
    let r2 = Date.now(), c2 = t2.map((i2) => {
      if (i2.duration === 1 / 0) return;
      let d2 = (i2.duration || 0) + i2.pauseDuration - (r2 - i2.createdAt);
      if (d2 < 0) {
        i2.visible && n$6.dismiss(i2.id);
        return;
      }
      return setTimeout(() => n$6.dismiss(i2.id), d2);
    });
    return () => {
      c2.forEach((i2) => i2 && clearTimeout(i2));
    };
  }, [t2, o2]);
  let s2 = reactExports.useCallback(() => {
    o2 && u$2({ type: 6, time: Date.now() });
  }, [o2]), a2 = reactExports.useCallback((r2, c2) => {
    let { reverseOrder: i2 = false, gutter: d2 = 8, defaultPosition: p2 } = c2 || {}, g2 = t2.filter((m2) => (m2.position || p2) === (r2.position || p2) && m2.height), E2 = g2.findIndex((m2) => m2.id === r2.id), x2 = g2.filter((m2, R2) => R2 < E2 && m2.visible).length;
    return g2.filter((m2) => m2.visible).slice(...i2 ? [x2 + 1] : [0, x2]).reduce((m2, R2) => m2 + (R2.height || 0) + d2, 0);
  }, [t2]);
  return { toasts: t2, handlers: { updateHeight: Z$2, startPause: ee$1, endPause: s2, calculateOffset: a2 } };
};
var oe$1 = h$7`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re$2 = h$7`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se$1 = h$7`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _$2 = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re$2} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e2) => e2.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se$1} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
var ne$1 = h$7`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V$2 = j$1("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e2) => e2.secondary || "#e0e0e0"};
  border-right-color: ${(e2) => e2.primary || "#616161"};
  animation: ${ne$1} 1s linear infinite;
`;
var pe$1 = h$7`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de$1 = h$7`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w$2 = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de$1} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e2) => e2.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
var ue$1 = j$1("div")`
  position: absolute;
`, le$1 = j$1("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te$1 = h$7`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe$1 = j$1("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te$1} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M$1 = ({ toast: e2 }) => {
  let { icon: t2, type: o2, iconTheme: s2 } = e2;
  return t2 !== void 0 ? typeof t2 == "string" ? reactExports.createElement(fe$1, null, t2) : t2 : o2 === "blank" ? null : reactExports.createElement(le$1, null, reactExports.createElement(V$2, { ...s2 }), o2 !== "loading" && reactExports.createElement(ue$1, null, o2 === "error" ? reactExports.createElement(_$2, { ...s2 }) : reactExports.createElement(w$2, { ...s2 })));
};
var ye$1 = (e2) => `
0% {transform: translate3d(0,${e2 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge$2 = (e2) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e2 * -150}%,-1px) scale(.6); opacity:0;}
`, he$1 = "0%{opacity:0;} 100%{opacity:1;}", xe$1 = "0%{opacity:1;} 100%{opacity:0;}", be$1 = j$1("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se$1 = j$1("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae$1 = (e2, t2) => {
  let s2 = e2.includes("top") ? 1 : -1, [a2, r2] = b$3() ? [he$1, xe$1] : [ye$1(s2), ge$2(s2)];
  return { animation: t2 ? `${h$7(a2)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$7(r2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, F$2 = reactExports.memo(({ toast: e2, position: t2, style: o2, children: s2 }) => {
  let a2 = e2.height ? Ae$1(e2.position || t2 || "top-center", e2.visible) : { opacity: 0 }, r2 = reactExports.createElement(M$1, { toast: e2 }), c2 = reactExports.createElement(Se$1, { ...e2.ariaProps }, T$1(e2.message, e2));
  return reactExports.createElement(be$1, { className: e2.className, style: { ...a2, ...o2, ...e2.style } }, typeof s2 == "function" ? s2({ icon: r2, message: c2 }) : reactExports.createElement(reactExports.Fragment, null, r2, c2));
});
m$3(reactExports.createElement);
var Ee$1 = ({ id: e2, className: t2, style: o2, onHeightUpdate: s2, children: a2 }) => {
  let r2 = reactExports.useCallback((c2) => {
    if (c2) {
      let i2 = () => {
        let d2 = c2.getBoundingClientRect().height;
        s2(e2, d2);
      };
      i2(), new MutationObserver(i2).observe(c2, { subtree: true, childList: true, characterData: true });
    }
  }, [e2, s2]);
  return reactExports.createElement("div", { ref: r2, className: t2, style: o2 }, a2);
}, Re$2 = (e2, t2) => {
  let o2 = e2.includes("top"), s2 = o2 ? { top: 0 } : { bottom: 0 }, a2 = e2.includes("center") ? { justifyContent: "center" } : e2.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b$3() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t2 * (o2 ? 1 : -1)}px)`, ...s2, ...a2 };
}, ve$1 = u$3`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O$1 = 16, Ie$1 = ({ reverseOrder: e2, position: t2 = "top-center", toastOptions: o2, gutter: s2, children: a2, containerStyle: r2, containerClassName: c2 }) => {
  let { toasts: i2, handlers: d2 } = D$1(o2);
  return reactExports.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O$1, left: O$1, right: O$1, bottom: O$1, pointerEvents: "none", ...r2 }, className: c2, onMouseEnter: d2.startPause, onMouseLeave: d2.endPause }, i2.map((p2) => {
    let g2 = p2.position || t2, E2 = d2.calculateOffset(p2, { reverseOrder: e2, gutter: s2, defaultPosition: t2 }), x2 = Re$2(g2, E2);
    return reactExports.createElement(Ee$1, { id: p2.id, key: p2.id, onHeightUpdate: d2.updateHeight, className: p2.visible ? ve$1 : "", style: x2 }, p2.type === "custom" ? T$1(p2.message, p2) : a2 ? a2(p2) : reactExports.createElement(F$2, { toast: p2, position: g2 }));
  }));
};
var _t$3 = n$6;
const useActiveWallet = () => {
  const { wallet, isLoading: isWalletLoading } = wp();
  const { balance, refetch } = Wu({
    address: wallet == null ? void 0 : wallet.address.toB256()
  });
  const { isConnected, isLoading: isConnectedLoading } = vl();
  const { network } = Sl();
  return {
    wallet,
    walletBalance: balance,
    refetchBalance: refetch,
    isPending: isWalletLoading || isConnectedLoading,
    isConnected,
    network
  };
};
const CopyIconDark = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!Font%20Awesome%20Free%206.5.1%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202024%20Fonticons,%20Inc.--%3e%3cpath%20fill='%23ffffff'%20d='M208%200H332.1c12.7%200%2024.9%205.1%2033.9%2014.1l67.9%2067.9c9%209%2014.1%2021.2%2014.1%2033.9V336c0%2026.5-21.5%2048-48%2048H208c-26.5%200-48-21.5-48-48V48c0-26.5%2021.5-48%2048-48zM48%20128h80v64H64V448H256V416h64v48c0%2026.5-21.5%2048-48%2048H48c-26.5%200-48-21.5-48-48V176c0-26.5%2021.5-48%2048-48z'%20/%3e%3c/svg%3e";
const CopyIconLight = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!Font%20Awesome%20Free%206.5.1%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202024%20Fonticons,%20Inc.--%3e%3cpath%20fill='%239ca3af'%20d='M208%200H332.1c12.7%200%2024.9%205.1%2033.9%2014.1l67.9%2067.9c9%209%2014.1%2021.2%2014.1%2033.9V336c0%2026.5-21.5%2048-48%2048H208c-26.5%200-48-21.5-48-48V48c0-26.5%2021.5-48%2048-48zM48%20128h80v64H64V448H256V416h64v48c0%2026.5-21.5%2048-48%2048H48c-26.5%200-48-21.5-48-48V176c0-26.5%2021.5-48%2048-48z'%20/%3e%3c/svg%3e";
/**
 * @remix-run/router v1.19.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value2, message) {
  if (value2 === false || value2 === null || typeof value2 === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location2, index) {
  return {
    usr: location2.state,
    key: location2.key,
    idx: index
  };
}
function createLocation(current, to2, state2, key) {
  if (state2 === void 0) {
    state2 = null;
  }
  let location2 = _extends$4({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state: state2,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location2;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$4({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state2 = globalHistory.state || {
      idx: null
    };
    return state2.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to2, state2) {
    action = Action.Push;
    let location2 = createLocation(history.location, to2, state2);
    index = getIndex() + 1;
    let historyState = getHistoryState(location2, index);
    let url2 = history.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url2);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url2);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to2, state2) {
    action = Action.Replace;
    let location2 = createLocation(history.location, to2, state2);
    index = getIndex();
    let historyState = getHistoryState(location2, index);
    let url2 = history.createHref(location2);
    globalHistory.replaceState(historyState, "", url2);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    href = href.replace(/ $/, "%20");
    invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base2);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url2 = createURL(to2);
      return {
        pathname: url2.pathname,
        search: url2.search,
        hash: url2.hash
      };
    },
    push,
    replace: replace2,
    go(n3) {
      return globalHistory.go(n3);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i2], decoded, allowPartial);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments2 = path.split("/");
  if (segments2.length === 0) return [];
  let [first, ...rest] = segments2;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments2 = path.split("/");
  let initialScore = segments2.length;
  if (segments2.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments2.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n3, i2) => n3 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match2 && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match2 = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value2 = captureGroups[index];
    if (isOptional && !value2) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value2 || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value2) {
  try {
    return value2.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value2 + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value2;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments2 = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments2.length > 1) segments2.pop();
    } else if (segment !== ".") {
      segments2.push(segment);
    }
  });
  return segments2.length > 1 ? segments2.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = _extends$4({}, toArg);
    invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
    invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
    invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.26.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to2, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to2, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useResolvedPath(to2, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments2 = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments2.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$3({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state2) {
    if (state2.location !== props.location || state2.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state2.error,
      location: state2.location,
      revalidation: props.revalidation || state2.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors2 = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors2 != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match2 = renderedMatches[i2];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors22
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors22 || errors22[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors2 && match2.route.id ? errors2[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state2 = reactExports.useContext(DataRouterStateContext);
  !state2 ? invariant(false) : void 0;
  return state2;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state2 = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state2.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to2 === "number") {
      router.navigate(to2);
    } else {
      router.navigate(to2, _extends$3({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$3({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state: state2 = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state: state2,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state2, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location: location2
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location2);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.26.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded2) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded2.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded$w = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state2, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state2.location,
    navigationType: state2.action,
    navigator: history,
    future
  });
}
const isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref2) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state: state2,
    target,
    to: to2,
    preventScrollReset,
    unstable_viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$1(_ref7, _excluded$w);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
    absoluteHref = to2;
    if (isBrowser$2) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to2 = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to2, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to2, {
    replace: replace2,
    state: state2,
    target,
    preventScrollReset,
    relative,
    unstable_viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$2({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref2,
      target
    }))
  );
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state: state2,
    preventScrollReset,
    relative,
    unstable_viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to2, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
      navigate(to2, {
        replace: replace2,
        state: state2,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
    }
  }, [location2, navigate, path, replaceProp, state2, target, to2, preventScrollReset, relative, unstable_viewTransition]);
}
const getTruncatedAddress = (address) => {
  return address.slice(0, 6) + "..." + address.slice(-4);
};
const copyToClipboard = (text) => {
  navigator.clipboard.writeText(text);
  _t$3.success("Address copied to clipboard");
};
const WalletDisplay = ({ darkMode }) => {
  const { wallet, walletBalance } = useActiveWallet();
  const CopyIcon = darkMode ? CopyIconDark : CopyIconLight;
  return wallet && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 md:gap-4 items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Link,
      {
        to: `https://app.fuel.network/account/${wallet.address.toB256()}`,
        target: "_blank",
        className: "text-gray-400 hover:underline hover:text-green-400",
        children: getTruncatedAddress(wallet.address.toB256())
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: CopyIcon,
        alt: "copy",
        style: { color: "#dddddd" },
        className: "cursor-pointer h-5 hover:opacity-80 active:scale-[90%]",
        onClick: () => copyToClipboard(wallet.address.toB256())
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "wallet-balance", className: "text-gray-400", children: [
      "Balance:",
      " ",
      walletBalance == null ? void 0 : walletBalance.format({
        precision: 5
      }),
      " ",
      "ETH"
    ] })
  ] });
};
const NODE_URL = "https://testnet.fuel.network/v1/graphql";
const TESTNET_FAUCET_LINK$1 = "https://faucet-testnet.fuel.network/";
const FAUCET_PRIVATE_KEY = "0x01";
const _abi$2 = {
  "encoding": "1",
  "types": [
    {
      "typeId": 0,
      "type": "u64",
      "components": null,
      "typeParameters": null
    }
  ],
  "functions": [
    {
      "inputs": [],
      "name": "get_count",
      "output": {
        "name": "",
        "type": 0,
        "typeArguments": null
      },
      "attributes": [
        {
          "name": "storage",
          "arguments": [
            "read"
          ]
        }
      ]
    },
    {
      "inputs": [
        {
          "name": "amount",
          "type": 0,
          "typeArguments": null
        }
      ],
      "name": "increment_counter",
      "output": {
        "name": "",
        "type": 0,
        "typeArguments": null
      },
      "attributes": [
        {
          "name": "storage",
          "arguments": [
            "write",
            "read"
          ]
        }
      ]
    }
  ],
  "loggedTypes": [],
  "messagesTypes": [],
  "configurables": []
};
const _storageSlots = [
  {
    "key": "6e3c7b4f69bbff7132c3c3a62883a6868f47b0bc2a7f21605f29038cd9a5e05f",
    "value": "0000000000000000000000000000000000000000000000000000000000000000"
  }
];
const TestContractAbi__factory = {
  abi: _abi$2,
  storageSlots: _storageSlots,
  createInterface() {
    return new Interface(_abi$2);
  },
  connect(id2, accountOrProvider) {
    return new Contract(id2, _abi$2, accountOrProvider);
  },
  async deployContract(bytecode, wallet, options = {}) {
    const factory = new ContractFactory(bytecode, _abi$2, wallet);
    return factory.deployContract({
      storageSlots: _storageSlots,
      ...options
    });
  }
};
const _abi$1 = {
  "encoding": "1",
  "types": [
    {
      "typeId": 0,
      "type": "u64",
      "components": null,
      "typeParameters": null
    }
  ],
  "functions": [
    {
      "inputs": [
        {
          "name": "input",
          "type": 0,
          "typeArguments": null
        }
      ],
      "name": "main",
      "output": {
        "name": "",
        "type": 0,
        "typeArguments": null
      },
      "attributes": null
    }
  ],
  "loggedTypes": [],
  "messagesTypes": [],
  "configurables": []
};
const _bin$1 = "0x1af030007400000200000000000002285dffc00110ffff001aec5000910001a05053b0e06140000a5fed0031614000045fed002b5043b1887244000828ed0440504bb0f072400008284bb4005043b16872440008284124405d43b02d5d4100005fed00335d43b02d724400081b441440104104405fed002d5d43b0335047b0085fed00015043b0f872480008284114805047b10072480008284504805043b16072480008284114805d43b02c1ae9000020f8330058fbe00250fbe0047400004f1a43d0005fed00325043b19072440400264400001a447000504bb0285fed1005724404005fed10065fec00075047b058724c0018284524c0504bb108724c0018284914c05047b0b0724c0018284524c0504bb010724c0018284914c05d57b0025d4fb0035d47b0047248000810491480154924c07648000174000005724800021b4d3480264c0000281d54401a54700010495440725800082849058072400008104114005047b0705fed500e5fed300f5fed00105043b09872480018284114805047b12072480018284504805043b17072480018284114805043b1705047b0c872480018284504805043b04072480018284114805d47b00850410010504bb0885fed101150452008724c0008284504c05043b13872440010284124405047b148724800102845048072400010285114005d4140015d5140002551000095000003960800001aec50001a43a0001a47e0001af500001af9100098080000970000034af8000047000000";
const TestScriptAbi__factory = {
  abi: _abi$1,
  bin: _bin$1,
  createInstance(wallet) {
    const script = new Script(_bin$1, _abi$1, wallet);
    return script;
  }
};
const _abi = {
  "encoding": "1",
  "types": [
    {
      "typeId": 0,
      "type": "bool",
      "components": null,
      "typeParameters": null
    },
    {
      "typeId": 1,
      "type": "u64",
      "components": null,
      "typeParameters": null
    }
  ],
  "functions": [
    {
      "inputs": [
        {
          "name": "password",
          "type": 1,
          "typeArguments": null
        }
      ],
      "name": "main",
      "output": {
        "name": "",
        "type": 0,
        "typeArguments": null
      },
      "attributes": null
    }
  ],
  "loggedTypes": [],
  "messagesTypes": [],
  "configurables": []
};
const _bin = "0x1af030007400000200000000000001785dffc00110ffff001aec500091000080714000035fed000c5d4bb00c614122005047b0185e4500005043b0185c41000013410000764000135043b0185c410000724400021341044076400001360000006141224a5fed000e5043b0705047b01072480008284504805043b0207248000828411480504bb0287244000828490440740000086141220c5fed000d5043b0687244000828ed0440504bb02872400008284bb4005043b03072440008284124405047b03872480008284504805043b05872480008284114805d43b00b5d4100005fed000f5d43b00b724400081b441440104104405fed000b5d43b00f5047b0085fed00015043b04072480008284114805047b04872480008284504805043b05072480008284114805d43b00a1ae9000020f8330058fbe00250fbe004740000021a43d0002440000095000007960800001aec50001a43a0001a47e00072480539134104801af500001af9100098080000970000074af80000";
const TestPredicateAbi__factory = {
  abi: _abi,
  bin: _bin,
  createInstance(provider, predicateData, configurables) {
    const predicate = new Predicate({
      bytecode: _bin,
      abi: _abi,
      provider,
      inputData: predicateData,
      configurableConstants: configurables
    });
    return predicate;
  }
};
const FuelLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      viewBox: "0 0 344 344",
      className: "PJLV PJLV-iiWunJk-css fuel_Logo w-[50px]",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "25", y: "37", width: "292", height: "284", fill: "black" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.8744 0C10.2181 0 0 10.218 0 22.8744V344H284.626C294.246 344 303.497 340.179 310.308 333.368L333.368 310.308C340.179 303.497 344 294.246 344 284.626V0H22.8744ZM224.608 44.231L112.718 156.121C109.956 158.882 106.182 160.447 102.27 160.447C96.5631 160.447 91.3157 157.134 88.8763 151.978L45.5194 60.3402C41.9756 52.8383 47.4525 44.231 55.7374 44.231H224.608ZM44.231 299.769V190.916C44.231 185.117 48.9257 180.422 54.7249 180.422H163.577L44.231 299.769ZM172.598 160.447H136.559L244.998 52.0097C249.968 47.0382 256.734 44.231 263.776 44.231H299.814L191.377 152.668C186.407 157.64 179.64 160.447 172.598 160.447Z",
            fill: "#00F58C"
          }
        )
      ]
    }
  );
};
var useAsync$1 = {};
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$2);
var useAsyncFn = {};
var useMountedState = {};
var hasRequiredUseMountedState;
function requireUseMountedState() {
  if (hasRequiredUseMountedState) return useMountedState;
  hasRequiredUseMountedState = 1;
  Object.defineProperty(useMountedState, "__esModule", { value: true });
  var react_12 = reactExports;
  function useMountedState$1() {
    var mountedRef = react_12.useRef(false);
    var get = react_12.useCallback(function() {
      return mountedRef.current;
    }, []);
    react_12.useEffect(function() {
      mountedRef.current = true;
      return function() {
        mountedRef.current = false;
      };
    }, []);
    return get;
  }
  useMountedState.default = useMountedState$1;
  return useMountedState;
}
var hasRequiredUseAsyncFn;
function requireUseAsyncFn() {
  if (hasRequiredUseAsyncFn) return useAsyncFn;
  hasRequiredUseAsyncFn = 1;
  Object.defineProperty(useAsyncFn, "__esModule", { value: true });
  var tslib_12 = require$$0$3;
  var react_12 = reactExports;
  var useMountedState_1 = tslib_12.__importDefault(requireUseMountedState());
  function useAsyncFn$1(fn2, deps, initialState2) {
    if (deps === void 0) {
      deps = [];
    }
    if (initialState2 === void 0) {
      initialState2 = { loading: false };
    }
    var lastCallId = react_12.useRef(0);
    var isMounted = useMountedState_1.default();
    var _a2 = react_12.useState(initialState2), state2 = _a2[0], set2 = _a2[1];
    var callback = react_12.useCallback(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var callId = ++lastCallId.current;
      if (!state2.loading) {
        set2(function(prevState) {
          return tslib_12.__assign(tslib_12.__assign({}, prevState), { loading: true });
        });
      }
      return fn2.apply(void 0, args).then(function(value2) {
        isMounted() && callId === lastCallId.current && set2({ value: value2, loading: false });
        return value2;
      }, function(error) {
        isMounted() && callId === lastCallId.current && set2({ error, loading: false });
        return error;
      });
    }, deps);
    return [state2, callback];
  }
  useAsyncFn.default = useAsyncFn$1;
  return useAsyncFn;
}
Object.defineProperty(useAsync$1, "__esModule", { value: true });
var tslib_1 = require$$0$3;
var react_1 = reactExports;
var useAsyncFn_1 = tslib_1.__importDefault(requireUseAsyncFn());
function useAsync(fn2, deps) {
  if (deps === void 0) {
    deps = [];
  }
  var _a2 = useAsyncFn_1.default(fn2, deps, {
    loading: true
  }), state2 = _a2[0], callback = _a2[1];
  react_1.useEffect(function() {
    callback();
  }, [callback]);
  return state2;
}
var _default$1 = useAsync$1.default = useAsync;
var CheckCircle = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(e2) {
    return e2 && e2.__esModule ? e2 : {
      "default": e2
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var createSvgIcon$1 = {};
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n3[r2] = t2[r2]);
    }
    return n3;
  }, _extends$1.apply(null, arguments);
}
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (!isPlainObject(source)) {
    return source;
  }
  const output2 = {};
  Object.keys(source).forEach((key) => {
    output2[key] = deepClone(source[key]);
  });
  return output2;
}
function deepmerge$1(target, source, options = {
  clone: true
}) {
  const output2 = options.clone ? _extends$1({}, target) : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        output2[key] = deepmerge$1(target[key], source[key], options);
      } else if (options.clone) {
        output2[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output2[key] = source[key];
      }
    });
  }
  return output2;
}
const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: deepmerge$1,
  isPlainObject
}, Symbol.toStringTag, { value: "Module" }));
function formatMuiErrorMessage$1(code2) {
  let url2 = "https://mui.com/production-error/?code=" + code2;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url2 += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code2 + "; visit " + url2 + " for the full message.";
}
const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: formatMuiErrorMessage$1
}, Symbol.toStringTag, { value: "Module" }));
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = Symbol.for("react.element"), c$5 = Symbol.for("react.portal"), d$2 = Symbol.for("react.fragment"), e$4 = Symbol.for("react.strict_mode"), f$6 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$5 = Symbol.for("react.context"), k$2 = Symbol.for("react.server_context"), l$3 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$5 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$3 = Symbol.for("react.lazy"), t$4 = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$2:
        switch (a2 = a2.type, a2) {
          case d$2:
          case f$6:
          case e$4:
          case m$2:
          case n$5:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case h$5:
              case l$3:
              case q$3:
              case p$2:
              case g$2:
                return a2;
              default:
                return r2;
            }
        }
      case c$5:
        return r2;
    }
  }
}
reactIs_production_min$1.ContextConsumer = h$5;
reactIs_production_min$1.ContextProvider = g$2;
reactIs_production_min$1.Element = b$2;
reactIs_production_min$1.ForwardRef = l$3;
reactIs_production_min$1.Fragment = d$2;
reactIs_production_min$1.Lazy = q$3;
reactIs_production_min$1.Memo = p$2;
reactIs_production_min$1.Portal = c$5;
reactIs_production_min$1.Profiler = f$6;
reactIs_production_min$1.StrictMode = e$4;
reactIs_production_min$1.Suspense = m$2;
reactIs_production_min$1.SuspenseList = n$5;
reactIs_production_min$1.isAsyncMode = function() {
  return false;
};
reactIs_production_min$1.isConcurrentMode = function() {
  return false;
};
reactIs_production_min$1.isContextConsumer = function(a2) {
  return v$2(a2) === h$5;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return v$2(a2) === g$2;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return v$2(a2) === l$3;
};
reactIs_production_min$1.isFragment = function(a2) {
  return v$2(a2) === d$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return v$2(a2) === q$3;
};
reactIs_production_min$1.isMemo = function(a2) {
  return v$2(a2) === p$2;
};
reactIs_production_min$1.isPortal = function(a2) {
  return v$2(a2) === c$5;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return v$2(a2) === f$6;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return v$2(a2) === e$4;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return v$2(a2) === m$2;
};
reactIs_production_min$1.isSuspenseList = function(a2) {
  return v$2(a2) === n$5;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$6 || a2 === e$4 || a2 === m$2 || a2 === n$5 || a2 === t$4 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$3 || a2.$$typeof === p$2 || a2.$$typeof === g$2 || a2.$$typeof === h$5 || a2.$$typeof === l$3 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min$1.typeOf = v$2;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIsExports$1 = reactIs$2.exports;
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn2) {
  const match2 = `${fn2}`.match(fnNameMatchRegex);
  const name = match2 && match2[1];
  return name || "";
}
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getDisplayName$1(Component) {
  if (Component == null) {
    return void 0;
  }
  if (typeof Component === "string") {
    return Component;
  }
  if (typeof Component === "function") {
    return getFunctionComponentName(Component, "Component");
  }
  if (typeof Component === "object") {
    switch (Component.$$typeof) {
      case reactIsExports$1.ForwardRef:
        return getWrappedName(Component, Component.render, "ForwardRef");
      case reactIsExports$1.Memo:
        return getWrappedName(Component, Component.type, "memo");
      default:
        return void 0;
    }
  }
  return void 0;
}
const getDisplayName = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: getDisplayName$1,
  getFunctionName
}, Symbol.toStringTag, { value: "Module" }));
function capitalize$1(string2) {
  if (typeof string2 !== "string") {
    throw new Error(formatMuiErrorMessage$1(7));
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: capitalize$1
}, Symbol.toStringTag, { value: "Module" }));
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function deprecatedPropType(validator, reason) {
  {
    return () => null;
  }
}
function isMuiElement(element, muiNames) {
  var _muiName, _element$type;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
  ) !== -1;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component) {
  {
    return () => null;
  }
}
function setRef(ref2, value2) {
  if (typeof ref2 === "function") {
    ref2(value2);
  } else if (ref2) {
    ref2.current = value2;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function unsupportedProp(props, propName, componentName, location2, propFullName) {
  {
    return null;
  }
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state: state2 = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value2 = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value2, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref2 = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref2.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref2.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (instance2) => {
      refs.forEach((ref2) => {
        setRef(ref2, instance2);
      });
    };
  }, refs);
}
const UNINITIALIZED = {};
function useLazyRef(init2, initArg) {
  const ref2 = reactExports.useRef(UNINITIALIZED);
  if (ref2.current === UNINITIALIZED) {
    ref2.current = init2(initArg);
  }
  return ref2;
}
const EMPTY = [];
function useOnMount(fn2) {
  reactExports.useEffect(fn2, EMPTY);
}
class Timeout {
  constructor() {
    this.currentId = null;
    this.clear = () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    };
    this.disposeEffect = () => {
      return this.clear;
    };
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
const hadFocusVisibleRecentlyTimeout = new Timeout();
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type: type3,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type3] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref2 = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      hadFocusVisibleRecentlyTimeout.start(100, () => {
        hadFocusVisibleRecently = false;
      });
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: ref2
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function resolveProps(defaultProps2, props) {
  const output2 = _extends$1({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output2[propName] = _extends$1({}, defaultProps2[propName], output2[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output2[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output2[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output2[propName] = slotProps;
      } else {
        output2[propName] = _extends$1({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output2[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output2[propName] === void 0) {
      output2[propName] = defaultProps2[propName];
    }
  });
  return output2;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output2 = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output2[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output2;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp$1(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
const clamp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clamp$1
}, Symbol.toStringTag, { value: "Module" }));
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n3 in r2) if ({}.hasOwnProperty.call(r2, n3)) {
    if (e2.includes(n3)) continue;
    t2[n3] = r2[n3];
  }
  return t2;
}
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$1({}, otherProps, {
    ownerState: _extends$1({}, otherProps.ownerState, ownerState)
  });
}
function r$6(e2) {
  var t2, f2, n3 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n3 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$6(e2[t2])) && (n3 && (n3 += " "), n3 += f2);
  } else for (f2 in e2) e2[f2] && (n3 && (n3 += " "), n3 += f2);
  return n3;
}
function clsx() {
  for (var e2, t2, f2 = 0, n3 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$6(e2)) && (n3 && (n3 += " "), n3 += t2);
  return n3;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
const _excluded$v = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$v);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$1({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref2 = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
    ref: ref2
  }), ownerState);
  return props;
}
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function getThemeProps$1(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps$1({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
var createStyled$3 = {};
var _extends = { exports: {} };
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends) return _extends.exports;
  hasRequired_extends = 1;
  (function(module) {
    function _extends3() {
      return module.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n3) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var t2 = arguments[e2];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n3[r2] = t2[r2]);
        }
        return n3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends3.apply(null, arguments);
    }
    module.exports = _extends3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_extends);
  return _extends.exports;
}
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose) return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose3(r2, e2) {
      if (null == r2) return {};
      var t2 = {};
      for (var n3 in r2) if ({}.hasOwnProperty.call(r2, n3)) {
        if (e2.includes(n3)) continue;
        t2[n3] = r2[n3];
      }
      return t2;
    }
    module.exports = _objectWithoutPropertiesLoose3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
function memoize$1(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment$2 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$2 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$3(value2, length2) {
  return charat(value2, 0) ^ 45 ? (((length2 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index) {
  return value2.charCodeAt(index) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array2) {
  return array2.push(value2), value2;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
var line = 1;
var column = 1;
var length$1 = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value2, root, parent, type3, props, children, length2) {
  return { value: value2, root, parent, type: type3, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev$1() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length$1 ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type3) {
  switch (type3) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length$1 = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type3) {
  return trim(slice(position - 1, delimiter(type3 === 91 ? type3 + 2 : type3 === 40 ? type3 + 1 : type3)));
}
function whitespace(type3) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type3) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type3) {
  while (next())
    switch (character) {
      case type3:
        return position;
      case 34:
      case 39:
        if (type3 !== 34 && type3 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type3 === 41)
          delimiter(type3);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type3, index) {
  while (next())
    if (type3 + character === 47 + 10)
      break;
    else if (type3 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type3 === 47 ? type3 : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value2) {
  return dealloc(parse$2("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse$2(value2, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type3 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type3;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset2, rules, points, type3, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$2(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$2(value2, reference, reference, rule && append(ruleset(value2, reference, reference, 0, 0, rules, points, type3, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type3 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type3 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root, parent, index, offset2, rules, points, type3, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr(value2, post + 1, post = abs(j2 = points[i2])), z2 = value2; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value2, root, parent, offset2 === 0 ? RULESET : type3, props, children, length2);
}
function comment(value2, root, parent) {
  return node(value2, root, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root, parent, length2) {
  return node(value2, root, parent, DECLARATION, substr(value2, 0, length2), substr(value2, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output2 = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output2 += callback(children[i2], i2, children, callback) || "";
  return output2;
}
function stringify$1(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output2 = "";
    for (var i2 = 0; i2 < length2; i2++)
      output2 += collection[i2](element, index, children, callback) || "";
    return output2;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points) {
  return dealloc(toRules(alloc(value2), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value2 = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value2, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value2 = element.value;
    if (
      // charcode for l
      value2.charCodeAt(0) === 108 && // charcode for b
      value2.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value2, length2) {
  switch (hash$3(value2, length2)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length2 > 6) switch (charat(value2, length2 + 1)) {
        case 109:
          if (charat(value2, length2 + 4) !== 45) break;
        case 102:
          return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length2 + 3) == 108 ? "$3" : "$2-$3")) + value2;
        case 115:
          return ~indexof(value2, "stretch") ? prefix(replace(value2, "stretch", "fill-available"), length2) + value2 : value2;
      }
      break;
    case 4949:
      if (charat(value2, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length2 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$1([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value2) {
          switch (match(value2, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$1([copy(element, {
                props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize$1([copy(element, {
                props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$4 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$3 = b$1 ? Symbol.for("react.fragment") : 60107, f$5 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$4 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$4 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$2 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$5 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$2 = b$1 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$4:
        switch (a2 = a2.type, a2) {
          case l$2:
          case m$1:
          case e$3:
          case g$1:
          case f$5:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$4:
              case t$3:
              case r$5:
              case h$4:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A(a2) {
  return z$2(a2) === m$1;
}
reactIs_production_min.AsyncMode = l$2;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h$4;
reactIs_production_min.Element = c$4;
reactIs_production_min.ForwardRef = n$4;
reactIs_production_min.Fragment = e$3;
reactIs_production_min.Lazy = t$3;
reactIs_production_min.Memo = r$5;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$5;
reactIs_production_min.Suspense = p$1;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z$2(a2) === l$2;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$2(a2) === k$1;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$2(a2) === h$4;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$4;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$2(a2) === n$4;
};
reactIs_production_min.isFragment = function(a2) {
  return z$2(a2) === e$3;
};
reactIs_production_min.isLazy = function(a2) {
  return z$2(a2) === t$3;
};
reactIs_production_min.isMemo = function(a2) {
  return z$2(a2) === r$5;
};
reactIs_production_min.isPortal = function(a2) {
  return z$2(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$2(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$2(a2) === f$5;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$2(a2) === p$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$3 || a2 === m$1 || a2 === g$1 || a2 === f$5 || a2 === p$1 || a2 === q$2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$3 || a2.$$typeof === r$5 || a2.$$typeof === h$4 || a2.$$typeof === k$1 || a2.$$typeof === n$4 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$2 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$2;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
  registerStyles(cache2, serialized, isStringTag2);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$1 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value2) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes3 = interpolation;
      if (keyframes3.anim === 1) {
        cursor = {
          name: keyframes3.name,
          styles: keyframes3.styles,
          next: cursor
        };
        return keyframes3.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var key in obj) {
      var value2 = obj[key];
      if (typeof value2 !== "object") {
        var asString = value2;
        if (registered != null && registered[asString] !== void 0) {
          string2 += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string2 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value2.length; _i2++) {
            if (isProcessableValue(value2[_i2])) {
              string2 += processStyleName(key) + ":" + processStyleValue(key, value2[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create3) {
  return create3();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var isDevelopment = false;
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag2);
  });
  return null;
};
var createStyled$2 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles2.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref2) {
        newProps.ref = ref2;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value2() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$2.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
let cache$1;
if (typeof document === "object") {
  cache$1 = createCache({
    key: "css",
    prepend: true
  });
}
function StyledEngineProvider(props) {
  const {
    injectFirst,
    children
  } = props;
  return injectFirst && cache$1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, {
    value: cache$1,
    children
  }) : children;
}
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
const styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GlobalStyles,
  StyledEngineProvider,
  ThemeContext,
  css,
  default: styled$2,
  internal_processStyles,
  keyframes
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(styledEngine);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(capitalize);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName);
const _excluded$u = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$1({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$u);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value2 = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value2}${unit})`;
  }
  function down(key) {
    const value2 = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value2 - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$1({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge$1(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output2 = styleFromPropValue(propValue);
  return output2;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge$1(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base2 = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i2) => {
      if (i2 < breakpointValues.length) {
        base2[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base2[breakpoint] = true;
      }
    });
  }
  return base2;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base2 = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base2);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i2) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i2] != null ? breakpointValues[i2] : breakpointValues[previous];
      previous = i2;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value2;
  if (typeof themeMapping === "function") {
    value2 = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value2 = themeMapping[propValueFinal] || userValue;
  } else {
    value2 = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value2 = transform(value2, userValue, themeMapping);
  }
  return value2;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value2 = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value2 && typeof propValueFinal === "string") {
        value2 = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value2;
      }
      return {
        [cssProperty]: value2
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn2(arg);
    }
    return cache2[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output2 = transform(argument);
      return typeof output2 === "number" ? `${output2}px` : output2;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value2) {
  if (typeof value2 !== "number") {
    return value2;
  }
  return `${value2}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$2({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value2, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value2;
}
const color = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value2) {
  return value2 <= 1 && value2 !== 0 ? `${value2 * 100}%` : value2;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value2) => ({
      "@media print": {
        display: value2
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union2 = new Set(allKeys);
  return objects.every((object) => union2.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value2 = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value2 && typeof propValueFinal === "string") {
        value2 = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value2;
      }
      return {
        [cssProperty]: value2
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value2 = callIfFn(sxObject[styleKey], theme);
        if (value2 !== null && value2 !== void 0) {
          if (typeof value2 === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value2, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value2, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value2)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value2,
                  theme
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value2, theme, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
const styleFunctionSx$2 = styleFunctionSx$1;
function applyStyles(key, styles2) {
  const theme = this;
  if (theme.vars && typeof theme.getColorSchemeSelector === "function") {
    const selector = theme.getColorSchemeSelector(key).replace(/(\[[^\]]+\])/, "*:where($1)");
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key) {
    return styles2;
  }
  return {};
}
const _excluded$t = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$2(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$t);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge$1({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$1({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$1({}, shape, shapeInput)
  }, other);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$2({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: createTheme$2,
  private_createBreakpoints: createBreakpoints,
  unstable_applyStyles: applyStyles
}, Symbol.toStringTag, { value: "Module" }));
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1);
const _excluded$s = ["sx"];
const splitProps = (props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$s);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject(result)) {
        return systemProps;
      }
      return _extends$1({}, systemProps, result);
    };
  } else {
    finalSx = _extends$1({}, systemProps, inSx);
  }
  return _extends$1({}, otherProps, {
    sx: finalSx
  });
}
const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: styleFunctionSx$2,
  extendSxProp,
  unstable_createStyleFunctionSx,
  unstable_defaultSxConfig: defaultSxConfig$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(createStyled$3, "__esModule", {
  value: true
});
var _default = createStyled$3.default = createStyled$1;
createStyled$3.shouldForwardProp = shouldForwardProp$1;
createStyled$3.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault$3(require_extends());
var _objectWithoutPropertiesLoose2 = _interopRequireDefault$3(requireObjectWithoutPropertiesLoose());
var _styledEngine = _interopRequireWildcard(require$$1$1);
var _deepmerge = require$$4;
_interopRequireDefault$3(require$$5);
_interopRequireDefault$3(require$$6);
var _createTheme = _interopRequireDefault$3(require$$7);
var _styleFunctionSx = _interopRequireDefault$3(require$$8);
const _excluded$r = ["ownerState"], _excluded2$3 = ["variants"], _excluded3$2 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function _getRequireWildcardCache(e2) {
  if ("function" != typeof WeakMap) return null;
  var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(e22) {
    return e22 ? t2 : r2;
  })(e2);
}
function _interopRequireWildcard(e2, r2) {
  if (e2 && e2.__esModule) return e2;
  if (null === e2 || "object" != typeof e2 && "function" != typeof e2) return { default: e2 };
  var t2 = _getRequireWildcardCache(r2);
  if (t2 && t2.has(e2)) return t2.get(e2);
  var n3 = { __proto__: null }, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u2 in e2) if ("default" !== u2 && Object.prototype.hasOwnProperty.call(e2, u2)) {
    var i2 = a2 ? Object.getOwnPropertyDescriptor(e2, u2) : null;
    i2 && (i2.get || i2.set) ? Object.defineProperty(n3, u2, i2) : n3[u2] = e2[u2];
  }
  return n3.default = e2, t2 && t2.set(e2, n3), n3;
}
function isEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag$1(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function shouldForwardProp$1(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme$2 = createStyled$3.systemDefaultTheme = (0, _createTheme.default)();
const lowercaseFirstLetter$1 = (string2) => {
  if (!string2) {
    return string2;
  }
  return string2.charAt(0).toLowerCase() + string2.slice(1);
};
function resolveTheme$1({
  defaultTheme: defaultTheme2,
  theme,
  themeId
}) {
  return isEmpty$1(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver$1(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
function processStyleArg$1(callableStyle, _ref) {
  let {
    ownerState
  } = _ref, props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded$r);
  const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle((0, _extends2.default)({
    ownerState
  }, props)) : callableStyle;
  if (Array.isArray(resolvedStylesArg)) {
    return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg$1(resolvedStyle, (0, _extends2.default)({
      ownerState
    }, props)));
  }
  if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
    const {
      variants = []
    } = resolvedStylesArg, otherStyles = (0, _objectWithoutPropertiesLoose2.default)(resolvedStylesArg, _excluded2$3);
    let result = otherStyles;
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        isMatch = variant.props((0, _extends2.default)({
          ownerState
        }, props, ownerState));
      } else {
        Object.keys(variant.props).forEach((key) => {
          if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (!Array.isArray(result)) {
          result = [result];
        }
        result.push(typeof variant.style === "function" ? variant.style((0, _extends2.default)({
          ownerState
        }, props, ownerState)) : variant.style);
      }
    });
    return result;
  }
  return resolvedStylesArg;
}
function createStyled$1(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme$2,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp$1,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp$1
  } = input;
  const systemSx = (props) => {
    return (0, _styleFunctionSx.default)((0, _extends2.default)({}, props, {
      theme: resolveTheme$1((0, _extends2.default)({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    (0, _styledEngine.internal_processStyles)(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver$1(lowercaseFirstLetter$1(componentSlot))
    } = inputOptions, options = (0, _objectWithoutPropertiesLoose2.default)(inputOptions, _excluded3$2);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp$1;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag$1(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = (0, _styledEngine.default)(tag, (0, _extends2.default)({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const transformStyleArg = (stylesArg) => {
      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || (0, _deepmerge.isPlainObject)(stylesArg)) {
        return (props) => processStyleArg$1(stylesArg, (0, _extends2.default)({}, props, {
          theme: resolveTheme$1({
            theme: props.theme,
            defaultTheme: defaultTheme2,
            themeId
          })
        }));
      }
      return stylesArg;
    };
    const muiStyledResolver = (styleArg, ...expressions) => {
      let transformedStyleArg = transformStyleArg(styleArg);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme$1((0, _extends2.default)({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = processStyleArg$1(slotStyle, (0, _extends2.default)({}, props, {
              theme
            }));
          });
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _theme$components;
          const theme = resolveTheme$1((0, _extends2.default)({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
          return processStyleArg$1({
            variants: themeVariants
          }, (0, _extends2.default)({}, props, {
            theme
          }));
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
function createMixins(breakpoints, mixins) {
  return _extends$1({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
var colorManipulator = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage);
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(clamp);
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
  value: true
});
var alpha_1 = colorManipulator.alpha = alpha;
colorManipulator.blend = blend;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
colorManipulator.emphasize = emphasize;
var getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex;
var _formatMuiErrorMessage2 = _interopRequireDefault$2(require$$1);
var _clamp = _interopRequireDefault$2(require$$2$1);
function clampWrapper(value2, min = 0, max = 1) {
  return (0, _clamp.default)(value2, min, max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n3) => n3 + n3);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n3, index) => {
    return index < 3 ? parseInt(n3, 16) : Math.round(parseInt(n3, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function intToHex(int) {
  const hex = int.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type3 = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type3) === -1) {
    throw new Error((0, _formatMuiErrorMessage2.default)(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type3 === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error((0, _formatMuiErrorMessage2.default)(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value2) => parseFloat(value2));
  return {
    type: type3,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf("hsl") !== -1 && idx !== 0 ? `${val}%` : val).join(" ");
};
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = (color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
};
colorManipulator.private_safeColorChannel = private_safeColorChannel;
function recomposeColor(color2) {
  const {
    type: type3,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type3.indexOf("rgb") !== -1) {
    values2 = values2.map((n3, i2) => i2 < 3 ? parseInt(n3, 10) : n3);
  } else if (type3.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type3.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type3}(${values2})`;
}
function rgbToHex(color2) {
  if (color2.indexOf("#") === 0) {
    return color2;
  }
  const {
    values: values2
  } = decomposeColor(color2);
  return `#${values2.map((n3, i2) => intToHex(i2 === 3 ? Math.round(255 * n3) : n3)).join("")}`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s2 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n3, k2 = (n3 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type3 = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type3 += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type: type3,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value2) {
  color2 = decomposeColor(color2);
  value2 = clampWrapper(value2);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value2}`;
  } else {
    color2.values[3] = value2;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value2, warning2) {
  try {
    return alpha(color2, value2);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
function blend(background, overlay, opacity, gamma = 1) {
  const blendChannel = (b2, o2) => Math.round((b2 ** (1 / gamma) * (1 - opacity) + o2 ** (1 / gamma) * opacity) ** gamma);
  const backgroundColor2 = decomposeColor(background);
  const overlayColor = decomposeColor(overlay);
  const rgb = [blendChannel(backgroundColor2.values[0], overlayColor.values[0]), blendChannel(backgroundColor2.values[1], overlayColor.values[1]), blendChannel(backgroundColor2.values[2], overlayColor.values[2])];
  return recomposeColor({
    type: "rgb",
    values: rgb
  });
}
const common$6 = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const _excluded$q = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$6.white,
    default: common$6.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$6.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$6.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten_1(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken_1(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode: mode2 = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$q);
  const primary = palette.primary || getDefaultPrimary(mode2);
  const secondary = palette.secondary || getDefaultSecondary(mode2);
  const error = palette.error || getDefaultError(mode2);
  const info = palette.info || getDefaultInfo(mode2);
  const success = palette.success || getDefaultSuccess(mode2);
  const warning2 = palette.warning || getDefaultWarning(mode2);
  function getContrastText(background) {
    const contrastText = getContrastRatio_1(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$1({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage$1(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage$1(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge$1(_extends$1({
    // A collection of common colors.
    common: _extends$1({}, common$6),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: mode2,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode2]), other);
  return paletteOutput;
}
const _excluded$p = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(value2) {
  return Math.round(value2 * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$p);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$1({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const _excluded$o = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
  const create3 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose(options, _excluded$o);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$1({
    getAutoHeightDuration,
    create: create3
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const _excluded$n = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$n);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage$1(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$2(options);
  let muiTheme = deepmerge$1(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$1({}, zIndex)
  });
  muiTheme = deepmerge$1(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$2({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const defaultTheme$2 = createTheme();
const THEME_ID = "$$material";
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled$1 = _default({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$2,
  rootShouldForwardProp
});
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$m = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$f = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled$1("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // for example heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends$1({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$f(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref: ref2
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$1({
      "data-testid": `${displayName}Icon`,
      ref: ref2
    }, props, {
      children: path
    }));
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    ClassNameGenerator.configure(generator);
  }
};
const utils$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: capitalize$1,
  createChainedFunction,
  createSvgIcon,
  debounce,
  deprecatedPropType,
  isMuiElement,
  ownerDocument,
  ownerWindow,
  requirePropFactory,
  setRef,
  unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: useEnhancedEffect,
  unstable_useId: useId,
  unsupportedProp,
  useControlled,
  useEventCallback,
  useForkRef,
  useIsFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(utils$d);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon) return createSvgIcon$1;
  hasRequiredCreateSvgIcon = 1;
  (function(exports) {
    "use client";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = require$$0$2;
  })(createSvgIcon$1);
  return createSvgIcon$1;
}
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(CheckCircle, "__esModule", {
  value: true
});
var default_1$2 = CheckCircle.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
default_1$2 = CheckCircle.default = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}), "CheckCircle");
const useIncrementCounter = ({
  contract,
  isConnected,
  walletBalance,
  setCounter,
  refetchBalance
}) => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const onIncrementPressed = async () => {
    if (!isConnected)
      return _t$3.error("Please connect your wallet to increment the counter");
    if (!contract) {
      return _t$3.error("Contract not loaded");
    }
    if (walletBalance == null ? void 0 : walletBalance.eq(0)) {
      return _t$3.error(
        "Your wallet does not have enough funds. Please click the 'Faucet' button in the top right corner, or use the local faucet."
      );
    }
    try {
      setIsLoading(true);
      const { waitForResult } = await contract.functions.increment_counter(bn$1(1)).call();
      const { value: value2, transactionId } = await waitForResult();
      _t$3(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { color: "success" }),
        "Counter Incremented! View it on the",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            target: "_blank",
            className: "pl-1 underline",
            href: `https://app.fuel.network/tx/${transactionId}`,
            children: "block explorer"
          }
        )
      ] }));
      setCounter(value2.toNumber());
      await (refetchBalance == null ? void 0 : refetchBalance());
    } catch (error) {
      console.error(error);
      _t$3.error("An error occurred while incrementing the counter.");
    } finally {
      setIsLoading(false);
    }
  };
  return {
    onIncrementPressed,
    isLoading
  };
};
var define_process_env_default$1 = { GITHUB_STATE: "/home/runner/work/_temp/_runner_file_commands/save_state_f718650a-ff98-4302-80d8-5fcdb4473af9", DEPLOYMENT_BASEPATH: "/opt/runner", DOTNET_NOLOGO: "1", STATS_TRP: "true", USER: "runner", npm_config_user_agent: "pnpm/8.15.7 npm/? node/v18.20.4 linux x64", CI: "true", VITE_APP_WC_PROJECT_ID: "e64002d84b020b9ae5eda323dd191093", npm_package_scripts_fuels_build: "fuels build", GITHUB_ENV: "/home/runner/work/_temp/_runner_file_commands/set_env_f718650a-ff98-4302-80d8-5fcdb4473af9", PIPX_HOME: "/opt/pipx", RUNNER_ENVIRONMENT: "github-hosted", npm_package_dependencies__fuels_connectors: "0.25.0", npm_package_devDependencies_vite: "^5.3.4", npm_node_execpath: "/usr/local/bin/node", JAVA_HOME_8_X64: "/usr/lib/jvm/temurin-8-jdk-amd64", SHLVL: "1", npm_package_scripts_fuels_typegen: "fuels typegen -i ./sway-programs/contract/out/debug/test-contract-abi.json -o ./src/sway-api/contracts", HOME: "/home/runner", VITE_PUBLIC_TESTNET_COUNTER_CONTRACT_ID: "0xd9377acd88d5ea4c498770b5210dad7ea87992652e2867d2713efc542caebb22", npm_package_devDependencies__typescript_eslint_parser: "^7.15.0", GITHUB_EVENT_PATH: "/home/runner/work/_temp/_github_workflow/event.json", RUNNER_TEMP: "/home/runner/work/_temp", npm_package_scripts_build_all: "NODE_ENV=production run-s build", npm_package_devDependencies_vite_plugin_static_copy: "^1.0.1", GITHUB_REPOSITORY_OWNER: "FuelLabs", JAVA_HOME_11_X64: "/usr/lib/jvm/temurin-11-jdk-amd64", PIPX_BIN_DIR: "/opt/pipx_bin", npm_config_auto_install_peers: "true", ANDROID_NDK_LATEST_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_RETENTION_DAYS: "90", GRADLE_HOME: "/usr/share/gradle-8.10", JAVA_HOME_21_X64: "/usr/lib/jvm/temurin-21-jdk-amd64", STATS_RDCL: "true", AZURE_EXTENSION_DIR: "/opt/az/azcliextensions", GITHUB_HEAD_REF: "rishabh/counter", GITHUB_REPOSITORY_OWNER_ID: "55993183", POWERSHELL_DISTRIBUTION_CHANNEL: "GitHub-Actions-ubuntu22", NFT_DIST: "/home/runner/work/sway-examples/sway-examples/dist/nft/", SYSTEMD_EXEC_PID: "471", npm_package_scripts_fuels_run: "run-s fuels:build fuels:typegen fuels:deploy", npm_package_scripts_fuels_deploy: "fuels deploy", npm_package_dependencies_dotenv: "^16.4.5", npm_package_devDependencies_eslint_plugin_react_hooks: "^4.6.2", GITHUB_GRAPHQL_URL: "https://api.github.com/graphql", NFT_BASE_URL: "/nft/", npm_package_dependencies_react_router_dom: "^6.25.1", npm_package_devDependencies_tailwindcss: "^3.4.6", npm_package_devDependencies_typescript: "^5.2.2", GOROOT_1_20_X64: "/opt/hostedtoolcache/go/1.20.14/x64", NVM_DIR: "/home/runner/.nvm", npm_package_devDependencies__types_react_dom: "^18.3.0", DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "1", GOROOT_1_21_X64: "/opt/hostedtoolcache/go/1.21.13/x64", ImageVersion: "20240901.1.0", JAVA_HOME_17_X64: "/usr/lib/jvm/temurin-17-jdk-amd64", npm_package_scripts_fuels_node: "fuels node", npm_package_scripts_dev: "vite", GITHUB_API_URL: "https://api.github.com", GOROOT_1_22_X64: "/opt/hostedtoolcache/go/1.22.6/x64", RUNNER_OS: "Linux", SWIFT_PATH: "/usr/share/swift/usr/bin", npm_package_type: "module", npm_package_dependencies_fuels: "0.93.0", npm_package_devDependencies__vitejs_plugin_react: "^4.3.1", CHROMEWEBDRIVER: "/usr/local/share/chromedriver-linux64", GITHUB_WORKFLOW: "Deploy PR preview", JOURNAL_STREAM: "8:18384", RUNNER_USER: "runner", STATS_V3PS: "true", _: "/home/runner/setup-pnpm/node_modules/.bin/pnpm", npm_package_private: "true", npm_package_dependencies__emotion_react: "^11.11.4", npm_package_devDependencies_autoprefixer: "^10.4.19", VITE_PUBLIC_DAPP_ENVIRONMENT: "testnet", npm_package_scripts_lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0", npm_package_devDependencies__typescript_eslint_eslint_plugin: "^7.15.0", npm_config_registry: "https://registry.npmjs.org/", ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE: "/opt/actionarchivecache", GITHUB_RUN_ID: "10743692800", STATS_D: "false", STATS_VMFE: "true", BOOTSTRAP_HASKELL_NONINTERACTIVE: "1", GITHUB_BASE_REF: "master", GITHUB_REF_TYPE: "branch", GITHUB_WORKFLOW_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", ImageOS: "ubuntu22", npm_package_devDependencies_eslint_plugin_react_refresh: "^0.4.7", GITHUB_ACTION_REPOSITORY: "", GITHUB_WORKFLOW_REF: "FuelLabs/sway-examples/.github/workflows/preview.yml@refs/pull/4/merge", PERFLOG_LOCATION_SETTING: "RUNNER_PERFLOG", npm_config_node_gyp: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node_modules/node-gyp/bin/node-gyp.js", PATH: "/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin", ANT_HOME: "/usr/share/ant", DOTNET_MULTILEVEL_LOOKUP: "0", INVOCATION_ID: "3b7e075b7e964240a53b54fd8e14c923", NODE: "/usr/local/bin/node", RUNNER_TOOL_CACHE: "/opt/hostedtoolcache", RUNNER_TRACKING_ID: "github_f78c3bd0-5916-4b6d-b102-cb79e51f2dec", TURBO_HASH: "aa8c12d69faaf243", npm_package_name: "counter-dapp", npm_package_dependencies__mui_material: "^5.16.5", AGENT_TOOLSDIRECTORY: "/opt/hostedtoolcache", GITHUB_ACTION: "__run", GITHUB_RUN_NUMBER: "76", GITHUB_TRIGGERING_ACTOR: "rishabhkeshan", RUNNER_ARCH: "X64", XDG_RUNTIME_DIR: "/run/user/1001", npm_package_dependencies_react_hot_toast: "^2.4.1", npm_config_frozen_lockfile: "", LANG: "C.UTF-8", VCPKG_INSTALLATION_ROOT: "/usr/local/share/vcpkg", npm_package_dependencies_react_dom: "^18.3.1", npm_package_devDependencies_eslint: "^8.57.0", CONDA: "/usr/share/miniconda", GITHUB_REF_NAME: "4/merge", GITHUB_REPOSITORY: "FuelLabs/sway-examples", RUNNER_NAME: "GitHub Actions 22", STATS_D_D: "false", STATS_VMD: "true", VITE_BASE_URL: "/sway-examples/pr-preview/pr-4", XDG_CONFIG_HOME: "/home/runner/.config", npm_lifecycle_script: "pnpm run fuels:build && tsc -b && vite build", ANDROID_NDK_ROOT: "/usr/local/lib/android/sdk/ndk/27.0.12077973", DEBIAN_FRONTEND: "noninteractive", GITHUB_ACTION_REF: "", STATS_UE: "true", GITHUB_ACTIONS: "true", GITHUB_REPOSITORY_ID: "820020030", NODE_PATH: "/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/run-s/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules", npm_package_version: "0.0.0", npm_package_devDependencies__types_react: "^18.3.3", npm_lifecycle_event: "build", GITHUB_REF_PROTECTED: "false", npm_package_scripts_fuels_dev: "fuels dev", npm_package_scripts_build: "pnpm run fuels:build && tsc -b && vite build", npm_package_dependencies_app_commons: "workspace:*", ACCEPT_EULA: "Y", GITHUB_JOB: "deploy-preview", GITHUB_WORKSPACE: "/home/runner/work/sway-examples/sway-examples", RUNNER_PERFLOG: "/home/runner/perflog", TURBO_INVOCATION_DIR: "/home/runner/work/sway-examples/sway-examples", npm_config_node_version: "20.11.0", COUNTER_DIST: "/home/runner/work/sway-examples/sway-examples/dist/counter/", GITHUB_RUN_ATTEMPT: "1", GITHUB_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", npm_package_dependencies__fuels_react: "^0.25.0", npm_package_dependencies__tanstack_react_query: "^5.29.2", ANDROID_SDK_ROOT: "/usr/local/lib/android/sdk", COUNTER_BASE_URL: "/counter/", GITHUB_ACTOR: "rishabhkeshan", GITHUB_REF: "refs/pull/4/merge", npm_config_save_exact: "true", LEIN_HOME: "/usr/local/lib/lein", npm_package_dependencies__mui_icons_material: "^5.16.5", GITHUB_ACTOR_ID: "58903797", GITHUB_PATH: "/home/runner/work/_temp/_runner_file_commands/add_path_f718650a-ff98-4302-80d8-5fcdb4473af9", JAVA_HOME: "/usr/lib/jvm/temurin-11-jdk-amd64", PWD: "/home/runner/work/sway-examples/sway-examples/counter", RUNNER_WORKSPACE: "/home/runner/work/sway-examples", VITE_PINATA_JWT: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJkODEwNDc5Zi1lYjk5LTQyNmMtOGMzMy02ZmU1Yjk1ZTVjYTIiLCJlbWFpbCI6Im1kYXVlcjMzM0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJpZCI6IkZSQTEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX0seyJpZCI6Ik5ZQzEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNjY0NzllYmFiMDFlOTEwMWJhYmUiLCJzY29wZWRLZXlTZWNyZXQiOiJmMDhiODk1NjVmNDQ0NjE5ZWZiMmM1NGNjOTEwN2E1ZWQ5NTI5OTgwYmZiMTAzOGYwZjc1NGVjNTkxNTE3OGY1IiwiaWF0IjoxNzE3MDE0NzQ1fQ.GvOu2LjeyyP4zE9_d9v8XUNV_Wgh595QTEy2kZa6Psk", npm_package_dependencies__emotion_styled: "^11.11.0", npm_package_dependencies__wagmi_connectors: "5.0.26", npm_package_dependencies_vite_plugin_vercel: "^8.0.0", npm_execpath: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/pnpm.cjs", ANDROID_HOME: "/usr/local/lib/android/sdk", GECKOWEBDRIVER: "/usr/local/share/gecko_driver", GHCUP_INSTALL_BASE_PREFIX: "/usr/local", GITHUB_EVENT_NAME: "pull_request", GITHUB_OUTPUT: "/home/runner/work/_temp/_runner_file_commands/set_output_f718650a-ff98-4302-80d8-5fcdb4473af9", GITHUB_SERVER_URL: "https://github.com", HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS: "3650", HOMEBREW_NO_AUTO_UPDATE: "1", LEIN_JAR: "/usr/local/lib/lein/self-installs/leiningen-2.11.2-standalone.jar", STATS_TIS: "mining", VITE_PUBLIC_GATEWAY_URL: "https://fuchsia-bizarre-butterfly-560.mypinata.cloud", EDGEWEBDRIVER: "/usr/local/share/edge_driver", PNPM_SCRIPT_SRC_DIR: "/home/runner/work/sway-examples/sway-examples/counter", STATS_EXT: "true", npm_package_dependencies__wagmi_core: "2.12.2", npm_package_devDependencies_postcss: "^8.4.39", npm_command: "run-script", ANDROID_NDK: "/usr/local/lib/android/sdk/ndk/27.0.12077973", CHROME_BIN: "/usr/bin/google-chrome", SGX_AESM_ADDR: "1", npm_package_scripts_preview: "vite preview", PNPM_HOME: "/home/runner/setup-pnpm/node_modules/.bin", SELENIUM_JAR_PATH: "/usr/share/java/selenium-server.jar", STATS_EXTP: "https://provjobdsettingscdn.blob.core.windows.net/settings/provjobdsettings-0.5.181+6/provjobd.data", NODE_ENV: "production", npm_package_dependencies_react_use: "^17.5.0", npm_package_devDependencies_npm_run_all: "^4.1.5", ANDROID_NDK_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_STEP_SUMMARY: "/home/runner/work/_temp/_runner_file_commands/step_summary_f718650a-ff98-4302-80d8-5fcdb4473af9", INIT_CWD: "/home/runner/work/sway-examples/sway-examples/counter", npm_package_dependencies_react: "^18.3.1" };
const contractId = define_process_env_default$1.VITE_PUBLIC_TESTNET_COUNTER_CONTRACT_ID;
function Home() {
  const { wallet, walletBalance, refetchBalance, isConnected } = useActiveWallet();
  const [contract, setContract] = reactExports.useState();
  const [counter, setCounter] = reactExports.useState();
  _default$1(async () => {
    if (wallet) {
      const testContract = TestContractAbi__factory.connect(contractId, wallet);
      setContract(testContract);
      const { value: value2 } = await testContract.functions.get_count().get();
      setCounter(value2.toNumber());
    }
  }, [wallet]);
  const { onIncrementPressed, isLoading } = useIncrementCounter({
    contract,
    isConnected,
    walletBalance,
    setCounter,
    refetchBalance
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FuelLogo, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-semibold", children: "Welcome to Fuel" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-400 text-center", children: [
      "Get started by editing ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: "sway-programs/contract/main.sw" }),
      " or",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: "src/pages/index.tsx" }),
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-400 text-center", children: [
      "This template uses the new",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "https://docs.fuel.network/docs/fuels-ts/fuels/#fuels-cli", children: "Fuels CLI" }),
      " ",
      "to enable type-safe hot-reloading for your Sway programs."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold", children: "Counter" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "counter", className: "text-gray-400 text-6xl", children: counter }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          onClick: onIncrementPressed,
          className: `mt-6 ${isLoading ? "bg-transparent border border-gray-400 pointer-events-none" : !isConnected ? "bg-gray-500" : ""}`,
          children: isLoading ? "Incrementing..." : "Increment Counter"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `${"/sway-examples/pr-preview/pr-4"}/counter/predicate`, className: "text-fuel-green hover:underline", children: "Predicate Example" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `${"/sway-examples/pr-preview/pr-4"}/counter/script`, className: "text-fuel-green hover:underline", children: "Script Example" })
  ] });
}
const Input = ({ value: value2, onChange, placeholder, type: type3, className, id: id2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      value: value2,
      onChange,
      placeholder,
      type: type3,
      className: `border-2 border-gray-700 placeholder:text-gray-600 text-gray-400 rounded-md px-4 py-2 bg-transparent outline-none ${className}`,
      id: id2
    }
  );
};
const useTransferFundsToPredicate = ({
  predicate,
  setPredicateBalance,
  refetchBalance
}) => {
  const { wallet, walletBalance, isConnected } = useActiveWallet();
  const [isLoadingTransfer, setIsLoadingTransfer] = reactExports.useState(false);
  const refreshBalances = async () => {
    await (refetchBalance == null ? void 0 : refetchBalance());
    setPredicateBalance(await (predicate == null ? void 0 : predicate.getBalance()) || bn$1(0));
  };
  const transferFundsToPredicate = async (amount) => {
    if (!isConnected)
      return _t$3.error(
        "Please connect your wallet to transfer funds to Predicate"
      );
    if (!predicate) {
      return _t$3.error("Predicate not loaded");
    }
    if (!wallet) {
      return _t$3.error("Wallet not loaded");
    }
    if (walletBalance == null ? void 0 : walletBalance.eq(0)) {
      return _t$3.error(
        "Your wallet does not have enough funds. Please click the 'Faucet' button in the top right corner, or use the local faucet."
      );
    }
    try {
      setIsLoadingTransfer(true);
      const baseAssetId = wallet.provider.getBaseAssetId();
      const tx = await wallet.transfer(predicate.address, amount, baseAssetId, {
        gasLimit: 1e4
      });
      console.log(tx);
      await refreshBalances();
      return _t$3(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { color: "success" }),
        "Funds transferred to predicate! View it on the",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            className: "pl-1 underline",
            target: "_blank",
            href: `https://app.fuel.network/tx/${tx == null ? void 0 : tx.id}`,
            children: "block explorer"
          }
        )
      ] }));
    } catch (error) {
      console.error(error);
      _t$3.error("An error occurred while transferring funds.");
    } finally {
      setIsLoadingTransfer(false);
    }
  };
  return { transferFundsToPredicate, isLoadingTransfer };
};
function useUnlockPredicateAndTransferFundsBack({
  predicate,
  predicateBalance,
  setPredicateBalance,
  refetchBalance
}) {
  const { wallet, walletBalance, isConnected } = useActiveWallet();
  const [isLoadingUnlock, setIsLoadingUnlock] = reactExports.useState(false);
  const unlockPredicateAndTransferFundsBack = async (amount, pin) => {
    try {
      if (!isConnected) {
        return _t$3.error(
          "Please connect your wallet to transfer funds back from Predicate"
        );
      }
      if (!wallet) {
        return _t$3.error("Wallet not loaded");
      }
      if (walletBalance == null ? void 0 : walletBalance.eq(0)) {
        return _t$3.error(
          "Your wallet does not have enough funds. Please click the 'Faucet' button in the top right corner, or use the local faucet."
        );
      }
      if (!predicateBalance || predicateBalance.lt(bn$1.parseUnits("0.0009"))) {
        return _t$3.error("Predicate balance is less than 0.0009 ETH");
      }
      setIsLoadingUnlock(true);
      const baseAssetId = wallet.provider.getBaseAssetId();
      const reInitializePredicate = TestPredicateAbi__factory.createInstance(
        wallet.provider,
        [bn$1(pin)]
      );
      if (!reInitializePredicate) {
        return _t$3.error("Failed to initialize predicate");
      }
      const tx = await reInitializePredicate.transfer(
        wallet.address,
        amount,
        baseAssetId
      );
      const { isStatusSuccess } = await tx.wait();
      if (!isStatusSuccess) {
        _t$3.error("Failed to unlock predicate");
        return;
      }
      _t$3(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { color: "success" }),
        "Funds transferred from predicate! View it on the",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            className: "pl-1 underline",
            target: "_blank",
            href: `https://app.fuel.network/tx/${tx.id}`,
            children: "block explorer"
          }
        )
      ] }));
      await (refetchBalance == null ? void 0 : refetchBalance());
      setPredicateBalance(await (predicate == null ? void 0 : predicate.getBalance()) ?? new BN(0));
    } catch (e2) {
      console.error(e2);
      _t$3.error(
        "Failed to unlock predicate. You probably entered the wrong pin, or the predicate does not have enough balance. Try again."
      );
    } finally {
      setIsLoadingUnlock(false);
    }
  };
  return {
    unlockPredicateAndTransferFundsBack,
    isLoadingUnlock
  };
}
function PredicateExample() {
  const { wallet, walletBalance, refetchBalance, isConnected } = useActiveWallet();
  const [predicate, setPredicate] = reactExports.useState();
  const [predicateBalance, setPredicateBalance] = reactExports.useState();
  const [pin, setPin] = reactExports.useState("");
  _default$1(async () => {
    if (wallet) {
      const predicateInstance = TestPredicateAbi__factory.createInstance(
        wallet.provider
      );
      setPredicate(predicateInstance);
      setPredicateBalance(await predicateInstance.getBalance());
    }
  }, [wallet]);
  const { transferFundsToPredicate, isLoadingTransfer } = useTransferFundsToPredicate({
    predicate,
    setPredicateBalance,
    refetchBalance
  });
  const { unlockPredicateAndTransferFundsBack, isLoadingUnlock } = useUnlockPredicateAndTransferFundsBack({
    predicate,
    predicateBalance,
    setPredicateBalance,
    refetchBalance
  });
  const isButtonDisabled = !isConnected || !predicateBalance || predicateBalance.lt(bn$1.parseUnits("0.0009"));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FuelLogo, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-semibold", children: "Predicate" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 items-baseline flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold text-xl", children: "Wallet Balance:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-400", children: [
        walletBalance == null ? void 0 : walletBalance.format({ precision: 3 }),
        " ETH"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "items-baseline flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold text-xl", children: "Predicate Balance:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-400", children: [
        predicateBalance == null ? void 0 : predicateBalance.format({ precision: 3 }),
        " ETH"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        className: `${isLoadingTransfer ? "bg-transparent border border-gray-400 pointer-events-none" : !isConnected ? "bg-gray-500" : ""}`,
        onClick: async () => await transferFundsToPredicate(bn$1.parseUnits("0.001")),
        children: isLoadingTransfer ? "Transferring to Predicate..." : "Transfer 0.001 ETH to Predicate"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input,
      {
        className: "w-[300px] mt-8",
        value: pin,
        onChange: (e2) => setPin(e2.target.value),
        placeholder: "Hint - the correct pin is 1337"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        className: `w-11/12 sm:w-fit ${isLoadingUnlock ? "bg-transparent border border-gray-400 pointer-events-none" : isButtonDisabled ? "bg-gray-500" : ""}`,
        onClick: async () => await unlockPredicateAndTransferFundsBack(
          bn$1.parseUnits("0.0009"),
          pin
        ),
        children: isLoadingUnlock ? "Unlocking Predicate and Transferring to Wallet..." : "Unlock Predicate and Transfer 0.0009 ETH back to Wallet"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mt-4 w-[360px] text-center text-gray-400", children: [
      "Do note that when you 'unlock' a predicate, the predicate also pays for the gas of the transaction. ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      "This is why you will notice that the balance of the predicate gets reduced by 0.0009 ETH + a nominal gas fee."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Link,
      {
        to: "https://docs.fuel.network/docs/intro/glossary/#predicate",
        target: "_blank",
        className: "text-fuel-green hover:underline",
        children: "Learn more about Predicates"
      }
    )
  ] });
}
function useRunScript({
  wallet,
  walletBalance,
  isConnected,
  input,
  setResult
}) {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [script, setScript] = reactExports.useState();
  _default$1(async () => {
    if (wallet) {
      const scriptInstance = TestScriptAbi__factory.createInstance(wallet);
      setScript(scriptInstance);
    }
  }, [wallet]);
  const runScript = async () => {
    try {
      if (!isConnected)
        return _t$3.error("Please connect your wallet to run the script");
      if (!script) {
        return _t$3.error("Script not loaded");
      }
      if (walletBalance == null ? void 0 : walletBalance.eq(0)) {
        return _t$3.error(
          "Your wallet does not have enough funds. Please click the 'Faucet' button in the top right corner, or use the local faucet."
        );
      }
      setIsLoading(true);
      const { waitForResult } = await script.functions.main(bn$1(input)).call();
      const { value: value2, transactionId } = await waitForResult();
      setResult(value2.toString());
      _t$3(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { color: "success" }),
        "Transaction Success! View it on the",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            className: "pl-1 underline",
            target: "_blank",
            href: `https://app.fuel.network/tx/${transactionId}`,
            children: "block explorer"
          }
        )
      ] }));
    } catch (error) {
      console.error(error);
      _t$3.error("Error running script.");
    } finally {
      setIsLoading(false);
    }
  };
  return { runScript, isLoading };
}
function ScriptExample() {
  const { wallet, walletBalance, isConnected } = useActiveWallet();
  const [input, setInput] = reactExports.useState();
  const [result, setResult] = reactExports.useState();
  const { runScript, isLoading } = useRunScript({
    wallet,
    walletBalance,
    isConnected,
    input: input ?? "",
    setResult
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FuelLogo, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-semibold", children: "Script" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input,
      {
        className: "mt-8",
        value: input,
        onChange: (e2) => setInput(e2.target.value),
        placeholder: "Enter a number",
        type: "number"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        className: `${isLoading ? "bg-transparent border border-gray-400 pointer-events-none" : !isConnected ? "bg-gray-500" : ""}`,
        onClick: runScript,
        children: isLoading ? "Running..." : "Run Script"
      }
    ),
    result && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 align-bottom", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold text-xl", children: "Result:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400 text-center flex justify-center items-center", children: result })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: "This script takes a number and simply echoes it back." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Link,
      {
        to: "https://docs.fuel.network/docs/intro/glossary/#script",
        target: "_blank",
        className: "text-fuel-green hover:underline",
        children: "Learn more about Scripts"
      }
    )
  ] });
}
const useFaucet$1 = () => {
  const [faucetWallet, setFaucetWallet] = reactExports.useState();
  _default$1(async () => {
    if (!faucetWallet) {
      const provider = await Provider.create(NODE_URL);
      const wallet = Wallet.fromPrivateKey(FAUCET_PRIVATE_KEY, provider);
      setFaucetWallet(wallet);
    }
  }, [faucetWallet]);
  return {
    faucetWallet
  };
};
function Faucet() {
  useFaucet$1();
  const { wallet, refetchBalance, walletBalance } = useActiveWallet();
  const navigate = useNavigate();
  const [receiverAddress, setReceiverAddress] = reactExports.useState("");
  reactExports.useState("5");
  const previousBalanceRef = reactExports.useRef(walletBalance);
  reactExports.useEffect(() => {
    if (wallet) {
      setReceiverAddress(wallet.address.toB256());
    }
  }, [wallet]);
  reactExports.useEffect(() => {
    const interval = setInterval(async () => {
      await (refetchBalance == null ? void 0 : refetchBalance());
    }, 500);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    if (previousBalanceRef.current && walletBalance && walletBalance.gt(previousBalanceRef.current)) {
      _t$3.success("Funds received! Navigating back to home page.");
      navigate(`${"/sway-examples/pr-preview/pr-4"}/counter`);
    }
    previousBalanceRef.current = walletBalance;
  }, [walletBalance, navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "iframe",
    {
      src: `${TESTNET_FAUCET_LINK$1}?address=${receiverAddress}`,
      width: "100%",
      height: "700px",
      allowFullScreen: true
    }
  ) });
}
var isBrowser = typeof window !== "undefined";
var getInitialState = function(query, defaultState2) {
  if (defaultState2 !== void 0) {
    return defaultState2;
  }
  if (isBrowser) {
    return window.matchMedia(query).matches;
  }
  return false;
};
var useMedia = function(query, defaultState2) {
  var _a2 = reactExports.useState(getInitialState(query, defaultState2)), state2 = _a2[0], setState = _a2[1];
  reactExports.useEffect(function() {
    var mounted = true;
    var mql = window.matchMedia(query);
    var onChange = function() {
      if (!mounted) {
        return;
      }
      setState(!!mql.matches);
    };
    mql.addEventListener("change", onChange);
    setState(mql.matches);
    return function() {
      mounted = false;
      mql.removeEventListener("change", onChange);
    };
  }, [query]);
  return state2;
};
const useBreakpoints$1 = () => {
  const isMobile = useMedia("(max-width: 640px)", false);
  const isTablet = useMedia("(max-width: 768px)", false);
  return { isMobile, isTablet };
};
const RtlContext = /* @__PURE__ */ reactExports.createContext();
const useRtl = () => {
  const value2 = reactExports.useContext(RtlContext);
  return value2 != null ? value2 : false;
};
const ListContext = /* @__PURE__ */ reactExports.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$l = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$e = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled$1("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$1({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$1({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
      as: component,
      className: clsx(classes.root, className),
      ref: ref2,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
const _excluded$k = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref2) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = (event) => {
    const list = listRef.current;
    const key = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref2);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$1({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c2) {
    return c2;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends$1({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$2();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
const _excluded$j = ["className", "component"];
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx$2);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref2) {
    const theme = useTheme$1(defaultTheme2);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$j);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends$1({
      as: component,
      ref: ref2,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme
    }, other));
  });
  return Box2;
}
const _excluded$i = ["ownerState"], _excluded2$2 = ["variants"], _excluded3$1 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$2();
const lowercaseFirstLetter = (string2) => {
  if (!string2) {
    return string2;
  }
  return string2.charAt(0).toLowerCase() + string2.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme,
  themeId
}) {
  return isEmpty(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
function processStyleArg(callableStyle, _ref) {
  let {
    ownerState
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$i);
  const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle(_extends$1({
    ownerState
  }, props)) : callableStyle;
  if (Array.isArray(resolvedStylesArg)) {
    return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg(resolvedStyle, _extends$1({
      ownerState
    }, props)));
  }
  if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
    const {
      variants = []
    } = resolvedStylesArg, otherStyles = _objectWithoutPropertiesLoose(resolvedStylesArg, _excluded2$2);
    let result = otherStyles;
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        isMatch = variant.props(_extends$1({
          ownerState
        }, props, ownerState));
      } else {
        Object.keys(variant.props).forEach((key) => {
          if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (!Array.isArray(result)) {
          result = [result];
        }
        result.push(typeof variant.style === "function" ? variant.style(_extends$1({
          ownerState
        }, props, ownerState)) : variant.style);
      }
    });
    return result;
  }
  return resolvedStylesArg;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx$2(_extends$1({}, props, {
      theme: resolveTheme(_extends$1({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded3$1);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, _extends$1({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const transformStyleArg = (stylesArg) => {
      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || isPlainObject(stylesArg)) {
        return (props) => processStyleArg(stylesArg, _extends$1({}, props, {
          theme: resolveTheme({
            theme: props.theme,
            defaultTheme: defaultTheme2,
            themeId
          })
        }));
      }
      return stylesArg;
    };
    const muiStyledResolver = (styleArg, ...expressions) => {
      let transformedStyleArg = transformStyleArg(styleArg);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = processStyleArg(slotStyle, _extends$1({}, props, {
              theme
            }));
          });
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _theme$components;
          const theme = resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
          return processStyleArg({
            variants: themeVariants
          }, _extends$1({}, props, {
            theme
          }));
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
const styled = createStyled2();
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}
const _excluded$h = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
const defaultTheme$1 = createTheme$2();
const defaultCreateStyledComponent = styled("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$1
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output2, child, index) => {
    output2.push(child);
    if (index < childrenArray.length - 1) {
      output2.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index}`
      }));
    }
    return output2;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style = ({
  ownerState,
  theme
}) => {
  let styles2 = _extends$1({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme);
    const base2 = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base: base2
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base: base2
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge$1(styles2, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid(inProps, ref2) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends$1({
      as: component,
      ownerState,
      ref: ref2,
      className: clsx(classes.root, className)
    }, other, {
      children: divider ? joinChildren(children, divider) : children
    }));
  });
  return Stack2;
}
function useTheme() {
  const theme = useTheme$1(defaultTheme$2);
  return theme[THEME_ID] || theme;
}
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
const _excluded$g = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value2) {
  return `scale(${value2}, ${value2 ** 2})`;
}
const styles$25 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref2) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state2, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
        style: _extends$1({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0
        }, styles$25[state2], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value: value2,
      el: el2,
      property
    }) => {
      if (value2) {
        el2.style.setProperty(property, value2);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i2,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
const _excluded$f = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$24 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref2) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state2, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
        style: _extends$1({
          opacity: 0,
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0
        }, styles$24[state2], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$e = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled$1("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$1({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref2) {
  var _slotProps$root, _ref, _slots$root;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const ownerState = _extends$1({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$d(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes,
      ref: ref2,
      children
    }))
  }));
});
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$1({}, propsEventHandlers, otherHandlers);
    return _extends$1({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$1({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$d = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$c = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled$1("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled$1(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const propsWithDefaults = _extends$1({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends$1({}, propsWithDefaults, {
    rootRef: ref2
  }));
  const ownerState = _extends$1({}, propsWithDefaults, {
    exited
  });
  const classes = useUtilityClasses$c(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref: ref2,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const backdropProps = useSlotProps({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$1({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$c = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$b = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled$1("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$1({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$1({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const ownerState = _extends$1({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$b(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2
  }, other));
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$b = ["onEntering"], _excluded2$1 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3 = ["slotProps"];
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n3) => typeof n3 === "number" ? `${n3}px` : n3).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$a = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled$1(Modal, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled$1(Paper, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref2) {
  var _slotProps$paper, _slots$root, _slots$paper;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots,
    slotProps,
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {},
    disableScrollLock = false
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$b), other = _objectWithoutPropertiesLoose(props, _excluded2$1);
  const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
  const ownerState = _extends$1({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$a(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top = anchorOffset.top - elemTransformOrigin.vertical;
    let left = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom = top + elemRect.height;
    const right = left + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top < marginThreshold) {
      const diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom > heightThreshold) {
      const diff = bottom - heightThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left < marginThreshold) {
      const diff = left - marginThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right > widthThreshold) {
      const diff = right - widthThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
  const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
  const paperProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: _extends$1({}, externalPaperSlotProps, {
      style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation,
      ref: handlePaperRef
    },
    ownerState,
    className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
  });
  const _useSlotProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
    externalForwardedProps: other,
    additionalProps: {
      ref: ref2,
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  }), {
    slotProps: rootSlotPropsProp
  } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
        children
      }))
    }))
  }));
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$a = ["onEntering"], _excluded2 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled$1(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled$1(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled$1(MenuList, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref2) {
  var _slots$paper, _slotProps$paper;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$a), other = _objectWithoutPropertiesLoose(props, _excluded2);
  const isRtl = useRtl();
  const ownerState = _extends$1({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$9(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
  const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const paperSlotProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open,
    ref: ref2,
    transitionDuration,
    TransitionProps: _extends$1({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className),
      children
    }))
  }));
});
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const _excluded$9 = ["center", "classes", "className"];
let _$1 = (t2) => t2, _t$2, _t2, _t3, _t4;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$2 || (_t$2 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2 || (_t2 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3 || (_t3 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$1("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled$1(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb2) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref2, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const _excluded$8 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$1("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type: type3
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type3 === void 0 ? "button" : type3;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref2, focusVisibleRef, buttonRef);
  const ownerState = _extends$1({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type: type3
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, _extends$1({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$7 = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize$1(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled$1("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  margin: 0
}, ownerState.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = (color2) => {
  return colorTransformations[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref2) {
  const themeProps = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors(themeProps.color);
  const props = extendSxProp(_extends$1({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
  const ownerState = _extends$1({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$1({
    as: Component,
    ref: ref2,
    ownerState,
    className: clsx(classes.root, className)
  }, other));
});
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const _excluded$6 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$6 = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const MenuItemRoot = styled$1(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$1({}, theme.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${menuItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$1({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme.typography.body2, {
  [`& .${listItemIconClasses.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$1({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$6(props);
  const handleRef = useForkRef(menuItemRef, ref2);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other, {
      ownerState,
      classes
    }))
  });
});
var TableRows = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(TableRows, "__esModule", {
  value: true
});
var default_1$1 = TableRows.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
default_1$1 = TableRows.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M21 8H3V4h18zm0 2H3v4h18zm0 6H3v4h18z"
}), "TableRows");
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const _excluded$5 = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize$1(color2)}`, edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled$1(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.action.active, theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends$1({}, ownerState.color === "inherit" && {
    color: "inherit"
  }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$1({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    "&:hover": _extends$1({}, palette && {
      backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(palette.main, theme.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), ownerState.size === "small" && {
    padding: 5,
    fontSize: theme.typography.pxToRem(18)
  }, ownerState.size === "large" && {
    padding: 12,
    fontSize: theme.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme.vars || theme).palette.action.disabled
    }
  });
});
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const ownerState = _extends$1({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size
  });
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$1({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref: ref2
  }, other, {
    ownerState,
    children
  }));
});
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useFormControl() {
  return reactExports.useContext(FormControlContext);
}
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const _excluded$4 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize$1(color2)}`, `size${capitalize$1(size)}`, `${variant}Size${capitalize$1(size)}`, `color${capitalize$1(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["icon", "startIcon", `iconSize${capitalize$1(size)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize$1(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) => _extends$1({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
});
const ButtonRoot = styled$1(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color)}`], styles2[`size${capitalize$1(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
  return _extends$1({}, theme.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": _extends$1({
      textDecoration: "none",
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
      boxShadow: (theme.vars || theme).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (theme.vars || theme).shadows[2],
        backgroundColor: (theme.vars || theme).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$1({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[8]
    }),
    [`&.${buttonClasses.focusVisible}`]: _extends$1({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[6]
    }),
    [`&.${buttonClasses.disabled}`]: _extends$1({
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    }, ownerState.variant === "contained" && {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha_1(theme.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme.vars ? (
      // this is safe because grey does not change between default light/dark mode
      theme.vars.palette.text.primary
    ) : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled$1("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$1({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled$1("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$1({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref2) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size = "medium",
    startIcon: startIconProp,
    type: type3,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const ownerState = _extends$1({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type: type3,
    variant
  });
  const classes = useUtilityClasses$4(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$1({
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref2,
    type: type3
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$3 = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize$1(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled$1(ButtonBase)(({
  ownerState
}) => _extends$1({
  padding: 9,
  borderRadius: "50%"
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}));
const SwitchBaseInput = styled$1("input", {
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref2) {
  const {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id: id2,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type: type3,
    value: value2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type3 === "checkbox" || type3 === "radio";
  const ownerState = _extends$1({}, props, {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$1({
    component: "span",
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ownerState,
    ref: ref2
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends$1({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes.input,
      disabled,
      id: hasLabelFor ? id2 : void 0,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type: type3
    }, type3 === "checkbox" && value2 === void 0 ? {} : {
      value: value2
    }, inputProps)), checked ? checkedIcon : icon]
  }));
});
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const _excluded$2 = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled$1(Backdrop, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize$1(scroll)}`],
    paper: ["paper", `paperScroll${capitalize$1(scroll)}`, `paperWidth${capitalize$1(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled$1(Modal, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled$1("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize$1(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends$1({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&::after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled$1(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize$1(ownerState.scroll)}`], styles2[`paperWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses.paperScrollBody}`]: {
    [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
  [`&.${dialogClasses.paperScrollBody}`]: {
    [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClick,
    onClose,
    open,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const ownerState = _extends$1({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  });
  const classes = useUtilityClasses$2(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$1({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$1({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    ref: ref2,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$1({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
});
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const _excluded$1 = ["className", "dividers"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled$1("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, ownerState.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
} : {
  [`.${dialogTitleClasses.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const ownerState = _extends$1({}, props, {
    dividers
  });
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$1({
    className: clsx(classes.root, className),
    ownerState,
    ref: ref2
  }, other));
});
const Stack = createStack({
  createStyledComponent: styled$1("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiStack"
  })
});
function getSwitchUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const _excluded = ["className", "color", "edge", "size", "sx"];
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    edge,
    size,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`],
    switchBase: ["switchBase", `color${capitalize$1(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const SwitchRoot = styled$1("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [{
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -8
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -8
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }
  }]
});
const SwitchSwitchBase = styled$1(SwitchBase, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
  transition: theme.transitions.create(["left", "transform"], {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${switchClasses.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses.disabled}`]: {
    color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
  },
  [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
    opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses.input}`]: {
    left: "-100%",
    width: "300%"
  }
}), ({
  theme
}) => ({
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.action.active, theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [...Object.entries(theme.palette).filter(([, value2]) => value2.main && value2.light).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${switchClasses.checked}`]: {
        color: (theme.vars || theme).palette[color2].main,
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[color2].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses.disabled}`]: {
          color: theme.vars ? theme.vars.palette.Switch[`${color2}DisabledColor`] : `${theme.palette.mode === "light" ? lighten_1(theme.palette[color2].main, 0.62) : darken_1(theme.palette[color2].main, 0.55)}`
        }
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        backgroundColor: (theme.vars || theme).palette[color2].main
      }
    }
  }))]
}));
const SwitchTrack = styled$1("span", {
  name: "MuiSwitch",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme.transitions.create(["opacity", "background-color"], {
    duration: theme.transitions.duration.shortest
  }),
  backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
  opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
}));
const SwitchThumb = styled$1("span", {
  name: "MuiSwitch",
  slot: "Thumb",
  overridesResolver: (props, styles2) => styles2.thumb
})(({
  theme
}) => ({
  boxShadow: (theme.vars || theme).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
}));
const Switch = /* @__PURE__ */ reactExports.forwardRef(function Switch2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const {
    className,
    color: color2 = "primary",
    edge = false,
    size = "medium",
    sx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const ownerState = _extends$1({}, props, {
    color: color2,
    edge,
    size
  });
  const classes = useUtilityClasses(ownerState);
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
    className: classes.thumb,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
    className: clsx(classes.root, className),
    sx,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$1({
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref: ref2,
      ownerState
    }, other, {
      classes: _extends$1({}, classes, {
        root: classes.switchBase
      })
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
      className: classes.track,
      ownerState
    })]
  });
});
const ConnectButton = () => {
  const { isPending: isLoading, isConnected } = useActiveWallet();
  const { connect } = re$3();
  const { disconnect } = fl();
  const buttonText = isLoading ? "Loading..." : isConnected ? "Disconnect" : "Connect";
  const onClick = isConnected ? disconnect : connect;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { className: isConnected ? "bg-red-500" : "bg-green-500", disabled: isLoading, onClick: () => onClick(), children: buttonText });
};
const NavMenu = ({ address }) => {
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const open = Boolean(anchorEl);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClose = () => {
    setAnchorEl(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        id: "basic-button",
        "aria-controls": open ? "basic-menu" : void 0,
        "aria-haspopup": "true",
        "aria-expanded": open ? "true" : void 0,
        onClick: handleClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, { className: "rounded-sm active:bg-gray-600 text-gray-400" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Menu,
      {
        container: () => document.getElementById("__next"),
        id: "basic-menu",
        anchorEl,
        open,
        onClose: handleClose,
        MenuListProps: { "aria-labelledby": "basic-button" },
        slotProps: { paper: { className: "bg-black" } },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "text-white", to: "/counter", children: "Home" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link,
            {
              to: "https://docs.fuel.network",
              target: "_blank",
              className: "text-white",
              children: "Fuel Docs"
            }
          ) }),
          address && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "text-white", to: "/counter/faucet", children: "Faucet" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectButton, {}) })
        ]
      }
    )
  ] });
};
const primaryPale = "#222";
const primaryLight = "#f0f0f0";
const BaseSwitch = styled$1(Switch)({
  width: 45,
  height: 22,
  padding: 0,
  display: "flex",
  "& .MuiSwitch-switchBase": {
    padding: 2,
    "&.Mui-checked": {
      transform: "translateX(23px)",
      "& + .MuiSwitch-track": {
        opacity: 1,
        backgroundColor: primaryPale
      }
    }
  },
  "& .MuiSwitch-thumb": {
    width: 18,
    height: 18,
    borderRadius: "25px",
    backgroundColor: "transparent",
    boxShadow: "none"
  },
  "& .MuiSwitch-track": {
    opacity: 1,
    borderRadius: "25px",
    backgroundColor: primaryLight,
    boxSizing: "border-box"
  }
});
const SwitchWithIcons = styled$1(BaseSwitch)({
  "& .MuiSwitch-track": {
    "&:before, &:after": {
      content: '""',
      position: "absolute",
      transform: "translateY(-50%)",
      width: 16,
      height: 16,
      top: 11
    },
    "&:before": {
      left: 3
    },
    "&:after": {
      right: 3
    }
  },
  "& .MuiSwitch-thumb:before": {
    content: "''",
    position: "absolute",
    width: "100%",
    height: "100%",
    left: 0,
    top: 0,
    backgroundRepeat: "no-repeat",
    backgroundPosition: "center",
    backgroundImage: `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="16" width="16" viewBox="0 0 20 20"><path fill="${encodeURIComponent(
      "#4c4949"
    )}" d="M9.305 1.667V3.75h1.389V1.667h-1.39zm-4.707 1.95l-.982.982L5.09 6.072l.982-.982-1.473-1.473zm10.802 0L13.927 5.09l.982.982 1.473-1.473-.982-.982zM10 5.139a4.872 4.872 0 00-4.862 4.86A4.872 4.872 0 0010 14.862 4.872 4.872 0 0014.86 10 4.872 4.872 0 0010 5.139zm0 1.389A3.462 3.462 0 0113.471 10a3.462 3.462 0 01-3.473 3.472A3.462 3.462 0 016.527 10 3.462 3.462 0 0110 6.528zM1.665 9.305v1.39h2.083v-1.39H1.666zm14.583 0v1.39h2.084v-1.39h-2.084zM5.09 13.928L3.616 15.4l.982.982 1.473-1.473-.982-.982zm9.82 0l-.982.982 1.473 1.473.982-.982-1.473-1.473zM9.305 16.25v2.083h1.389V16.25h-1.39z"/></svg>')`
  },
  "& .MuiSwitch-switchBase": {
    "&.Mui-checked": {
      "& .MuiSwitch-thumb:before": {
        content: "''",
        position: "absolute",
        width: "100%",
        height: "100%",
        left: 0,
        top: 0,
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        backgroundImage: `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="16" width="16" viewBox="0 0 20 20"><path fill="${encodeURIComponent(
          "#fff"
        )}" d="M4.2 2.5l-.7 1.8-1.8.7 1.8.7.7 1.8.6-1.8L6.7 5l-1.9-.7-.6-1.8zm15 8.3a6.7 6.7 0 11-6.6-6.6 5.8 5.8 0 006.6 6.6z"/></svg>')`
      }
    }
  }
});
const ThemeToggle = ({ darkMode, setDarkMode }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SwitchWithIcons,
    {
      checked: darkMode,
      onChange: () => setDarkMode(!darkMode)
    }
  ) });
};
function App() {
  const { wallet, network, isConnected } = useActiveWallet();
  const { connect } = re$3();
  const { disconnect } = fl();
  const navigate = useNavigate();
  const { isMobile } = useBreakpoints$1();
  const showAddNetworkButton = wallet && network && (network == null ? void 0 : network.url) !== NODE_URL;
  const isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const tryToAddNetwork = () => {
    return alert(
      `Please add the network ${NODE_URL} to your Fuel wallet, or swtich to it if you have it already, and refresh the page.`
    );
  };
  const [darkMode, setDarkMode] = reactExports.useState(() => {
    return localStorage.getItem("theme") === "dark" || !localStorage.getItem("theme") && window.matchMedia("(prefers-color-scheme: dark)").matches;
  });
  reactExports.useEffect(() => {
    if (darkMode) {
      document.documentElement.setAttribute("data-theme", "dark");
      localStorage.setItem("theme", "dark");
    } else {
      document.documentElement.removeAttribute("data-theme");
      localStorage.setItem("theme", "light");
    }
  }, [darkMode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col bg-background text-text-primary", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex justify-between items-center p-4 bg-background text-text-primary gap-6", children: [
      !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "text-fuel-green hover:underline", to: `${"/sway-examples/pr-preview/pr-4"}/counter`, children: "Home" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: "https://docs.fuel.network",
            target: "_blank",
            className: "text-fuel-green hover:underline",
            children: "Fuel Docs"
          }
        )
      ] }),
      showAddNetworkButton && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: tryToAddNetwork, className: "bg-red-500", children: "Wrong Network" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletDisplay, { darkMode }) }),
      !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          className: "bg-gray-500",
          onClick: () => {
            if (!isConnected)
              return _t$3.error(
                "Please connect your wallet to visit the faucet."
              );
            if (isSafari2 && wallet) {
              const redirectUrl = new URL("https://faucet-testnet.fuel.network/");
              redirectUrl.searchParams.append("address", wallet.address.toString());
              redirectUrl.searchParams.append("redirectUrl", window.location.href);
              window.location.href = redirectUrl.href;
            } else {
              navigate(`${"/sway-examples/pr-preview/pr-4"}/counter/faucet`);
            }
          },
          children: "Faucet"
        }
      ),
      isConnected && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { className: "bg-red-600", onClick: disconnect, children: "Disconnect" }),
      !isConnected && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: connect, children: "Connect Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeToggle, { darkMode, setDarkMode }),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(NavMenu, { address: wallet == null ? void 0 : wallet.address.toString() })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen items-center justify-center flex flex-col gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: `${"/sway-examples/pr-preview/pr-4"}/counter`, element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: `${"/sway-examples/pr-preview/pr-4"}/counter/predicate`, element: /* @__PURE__ */ jsxRuntimeExports.jsx(PredicateExample, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: `${"/sway-examples/pr-preview/pr-4"}/counter/script`, element: /* @__PURE__ */ jsxRuntimeExports.jsx(ScriptExample, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: `${"/sway-examples/pr-preview/pr-4"}/counter/faucet`, element: /* @__PURE__ */ jsxRuntimeExports.jsx(Faucet, {}) })
      ] }),
      " "
    ] })
  ] }) });
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type: type3, data: data2 }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data2 instanceof Blob) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(data2, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data2 instanceof ArrayBuffer || isView$1(data2))) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(new Blob([data2]), callback);
    }
  }
  return callback(PACKET_TYPES[type3] + (data2 || ""));
};
const encodeBlobAsBase64 = (data2, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data2);
};
function toArray$1(data2) {
  if (data2 instanceof Uint8Array) {
    return data2;
  } else if (data2 instanceof ArrayBuffer) {
    return new Uint8Array(data2);
  } else {
    return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray$1).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray$1(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$2[chars.charCodeAt(i2)] = i2;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$2[base64.charCodeAt(i2)];
    encoded2 = lookup$2[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$2[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$2[base64.charCodeAt(i2 + 3)];
    bytes2[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type3 = encodedPacket.charAt(0);
  if (type3 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type3];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type3],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type3]
  };
};
const decodeBase64Packet = (data2, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data2);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data: data2 };
  }
};
const mapBinary = (data2, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data2 instanceof Blob) {
        return data2;
      } else {
        return new Blob([data2]);
      }
    case "arraybuffer":
    default:
      if (data2 instanceof ArrayBuffer) {
        return data2;
      } else {
        return data2.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count2 = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count2 === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer2 = new Uint8Array(size);
  let j2 = 0;
  for (let i2 = 0; i2 < size; i2++) {
    buffer2[i2] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer2;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state2 = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state2 === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state2 = 3;
          } else if (expectedLength === 126) {
            state2 = 1;
          } else {
            state2 = 2;
          }
        } else if (state2 === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state2 = 3;
        } else if (state2 === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n3 = view.getUint32(0);
          if (n3 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n3 * Math.pow(2, 32) + view.getUint32(4);
          state2 = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data2 = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data2 : TEXT_DECODER.decode(data2), binaryType));
          state2 = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn2) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn2);
  return this;
};
Emitter.prototype.once = function(event, fn2) {
  function on2() {
    this.off(event, on2);
    fn2.apply(this, arguments);
  }
  on2.fn = fn2;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn2) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb2;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb2 = callbacks[i2];
    if (cb2 === fn2 || cb2.fn === fn2) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength$1(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length2 = 0;
  for (let i2 = 0, l2 = str.length; i2 < l2; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      length2 += 1;
    } else if (c2 < 2048) {
      length2 += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length2 += 3;
    } else {
      i2++;
      length2 += 4;
    }
  }
  return length2;
}
function encode$1(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l2 = pairs.length; i2 < l2; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data2) {
    const packet = decodePacket(data2, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode$1(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i$5 = 0, prev;
function encode(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode(+/* @__PURE__ */ new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode(seed++);
}
for (; i$5 < length; i$5++)
  map[alphabet[i$5]] = i$5;
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e2) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e2) {
    }
  }
}
function createCookieJar() {
}
function empty() {
}
const hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data2) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data2, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data2) => {
      this.doWrite(data2, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data2, fn2) {
    const req = this.request({
      method: "POST",
      data: data2
    });
    req.on("success", fn2);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a2;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e2) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e2) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e2) {
      }
      (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a3;
        if (xhr.readyState === 3) {
          (_a3 = this.opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(xhr);
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e2) {
      this.setTimeoutFn(() => {
        this.onError(e2);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e2) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data2 = this.xhr.responseText;
    if (data2 !== null) {
      this.emitReserved("data", data2);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb2) => Promise.resolve().then(cb2);
  } else {
    return (cb2, setTimeoutFn) => setTimeoutFn(cb2, 0);
  }
})();
const WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e2) => this.onError("websocket error", e2);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data2) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data2);
          }
        } catch (e2) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this.writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a2;
    (_a2 = this.transport) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};
const re$1 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(str) {
  if (str.length > 2e3) {
    throw "URI too long";
  }
  const src2 = str, b2 = str.indexOf("["), e2 = str.indexOf("]");
  if (b2 != -1 && e2 != -1) {
    str = str.substring(0, b2) + str.substring(b2, e2).replace(/:/g, ";") + str.substring(e2, str.length);
  }
  let m2 = re$1.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b2 != -1 && e2 != -1) {
    uri.source = src2;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data2 = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data2[$1] = $2;
    }
  });
  return data2;
}
let Socket$1 = class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse$1(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse$1(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e2) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to2) {
      if (transport && to2.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i2 = 0;
      const l2 = this.upgrades.length;
      for (; i2 < l2; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data2) {
    this.emitReserved("handshake", data2);
    this.id = data2.sid;
    this.transport.query.sid = data2.sid;
    this.upgrades = this.filterUpgrades(data2.upgrades);
    this.pingInterval = data2.pingInterval;
    this.pingTimeout = data2.pingTimeout;
    this.maxPayload = data2.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data2 = this.writeBuffer[i2].data;
      if (data2) {
        payloadSize += byteLength$1(data2);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  send(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type3, data2, options, fn2) {
    if ("function" === typeof data2) {
      fn2 = data2;
      data2 = void 0;
    }
    if ("function" === typeof options) {
      fn2 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type: type3,
      data: data2,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn2)
      this.once("flush", fn2);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j2 = upgrades.length;
    for (; i2 < j2; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket$1.protocol = protocol$1;
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (isBinary(data2)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data2);
    return placeholder;
  } else if (Array.isArray(data2)) {
    const newData = new Array(data2.length);
    for (let i2 = 0; i2 < data2.length; i2++) {
      newData[i2] = _deconstructPacket(data2[i2], buffers);
    }
    return newData;
  } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
    const newData = {};
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        newData[key] = _deconstructPacket(data2[key], buffers);
      }
    }
    return newData;
  }
  return data2;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (data2 && data2._placeholder === true) {
    const isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
    if (isIndexValid) {
      return buffers[data2.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data2)) {
    for (let i2 = 0; i2 < data2.length; i2++) {
      data2[i2] = _reconstructPacket(data2[i2], buffers);
    }
  } else if (typeof data2 === "object") {
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        data2[key] = _reconstructPacket(data2[key], buffers);
      }
    }
  }
  return data2;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject$3(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if ("," === c2)
          break;
        if (i2 === str.length)
          break;
      }
      p2.nsp = str.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next2 = str.charAt(i2 + 1);
    if ("" !== next2 && Number(next2) == next2) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if (null == c2 || Number(c2) != c2) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e2) {
      return false;
    }
  }
  static isPayloadValid(type3, payload) {
    switch (type3) {
      case PacketType.CONNECT:
        return isObject$3(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject$3(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn2) {
  obj.on(ev, fn2);
  return function subDestroy() {
    obj.off(ev, fn2);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id2 = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id2, ack);
      packet.id = id2;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id2, ack) {
    var _a2;
    const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id2] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id2];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id2) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id2] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((resolve, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve(arg2);
        } else {
          return resolve(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data2) => {
        this._sendConnectPacket(data2);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data2) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data2) : data2
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners2 = this._anyListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2, pid) {
    this.id = id2;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners2.length; i2++) {
        if (listener === listeners2[i2]) {
          listeners2.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners2 = this._anyOutgoingListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a2;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn2) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn2 && fn2();
    });
    const onError2 = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn2) {
        fn2(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError2);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError2(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn2) {
    return this.open(fn2);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data2) {
    try {
      this.decoder.add(data2);
    } catch (e2) {
      this.onclose("parse error", e2);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup$1(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id2 = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id2]) {
      cache[id2] = new Manager(source, opts);
    }
    io = cache[id2];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup$1, {
  Manager,
  Socket: Socket2,
  io: lookup$1,
  connect: lookup$1
});
const version$3 = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value2 = params[key];
      try {
        if (value2 instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value2.length; i2++) {
            hex += HEX[value2[i2] >> 4];
            hex += HEX[value2[i2] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value2));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url2 = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url2 = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url2 += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url2 += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url2 += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url2 = code2;
        break;
    }
    if (url2) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url2 + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name, value2) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value: value2
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name, value2) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value2);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value2, message) {
    if (typeof value2 !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value2 < 0 || value2 >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: value2
      });
    }
    if (value2 % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: value2
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$3);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$2 = "bytes/5.7.0";
const logger = new Logger(version$2);
function isHexable(value2) {
  return !!value2.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isInteger(value2) {
  return typeof value2 === "number" && value2 == value2 && value2 % 1 === 0;
}
function isBytes$2(value2) {
  if (value2 == null) {
    return false;
  }
  if (value2.constructor === Uint8Array) {
    return true;
  }
  if (typeof value2 === "string") {
    return false;
  }
  if (!isInteger(value2.length) || value2.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value2.length; i2++) {
    const v2 = value2[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value2, options) {
  if (!options) {
    options = {};
  }
  if (typeof value2 === "number") {
    logger.checkSafeUint53(value2, "invalid arrayify value");
    const result = [];
    while (value2) {
      result.unshift(value2 & 255);
      value2 = parseInt(String(value2 / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (isHexable(value2)) {
    value2 = value2.toHexString();
  }
  if (isHexString(value2)) {
    let hex = value2.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value2);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$2(value2)) {
    return addSlice(new Uint8Array(value2));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value2);
}
function isHexString(value2, length2) {
  if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  return true;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$4 = 0, len = code.length; i$4 < len; ++i$4) {
  lookup[i$4] = code[i$4];
  revLookup[code.charCodeAt(i$4)] = i$4;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts2 = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts2.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts2.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts2.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE2 ? nBytes - 1 : 0;
  var d2 = isLE2 ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value2, offset2, isLE2, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE2 ? 0 : nBytes - 1;
  var d2 = isLE2 ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt2 / c2;
    } else {
      value2 += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length2) {
    if (typeof value2 === "string") {
      return fromString(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof value2 === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value2);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
    );
  }
  Buffer2.from = function(value2, encodingOrOffset, length2) {
    return from2(value2, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding2) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding2) {
    return alloc2(size, fill, encoding2);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length2 = byteLength2(string2, encoding2) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string2, encoding2);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b2) {
    if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2) return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding2) encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n3, m2) {
    const i2 = b2[n3];
    b2[n3] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i2 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found) return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf, string2, offset2, length2) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i2;
      buf[offset2 + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset2, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length2);
  }
  function asciiWrite(buf, string2, offset2, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset2, length2);
  }
  function base64Write(buf, string2, offset2, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset2, length2);
  }
  function ucs2Write(buf, string2, offset2, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length2);
  }
  Buffer2.prototype.write = function write3(string2, offset2, length2, encoding2) {
    if (offset2 === void 0) {
      encoding2 = "utf8";
      length2 = this.length;
      offset2 = 0;
    } else if (length2 === void 0 && typeof offset2 === "string") {
      encoding2 = offset2;
      length2 = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding2 === void 0) encoding2 = "utf8";
      } else {
        encoding2 = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length2 === void 0 || length2 > remaining) length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2) encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset2, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset2, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset2, length2);
        case "base64":
          return base64Write(this, string2, offset2, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset2, length2);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret2 = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret2 += String.fromCharCode(buf[i2] & 127);
    }
    return ret2;
  }
  function latin1Slice(buf, start, end) {
    let ret2 = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret2 += String.fromCharCode(buf[i2]);
    }
    return ret2;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length2) {
    if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
    if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul2 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul2 *= 256)) {
      val += this[offset2 + i2] * mul2;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul2 = 1;
    while (byteLength3 > 0 && (mul2 *= 256)) {
      val += this[offset2 + --byteLength3] * mul2;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul2 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul2 *= 256)) {
      val += this[offset2 + i2] * mul2;
    }
    mul2 *= 128;
    if (val >= mul2) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let i2 = byteLength3;
    let mul2 = 1;
    let val = this[offset2 + --i2];
    while (i2 > 0 && (mul2 *= 256)) {
      val += this[offset2 + --i2] * mul2;
    }
    mul2 *= 128;
    if (val >= mul2) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128)) return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value2, offset2, ext, max, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max || value2 < min) throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
    }
    let mul2 = 1;
    let i2 = 0;
    this[offset2] = value2 & 255;
    while (++i2 < byteLength3 && (mul2 *= 256)) {
      this[offset2 + i2] = value2 / mul2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul2 = 1;
    this[offset2 + i2] = value2 & 255;
    while (--i2 >= 0 && (mul2 *= 256)) {
      this[offset2 + i2] = value2 / mul2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
    this[offset2] = value2 & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value2, offset2, min, max) {
    checkIntBI(value2, min, max, buf, offset2, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value2, offset2, min, max) {
    checkIntBI(value2, min, max, buf, offset2, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2] = hi2;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset2 = 0) {
    return wrtBigUInt64LE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset2 = 0) {
    return wrtBigUInt64BE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul2 = 1;
    let sub = 0;
    this[offset2] = value2 & 255;
    while (++i2 < byteLength3 && (mul2 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value2 / mul2 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength3, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul2 = 1;
    let sub = 0;
    this[offset2 + i2] = value2 & 255;
    while (--i2 >= 0 && (mul2 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value2 / mul2 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
    if (value2 < 0) value2 = 255 + value2 + 1;
    this[offset2] = value2 & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
    if (value2 < 0) value2 = 4294967295 + value2 + 1;
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset2 = 0) {
    return wrtBigUInt64LE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset2 = 0) {
    return wrtBigUInt64BE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value2, offset2, ext, max, min) {
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    if (offset2 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset2, 4);
    }
    ieee754$1.write(buf, value2, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
    return writeFloat(this, value2, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
    return writeFloat(this, value2, offset2, false, noAssert);
  };
  function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
    value2 = +value2;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset2, 8);
    }
    ieee754$1.write(buf, value2, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
    return writeDouble(this, value2, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
    return writeDouble(this, value2, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding2 = end;
        end = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len = bytes2.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: value2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value2, min, max, buf, offset2, byteLength3) {
    if (value2 > max || value2 < min) {
      const n3 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n3} and < 2${n3} ** ${(byteLength3 + 1) * 8}${n3}`;
        } else {
          range = `>= -(2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n3}`;
        }
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value2);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value2, name) {
    if (typeof value2 !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value2);
    }
  }
  function boundsError(value2, length2, type3) {
    if (Math.floor(value2) !== value2) {
      validateNumber(value2, type3);
      throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value2);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length2}`,
      value2
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset2, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset2 >= dst.length || i2 >= src2.length) break;
      dst[i2 + offset2] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type3) {
    return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$6 = BigInt(1), _2n$4 = BigInt(2), _8n$2 = BigInt(8);
const VERIFY_DEFAULT = { zip215: true };
function validateOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts$1(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n$4 << BigInt(nByteLength * 8) - _1n$6;
  const modP = Fp2.create;
  const Fn = Field$1(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u2, v2) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u2 * Fp2.inv(v2)) };
    } catch (e2) {
      return { isValid: false, value: _0n$4 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data2, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data2;
  });
  function aCoordinate(title, n3) {
    aInRange("coordinate " + title, n3, _0n$4, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { ex: x2, ey: y2, ez: z2 } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n$2 : Fp2.inv(z2);
    const ax = modP(x2 * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z2 * iz);
    if (is0)
      return { x: _0n$4, y: _1n$6 };
    if (zz !== _1n$6)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p2) => {
    const { a: a2, d: d2 } = CURVE;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { ex: X2, ey: Y3, ez: Z3, et: T2 } = p2;
    const X22 = modP(X2 * X2);
    const Y22 = modP(Y3 * Y3);
    const Z22 = modP(Z3 * Z3);
    const Z4 = modP(Z22 * Z22);
    const aX2 = modP(X22 * a2);
    const left = modP(Z22 * modP(aX2 + Y22));
    const right = modP(Z4 + modP(d2 * modP(X22 * Y22)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X2 * Y3);
    const ZT = modP(Z3 * T2);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et3) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et3;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et3);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point)
        throw new Error("extended point not allowed");
      const { x: x2, y: y2 } = p2 || {};
      aCoordinate("x", x2);
      aCoordinate("y", y2);
      return new Point(x2, y2, _1n$6, modP(x2 * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.ez));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y22, ez: Z22 } = other;
      const X1Z2 = modP(X1 * Z22);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z22);
      const Y2Z1 = modP(Y22 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A2 = modP(X1 * X1);
      const B3 = modP(Y1 * Y1);
      const C2 = modP(_2n$4 * modP(Z1 * Z1));
      const D2 = modP(a2 * A2);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A2 - B3);
      const G4 = D2 + B3;
      const F3 = G4 - C2;
      const H2 = D2 - B3;
      const X3 = modP(E2 * F3);
      const Y3 = modP(G4 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F3 * G4);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a: a2, d: d2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y22, ez: Z22, et: T2 } = other;
      if (a2 === BigInt(-1)) {
        const A3 = modP((Y1 - X1) * (Y22 + X2));
        const B4 = modP((Y1 + X1) * (Y22 - X2));
        const F4 = modP(B4 - A3);
        if (F4 === _0n$4)
          return this.double();
        const C3 = modP(Z1 * _2n$4 * T2);
        const D3 = modP(T1 * _2n$4 * Z22);
        const E3 = D3 + C3;
        const G5 = B4 + A3;
        const H3 = D3 - C3;
        const X32 = modP(E3 * F4);
        const Y32 = modP(G5 * H3);
        const T32 = modP(E3 * H3);
        const Z32 = modP(F4 * G5);
        return new Point(X32, Y32, Z32, T32);
      }
      const A2 = modP(X1 * X2);
      const B3 = modP(Y1 * Y22);
      const C2 = modP(T1 * d2 * T2);
      const D2 = modP(Z1 * Z22);
      const E2 = modP((X1 + Y1) * (X2 + Y22) - A2 - B3);
      const F3 = D2 - C2;
      const G4 = D2 + C2;
      const H2 = modP(B3 - a2 * A2);
      const X3 = modP(E2 * F3);
      const Y3 = modP(G4 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F3 * G4);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, n3, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n3 = scalar;
      aInRange("scalar", n3, _1n$6, CURVE_ORDER);
      const { p: p2, f: f2 } = this.wNAF(n3);
      return Point.normalizeZ([p2, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      const n3 = scalar;
      aInRange("scalar", n3, _0n$4, CURVE_ORDER);
      if (n3 === _0n$4)
        return I2;
      if (this.equals(I2) || n3 === _1n$6)
        return this;
      if (this.equals(G3))
        return this.wNAF(n3).p;
      return wnaf.unsafeLadder(this, n3);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n$6)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a: a2 } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes$1("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE$1(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y2, _0n$4, max);
      const y22 = modP(y2 * y2);
      const u2 = modP(y22 - _1n$6);
      const v2 = modP(d2 * y22 - a2);
      let { isValid: isValid3, value: x2 } = uvRatio2(u2, v2);
      if (!isValid3)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n$6) === _1n$6;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n$4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point.fromAffine({ x: x2, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x2, y: y2 } = this.toAffine();
      const bytes2 = numberToBytesLE$1(y2, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n$6 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex$1(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$6, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n$4, _1n$6, _1n$6, _0n$4);
  const { BASE: G3, ZERO: I2 } = Point;
  const wnaf = wNAF$1(Point, nByteLength * 8);
  function modN(a2) {
    return mod$1(a2, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE$1(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes$1("private key", key, len);
    const hashed = ensureBytes$1("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix2 = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G3.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix: prefix2, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes$2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes$1("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes$1("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix: prefix2, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix2, msg);
    const R2 = G3.multiply(r2).toRawBytes();
    const k2 = hashDomainToScalar(options.context, R2, pointBytes, msg);
    const s2 = modN(r2 + k2 * scalar);
    aInRange("signature.s", s2, _0n$4, CURVE_ORDER);
    const res = concatBytes$2(R2, numberToBytesLE$1(s2, Fp2.BYTES));
    return ensureBytes$1("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey2, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes$1("signature", sig, 2 * len);
    msg = ensureBytes$1("message", msg);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE$1(sig.slice(len, 2 * len));
    let A2, R2, SB;
    try {
      A2 = Point.fromHex(publicKey2, zip215);
      R2 = Point.fromHex(sig.slice(0, len), zip215);
      SB = G3.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A2.isSmallOrder())
      return false;
    const k2 = hashDomainToScalar(context, R2.toRawBytes(), A2.toRawBytes(), msg);
    const RkA = R2.add(A2.multiplyUnsafe(k2));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G3._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes3(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$5 = BigInt(1), _2n$3 = BigInt(2);
BigInt(3);
const _5n$1 = BigInt(5), _8n$1 = BigInt(8);
function ed25519_pow_2_252_3(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ED25519_P;
  const x22 = x2 * x2 % P2;
  const b2 = x22 * x2 % P2;
  const b4 = pow2$1(b2, _2n$3, P2) * b2 % P2;
  const b5 = pow2$1(b4, _1n$5, P2) * x2 % P2;
  const b10 = pow2$1(b5, _5n$1, P2) * b5 % P2;
  const b20 = pow2$1(b10, _10n, P2) * b10 % P2;
  const b40 = pow2$1(b20, _20n, P2) * b20 % P2;
  const b80 = pow2$1(b40, _40n, P2) * b40 % P2;
  const b160 = pow2$1(b80, _80n, P2) * b80 % P2;
  const b240 = pow2$1(b160, _80n, P2) * b80 % P2;
  const b250 = pow2$1(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2$1(b250, _2n$3, P2) * x2 % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u2, v2) {
  const P2 = ED25519_P;
  const v32 = mod$1(v2 * v2 * v2, P2);
  const v7 = mod$1(v32 * v32 * v2, P2);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x2 = mod$1(u2 * v32 * pow3, P2);
  const vx2 = mod$1(v2 * x2 * x2, P2);
  const root1 = x2;
  const root2 = mod$1(x2 * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod$1(-u2, P2);
  const noRoot = vx2 === mod$1(-u2 * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P2))
    x2 = mod$1(-x2, P2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
const Fp$1 = /* @__PURE__ */ (() => Field$1(ED25519_P, void 0, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp$1,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes: randomBytes$2,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer$1 = buffer;
  var Buffer2 = buffer$1.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer$1;
  } else {
    copyProps(buffer$1, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding2) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$1.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var _Buffer = safeBufferExports.Buffer;
function base$1(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError("Expected Buffer");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (psz < source.length) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0, 0, zeroes);
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode3
  };
}
var src$1 = base$1;
var basex$1 = src$1;
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex$1(ALPHABET$1);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs(bs58);
var lib = {};
function inRange(a2, min, max) {
  return min <= a2 && a2 <= max;
}
function ToDictionary(o2) {
  if (o2 === void 0) return {};
  if (o2 === Object(o2)) return o2;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string2) {
  var s2 = String(string2);
  var n3 = s2.length;
  var i2 = 0;
  var u2 = [];
  while (i2 < n3) {
    var c2 = s2.charCodeAt(i2);
    if (c2 < 55296 || c2 > 57343) {
      u2.push(c2);
    } else if (56320 <= c2 && c2 <= 57343) {
      u2.push(65533);
    } else if (55296 <= c2 && c2 <= 56319) {
      if (i2 === n3 - 1) {
        u2.push(65533);
      } else {
        var d2 = string2.charCodeAt(i2 + 1);
        if (56320 <= d2 && d2 <= 57343) {
          var a2 = c2 & 1023;
          var b2 = d2 & 1023;
          u2.push(65536 + (a2 << 10) + b2);
          i2 += 1;
        } else {
          u2.push(65533);
        }
      }
    }
    i2 += 1;
  }
  return u2;
}
function codePointsToString(code_points) {
  var s2 = "";
  for (var i2 = 0; i2 < code_points.length; ++i2) {
    var cp = code_points[i2];
    if (cp <= 65535) {
      s2 += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s2 += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s2;
}
var end_of_stream = -1;
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    if (!this.tokens.length)
      return end_of_stream;
    return this.tokens.shift();
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token2) {
    if (Array.isArray(token2)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token2
      );
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token2);
    }
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token2) {
    if (Array.isArray(token2)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token2
      );
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token2);
    }
  }
};
var finished = -1;
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(encoding2, options) {
  if (!(this instanceof TextDecoder$1)) {
    return new TextDecoder$1(encoding2, options);
  }
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode2(input, options) {
    var bytes2;
    if (typeof input === "object" && input instanceof ArrayBuffer) {
      bytes2 = new Uint8Array(input);
    } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
      bytes2 = new Uint8Array(
        input.buffer,
        input.byteOffset,
        input.byteLength
      );
    } else {
      bytes2 = new Uint8Array(0);
    }
    options = ToDictionary(options);
    if (!this._streaming) {
      this._decoder = new UTF8Decoder({ fatal: this._fatal });
      this._BOMseen = false;
    }
    this._streaming = Boolean(options["stream"]);
    var input_stream = new Stream(bytes2);
    var code_points = [];
    var result;
    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(
          code_points,
          /**@type {!Array.<number>}*/
          result
        );
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(
            code_points,
            /**@type {!Array.<number>}*/
            result
          );
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }
    if (code_points.length) {
      if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
        if (code_points[0] === 65279) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          this._BOMseen = true;
        }
      }
    }
    return codePointsToString(code_points);
  }
};
function TextEncoder$1(encoding2, options) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(encoding2, options);
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode2(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options["stream"]);
    var bytes2 = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes2.push.apply(
          bytes2,
          /**@type {!Array.<number>}*/
          result
        );
      else
        bytes2.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes2.push.apply(
            bytes2,
            /**@type {!Array.<number>}*/
            result
          );
        else
          bytes2.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes2);
  }
};
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count2, offset2;
    if (inRange(code_point, 128, 2047)) {
      count2 = 1;
      offset2 = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count2 = 2;
      offset2 = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count2 = 3;
      offset2 = 240;
    }
    var bytes2 = [(code_point >> 6 * count2) + offset2];
    while (count2 > 0) {
      var temp = code_point >> 6 * (count2 - 1);
      bytes2.push(128 | temp & 63);
      count2 -= 1;
    }
    return bytes2;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __decorate$2D = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2) if (k2 !== "default" && Object.hasOwnProperty.call(mod2, k2)) __createBinding$1(result, mod2, k2);
  }
  __setModuleDefault(result, mod2);
  return result;
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(lib, "__esModule", { value: true });
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault$1(bnExports);
const bs58_1 = __importDefault$1(bs58);
const encoding = __importStar$1(require$$2);
const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
function baseEncode(value2) {
  if (typeof value2 === "string") {
    value2 = Buffer.from(value2, "utf8");
  }
  return bs58_1.default.encode(Buffer.from(value2));
}
lib.baseEncode = baseEncode;
function baseDecode(value2) {
  return Buffer.from(bs58_1.default.decode(value2));
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(message) {
    super(message);
    this.fieldPath = [];
    this.originalMessage = message;
  }
  addToFieldPath(fieldName) {
    this.fieldPath.splice(0, 0, fieldName);
    this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer.alloc(INITIAL_LENGTH);
    this.length = 0;
  }
  maybeResize() {
    if (this.buf.length < 16 + this.length) {
      this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
    }
  }
  writeU8(value2) {
    this.maybeResize();
    this.buf.writeUInt8(value2, this.length);
    this.length += 1;
  }
  writeU16(value2) {
    this.maybeResize();
    this.buf.writeUInt16LE(value2, this.length);
    this.length += 2;
  }
  writeU32(value2) {
    this.maybeResize();
    this.buf.writeUInt32LE(value2, this.length);
    this.length += 4;
  }
  writeU64(value2) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 8)));
  }
  writeU128(value2) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 16)));
  }
  writeU256(value2) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 32)));
  }
  writeU512(value2) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 64)));
  }
  writeBuffer(buffer2) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      buffer2,
      Buffer.alloc(INITIAL_LENGTH)
    ]);
    this.length += buffer2.length;
  }
  writeString(str) {
    this.maybeResize();
    const b2 = Buffer.from(str, "utf8");
    this.writeU32(b2.length);
    this.writeBuffer(b2);
  }
  writeFixedArray(array2) {
    this.writeBuffer(Buffer.from(array2));
  }
  writeArray(array2, fn2) {
    this.maybeResize();
    this.writeU32(array2.length);
    for (const elem of array2) {
      this.maybeResize();
      fn2(elem);
    }
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib.BinaryWriter = BinaryWriter;
function handlingRangeError(target, propertyKey, propertyDescriptor) {
  const originalMethod = propertyDescriptor.value;
  propertyDescriptor.value = function(...args) {
    try {
      return originalMethod.apply(this, args);
    } catch (e2) {
      if (e2 instanceof RangeError) {
        const code2 = e2.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
          throw new BorshError("Reached the end of buffer when deserializing");
        }
      }
      throw e2;
    }
  };
}
class BinaryReader {
  constructor(buf) {
    this.buf = buf;
    this.offset = 0;
  }
  readU8() {
    const value2 = this.buf.readUInt8(this.offset);
    this.offset += 1;
    return value2;
  }
  readU16() {
    const value2 = this.buf.readUInt16LE(this.offset);
    this.offset += 2;
    return value2;
  }
  readU32() {
    const value2 = this.buf.readUInt32LE(this.offset);
    this.offset += 4;
    return value2;
  }
  readU64() {
    const buf = this.readBuffer(8);
    return new bn_js_1.default(buf, "le");
  }
  readU128() {
    const buf = this.readBuffer(16);
    return new bn_js_1.default(buf, "le");
  }
  readU256() {
    const buf = this.readBuffer(32);
    return new bn_js_1.default(buf, "le");
  }
  readU512() {
    const buf = this.readBuffer(64);
    return new bn_js_1.default(buf, "le");
  }
  readBuffer(len) {
    if (this.offset + len > this.buf.length) {
      throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
    }
    const result = this.buf.slice(this.offset, this.offset + len);
    this.offset += len;
    return result;
  }
  readString() {
    const len = this.readU32();
    const buf = this.readBuffer(len);
    try {
      return textDecoder.decode(buf);
    } catch (e2) {
      throw new BorshError(`Error decoding UTF-8 string: ${e2}`);
    }
  }
  readFixedArray(len) {
    return new Uint8Array(this.readBuffer(len));
  }
  readArray(fn2) {
    const len = this.readU32();
    const result = Array();
    for (let i2 = 0; i2 < len; ++i2) {
      result.push(fn2());
    }
    return result;
  }
}
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate$2D([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;
function capitalizeFirstLetter(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function serializeField(schema, fieldName, value2, fieldType, writer) {
  try {
    if (typeof fieldType === "string") {
      writer[`write${capitalizeFirstLetter(fieldType)}`](value2);
    } else if (fieldType instanceof Array) {
      if (typeof fieldType[0] === "number") {
        if (value2.length !== fieldType[0]) {
          throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value2.length} bytes`);
        }
        writer.writeFixedArray(value2);
      } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
        if (value2.length !== fieldType[1]) {
          throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value2.length} bytes`);
        }
        for (let i2 = 0; i2 < fieldType[1]; i2++) {
          serializeField(schema, null, value2[i2], fieldType[0], writer);
        }
      } else {
        writer.writeArray(value2, (item) => {
          serializeField(schema, fieldName, item, fieldType[0], writer);
        });
      }
    } else if (fieldType.kind !== void 0) {
      switch (fieldType.kind) {
        case "option": {
          if (value2 === null || value2 === void 0) {
            writer.writeU8(0);
          } else {
            writer.writeU8(1);
            serializeField(schema, fieldName, value2, fieldType.type, writer);
          }
          break;
        }
        case "map": {
          writer.writeU32(value2.size);
          value2.forEach((val, key) => {
            serializeField(schema, fieldName, key, fieldType.key, writer);
            serializeField(schema, fieldName, val, fieldType.value, writer);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${fieldType} unrecognized`);
      }
    } else {
      serializeStruct(schema, value2, writer);
    }
  } catch (error) {
    if (error instanceof BorshError) {
      error.addToFieldPath(fieldName);
    }
    throw error;
  }
}
function serializeStruct(schema, obj, writer) {
  if (typeof obj.borshSerialize === "function") {
    obj.borshSerialize(writer);
    return;
  }
  const structSchema = schema.get(obj.constructor);
  if (!structSchema) {
    throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
  }
  if (structSchema.kind === "struct") {
    structSchema.fields.map(([fieldName, fieldType]) => {
      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
    });
  } else if (structSchema.kind === "enum") {
    const name = obj[structSchema.field];
    for (let idx = 0; idx < structSchema.values.length; ++idx) {
      const [fieldName, fieldType] = structSchema.values[idx];
      if (fieldName === name) {
        writer.writeU8(idx);
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        break;
      }
    }
  } else {
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
  }
}
function serialize(schema, obj, Writer = BinaryWriter) {
  const writer = new Writer();
  serializeStruct(schema, obj, writer);
  return writer.toArray();
}
var serialize_1 = lib.serialize = serialize;
function deserializeField(schema, fieldName, fieldType, reader) {
  try {
    if (typeof fieldType === "string") {
      return reader[`read${capitalizeFirstLetter(fieldType)}`]();
    }
    if (fieldType instanceof Array) {
      if (typeof fieldType[0] === "number") {
        return reader.readFixedArray(fieldType[0]);
      } else if (typeof fieldType[1] === "number") {
        const arr = [];
        for (let i2 = 0; i2 < fieldType[1]; i2++) {
          arr.push(deserializeField(schema, null, fieldType[0], reader));
        }
        return arr;
      } else {
        return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
      }
    }
    if (fieldType.kind === "option") {
      const option = reader.readU8();
      if (option) {
        return deserializeField(schema, fieldName, fieldType.type, reader);
      }
      return void 0;
    }
    if (fieldType.kind === "map") {
      let map2 = /* @__PURE__ */ new Map();
      const length2 = reader.readU32();
      for (let i2 = 0; i2 < length2; i2++) {
        const key = deserializeField(schema, fieldName, fieldType.key, reader);
        const val = deserializeField(schema, fieldName, fieldType.value, reader);
        map2.set(key, val);
      }
      return map2;
    }
    return deserializeStruct(schema, fieldType, reader);
  } catch (error) {
    if (error instanceof BorshError) {
      error.addToFieldPath(fieldName);
    }
    throw error;
  }
}
function deserializeStruct(schema, classType, reader) {
  if (typeof classType.borshDeserialize === "function") {
    return classType.borshDeserialize(reader);
  }
  const structSchema = schema.get(classType);
  if (!structSchema) {
    throw new BorshError(`Class ${classType.name} is missing in schema`);
  }
  if (structSchema.kind === "struct") {
    const result = {};
    for (const [fieldName, fieldType] of schema.get(classType).fields) {
      result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
    }
    return new classType(result);
  }
  if (structSchema.kind === "enum") {
    const idx = reader.readU8();
    if (idx >= structSchema.values.length) {
      throw new BorshError(`Enum index: ${idx} is out of range`);
    }
    const [fieldName, fieldType] = structSchema.values[idx];
    const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
    return new classType({ [fieldName]: fieldValue });
  }
  throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
}
function deserialize(schema, classType, buffer2, Reader = BinaryReader) {
  const reader = new Reader(buffer2);
  const result = deserializeStruct(schema, classType, reader);
  if (reader.offset < buffer2.length) {
    throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
  }
  return result;
}
var deserialize_1 = lib.deserialize = deserialize;
function deserializeUnchecked(schema, classType, buffer2, Reader = BinaryReader) {
  const reader = new Reader(buffer2);
  return deserializeStruct(schema, classType, reader);
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: true });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = buffer;
function checkUint8Array(b2) {
  if (!(b2 instanceof Uint8Array)) {
    throw new TypeError("b must be a Uint8Array");
  }
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(b2) {
  checkUint8Array(b2);
  return buffer_1.Buffer.from(b2.buffer, b2.byteOffset, b2.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(span, property) {
    if (!Number.isInteger(span)) {
      throw new TypeError("span must be an integer");
    }
    this.span = span;
    this.property = property;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(b2, offset2) {
    if (0 > this.span) {
      throw new RangeError("indeterminate span");
    }
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(property) {
    const rv = Object.create(this.constructor.prototype);
    Object.assign(rv, this);
    rv.property = property;
    return rv;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(values2) {
    return void 0;
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(Class, layout) {
  if ("function" !== typeof Class) {
    throw new TypeError("Class must be constructor");
  }
  if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
    throw new Error("Class is already bound to a layout");
  }
  if (!(layout && layout instanceof Layout)) {
    throw new TypeError("layout must be a Layout");
  }
  if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
    throw new Error("layout is already bound to a constructor");
  }
  Class.layout_ = layout;
  layout.boundConstructor_ = Class;
  layout.makeDestinationObject = () => new Class();
  Object.defineProperty(Class.prototype, "encode", {
    value(b2, offset2) {
      return layout.encode(this, b2, offset2);
    },
    writable: true
  });
  Object.defineProperty(Class, "decode", {
    value(b2, offset2) {
      return layout.decode(b2, offset2);
    },
    writable: true
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(elementSpan = 1, property) {
    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
      throw new TypeError("elementSpan must be a (positive) integer");
    }
    super(-1, property);
    this.elementSpan = elementSpan;
  }
  /** @override */
  isCount() {
    return true;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    checkUint8Array(b2);
    const rem = b2.length - offset2;
    return Math.floor(rem / this.elementSpan);
  }
  /** @override */
  encode(src2, b2, offset2) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(layout, offset2 = 0, property) {
    if (!(layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (!Number.isInteger(offset2)) {
      throw new TypeError("offset must be integer or undefined");
    }
    super(layout.span, property || layout.property);
    this.layout = layout;
    this.offset = offset2;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return this.layout.decode(b2, offset2 + this.offset);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    return this.layout.encode(src2, b2, offset2 + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readUIntLE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeUIntLE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readUIntBE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeUIntBE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readIntLE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeIntLE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readIntBE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeIntBE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(src2) {
  const hi32 = Math.floor(src2 / V2E32);
  const lo32 = src2 - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}
class NearUInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const lo32 = buffer2.readUInt32LE(offset2);
    const hi32 = buffer2.readUInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32LE(split2.lo32, offset2);
    buffer2.writeUInt32LE(split2.hi32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const hi32 = buffer2.readUInt32BE(offset2);
    const lo32 = buffer2.readUInt32BE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32BE(split2.hi32, offset2);
    buffer2.writeUInt32BE(split2.lo32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const lo32 = buffer2.readUInt32LE(offset2);
    const hi32 = buffer2.readInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32LE(split2.lo32, offset2);
    buffer2.writeInt32LE(split2.hi32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const hi32 = buffer2.readInt32BE(offset2);
    const lo32 = buffer2.readUInt32BE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeInt32BE(split2.hi32, offset2);
    buffer2.writeUInt32BE(split2.lo32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(property) {
    super(4, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readFloatLE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeFloatLE(src2, offset2);
    return 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(property) {
    super(4, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readFloatBE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeFloatBE(src2, offset2);
    return 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readDoubleLE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeDoubleLE(src2, offset2);
    return 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readDoubleBE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeDoubleBE(src2, offset2);
    return 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(elementLayout, count2, property) {
    if (!(elementLayout instanceof Layout)) {
      throw new TypeError("elementLayout must be a Layout");
    }
    if (!(count2 instanceof ExternalLayout && count2.isCount() || Number.isInteger(count2) && 0 <= count2)) {
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(count2 instanceof ExternalLayout) && 0 < elementLayout.span) {
      span = count2 * elementLayout.span;
    }
    super(span, property);
    this.elementLayout = elementLayout;
    this.count = count2;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let span = 0;
    let count2 = this.count;
    if (count2 instanceof ExternalLayout) {
      count2 = count2.decode(b2, offset2);
    }
    if (0 < this.elementLayout.span) {
      span = count2 * this.elementLayout.span;
    } else {
      let idx = 0;
      while (idx < count2) {
        span += this.elementLayout.getSpan(b2, offset2 + span);
        ++idx;
      }
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const rv = [];
    let i2 = 0;
    let count2 = this.count;
    if (count2 instanceof ExternalLayout) {
      count2 = count2.decode(b2, offset2);
    }
    while (i2 < count2) {
      rv.push(this.elementLayout.decode(b2, offset2));
      offset2 += this.elementLayout.getSpan(b2, offset2);
      i2 += 1;
    }
    return rv;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src2, b2, offset2 = 0) {
    const elo = this.elementLayout;
    const span = src2.reduce((span2, v2) => {
      return span2 + elo.encode(v2, b2, offset2 + span2);
    }, 0);
    if (this.count instanceof ExternalLayout) {
      this.count.encode(src2.length, b2, offset2);
    }
    return span;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(fields, property, decodePrefixes) {
    if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout, true))) {
      throw new TypeError("fields must be array of Layout instances");
    }
    if ("boolean" === typeof property && void 0 === decodePrefixes) {
      decodePrefixes = property;
      property = void 0;
    }
    for (const fd2 of fields) {
      if (0 > fd2.span && void 0 === fd2.property) {
        throw new Error("fields cannot contain unnamed variable-length layout");
      }
    }
    let span = -1;
    try {
      span = fields.reduce((span2, fd2) => span2 + fd2.getSpan(), 0);
    } catch (e2) {
    }
    super(span, property);
    this.fields = fields;
    this.decodePrefixes = !!decodePrefixes;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let span = 0;
    try {
      span = this.fields.reduce((span2, fd2) => {
        const fsp = fd2.getSpan(b2, offset2);
        offset2 += fsp;
        return span2 + fsp;
      }, 0);
    } catch (e2) {
      throw new RangeError("indeterminate span");
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    checkUint8Array(b2);
    const dest = this.makeDestinationObject();
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        dest[fd2.property] = fd2.decode(b2, offset2);
      }
      offset2 += fd2.getSpan(b2, offset2);
      if (this.decodePrefixes && b2.length === offset2) {
        break;
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(src2, b2, offset2 = 0) {
    const firstOffset = offset2;
    let lastOffset = 0;
    let lastWrote = 0;
    for (const fd2 of this.fields) {
      let span = fd2.span;
      lastWrote = 0 < span ? span : 0;
      if (void 0 !== fd2.property) {
        const fv = src2[fd2.property];
        if (void 0 !== fv) {
          lastWrote = fd2.encode(fv, b2, offset2);
          if (0 > span) {
            span = fd2.getSpan(b2, offset2);
          }
        }
      }
      lastOffset = offset2;
      offset2 += span;
    }
    return lastOffset + lastWrote - firstOffset;
  }
  /** @override */
  fromArray(values2) {
    const dest = this.makeDestinationObject();
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property && 0 < values2.length) {
        dest[fd2.property] = values2.shift();
      }
    }
    return dest;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return fd2;
      }
    }
    return void 0;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    let offset2 = 0;
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return offset2;
      }
      if (0 > fd2.span) {
        offset2 = -1;
      } else if (0 <= offset2) {
        offset2 += fd2.span;
      }
    }
    return void 0;
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(property) {
    this.property = property;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(b2, offset2) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(src2, b2, offset2) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(layout, property) {
    if (!(layout instanceof ExternalLayout && layout.isCount())) {
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    }
    super(property || layout.property || "variant");
    this.layout = layout;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(b2, offset2) {
    return this.layout.decode(b2, offset2);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(src2, b2, offset2) {
    return this.layout.encode(src2, b2, offset2);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(discr, defaultLayout, property) {
    let discriminator;
    if (discr instanceof UInt || discr instanceof UIntBE) {
      discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    } else if (discr instanceof ExternalLayout && discr.isCount()) {
      discriminator = new UnionLayoutDiscriminator(discr);
    } else if (!(discr instanceof UnionDiscriminator)) {
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    } else {
      discriminator = discr;
    }
    if (void 0 === defaultLayout) {
      defaultLayout = null;
    }
    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
      throw new TypeError("defaultLayout must be null or a Layout");
    }
    if (null !== defaultLayout) {
      if (0 > defaultLayout.span) {
        throw new Error("defaultLayout must have constant span");
      }
      if (void 0 === defaultLayout.property) {
        defaultLayout = defaultLayout.replicate("content");
      }
    }
    let span = -1;
    if (defaultLayout) {
      span = defaultLayout.span;
      if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
        span += discriminator.layout.span;
      }
    }
    super(span, property);
    this.discriminator = discriminator;
    this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
    this.defaultLayout = defaultLayout;
    this.registry = {};
    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(src2) {
      return boundGetSourceVariant(src2);
    };
    this.configGetSourceVariant = function(gsv) {
      boundGetSourceVariant = gsv.bind(this);
    };
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    const vlo = this.getVariant(b2, offset2);
    if (!vlo) {
      throw new Error("unable to determine span for unrecognized variant");
    }
    return vlo.getSpan(b2, offset2);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(src2) {
    if (Object.prototype.hasOwnProperty.call(src2, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src2, this.defaultLayout.property)) {
        return void 0;
      }
      const vlo = this.registry[src2[this.discriminator.property]];
      if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property))) {
        return vlo;
      }
    } else {
      for (const tag in this.registry) {
        const vlo = this.registry[tag];
        if (vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property)) {
          return vlo;
        }
      }
    }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(b2, offset2 = 0) {
    let dest;
    const dlo = this.discriminator;
    const discr = dlo.decode(b2, offset2);
    const clo = this.registry[discr];
    if (void 0 === clo) {
      const defaultLayout = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dest = this.makeDestinationObject();
      dest[dlo.property] = discr;
      dest[defaultLayout.property] = defaultLayout.decode(b2, offset2 + contentOffset);
    } else {
      dest = clo.decode(b2, offset2);
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(src2, b2, offset2 = 0) {
    const vlo = this.getSourceVariant(src2);
    if (void 0 === vlo) {
      const dlo = this.discriminator;
      const clo = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dlo.encode(src2[dlo.property], b2, offset2);
      return contentOffset + clo.encode(src2[clo.property], b2, offset2 + contentOffset);
    }
    return vlo.encode(src2, b2, offset2);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(variant, layout, property) {
    const rv = new VariantLayout(this, variant, layout, property);
    this.registry[variant] = rv;
    return rv;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(vb2, offset2 = 0) {
    let variant;
    if (vb2 instanceof Uint8Array) {
      variant = this.discriminator.decode(vb2, offset2);
    } else {
      variant = vb2;
    }
    return this.registry[variant];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(union2, variant, layout, property) {
    if (!(union2 instanceof Union)) {
      throw new TypeError("union must be a Union");
    }
    if (!Number.isInteger(variant) || 0 > variant) {
      throw new TypeError("variant must be a (non-negative) integer");
    }
    if ("string" === typeof layout && void 0 === property) {
      property = layout;
      layout = null;
    }
    if (layout) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
        throw new Error("variant span exceeds span of containing union");
      }
      if ("string" !== typeof property) {
        throw new TypeError("variant must have a String property");
      }
    }
    let span = union2.span;
    if (0 > union2.span) {
      span = layout ? layout.span : 0;
      if (0 <= span && union2.usesPrefixDiscriminator) {
        span += union2.discriminator.layout.span;
      }
    }
    super(span, property);
    this.union = union2;
    this.variant = variant;
    this.layout = layout || null;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    let span = 0;
    if (this.layout) {
      span = this.layout.getSpan(b2, offset2 + contentOffset);
    }
    return contentOffset + span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const dest = this.makeDestinationObject();
    if (this !== this.union.getVariant(b2, offset2)) {
      throw new Error("variant mismatch");
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout) {
      dest[this.property] = this.layout.decode(b2, offset2 + contentOffset);
    } else if (this.property) {
      dest[this.property] = true;
    } else if (this.union.usesPrefixDiscriminator) {
      dest[this.union.discriminator.property] = this.variant;
    }
    return dest;
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout && !Object.prototype.hasOwnProperty.call(src2, this.property)) {
      throw new TypeError("variant lacks property " + this.property);
    }
    this.union.discriminator.encode(this.variant, b2, offset2);
    let span = contentOffset;
    if (this.layout) {
      this.layout.encode(src2[this.property], b2, offset2 + contentOffset);
      span += this.layout.getSpan(b2, offset2 + contentOffset);
      if (0 <= this.union.span && span > this.union.span) {
        throw new Error("encoded variant overruns containing union");
      }
    }
    return span;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(values2) {
    if (this.layout) {
      return this.layout.fromArray(values2);
    }
    return void 0;
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(v2) {
  if (0 > v2) {
    v2 += 4294967296;
  }
  return v2;
}
class BitStructure extends Layout {
  constructor(word, msb, property) {
    if (!(word instanceof UInt || word instanceof UIntBE)) {
      throw new TypeError("word must be a UInt or UIntBE layout");
    }
    if ("string" === typeof msb && void 0 === property) {
      property = msb;
      msb = false;
    }
    if (4 < word.span) {
      throw new RangeError("word cannot exceed 32 bits");
    }
    super(word.span, property);
    this.word = word;
    this.msb = !!msb;
    this.fields = [];
    let value2 = 0;
    this._packedSetValue = function(v2) {
      value2 = fixBitwiseResult(v2);
      return this;
    };
    this._packedGetValue = function() {
      return value2;
    };
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const dest = this.makeDestinationObject();
    const value2 = this.word.decode(b2, offset2);
    this._packedSetValue(value2);
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        dest[fd2.property] = fd2.decode(b2);
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(src2, b2, offset2 = 0) {
    const value2 = this.word.decode(b2, offset2);
    this._packedSetValue(value2);
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        const fv = src2[fd2.property];
        if (void 0 !== fv) {
          fd2.encode(fv);
        }
      }
    }
    return this.word.encode(this._packedGetValue(), b2, offset2);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(bits, property) {
    const bf2 = new BitField(this, bits, property);
    this.fields.push(bf2);
    return bf2;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(property) {
    const bf2 = new Boolean$1(this, property);
    this.fields.push(bf2);
    return bf2;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return fd2;
      }
    }
    return void 0;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(container, bits, property) {
    if (!(container instanceof BitStructure)) {
      throw new TypeError("container must be a BitStructure");
    }
    if (!Number.isInteger(bits) || 0 >= bits) {
      throw new TypeError("bits must be positive integer");
    }
    const totalBits = 8 * container.span;
    const usedBits = container.fields.reduce((sum, fd2) => sum + fd2.bits, 0);
    if (bits + usedBits > totalBits) {
      throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
    }
    this.container = container;
    this.bits = bits;
    this.valueMask = (1 << bits) - 1;
    if (32 === bits) {
      this.valueMask = 4294967295;
    }
    this.start = usedBits;
    if (this.container.msb) {
      this.start = totalBits - usedBits - bits;
    }
    this.wordMask = fixBitwiseResult(this.valueMask << this.start);
    this.property = property;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(b2, offset2) {
    const word = this.container._packedGetValue();
    const wordValue = fixBitwiseResult(word & this.wordMask);
    const value2 = wordValue >>> this.start;
    return value2;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(value2) {
    if ("number" !== typeof value2 || !Number.isInteger(value2) || value2 !== fixBitwiseResult(value2 & this.valueMask)) {
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    }
    const word = this.container._packedGetValue();
    const wordValue = fixBitwiseResult(value2 << this.start);
    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
  }
}
Layout$1.BitField = BitField;
let Boolean$1 = class Boolean2 extends BitField {
  constructor(container, property) {
    super(container, 1, property);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(b2, offset2) {
    return !!super.decode(b2, offset2);
  }
  /** @override */
  encode(value2) {
    if ("boolean" === typeof value2) {
      value2 = +value2;
    }
    super.encode(value2);
  }
};
Layout$1.Boolean = Boolean$1;
let Blob$1 = class Blob2 extends Layout {
  constructor(length2, property) {
    if (!(length2 instanceof ExternalLayout && length2.isCount() || Number.isInteger(length2) && 0 <= length2)) {
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(length2 instanceof ExternalLayout)) {
      span = length2;
    }
    super(span, property);
    this.length = length2;
  }
  /** @override */
  getSpan(b2, offset2) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b2, offset2);
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b2, offset2);
    }
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src2, b2, offset2) {
    let span = this.length;
    if (this.length instanceof ExternalLayout) {
      span = src2.length;
    }
    if (!(src2 instanceof Uint8Array && span === src2.length)) {
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
    }
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Uint8Array");
    }
    const srcBuffer = uint8ArrayToBuffer(src2);
    uint8ArrayToBuffer(b2).write(srcBuffer.toString("hex"), offset2, span, "hex");
    if (this.length instanceof ExternalLayout) {
      this.length.encode(span, b2, offset2);
    }
    return span;
  }
};
Layout$1.Blob = Blob$1;
class CString extends Layout {
  constructor(property) {
    super(-1, property);
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    checkUint8Array(b2);
    let idx = offset2;
    while (idx < b2.length && 0 !== b2[idx]) {
      idx += 1;
    }
    return 1 + idx - offset2;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const span = this.getSpan(b2, offset2);
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span - 1).toString("utf-8");
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    if ("string" !== typeof src2) {
      src2 = String(src2);
    }
    const srcb = buffer_1.Buffer.from(src2, "utf8");
    const span = srcb.length;
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    const buffer2 = uint8ArrayToBuffer(b2);
    srcb.copy(buffer2, offset2);
    buffer2[offset2 + span] = 0;
    return span + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(maxSpan, property) {
    if ("string" === typeof maxSpan && void 0 === property) {
      property = maxSpan;
      maxSpan = void 0;
    }
    if (void 0 === maxSpan) {
      maxSpan = -1;
    } else if (!Number.isInteger(maxSpan)) {
      throw new TypeError("maxSpan must be an integer");
    }
    super(-1, property);
    this.maxSpan = maxSpan;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    checkUint8Array(b2);
    return b2.length - offset2;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const span = this.getSpan(b2, offset2);
    if (0 <= this.maxSpan && this.maxSpan < span) {
      throw new RangeError("text length exceeds maxSpan");
    }
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span).toString("utf-8");
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    if ("string" !== typeof src2) {
      src2 = String(src2);
    }
    const srcb = buffer_1.Buffer.from(src2, "utf8");
    const span = srcb.length;
    if (0 <= this.maxSpan && this.maxSpan < span) {
      throw new RangeError("text length exceeds maxSpan");
    }
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    srcb.copy(uint8ArrayToBuffer(b2), offset2);
    return span;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(value2, property) {
    super(0, property);
    this.value = value2;
  }
  /** @override */
  decode(b2, offset2) {
    return this.value;
  }
  /** @override */
  encode(src2, b2, offset2) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
var offset = Layout$1.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
var u8 = Layout$1.u8 = (property) => new UInt(1, property);
var u16 = Layout$1.u16 = (property) => new UInt(2, property);
Layout$1.u24 = (property) => new UInt(3, property);
var u32 = Layout$1.u32 = (property) => new UInt(4, property);
Layout$1.u40 = (property) => new UInt(5, property);
Layout$1.u48 = (property) => new UInt(6, property);
var nu64 = Layout$1.nu64 = (property) => new NearUInt64(property);
Layout$1.u16be = (property) => new UIntBE(2, property);
Layout$1.u24be = (property) => new UIntBE(3, property);
Layout$1.u32be = (property) => new UIntBE(4, property);
Layout$1.u40be = (property) => new UIntBE(5, property);
Layout$1.u48be = (property) => new UIntBE(6, property);
Layout$1.nu64be = (property) => new NearUInt64BE(property);
Layout$1.s8 = (property) => new Int(1, property);
Layout$1.s16 = (property) => new Int(2, property);
Layout$1.s24 = (property) => new Int(3, property);
Layout$1.s32 = (property) => new Int(4, property);
Layout$1.s40 = (property) => new Int(5, property);
Layout$1.s48 = (property) => new Int(6, property);
var ns64 = Layout$1.ns64 = (property) => new NearInt64(property);
Layout$1.s16be = (property) => new IntBE(2, property);
Layout$1.s24be = (property) => new IntBE(3, property);
Layout$1.s32be = (property) => new IntBE(4, property);
Layout$1.s40be = (property) => new IntBE(5, property);
Layout$1.s48be = (property) => new IntBE(6, property);
Layout$1.ns64be = (property) => new NearInt64BE(property);
Layout$1.f32 = (property) => new Float(property);
Layout$1.f32be = (property) => new FloatBE(property);
Layout$1.f64 = (property) => new Double(property);
Layout$1.f64be = (property) => new DoubleBE(property);
var struct = Layout$1.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
Layout$1.bits = (word, msb, property) => new BitStructure(word, msb, property);
var seq = Layout$1.seq = (elementLayout, count2, property) => new Sequence(elementLayout, count2, property);
Layout$1.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
Layout$1.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
var blob = Layout$1.blob = (length2, property) => new Blob$1(length2, property);
Layout$1.cstr = (property) => new CString(property);
Layout$1.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
Layout$1.constant = (value2, property) => new Constant(value2, property);
var browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: true });
function toBigIntLE(buf) {
  {
    const reversed = Buffer.from(buf);
    reversed.reverse();
    const hex = reversed.toString("hex");
    if (hex.length === 0) {
      return BigInt(0);
    }
    return BigInt(`0x${hex}`);
  }
}
var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
function toBigIntBE(buf) {
  {
    const hex = buf.toString("hex");
    if (hex.length === 0) {
      return BigInt(0);
    }
    return BigInt(`0x${hex}`);
  }
}
browser$1.toBigIntBE = toBigIntBE;
function toBufferLE(num, width2) {
  {
    const hex = num.toString(16);
    const buffer2 = Buffer.from(hex.padStart(width2 * 2, "0").slice(0, width2 * 2), "hex");
    buffer2.reverse();
    return buffer2;
  }
}
var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
function toBufferBE(num, width2) {
  {
    const hex = num.toString(16);
    return Buffer.from(hex.padStart(width2 * 2, "0").slice(0, width2 * 2), "hex");
  }
}
browser$1.toBufferBE = toBufferBE;
let StructError$1 = class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
};
function isIterable$1(x2) {
  return isObject$2(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject$2(x2) {
  return typeof x2 === "object" && x2 != null;
}
function print$1(value2) {
  if (typeof value2 === "symbol") {
    return value2.toString();
  }
  return typeof value2 === "string" ? JSON.stringify(value2) : `${value2}`;
}
function shiftIterator$1(input) {
  const { done, value: value2 } = input.next();
  return done ? void 0 : value2;
}
function toFailure$1(result, context, struct2, value2) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type3 } = struct2;
  const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print$1(value2)}\`` } = result;
  return {
    value: value2,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures$1(result, context, struct2, value2) {
  if (!isIterable$1(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure$1(r2, context, struct2, value2);
    if (failure) {
      yield failure;
    }
  }
}
function* run$1(value2, struct2, options = {}) {
  const { path = [], branch = [value2], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch };
  if (coerce2) {
    value2 = struct2.coercer(value2, ctx);
    if (mask2 && struct2.type !== "type" && isObject$2(struct2.schema) && isObject$2(value2) && !Array.isArray(value2)) {
      for (const key in value2) {
        if (struct2.schema[key] === void 0) {
          delete value2[key];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct2.validator(value2, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k2, v2, s2] of struct2.entries(value2, ctx)) {
    const ts = run$1(v2, s2, {
      path: k2 === void 0 ? path : [...path, k2],
      branch: k2 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t2 of ts) {
      if (t2[0]) {
        status = t2[0].refinement != null ? "not_refined" : "not_valid";
        yield [t2[0], void 0];
      } else if (coerce2) {
        v2 = t2[1];
        if (k2 === void 0) {
          value2 = v2;
        } else if (value2 instanceof Map) {
          value2.set(k2, v2);
        } else if (value2 instanceof Set) {
          value2.add(v2);
        } else if (isObject$2(value2)) {
          if (v2 !== void 0 || k2 in value2)
            value2[k2] = v2;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value2, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value2];
  }
}
let Struct$3 = class Struct {
  constructor(props) {
    const { type: type3, schema, validator, refiner, coercer = (value2) => value2, entries: entries2 = function* () {
    } } = props;
    this.type = type3;
    this.schema = schema;
    this.entries = entries2;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value2, context) => {
        const result = validator(value2, context);
        return toFailures$1(result, context, this, value2);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value2, context) => {
        const result = refiner(value2, context);
        return toFailures$1(result, context, this, value2);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value2, message) {
    return assert$7(value2, this, message);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value2, message) {
    return create$1(value2, this, message);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value2) {
    return is$1(value2, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value2, message) {
    return mask$1(value2, this, message);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value2, options = {}) {
    return validate$2(value2, this, options);
  }
};
function assert$7(value2, struct2, message) {
  const result = validate$2(value2, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create$1(value2, struct2, message) {
  const result = validate$2(value2, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask$1(value2, struct2, message) {
  const result = validate$2(value2, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is$1(value2, struct2) {
  const result = validate$2(value2, struct2);
  return !result[0];
}
function validate$2(value2, struct2, options = {}) {
  const tuples = run$1(value2, struct2, options);
  const tuple2 = shiftIterator$1(tuples);
  if (tuple2[0]) {
    const error = new StructError$1(tuple2[0], function* () {
      for (const t2 of tuples) {
        if (t2[0]) {
          yield t2[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function define$1(name, validator) {
  return new Struct$3({ type: name, schema: null, validator });
}
function any$1() {
  return define$1("any", () => true);
}
function array$1(Element) {
  return new Struct$3({
    type: "array",
    schema: Element,
    *entries(value2) {
      if (Element && Array.isArray(value2)) {
        for (const [i2, v2] of value2.entries()) {
          yield [i2, v2, Element];
        }
      }
    },
    coercer(value2) {
      return Array.isArray(value2) ? value2.slice() : value2;
    },
    validator(value2) {
      return Array.isArray(value2) || `Expected an array value, but received: ${print$1(value2)}`;
    }
  });
}
function boolean$1() {
  return define$1("boolean", (value2) => {
    return typeof value2 === "boolean";
  });
}
function instance$1(Class) {
  return define$1("instance", (value2) => {
    return value2 instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print$1(value2)}`;
  });
}
function literal$1(constant) {
  const description = print$1(constant);
  const t2 = typeof constant;
  return new Struct$3({
    type: "literal",
    schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
    validator(value2) {
      return value2 === constant || `Expected the literal \`${description}\`, but received: ${print$1(value2)}`;
    }
  });
}
function never$1() {
  return define$1("never", () => false);
}
function nullable$1(struct2) {
  return new Struct$3({
    ...struct2,
    validator: (value2, ctx) => value2 === null || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === null || struct2.refiner(value2, ctx)
  });
}
function number$2() {
  return define$1("number", (value2) => {
    return typeof value2 === "number" && !isNaN(value2) || `Expected a number, but received: ${print$1(value2)}`;
  });
}
function optional$1(struct2) {
  return new Struct$3({
    ...struct2,
    validator: (value2, ctx) => value2 === void 0 || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === void 0 || struct2.refiner(value2, ctx)
  });
}
function record$1(Key, Value) {
  return new Struct$3({
    type: "record",
    schema: null,
    *entries(value2) {
      if (isObject$2(value2)) {
        for (const k2 in value2) {
          const v2 = value2[k2];
          yield [k2, k2, Key];
          yield [k2, v2, Value];
        }
      }
    },
    validator(value2) {
      return isObject$2(value2) || `Expected an object, but received: ${print$1(value2)}`;
    }
  });
}
function string$1() {
  return define$1("string", (value2) => {
    return typeof value2 === "string" || `Expected a string, but received: ${print$1(value2)}`;
  });
}
function tuple$1(Structs) {
  const Never = never$1();
  return new Struct$3({
    type: "tuple",
    schema: null,
    *entries(value2) {
      if (Array.isArray(value2)) {
        const length2 = Math.max(Structs.length, value2.length);
        for (let i2 = 0; i2 < length2; i2++) {
          yield [i2, value2[i2], Structs[i2] || Never];
        }
      }
    },
    validator(value2) {
      return Array.isArray(value2) || `Expected an array, but received: ${print$1(value2)}`;
    }
  });
}
function type$1(schema) {
  const keys = Object.keys(schema);
  return new Struct$3({
    type: "type",
    schema,
    *entries(value2) {
      if (isObject$2(value2)) {
        for (const k2 of keys) {
          yield [k2, value2[k2], schema[k2]];
        }
      }
    },
    validator(value2) {
      return isObject$2(value2) || `Expected an object, but received: ${print$1(value2)}`;
    },
    coercer(value2) {
      return isObject$2(value2) ? { ...value2 } : value2;
    }
  });
}
function union$1(Structs) {
  const description = Structs.map((s2) => s2.type).join(" | ");
  return new Struct$3({
    type: "union",
    schema: null,
    coercer(value2) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value2, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value2;
    },
    validator(value2, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run$1(value2, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print$1(value2)}`,
        ...failures
      ];
    }
  });
}
function unknown$1() {
  return define$1("unknown", () => true);
}
function coerce$2(struct2, condition, coercer) {
  return new Struct$3({
    ...struct2,
    coercer: (value2, ctx) => {
      return is$1(value2, condition) ? struct2.coercer(coercer(value2, ctx), ctx) : struct2.coercer(value2, ctx);
    }
  });
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid2) {
  return typeof uuid2 === "string" && REGEX.test(uuid2);
}
var byteToHex = [];
for (var i$3 = 0; i$3 < 256; ++i$3) {
  byteToHex.push((i$3 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid2 = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate$1(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset2) {
  var i2 = buf && offset2 || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node2 = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node2 == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node2 == null) {
      node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt2 < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i2++] = tl2 >>> 24 & 255;
  b2[i2++] = tl2 >>> 16 & 255;
  b2[i2++] = tl2 >>> 8 & 255;
  b2[i2++] = tl2 & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i2++] = tmh >>> 8 & 255;
  b2[i2++] = tmh & 255;
  b2[i2++] = tmh >>> 24 & 15 | 16;
  b2[i2++] = tmh >>> 16 & 255;
  b2[i2++] = clockseq >>> 8 | 128;
  b2[i2++] = clockseq & 255;
  for (var n3 = 0; n3 < 6; ++n3) {
    b2[i2 + n3] = node2[n3];
  }
  return buf || stringify(b2);
}
function parse(uuid2) {
  if (!validate$1(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes2.push(str.charCodeAt(i2));
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value2, namespace, buf, offset2) {
    if (typeof value2 === "string") {
      value2 = stringToBytes(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value2.length);
    bytes2.set(namespace);
    bytes2.set(value2, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset2 + i2] = bytes2[i2];
      }
      return buf;
    }
    return stringify(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes2[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x2 = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c2 = -1732584194;
  var d2 = 271733878;
  for (var i2 = 0; i2 < x2.length; i2 += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c2;
    var oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x2[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x2[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x2[i2], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x2[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output2[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output2;
}
function safeAdd(x2, y2) {
  var lsw = (x2 & 65535) + (y2 & 65535);
  var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a2, b2, x2, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q3), safeAdd(x2, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function md5gg(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function md5hh(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function md5ii(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify(rnds);
}
function f$4(s2, x2, y2, z2) {
  switch (s2) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n3) {
  return x2 << n3 | x2 >>> 32 - n3;
}
function sha1(bytes2) {
  var K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes2.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l2 = bytes2.length / 4 + 2;
  var N2 = Math.ceil(l2 / 16);
  var M2 = new Array(N2);
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes2[_i2 * 64 + j2 * 4] << 24 | bytes2[_i2 * 64 + j2 * 4 + 1] << 16 | bytes2[_i2 * 64 + j2 * 4 + 2] << 8 | bytes2[_i2 * 64 + j2 * 4 + 3];
    }
    M2[_i2] = arr;
  }
  M2[N2 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N2; ++_i22) {
    var W2 = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[_i22][t2];
    }
    for (var _t6 = 16; _t6 < 80; ++_t6) {
      W2[_t6] = ROTL(W2[_t6 - 3] ^ W2[_t6 - 8] ^ W2[_t6 - 14] ^ W2[_t6 - 16], 1);
    }
    var a2 = H2[0];
    var b2 = H2[1];
    var c2 = H2[2];
    var d2 = H2[3];
    var e2 = H2[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s2 = Math.floor(_t22 / 20);
      var T2 = ROTL(a2, 5) + f$4(s2, b2, c2, d2) + e2 + K3[s2] + W2[_t22] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T2;
    }
    H2[0] = H2[0] + a2 >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c2 >>> 0;
    H2[3] = H2[3] + d2 >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5;
const nil = "00000000-0000-0000-0000-000000000000";
function version$1(uuid2) {
  if (!validate$1(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid2.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$1,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
const uuid$1 = require$$0$1.v4;
const generateRequest$1 = function(method, params, id2, options) {
  if (typeof method !== "string") {
    throw new TypeError(method + " must be a string");
  }
  options = options || {};
  const version2 = typeof options.version === "number" ? options.version : 2;
  if (version2 !== 1 && version2 !== 2) {
    throw new TypeError(version2 + " must be 1 or 2");
  }
  const request = {
    method
  };
  if (version2 === 2) {
    request.jsonrpc = "2.0";
  }
  if (params) {
    if (typeof params !== "object" && !Array.isArray(params)) {
      throw new TypeError(params + " must be an object, array or omitted");
    }
    request.params = params;
  }
  if (typeof id2 === "undefined") {
    const generator = typeof options.generator === "function" ? options.generator : function() {
      return uuid$1();
    };
    request.id = generator(request, options);
  } else if (version2 === 2 && id2 === null) {
    if (options.notificationIdNull) {
      request.id = null;
    }
  } else {
    request.id = id2;
  }
  return request;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0$1.v4;
const generateRequest = generateRequest_1;
const ClientBrowser = function(callServer, options) {
  if (!(this instanceof ClientBrowser)) {
    return new ClientBrowser(callServer, options);
  }
  if (!options) {
    options = {};
  }
  this.options = {
    reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
    replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
    generator: typeof options.generator !== "undefined" ? options.generator : function() {
      return uuid();
    },
    version: typeof options.version !== "undefined" ? options.version : 2,
    notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
  };
  this.callServer = callServer;
};
ClientBrowser.prototype.request = function(method, params, id2, callback) {
  const self2 = this;
  let request = null;
  const isBatch = Array.isArray(method) && typeof params === "function";
  if (this.options.version === 1 && isBatch) {
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  }
  const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
  if (isBatch || isRaw) {
    callback = params;
    request = method;
  } else {
    if (typeof id2 === "function") {
      callback = id2;
      id2 = void 0;
    }
    const hasCallback = typeof callback === "function";
    try {
      request = generateRequest(method, params, id2, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (err) {
      if (hasCallback) {
        return callback(err);
      }
      throw err;
    }
    if (!hasCallback) {
      return request;
    }
  }
  let message;
  try {
    message = JSON.stringify(request, this.options.replacer);
  } catch (err) {
    return callback(err);
  }
  this.callServer(message, function(err, response) {
    self2._parseResponse(err, response, callback);
  });
  return request;
};
ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
  if (err) {
    callback(err);
    return;
  }
  if (!responseText) {
    return callback();
  }
  let response;
  try {
    response = JSON.parse(responseText, this.options.reviver);
  } catch (err2) {
    return callback(err2);
  }
  if (callback.length === 3) {
    if (Array.isArray(response)) {
      const isError = function(res) {
        return typeof res.error !== "undefined";
      };
      const isNotError = function(res) {
        return !isError(res);
      };
      return callback(null, response.filter(isError), response.filter(isNotError));
    } else {
      return callback(null, response.error, response.result);
    }
  }
  callback(null, response);
};
var eventemitter3$1 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix2 = false;
  }
  function EE(fn2, context, once3) {
    this.fn = fn2;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn2, context, once3) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once3), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names = [], events2, name;
    if (this._eventsCount === 0) return names;
    for (name in events2 = this._events) {
      if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners2 = this._events[evt];
    if (!listeners2) return 0;
    if (listeners2.fn) return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners2[i2].once) this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
              args[j2 - 1] = arguments[j2];
            }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context) {
    return addListener2(this, event, fn2, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn2, context) {
    return addListener2(this, event, fn2, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context, once3) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length2 = listeners2.length; i2 < length2; i2++) {
        if (listeners2[i2].fn !== fn2 || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3$1);
function isOnCurve$1(publicKey2) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
const toBuffer$1 = (arr) => {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};
let Struct$2 = class Struct2 {
  constructor(properties2) {
    Object.assign(this, properties2);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA$1, this));
  }
  static decode(data2) {
    return deserialize_1(SOLANA_SCHEMA$1, this, data2);
  }
  static decodeUnchecked(data2) {
    return deserializeUnchecked_1(SOLANA_SCHEMA$1, this, data2);
  }
};
const SOLANA_SCHEMA$1 = /* @__PURE__ */ new Map();
var _PublicKey;
const MAX_SEED_LENGTH$1 = 32;
const PUBLIC_KEY_LENGTH$1 = 32;
function isPublicKeyData$1(value2) {
  return value2._bn !== void 0;
}
let uniquePublicKeyCounter$1 = 1;
let PublicKey$1 = class PublicKey extends Struct$2 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value2) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData$1(value2)) {
      this._bn = value2._bn;
    } else {
      if (typeof value2 === "string") {
        const decoded = bs58$1.decode(value2);
        if (decoded.length != PUBLIC_KEY_LENGTH$1) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new BN$1(decoded);
      } else {
        this._bn = new BN$1(value2);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH$1) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter$1);
    uniquePublicKeyCounter$1 += 1;
    return new PublicKey(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$1.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b2 = this._bn.toArrayLike(buffer.Buffer);
    if (b2.length === PUBLIC_KEY_LENGTH$1) {
      return b2;
    }
    const zeroPad = buffer.Buffer.alloc(32);
    b2.copy(zeroPad, 32 - b2.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed2, programId) {
    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed2), programId.toBuffer()]);
    const publicKeyBytes = sha256$3(buffer$1);
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer$1 = buffer.Buffer.alloc(0);
    seeds.forEach(function(seed2) {
      if (seed2.length > MAX_SEED_LENGTH$1) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer$1(seed2)]);
    });
    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256$3(buffer$1);
    if (isOnCurve$1(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve$1(pubkey.toBytes());
  }
};
_PublicKey = PublicKey$1;
PublicKey$1.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA$1.set(PublicKey$1, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey$1("BPFLoader1111111111111111111111111111111111");
const SIGNATURE_LENGTH_IN_BYTES$1 = 64;
const publicKey$1 = (property = "publicKey") => {
  return blob(32, property);
};
const rustString$1 = (property = "string") => {
  const rsl = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b2, offset2) => {
    const data2 = _decode(b2, offset2);
    return data2["chars"].toString();
  };
  rslShim.encode = (str, b2, offset2) => {
    const data2 = {
      chars: buffer.Buffer.from(str, "utf8")
    };
    return _encode(data2, b2, offset2);
  };
  rslShim.alloc = (str) => {
    return u32().span + u32().span + buffer.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
const authorized$1 = (property = "authorized") => {
  return struct([publicKey$1("staker"), publicKey$1("withdrawer")], property);
};
const lockup$1 = (property = "lockup") => {
  return struct([ns64("unixTimestamp"), ns64("epoch"), publicKey$1("custodian")], property);
};
const voteInit$1 = (property = "voteInit") => {
  return struct([publicKey$1("nodePubkey"), publicKey$1("authorizedVoter"), publicKey$1("authorizedWithdrawer"), u8("commission")], property);
};
const voteAuthorizeWithSeedArgs$1 = (property = "voteAuthorizeWithSeedArgs") => {
  return struct([u32("voteAuthorizationType"), publicKey$1("currentAuthorityDerivedKeyOwnerPubkey"), rustString$1("currentAuthorityDerivedKeySeed"), publicKey$1("newAuthorized")], property);
};
buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES$1).fill(0);
new PublicKey$1("SysvarC1ock11111111111111111111111111111111");
new PublicKey$1("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey$1("Sysvar1nstructions1111111111111111111111111");
new PublicKey$1("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey$1("SysvarRent111111111111111111111111111111111");
new PublicKey$1("SysvarRewards111111111111111111111111111111");
new PublicKey$1("SysvarS1otHashes111111111111111111111111111");
new PublicKey$1("SysvarS1otHistory11111111111111111111111111");
new PublicKey$1("SysvarStakeHistory1111111111111111111111111");
const FeeCalculatorLayout$1 = nu64("lamportsPerSignature");
const NonceAccountLayout$1 = struct([u32("version"), u32("state"), publicKey$1("authorizedPubkey"), publicKey$1("nonce"), struct([FeeCalculatorLayout$1], "feeCalculator")]);
NonceAccountLayout$1.span;
const encodeDecode$1 = (layout) => {
  const decode3 = layout.decode.bind(layout);
  const encode4 = layout.encode.bind(layout);
  return {
    decode: decode3,
    encode: encode4
  };
};
const bigInt$1 = (length2) => (property) => {
  const layout = blob(length2, property);
  const {
    encode: encode4,
    decode: decode3
  } = encodeDecode$1(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer$1, offset2) => {
    const src2 = decode3(buffer$1, offset2);
    return toBigIntLE_1(buffer.Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt2, buffer2, offset2) => {
    const src2 = toBufferLE_1(bigInt2, length2);
    return encode4(src2, buffer2, offset2);
  };
  return bigIntLayout;
};
const u64$1 = bigInt$1(8);
Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey$1("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey$1("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64$1("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey$1("base"), rustString$1("seed"), ns64("lamports"), ns64("space"), publicKey$1("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey$1("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey$1("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey$1("base"), rustString$1("seed"), ns64("space"), publicKey$1("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey$1("base"), rustString$1("seed"), publicKey$1("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64$1("lamports"), rustString$1("seed"), publicKey$1("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
new PublicKey$1("11111111111111111111111111111111");
new PublicKey$1("BPFLoader2111111111111111111111111111111111");
({
  index: 1,
  layout: struct([
    u32("typeIndex"),
    u64$1("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    // option
    seq(publicKey$1(), offset(u8(), -1), "authority")
  ])
});
const PublicKeyFromString$1 = coerce$2(instance$1(PublicKey$1), string$1(), (value2) => new PublicKey$1(value2));
const RawAccountDataResult$1 = tuple$1([string$1(), literal$1("base64")]);
const BufferFromRawAccountData$1 = coerce$2(instance$1(buffer.Buffer), RawAccountDataResult$1, (value2) => buffer.Buffer.from(value2[0], "base64"));
function createRpcResult$1(result) {
  return union$1([type$1({
    jsonrpc: literal$1("2.0"),
    id: string$1(),
    result
  }), type$1({
    jsonrpc: literal$1("2.0"),
    id: string$1(),
    error: type$1({
      code: unknown$1(),
      message: string$1(),
      data: optional$1(any$1())
    })
  })]);
}
const UnknownRpcResult$1 = createRpcResult$1(unknown$1());
function jsonRpcResult$1(schema) {
  return coerce$2(createRpcResult$1(schema), UnknownRpcResult$1, (value2) => {
    if ("error" in value2) {
      return value2;
    } else {
      return {
        ...value2,
        result: create$1(value2.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext$1(value2) {
  return jsonRpcResult$1(type$1({
    context: type$1({
      slot: number$2()
    }),
    value: value2
  }));
}
function notificationResultAndContext$1(value2) {
  return type$1({
    context: type$1({
      slot: number$2()
    }),
    value: value2
  });
}
const GetInflationGovernorResult$1 = type$1({
  foundation: number$2(),
  foundationTerm: number$2(),
  initial: number$2(),
  taper: number$2(),
  terminal: number$2()
});
jsonRpcResult$1(array$1(nullable$1(type$1({
  epoch: number$2(),
  effectiveSlot: number$2(),
  amount: number$2(),
  postBalance: number$2(),
  commission: optional$1(nullable$1(number$2()))
}))));
const GetRecentPrioritizationFeesResult$1 = array$1(type$1({
  slot: number$2(),
  prioritizationFee: number$2()
}));
const GetInflationRateResult$1 = type$1({
  total: number$2(),
  validator: number$2(),
  foundation: number$2(),
  epoch: number$2()
});
const GetEpochInfoResult$1 = type$1({
  epoch: number$2(),
  slotIndex: number$2(),
  slotsInEpoch: number$2(),
  absoluteSlot: number$2(),
  blockHeight: optional$1(number$2()),
  transactionCount: optional$1(number$2())
});
const GetEpochScheduleResult$1 = type$1({
  slotsPerEpoch: number$2(),
  leaderScheduleSlotOffset: number$2(),
  warmup: boolean$1(),
  firstNormalEpoch: number$2(),
  firstNormalSlot: number$2()
});
const GetLeaderScheduleResult$1 = record$1(string$1(), array$1(number$2()));
const TransactionErrorResult$1 = nullable$1(union$1([type$1({}), string$1()]));
const SignatureStatusResult$1 = type$1({
  err: TransactionErrorResult$1
});
const SignatureReceivedResult$1 = literal$1("receivedSignature");
type$1({
  "solana-core": string$1(),
  "feature-set": optional$1(number$2())
});
jsonRpcResultAndContext$1(type$1({
  err: nullable$1(union$1([type$1({}), string$1()])),
  logs: nullable$1(array$1(string$1())),
  accounts: optional$1(nullable$1(array$1(nullable$1(type$1({
    executable: boolean$1(),
    owner: string$1(),
    lamports: number$2(),
    data: array$1(string$1()),
    rentEpoch: optional$1(number$2())
  }))))),
  unitsConsumed: optional$1(number$2()),
  returnData: optional$1(nullable$1(type$1({
    programId: string$1(),
    data: tuple$1([string$1(), literal$1("base64")])
  })))
}));
jsonRpcResultAndContext$1(type$1({
  byIdentity: record$1(string$1(), array$1(number$2())),
  range: type$1({
    firstSlot: number$2(),
    lastSlot: number$2()
  })
}));
jsonRpcResult$1(GetInflationGovernorResult$1);
jsonRpcResult$1(GetInflationRateResult$1);
jsonRpcResult$1(GetRecentPrioritizationFeesResult$1);
jsonRpcResult$1(GetEpochInfoResult$1);
jsonRpcResult$1(GetEpochScheduleResult$1);
jsonRpcResult$1(GetLeaderScheduleResult$1);
jsonRpcResult$1(number$2());
jsonRpcResultAndContext$1(type$1({
  total: number$2(),
  circulating: number$2(),
  nonCirculating: number$2(),
  nonCirculatingAccounts: array$1(PublicKeyFromString$1)
}));
const TokenAmountResult$1 = type$1({
  amount: string$1(),
  uiAmount: nullable$1(number$2()),
  decimals: number$2(),
  uiAmountString: optional$1(string$1())
});
jsonRpcResultAndContext$1(array$1(type$1({
  address: PublicKeyFromString$1,
  amount: string$1(),
  uiAmount: nullable$1(number$2()),
  decimals: number$2(),
  uiAmountString: optional$1(string$1())
})));
jsonRpcResultAndContext$1(array$1(type$1({
  pubkey: PublicKeyFromString$1,
  account: type$1({
    executable: boolean$1(),
    owner: PublicKeyFromString$1,
    lamports: number$2(),
    data: BufferFromRawAccountData$1,
    rentEpoch: number$2()
  })
})));
const ParsedAccountDataResult$1 = type$1({
  program: string$1(),
  parsed: unknown$1(),
  space: number$2()
});
jsonRpcResultAndContext$1(array$1(type$1({
  pubkey: PublicKeyFromString$1,
  account: type$1({
    executable: boolean$1(),
    owner: PublicKeyFromString$1,
    lamports: number$2(),
    data: ParsedAccountDataResult$1,
    rentEpoch: number$2()
  })
})));
jsonRpcResultAndContext$1(array$1(type$1({
  lamports: number$2(),
  address: PublicKeyFromString$1
})));
const AccountInfoResult$1 = type$1({
  executable: boolean$1(),
  owner: PublicKeyFromString$1,
  lamports: number$2(),
  data: BufferFromRawAccountData$1,
  rentEpoch: number$2()
});
type$1({
  pubkey: PublicKeyFromString$1,
  account: AccountInfoResult$1
});
const ParsedOrRawAccountData$1 = coerce$2(union$1([instance$1(buffer.Buffer), ParsedAccountDataResult$1]), union$1([RawAccountDataResult$1, ParsedAccountDataResult$1]), (value2) => {
  if (Array.isArray(value2)) {
    return create$1(value2, BufferFromRawAccountData$1);
  } else {
    return value2;
  }
});
const ParsedAccountInfoResult$1 = type$1({
  executable: boolean$1(),
  owner: PublicKeyFromString$1,
  lamports: number$2(),
  data: ParsedOrRawAccountData$1,
  rentEpoch: number$2()
});
type$1({
  pubkey: PublicKeyFromString$1,
  account: ParsedAccountInfoResult$1
});
type$1({
  state: union$1([literal$1("active"), literal$1("inactive"), literal$1("activating"), literal$1("deactivating")]),
  active: number$2(),
  inactive: number$2()
});
jsonRpcResult$1(array$1(type$1({
  signature: string$1(),
  slot: number$2(),
  err: TransactionErrorResult$1,
  memo: nullable$1(string$1()),
  blockTime: optional$1(nullable$1(number$2()))
})));
jsonRpcResult$1(array$1(type$1({
  signature: string$1(),
  slot: number$2(),
  err: TransactionErrorResult$1,
  memo: nullable$1(string$1()),
  blockTime: optional$1(nullable$1(number$2()))
})));
type$1({
  subscription: number$2(),
  result: notificationResultAndContext$1(AccountInfoResult$1)
});
const ProgramAccountInfoResult$1 = type$1({
  pubkey: PublicKeyFromString$1,
  account: AccountInfoResult$1
});
type$1({
  subscription: number$2(),
  result: notificationResultAndContext$1(ProgramAccountInfoResult$1)
});
const SlotInfoResult$1 = type$1({
  parent: number$2(),
  slot: number$2(),
  root: number$2()
});
type$1({
  subscription: number$2(),
  result: SlotInfoResult$1
});
const SlotUpdateResult$1 = union$1([type$1({
  type: union$1([literal$1("firstShredReceived"), literal$1("completed"), literal$1("optimisticConfirmation"), literal$1("root")]),
  slot: number$2(),
  timestamp: number$2()
}), type$1({
  type: literal$1("createdBank"),
  parent: number$2(),
  slot: number$2(),
  timestamp: number$2()
}), type$1({
  type: literal$1("frozen"),
  slot: number$2(),
  timestamp: number$2(),
  stats: type$1({
    numTransactionEntries: number$2(),
    numSuccessfulTransactions: number$2(),
    numFailedTransactions: number$2(),
    maxTransactionsPerEntry: number$2()
  })
}), type$1({
  type: literal$1("dead"),
  slot: number$2(),
  timestamp: number$2(),
  err: string$1()
})]);
type$1({
  subscription: number$2(),
  result: SlotUpdateResult$1
});
type$1({
  subscription: number$2(),
  result: notificationResultAndContext$1(union$1([SignatureStatusResult$1, SignatureReceivedResult$1]))
});
type$1({
  subscription: number$2(),
  result: number$2()
});
type$1({
  pubkey: string$1(),
  gossip: nullable$1(string$1()),
  tpu: nullable$1(string$1()),
  rpc: nullable$1(string$1()),
  version: nullable$1(string$1())
});
const VoteAccountInfoResult$1 = type$1({
  votePubkey: string$1(),
  nodePubkey: string$1(),
  activatedStake: number$2(),
  epochVoteAccount: boolean$1(),
  epochCredits: array$1(tuple$1([number$2(), number$2(), number$2()])),
  commission: number$2(),
  lastVote: number$2(),
  rootSlot: nullable$1(number$2())
});
jsonRpcResult$1(type$1({
  current: array$1(VoteAccountInfoResult$1),
  delinquent: array$1(VoteAccountInfoResult$1)
}));
const ConfirmationStatus$1 = union$1([literal$1("processed"), literal$1("confirmed"), literal$1("finalized")]);
const SignatureStatusResponse$1 = type$1({
  slot: number$2(),
  confirmations: nullable$1(number$2()),
  err: TransactionErrorResult$1,
  confirmationStatus: optional$1(ConfirmationStatus$1)
});
jsonRpcResultAndContext$1(array$1(nullable$1(SignatureStatusResponse$1)));
jsonRpcResult$1(number$2());
const AddressTableLookupStruct$1 = type$1({
  accountKey: PublicKeyFromString$1,
  writableIndexes: array$1(number$2()),
  readonlyIndexes: array$1(number$2())
});
const ConfirmedTransactionResult$1 = type$1({
  signatures: array$1(string$1()),
  message: type$1({
    accountKeys: array$1(string$1()),
    header: type$1({
      numRequiredSignatures: number$2(),
      numReadonlySignedAccounts: number$2(),
      numReadonlyUnsignedAccounts: number$2()
    }),
    instructions: array$1(type$1({
      accounts: array$1(number$2()),
      data: string$1(),
      programIdIndex: number$2()
    })),
    recentBlockhash: string$1(),
    addressTableLookups: optional$1(array$1(AddressTableLookupStruct$1))
  })
});
const AnnotatedAccountKey$1 = type$1({
  pubkey: PublicKeyFromString$1,
  signer: boolean$1(),
  writable: boolean$1(),
  source: optional$1(union$1([literal$1("transaction"), literal$1("lookupTable")]))
});
const ConfirmedTransactionAccountsModeResult$1 = type$1({
  accountKeys: array$1(AnnotatedAccountKey$1),
  signatures: array$1(string$1())
});
const ParsedInstructionResult$1 = type$1({
  parsed: unknown$1(),
  program: string$1(),
  programId: PublicKeyFromString$1
});
const RawInstructionResult$1 = type$1({
  accounts: array$1(PublicKeyFromString$1),
  data: string$1(),
  programId: PublicKeyFromString$1
});
const InstructionResult$1 = union$1([RawInstructionResult$1, ParsedInstructionResult$1]);
const UnknownInstructionResult$1 = union$1([type$1({
  parsed: unknown$1(),
  program: string$1(),
  programId: string$1()
}), type$1({
  accounts: array$1(string$1()),
  data: string$1(),
  programId: string$1()
})]);
const ParsedOrRawInstruction$1 = coerce$2(InstructionResult$1, UnknownInstructionResult$1, (value2) => {
  if ("accounts" in value2) {
    return create$1(value2, RawInstructionResult$1);
  } else {
    return create$1(value2, ParsedInstructionResult$1);
  }
});
const ParsedConfirmedTransactionResult$1 = type$1({
  signatures: array$1(string$1()),
  message: type$1({
    accountKeys: array$1(AnnotatedAccountKey$1),
    instructions: array$1(ParsedOrRawInstruction$1),
    recentBlockhash: string$1(),
    addressTableLookups: optional$1(nullable$1(array$1(AddressTableLookupStruct$1)))
  })
});
const TokenBalanceResult$1 = type$1({
  accountIndex: number$2(),
  mint: string$1(),
  owner: optional$1(string$1()),
  uiTokenAmount: TokenAmountResult$1
});
const LoadedAddressesResult$1 = type$1({
  writable: array$1(PublicKeyFromString$1),
  readonly: array$1(PublicKeyFromString$1)
});
const ConfirmedTransactionMetaResult$1 = type$1({
  err: TransactionErrorResult$1,
  fee: number$2(),
  innerInstructions: optional$1(nullable$1(array$1(type$1({
    index: number$2(),
    instructions: array$1(type$1({
      accounts: array$1(number$2()),
      data: string$1(),
      programIdIndex: number$2()
    }))
  })))),
  preBalances: array$1(number$2()),
  postBalances: array$1(number$2()),
  logMessages: optional$1(nullable$1(array$1(string$1()))),
  preTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult$1))),
  postTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult$1))),
  loadedAddresses: optional$1(LoadedAddressesResult$1),
  computeUnitsConsumed: optional$1(number$2())
});
const ParsedConfirmedTransactionMetaResult$1 = type$1({
  err: TransactionErrorResult$1,
  fee: number$2(),
  innerInstructions: optional$1(nullable$1(array$1(type$1({
    index: number$2(),
    instructions: array$1(ParsedOrRawInstruction$1)
  })))),
  preBalances: array$1(number$2()),
  postBalances: array$1(number$2()),
  logMessages: optional$1(nullable$1(array$1(string$1()))),
  preTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult$1))),
  postTokenBalances: optional$1(nullable$1(array$1(TokenBalanceResult$1))),
  loadedAddresses: optional$1(LoadedAddressesResult$1),
  computeUnitsConsumed: optional$1(number$2())
});
const TransactionVersionStruct$1 = union$1([literal$1(0), literal$1("legacy")]);
const RewardsResult$1 = type$1({
  pubkey: string$1(),
  lamports: number$2(),
  postBalance: nullable$1(number$2()),
  rewardType: nullable$1(string$1()),
  commission: optional$1(nullable$1(number$2()))
});
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  transactions: array$1(type$1({
    transaction: ConfirmedTransactionResult$1,
    meta: nullable$1(ConfirmedTransactionMetaResult$1),
    version: optional$1(TransactionVersionStruct$1)
  })),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  transactions: array$1(type$1({
    transaction: ConfirmedTransactionAccountsModeResult$1,
    meta: nullable$1(ConfirmedTransactionMetaResult$1),
    version: optional$1(TransactionVersionStruct$1)
  })),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  transactions: array$1(type$1({
    transaction: ParsedConfirmedTransactionResult$1,
    meta: nullable$1(ParsedConfirmedTransactionMetaResult$1),
    version: optional$1(TransactionVersionStruct$1)
  })),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  transactions: array$1(type$1({
    transaction: ConfirmedTransactionAccountsModeResult$1,
    meta: nullable$1(ParsedConfirmedTransactionMetaResult$1),
    version: optional$1(TransactionVersionStruct$1)
  })),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2()),
  blockHeight: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  transactions: array$1(type$1({
    transaction: ConfirmedTransactionResult$1,
    meta: nullable$1(ConfirmedTransactionMetaResult$1)
  })),
  rewards: optional$1(array$1(RewardsResult$1)),
  blockTime: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  blockhash: string$1(),
  previousBlockhash: string$1(),
  parentSlot: number$2(),
  signatures: array$1(string$1()),
  blockTime: nullable$1(number$2())
})));
jsonRpcResult$1(nullable$1(type$1({
  slot: number$2(),
  meta: nullable$1(ConfirmedTransactionMetaResult$1),
  blockTime: optional$1(nullable$1(number$2())),
  transaction: ConfirmedTransactionResult$1,
  version: optional$1(TransactionVersionStruct$1)
})));
jsonRpcResult$1(nullable$1(type$1({
  slot: number$2(),
  transaction: ParsedConfirmedTransactionResult$1,
  meta: nullable$1(ParsedConfirmedTransactionMetaResult$1),
  blockTime: optional$1(nullable$1(number$2())),
  version: optional$1(TransactionVersionStruct$1)
})));
jsonRpcResultAndContext$1(type$1({
  blockhash: string$1(),
  feeCalculator: type$1({
    lamportsPerSignature: number$2()
  })
}));
jsonRpcResultAndContext$1(type$1({
  blockhash: string$1(),
  lastValidBlockHeight: number$2()
}));
jsonRpcResultAndContext$1(boolean$1());
const PerfSampleResult$1 = type$1({
  slot: number$2(),
  numTransactions: number$2(),
  numSlots: number$2(),
  samplePeriodSecs: number$2()
});
jsonRpcResult$1(array$1(PerfSampleResult$1));
jsonRpcResultAndContext$1(nullable$1(type$1({
  feeCalculator: type$1({
    lamportsPerSignature: number$2()
  })
})));
jsonRpcResult$1(string$1());
jsonRpcResult$1(string$1());
const LogsResult$1 = type$1({
  err: TransactionErrorResult$1,
  logs: array$1(string$1()),
  signature: string$1()
});
type$1({
  result: notificationResultAndContext$1(LogsResult$1),
  subscription: number$2()
});
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64$1("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64$1(), seq(publicKey$1(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
new PublicKey$1("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64$1("microLamports")])
  }
});
new PublicKey$1("ComputeBudget111111111111111111111111111111");
struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey$1("Ed25519SigVerify111111111111111111111111111");
secp256k1$1.utils.isValidPrivateKey;
secp256k1$1.getPublicKey;
struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
new PublicKey$1("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
new PublicKey$1("StakeConfig11111111111111111111111111111111");
let Lockup$1 = class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup = Lockup$1;
Lockup$1.default = new _Lockup(0, 0, PublicKey$1.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized$1(), lockup$1()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey$1("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey$1("newAuthorized"), u32("stakeAuthorizationType"), rustString$1("authoritySeed"), publicKey$1("authorityOwner")])
  }
});
new PublicKey$1("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit$1()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey$1("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs$1()])
  }
});
new PublicKey$1("Vote111111111111111111111111111111111111111");
new PublicKey$1("Va1idator1nfo111111111111111111111111111111");
type$1({
  name: string$1(),
  website: optional$1(string$1()),
  details: optional$1(string$1()),
  keybaseUsername: optional$1(string$1())
});
new PublicKey$1("Vote111111111111111111111111111111111111111");
struct([
  publicKey$1("nodePubkey"),
  publicKey$1("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  // votes.length
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  // authorizedVoters.length
  seq(struct([nu64("epoch"), publicKey$1("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey$1("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  // epochCredits.length
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
const t$2 = Symbol();
const s$2 = Object.getPrototypeOf, c$3 = /* @__PURE__ */ new WeakMap(), l$1 = (e2) => e2 && (c$3.has(e2) ? c$3.get(e2) : s$2(e2) === Object.prototype || s$2(e2) === Array.prototype), y$1 = (e2) => l$1(e2) && e2[t$2] || null, h$3 = (e2, t2 = true) => {
  c$3.set(e2, t2);
};
const __vite_import_meta_env__ = { "BASE_URL": "/sway-examples/pr-preview/pr-4/counter", "DEV": false, "MODE": "production", "PROD": true, "SSR": false, "VITE_APP_WC_PROJECT_ID": "e64002d84b020b9ae5eda323dd191093", "VITE_BASE_URL": "/sway-examples/pr-preview/pr-4", "VITE_PINATA_JWT": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJkODEwNDc5Zi1lYjk5LTQyNmMtOGMzMy02ZmU1Yjk1ZTVjYTIiLCJlbWFpbCI6Im1kYXVlcjMzM0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJpZCI6IkZSQTEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX0seyJpZCI6Ik5ZQzEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNjY0NzllYmFiMDFlOTEwMWJhYmUiLCJzY29wZWRLZXlTZWNyZXQiOiJmMDhiODk1NjVmNDQ0NjE5ZWZiMmM1NGNjOTEwN2E1ZWQ5NTI5OTgwYmZiMTAzOGYwZjc1NGVjNTkxNTE3OGY1IiwiaWF0IjoxNzE3MDE0NzQ1fQ.GvOu2LjeyyP4zE9_d9v8XUNV_Wgh595QTEy2kZa6Psk", "VITE_PUBLIC_DAPP_ENVIRONMENT": "testnet", "VITE_PUBLIC_GATEWAY_URL": "https://fuchsia-bizarre-butterfly-560.mypinata.cloud", "VITE_PUBLIC_TESTNET_COUNTER_CONTRACT_ID": "0xd9377acd88d5ea4c498770b5210dad7ea87992652e2867d2713efc542caebb22" };
const isObject$1 = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject$1(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version2) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$3(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value2 = Reflect.get(target, key);
    const desc = {
      value: value2,
      enumerable: true,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value2)) {
      h$3(value2, false);
    } else if (value2 instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value2);
    } else if (proxyStateMap.has(value2)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value2
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject$1(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners2 = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners2.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners2.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners2.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a2;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
    }
  };
  const addListener2 = (listener) => {
    listeners2.add(listener);
    if (listeners2.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener2 = () => {
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value2, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value2) || proxyCache.has(value2) && objectIs(prevValue, proxyCache.get(value2)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$1(value2)) {
        value2 = y$1(value2) || value2;
      }
      let nextValue = value2;
      if (value2 instanceof Promise) {
        value2.then((v2) => {
          value2.status = "fulfilled";
          value2.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          value2.status = "rejected";
          value2.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value2) && canProxy(value2)) {
          nextValue = proxyFunction(value2);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value2, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener2
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if ("value" in desc) {
      proxyObject[key] = initialObject[key];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener2 = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener2 = addListener2(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener2();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    }
  );
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n3 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n4 = t3 % 100;
      return "[" + t3 + (e3[(n4 - 20) % 10] || e3[n4] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n4) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n4) + t3;
    }, v2 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n4 = Math.abs(e3), r3 = Math.floor(n4 / 60), i3 = n4 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
    }, m: function t3(e3, n4) {
      if (e3.date() < n4.date()) return -t3(n4, e3);
      var r3 = 12 * (n4.year() - e3.year()) + (n4.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n4 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n4 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _2 || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n4, r3) {
      var i3;
      if (!e3) return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n4 && (D2[s3] = n4, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1) return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S2(t3)) return t3.clone();
      var n4 = "object" == typeof e3 ? e3 : {};
      return n4.date = t3, n4.args = arguments, new _2(n4);
    }, b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n4 = t4.utc;
          if (null === e3) return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3)) return /* @__PURE__ */ new Date();
          if (e3 instanceof Date) return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n4 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n4 = O2(t3);
        return this.startOf(e3) <= n4 && n4 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n4) {
        return b2.u(t3) ? this[e3] : this.set(n4, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n4 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
          var i3 = b2.w(n4.$u ? Date.UTC(n4.$y, e4, t4) : new Date(n4.$y, e4, t4), n4);
          return r3 ? i3 : i3.endOf(a2);
        }, $3 = function(t4, e4) {
          return b2.w(n4.toDate()[t4].apply(n4.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n4);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v6 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $3(v6 + "Hours", 0);
          case u2:
            return $3(v6 + "Minutes", 1);
          case s2:
            return $3(v6 + "Seconds", 2);
          case i2:
            return $3(v6 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n4, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n4 = {}, n4[a2] = f3 + "Date", n4[d2] = f3 + "Date", n4[c2] = f3 + "Month", n4[h2] = f3 + "FullYear", n4[u2] = f3 + "Hours", n4[s2] = f3 + "Minutes", n4[i2] = f3 + "Seconds", n4[r2] = f3 + "Milliseconds", n4)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b2.p(t3)]();
      }, m3.add = function(r3, f3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $3 = b2.p(f3), y3 = function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === c2) return this.set(c2, this.$M + r3);
        if ($3 === h2) return this.set(h2, this.$y + r3);
        if ($3 === a2) return y3(1);
        if ($3 === o2) return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n3, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
        return b2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n4 = this.$locale();
        if (!this.isValid()) return n4.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n4.weekdays, c3 = n4.months, f3 = n4.meridiem, h3 = function(t4, n5, i4, s4) {
          return t4 && (t4[n5] || t4(e3, r3)) || i4[n5].slice(0, s4);
        }, d3 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $3 = f3 || function(t4, e4, n5) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n5 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n4.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n4.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n4.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $3(s3, u3, true);
              case "A":
                return $3(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v6 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
          return b2.m(y3, m4);
        };
        switch (M4) {
          case h2:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g3 - v6) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v6) / 864e5;
            break;
          case u2:
            $3 = g3 / n3;
            break;
          case s2:
            $3 = g3 / e2;
            break;
          case i2:
            $3 = g3 / t2;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b2.a($3);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3) return this.$L;
        var n4 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n4.$L = r3), n4;
      }, m3.clone = function() {
        return b2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var en$1 = { exports: {} };
(function(module, exports) {
  !function(e2, n3) {
    module.exports = n3();
  }(commonjsGlobal, function() {
    return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e2) {
      var n3 = ["th", "st", "nd", "rd"], t2 = e2 % 100;
      return "[" + e2 + (n3[(t2 - 20) % 10] || n3[t2] || n3[0]) + "]";
    } };
  });
})(en$1);
var enExports = en$1.exports;
const englishLocale = /* @__PURE__ */ getDefaultExportFromCjs(enExports);
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n3 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i2(r3, e3, t3, o3) {
        return n3.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n3.fromToBase = function(e3, n4, i3, d3, u2) {
        for (var f2, a2, s2, l2 = i3.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h2.length, c2 = 0; c2 < m2; c2 += 1) {
          var y2 = h2[c2];
          y2.d && (f2 = d3 ? t2(e3).diff(i3, y2.d, true) : i3.diff(e3, y2.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f2));
          if (s2 = f2 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h2[c2 - 1]);
            var v2 = l2[y2.l];
            u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n4, y2.l, s2);
            break;
          }
        }
        if (n4) return a2;
        var M2 = s2 ? l2.future : l2.past;
        return "function" == typeof M2 ? M2(a2) : M2.replace("%s", a2);
      }, n3.to = function(r3, e3) {
        return i2(r3, e3, this, true);
      }, n3.from = function(r3, e3) {
        return i2(r3, e3, this);
      };
      var d2 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n3.toNow = function(r3) {
        return this.to(d2(this), r3);
      }, n3.fromNow = function(r3) {
        return this.from(d2(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
var updateLocale$1 = { exports: {} };
(function(module, exports) {
  !function(e2, n3) {
    module.exports = n3();
  }(commonjsGlobal, function() {
    return function(e2, n3, t2) {
      t2.updateLocale = function(e3, n4) {
        var o2 = t2.Ls[e3];
        if (o2) return (n4 ? Object.keys(n4) : []).forEach(function(e4) {
          o2[e4] = n4[e4];
        }), o2;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
const localeObject = {
  ...englishLocale,
  name: "en-web3-modal",
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%d sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
};
dayjs.locale("en-web3-modal", localeObject);
const DateUtil = {
  getYear(date = (/* @__PURE__ */ new Date()).toISOString()) {
    return dayjs(date).year();
  },
  getRelativeDateFromNow(date) {
    return dayjs(date).locale("en-web3-modal").fromNow(true);
  },
  formatDate(date, format2 = "DD MMM") {
    return dayjs(date).format(format2);
  }
};
const NetworkUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  }
};
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone2(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v2, b2) {
    var alphabet2, c2, caseChanged, e2, i2, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
    if (b2 == null) {
      if (v2 && v2._isBigNumber === true) {
        x2.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v2.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v2.e;
          x2.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++) ;
          if (e2 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e2;
            x2.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e2 < 0) e2 = i2;
        e2 += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET2.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v2);
        return round2(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
        x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET2.slice(0, b2);
      e2 = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet2.indexOf(c2 = str.charAt(i2)) < 0) {
          if (c2 == ".") {
            if (i2 > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v2), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x2.s);
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e2 = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x2.s * v2);
      }
      if ((e2 = e2 - i2 - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e2 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e2;
        x2.c = [];
        i2 = (e2 + 1) % LOG_BASE;
        if (e2 < 0) i2 += LOG_BASE;
        if (i2 < len) {
          if (i2) x2.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x2.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0") ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone2;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p2, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 8, p2);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p2);
            intCheck(v2[1], 0, MAX, p2);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "RANGE")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p2);
            intCheck(v2[1], 1, MAX, p2);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p2 + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p2 = "CRYPTO")) {
          v2 = obj[p2];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p2 + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 9, p2);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p2 = "FORMAT")) {
          v2 = obj[p2];
          if (typeof v2 == "object") FORMAT = v2;
          else throw Error(bignumberError + p2 + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p2 = "ALPHABET")) {
          v2 = obj[p2];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET2 = v2;
          } else {
            throw Error(bignumberError + p2 + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i2, n3, c2 = v2.c, e2 = v2.e, s2 = v2.s;
    out: if ({}.toString.call(c2) == "[object Array]") {
      if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
        if (c2[0] === 0) {
          if (e2 === 0 && c2.length === 1) return true;
          break out;
        }
        i2 = (e2 + 1) % LOG_BASE;
        if (i2 < 1) i2 += LOG_BASE;
        if (String(c2[0]).length == i2) {
          for (i2 = 0; i2 < c2.length; i2++) {
            n3 = c2[i2];
            if (n3 < 0 || n3 >= BASE || n3 !== mathfloor(n3)) break out;
          }
          if (n3 !== 0) return true;
        }
      }
    } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a2, b2, e2, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i2 < k2; ) {
            v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
            if (v2 >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a2[i2] = b2[0];
              a2[i2 + 1] = b2[1];
            } else {
              c2.push(v2 % 1e14);
              i2 += 2;
            }
          }
          i2 = k2 / 2;
        } else if (crypto.randomBytes) {
          a2 = crypto.randomBytes(k2 *= 7);
          for (; i2 < k2; ) {
            v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a2, i2);
            } else {
              c2.push(v2 % 1e14);
              i2 += 7;
            }
          }
          i2 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k2; ) {
          v2 = random53bitInt();
          if (v2 < 9e15) c2[i2++] = v2 % 1e14;
        }
      }
      k2 = c2[--i2];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c2[i2] = mathfloor(k2 / v2) * v2;
      }
      for (; c2[i2] === 0; c2.pop(), i2--) ;
      if (i2 < 0) {
        c2 = [e2 = 0];
      } else {
        for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
        for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++) ;
        if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
      }
      rand.e = e2;
      rand.c = c2;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet2) {
      var j2, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet2.indexOf(str.charAt(i2++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet2, d2, e2, k2, r2, x2, xc2, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y2 = new BigNumber2(baseIn);
        x2 = y2.pow(str.length - i2);
        POW_PRECISION = k2;
        y2.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y2.e = y2.c.length;
      }
      xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
      e2 = k2 = xc2.length;
      for (; xc2[--k2] == 0; xc2.pop()) ;
      if (!xc2[0]) return alphabet2.charAt(0);
      if (i2 < 0) {
        --e2;
      } else {
        x2.c = xc2;
        x2.e = e2;
        x2.s = sign;
        x2 = div(x2, y2, dp, rm, baseOut);
        xc2 = x2.c;
        r2 = x2.r;
        e2 = x2.e;
      }
      d2 = e2 + dp + 1;
      i2 = xc2[d2];
      k2 = baseOut / 2;
      r2 = r2 || d2 < 0 || xc2[d2 + 1] != null;
      r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc2[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d2 < 1 || !xc2[0]) {
        str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc2.length = d2;
        if (r2) {
          for (--baseOut; ++xc2[--d2] > baseOut; ) {
            xc2[d2] = 0;
            if (!d2) {
              ++e2;
              xc2 = [1].concat(xc2);
            }
          }
        }
        for (k2 = xc2.length; !xc2[--k2]; ) ;
        for (i2 = 0, str = ""; i2 <= k2; str += alphabet2.charAt(xc2[i2++])) ;
        str = toFixedPoint(str, e2, alphabet2.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x2, k2, base2) {
      var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i2--; ) {
        xlo = x2[i2] % SQRT_BASE;
        xhi = x2[i2] / SQRT_BASE | 0;
        m2 = khi * xlo + xhi * klo;
        temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base2 | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
        x2[i2] = temp % base2;
      }
      if (carry) x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a2, b2, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a2[i2] != b2[i2]) {
            cmp = a2[i2] > b2[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a2, b2, aL, base2) {
      var i2 = 0;
      for (; aL--; ) {
        a2[aL] -= i2;
        i2 = a2[aL] < b2[aL] ? 1 : 0;
        a2[aL] = i2 * base2 + a2[aL] - b2[aL];
      }
      for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
    }
    return function(x2, y2, dp, rm, base2) {
      var cmp, e2, i2, more, n3, prod, prodL, q3, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc2 = x2.c, yc2 = y2.c;
      if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc2 && xc2[0] == 0 || !yc2 ? s2 * 0 : s2 / 0
          )
        );
      }
      q3 = new BigNumber2(s2);
      qc2 = q3.c = [];
      e2 = x2.e - y2.e;
      s2 = dp + e2 + 1;
      if (!base2) {
        base2 = BASE;
        e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i2 = 0; yc2[i2] == (xc2[i2] || 0); i2++) ;
      if (yc2[i2] > (xc2[i2] || 0)) e2--;
      if (s2 < 0) {
        qc2.push(1);
        more = true;
      } else {
        xL = xc2.length;
        yL = yc2.length;
        i2 = 0;
        s2 += 2;
        n3 = mathfloor(base2 / (yc2[0] + 1));
        if (n3 > 1) {
          yc2 = multiply(yc2, n3, base2);
          xc2 = multiply(xc2, n3, base2);
          yL = yc2.length;
          xL = xc2.length;
        }
        xi2 = yL;
        rem = xc2.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc2.slice();
        yz = [0].concat(yz);
        yc0 = yc2[0];
        if (yc2[1] >= base2 / 2) yc0++;
        do {
          n3 = 0;
          cmp = compare2(yc2, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
            n3 = mathfloor(rem0 / yc0);
            if (n3 > 1) {
              if (n3 >= base2) n3 = base2 - 1;
              prod = multiply(yc2, n3, base2);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n3--;
                subtract(prod, yL < prodL ? yz : yc2, prodL, base2);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n3 == 0) {
                cmp = n3 = 1;
              }
              prod = yc2.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base2);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc2, rem, yL, remL) < 1) {
                n3++;
                subtract(rem, yL < remL ? yz : yc2, remL, base2);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n3++;
            rem = [0];
          }
          qc2[i2++] = n3;
          if (rem[0]) {
            rem[remL++] = xc2[xi2] || 0;
          } else {
            rem = [xc2[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc2[0]) qc2.splice(0, 1);
      }
      if (base2 == BASE) {
        for (i2 = 1, s2 = qc2[0]; s2 >= 10; s2 /= 10, i2++) ;
        round2(q3, dp + (q3.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q3.e = e2;
        q3.r = +more;
      }
      return q3;
    };
  }();
  function format2(n3, i2, rm, id2) {
    var c0, e2, ne2, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n3.c) return n3.toString();
    c0 = n3.c[0];
    ne2 = n3.e;
    if (i2 == null) {
      str = coeffToString(n3.c);
      str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
    } else {
      n3 = round2(new BigNumber2(n3), i2, rm);
      e2 = n3.e;
      str = coeffToString(n3.c);
      len = str.length;
      if (id2 == 1 || id2 == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++) ;
        str = toExponential(str, e2);
      } else {
        i2 -= ne2;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i2 > 0) for (str += "."; i2--; str += "0") ;
        } else {
          i2 += e2 - len;
          if (i2 > 0) {
            if (e2 + 1 == len) str += ".";
            for (; i2--; str += "0") ;
          }
        }
      }
    }
    return n3.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n3) {
    var k2, y2, i2 = 1, x2 = new BigNumber2(args[0]);
    for (; i2 < args.length; i2++) {
      y2 = new BigNumber2(args[i2]);
      if (!y2.s || (k2 = compare(x2, y2)) === n3 || k2 === 0 && x2.s === n3) {
        x2 = y2;
      }
    }
    return x2;
  }
  function normalise(n3, c2, e2) {
    var i2 = 1, j2 = c2.length;
    for (; !c2[--j2]; c2.pop()) ;
    for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
    if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
      n3.c = n3.e = null;
    } else if (e2 < MIN_EXP) {
      n3.c = [n3.e = 0];
    } else {
      n3.e = e2;
      n3.c = c2;
    }
    return n3;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b2) {
      var base2, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m2, p1, p2) {
            base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base2 ? p1 : m2;
          });
          if (b2) {
            base2 = b2;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2) return new BigNumber2(s2, base2);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round2(x2, sd2, rm, r2) {
    var d2, i2, j2, k2, n3, ni2, rd2, xc2 = x2.c, pows10 = POWS_TEN;
    if (xc2) {
      out: {
        for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++) ;
        i2 = sd2 - d2;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j2 = sd2;
          n3 = xc2[ni2 = 0];
          rd2 = mathfloor(n3 / pows10[d2 - j2 - 1] % 10);
        } else {
          ni2 = mathceil((i2 + 1) / LOG_BASE);
          if (ni2 >= xc2.length) {
            if (r2) {
              for (; xc2.length <= ni2; xc2.push(0)) ;
              n3 = rd2 = 0;
              d2 = 1;
              i2 %= LOG_BASE;
              j2 = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n3 = k2 = xc2[ni2];
            for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
            i2 %= LOG_BASE;
            j2 = i2 - LOG_BASE + d2;
            rd2 = j2 < 0 ? 0 : mathfloor(n3 / pows10[d2 - j2 - 1] % 10);
          }
        }
        r2 = r2 || sd2 < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc2[ni2 + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d2 - j2 - 1]);
        r2 = rm < 4 ? (rd2 || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i2 > 0 ? j2 > 0 ? n3 / pows10[d2 - j2] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd2 < 1 || !xc2[0]) {
          xc2.length = 0;
          if (r2) {
            sd2 -= x2.e + 1;
            xc2[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
            x2.e = -sd2 || 0;
          } else {
            xc2[0] = x2.e = 0;
          }
          return x2;
        }
        if (i2 == 0) {
          xc2.length = ni2;
          k2 = 1;
          ni2--;
        } else {
          xc2.length = ni2 + 1;
          k2 = pows10[LOG_BASE - i2];
          xc2[ni2] = j2 > 0 ? mathfloor(n3 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni2 == 0) {
              for (i2 = 1, j2 = xc2[0]; j2 >= 10; j2 /= 10, i2++) ;
              j2 = xc2[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
              if (i2 != k2) {
                x2.e++;
                if (xc2[0] == BASE) xc2[0] = 1;
              }
              break;
            } else {
              xc2[ni2] += k2;
              if (xc2[ni2] != BASE) break;
              xc2[ni2--] = 0;
              k2 = 1;
            }
          }
        }
        for (i2 = xc2.length; xc2[--i2] === 0; xc2.pop()) ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n3) {
    var str, e2 = n3.e;
    if (e2 === null) return n3.toString();
    str = coeffToString(n3.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n3.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0) x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c2, n3, v2, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c2 = x2.c)) return null;
    n3 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n3--) ;
    if (n3 < 0) n3 = 0;
    return n3;
  };
  P2.dividedBy = P2.div = function(y2, b2) {
    return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
    return div(this, new BigNumber2(y2, b2), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n3, m2) {
    var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
    n3 = new BigNumber2(n3);
    if (n3.c && !n3.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n3));
    }
    if (m2 != null) m2 = new BigNumber2(m2);
    nIsBig = n3.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n3.c || !n3.c[0]) {
      y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n3.s * (2 - isOdd(n3)) : +valueOf(n3)));
      return m2 ? y2.mod(m2) : y2;
    }
    nIsNeg = n3.s < 0;
    if (m2) {
      if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
      if (isModExp) x2 = x2.mod(m2);
    } else if (n3.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n3) ? -0 : 0;
      if (x2.e > -1) k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n3.s = 1;
      nIsOdd = isOdd(n3);
    } else {
      i2 = Math.abs(+valueOf(n3));
      nIsOdd = i2 % 2;
    }
    y2 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y2 = y2.times(x2);
        if (!y2.c) break;
        if (k2) {
          if (y2.c.length > k2) y2.c.length = k2;
        } else if (isModExp) {
          y2 = y2.mod(m2);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0) break;
        nIsOdd = i2 % 2;
      } else {
        n3 = n3.times(half);
        round2(n3, n3.e + 1, 1);
        if (n3.e > 14) {
          nIsOdd = isOdd(n3);
        } else {
          i2 = +valueOf(n3);
          if (i2 === 0) break;
          nIsOdd = i2 % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2) x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m2);
      }
    }
    if (isModExp) return y2;
    if (nIsNeg) y2 = ONE.div(y2);
    return m2 ? y2.mod(m2) : k2 ? round2(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
  };
  P2.integerValue = function(rm) {
    var n3 = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round2(n3, n3.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y2, b2) {
    var i2, j2, t2, xLTy, x2 = this, a2 = x2.s;
    y2 = new BigNumber2(y2, b2);
    b2 = y2.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y2.s = -b2;
      return x2.plus(y2);
    }
    var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
    if (!xe2 || !ye2) {
      if (!xc2 || !yc2) return xc2 ? (y2.s = -b2, y2) : new BigNumber2(yc2 ? x2 : NaN);
      if (!xc2[0] || !yc2[0]) {
        return yc2[0] ? (y2.s = -b2, y2) : new BigNumber2(xc2[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc2 = xc2.slice();
    if (a2 = xe2 - ye2) {
      if (xLTy = a2 < 0) {
        a2 = -a2;
        t2 = xc2;
      } else {
        ye2 = xe2;
        t2 = yc2;
      }
      t2.reverse();
      for (b2 = a2; b2--; t2.push(0)) ;
      t2.reverse();
    } else {
      j2 = (xLTy = (a2 = xc2.length) < (b2 = yc2.length)) ? a2 : b2;
      for (a2 = b2 = 0; b2 < j2; b2++) {
        if (xc2[b2] != yc2[b2]) {
          xLTy = xc2[b2] < yc2[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t2 = xc2;
      xc2 = yc2;
      yc2 = t2;
      y2.s = -y2.s;
    }
    b2 = (j2 = yc2.length) - (i2 = xc2.length);
    if (b2 > 0) for (; b2--; xc2[i2++] = 0) ;
    b2 = BASE - 1;
    for (; j2 > a2; ) {
      if (xc2[--j2] < yc2[j2]) {
        for (i2 = j2; i2 && !xc2[--i2]; xc2[i2] = b2) ;
        --xc2[i2];
        xc2[j2] += BASE;
      }
      xc2[j2] -= yc2[j2];
    }
    for (; xc2[0] == 0; xc2.splice(0, 1), --ye2) ;
    if (!xc2[0]) {
      y2.s = ROUNDING_MODE == 3 ? -1 : 1;
      y2.c = [y2.e = 0];
      return y2;
    }
    return normalise(y2, xc2, ye2);
  };
  P2.modulo = P2.mod = function(y2, b2) {
    var q3, s2, x2 = this;
    y2 = new BigNumber2(y2, b2);
    if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y2.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s2 = y2.s;
      y2.s = 1;
      q3 = div(x2, y2, 0, 3);
      y2.s = s2;
      q3.s *= s2;
    } else {
      q3 = div(x2, y2, 0, MODULO_MODE);
    }
    y2 = x2.minus(q3.times(y2));
    if (!y2.c[0] && MODULO_MODE == 1) y2.s = x2.s;
    return y2;
  };
  P2.multipliedBy = P2.times = function(y2, b2) {
    var c2, e2, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base2, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y2 = new BigNumber2(y2, b2)).c;
    if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
      if (!x2.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
        y2.c = y2.e = y2.s = null;
      } else {
        y2.s *= x2.s;
        if (!xc2 || !yc2) {
          y2.c = y2.e = null;
        } else {
          y2.c = [0];
          y2.e = 0;
        }
      }
      return y2;
    }
    e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
    y2.s *= x2.s;
    xcL = xc2.length;
    ycL = yc2.length;
    if (xcL < ycL) {
      zc2 = xc2;
      xc2 = yc2;
      yc2 = zc2;
      i2 = xcL;
      xcL = ycL;
      ycL = i2;
    }
    for (i2 = xcL + ycL, zc2 = []; i2--; zc2.push(0)) ;
    base2 = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c2 = 0;
      ylo = yc2[i2] % sqrtBase;
      yhi = yc2[i2] / sqrtBase | 0;
      for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
        xlo = xc2[--k2] % sqrtBase;
        xhi = xc2[k2] / sqrtBase | 0;
        m2 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j2] + c2;
        c2 = (xlo / base2 | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
        zc2[j2--] = xlo % base2;
      }
      zc2[j2] = c2;
    }
    if (c2) {
      ++e2;
    } else {
      zc2.splice(0, 1);
    }
    return normalise(y2, zc2, e2);
  };
  P2.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y2, b2) {
    var t2, x2 = this, a2 = x2.s;
    y2 = new BigNumber2(y2, b2);
    b2 = y2.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y2.s = -b2;
      return x2.minus(y2);
    }
    var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
    if (!xe2 || !ye2) {
      if (!xc2 || !yc2) return new BigNumber2(a2 / 0);
      if (!xc2[0] || !yc2[0]) return yc2[0] ? y2 : new BigNumber2(xc2[0] ? x2 : a2 * 0);
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc2 = xc2.slice();
    if (a2 = xe2 - ye2) {
      if (a2 > 0) {
        ye2 = xe2;
        t2 = yc2;
      } else {
        a2 = -a2;
        t2 = xc2;
      }
      t2.reverse();
      for (; a2--; t2.push(0)) ;
      t2.reverse();
    }
    a2 = xc2.length;
    b2 = yc2.length;
    if (a2 - b2 < 0) {
      t2 = yc2;
      yc2 = xc2;
      xc2 = t2;
      b2 = a2;
    }
    for (a2 = 0; b2; ) {
      a2 = (xc2[--b2] = xc2[b2] + yc2[b2] + a2) / BASE | 0;
      xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
    }
    if (a2) {
      xc2 = [a2].concat(xc2);
      ++ye2;
    }
    return normalise(y2, xc2, ye2);
  };
  P2.precision = P2.sd = function(sd2, rm) {
    var c2, n3, v2, x2 = this;
    if (sd2 != null && sd2 !== !!sd2) {
      intCheck(sd2, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x2), sd2, rm);
    }
    if (!(c2 = x2.c)) return null;
    v2 = c2.length - 1;
    n3 = v2 * LOG_BASE + 1;
    if (v2 = c2[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n3--) ;
      for (v2 = c2[0]; v2 >= 10; v2 /= 10, n3++) ;
    }
    if (sd2 && x2.e + 1 > n3) n3 = x2.e + 1;
    return n3;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m2, n3, r2, rep, t2, x2 = this, c2 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s2 !== 1 || !c2 || !c2[0]) {
      return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x2));
    if (s2 == 0 || s2 == 1 / 0) {
      n3 = coeffToString(c2);
      if ((n3.length + e2) % 2 == 0) n3 += "0";
      s2 = Math.sqrt(+n3);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s2 == 1 / 0) {
        n3 = "5e" + e2;
      } else {
        n3 = s2.toExponential();
        n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
      }
      r2 = new BigNumber2(n3);
    } else {
      r2 = new BigNumber2(s2 + "");
    }
    if (r2.c[0]) {
      e2 = r2.e;
      s2 = e2 + dp;
      if (s2 < 3) s2 = 0;
      for (; ; ) {
        t2 = r2;
        r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
        if (coeffToString(t2.c).slice(0, s2) === (n3 = coeffToString(r2.c)).slice(0, s2)) {
          if (r2.e < e2) --s2;
          n3 = n3.slice(s2 - 3, s2 + 1);
          if (n3 == "9999" || !rep && n3 == "4999") {
            if (!rep) {
              round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
              if (t2.times(t2).eq(x2)) {
                r2 = t2;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
              round2(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m2 = !r2.times(r2).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round2(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format2(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format2(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format3) {
    var str, x2 = this;
    if (format3 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format3 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format3 = dp;
        dp = rm = null;
      } else {
        format3 = FORMAT;
      }
    } else if (typeof format3 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format3);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i2, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i2 = g1;
        g1 = g2;
        g2 = i2;
        len -= i2;
      }
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format3.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format3.prefix || "") + str + (format3.suffix || "");
  };
  P2.toFraction = function(md2) {
    var d2, d0, d1, d22, e2, exp2, n3, n0, n1, q3, r2, s2, x2 = this, xc2 = x2.c;
    if (md2 != null) {
      n3 = new BigNumber2(md2);
      if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
      }
    }
    if (!xc2) return new BigNumber2(x2);
    d2 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s2 = coeffToString(xc2);
    e2 = d2.e = s2.length - x2.e - 1;
    d2.c[0] = POWS_TEN[(exp2 = e2 % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
    md2 = !md2 || n3.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n3;
    exp2 = MAX_EXP;
    MAX_EXP = 1 / 0;
    n3 = new BigNumber2(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q3 = div(n3, d2, 0, 1);
      d22 = d0.plus(q3.times(d1));
      if (d22.comparedTo(md2) == 1) break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q3.times(d22 = n1));
      n0 = d22;
      d2 = n3.minus(q3.times(d22 = d2));
      n3 = d22;
    }
    d22 = div(md2.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e2 = e2 * 2;
    r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp2;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd2, rm) {
    if (sd2 != null) intCheck(sd2, 1, MAX);
    return format2(this, sd2, rm, 2);
  };
  P2.toString = function(b2) {
    var str, n3 = this, s2 = n3.s, e2 = n3.e;
    if (e2 === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n3.c), e2) : toFixedPoint(coeffToString(n3.c), e2, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n3 = round2(new BigNumber2(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n3.c), n3.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n3.c), e2, "0"), 10, b2, s2, true);
      }
      if (s2 < 0 && n3.c[0]) str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n3) {
  var i2 = n3 | 0;
  return n3 > 0 || n3 === i2 ? i2 : i2 - 1;
}
function coeffToString(a2) {
  var s2, z2, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
  for (; i2 < j2; ) {
    s2 = a2[i2++] + "";
    z2 = LOG_BASE - s2.length;
    for (; z2--; s2 = "0" + s2) ;
    r2 += s2;
  }
  for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
  return r2.slice(0, j2 + 1 || 1);
}
function compare(x2, y2) {
  var a2, b2, xc2 = x2.c, yc2 = y2.c, i2 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
  if (!i2 || !j2) return null;
  a2 = xc2 && !xc2[0];
  b2 = yc2 && !yc2[0];
  if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
  if (i2 != j2) return i2;
  a2 = i2 < 0;
  b2 = k2 == l2;
  if (!xc2 || !yc2) return b2 ? 0 : !xc2 ^ a2 ? 1 : -1;
  if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
  j2 = (k2 = xc2.length) < (l2 = yc2.length) ? k2 : l2;
  for (i2 = 0; i2 < j2; i2++) if (xc2[i2] != yc2[i2]) return xc2[i2] > yc2[i2] ^ a2 ? 1 : -1;
  return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
}
function intCheck(n3, min, max, name) {
  if (n3 < min || n3 > max || n3 !== mathfloor(n3)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n3 == "number" ? n3 < min || n3 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
  }
}
function isOdd(n3) {
  var k2 = n3.c.length - 1;
  return bitFloor(n3.e / LOG_BASE) == k2 && n3.c[k2] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z2) {
  var len, zs;
  if (e2 < 0) {
    for (zs = z2 + "."; ++e2; zs += z2) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs = z2, e2 -= len; --e2; zs += z2) ;
      str += zs;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var BigNumber = clone2();
const NumberUtil = {
  bigNumber(value2) {
    return new BigNumber(value2);
  },
  multiply(a2, b2) {
    if (a2 === void 0 || b2 === void 0) {
      return BigNumber(0);
    }
    const aBigNumber = new BigNumber(a2);
    const bBigNumber = new BigNumber(b2);
    return aBigNumber.multipliedBy(bBigNumber);
  },
  formatNumberToLocalString(value2, decimals = 2) {
    if (value2 === void 0) {
      return "0.00";
    }
    if (typeof value2 === "number") {
      return value2.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value2).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};
const InputUtil = {
  numericInputKeyDown(event, currentValue, onChange) {
    const allowedKeys = [
      "Backspace",
      "Meta",
      "Ctrl",
      "a",
      "A",
      "c",
      "C",
      "x",
      "X",
      "v",
      "V",
      "ArrowLeft",
      "ArrowRight",
      "Tab"
    ];
    const controlPressed = event.metaKey || event.ctrlKey;
    const selectAll = event.key === "a" || event.key === "A";
    const copyKey = event.key === "c" || event.key === "C";
    const pasteKey = event.key === "v" || event.key === "V";
    const cutKey = event.key === "x" || event.key === "X";
    const isComma = event.key === ",";
    const isDot = event.key === ".";
    const isNumericKey = event.key >= "0" && event.key <= "9";
    if (!controlPressed && (selectAll || copyKey || pasteKey || cutKey)) {
      event.preventDefault();
    }
    if (currentValue === "0" && !isComma && !isDot && event.key === "0") {
      event.preventDefault();
    }
    if (currentValue === "0" && isNumericKey) {
      onChange(event.key);
      event.preventDefault();
    }
    if (isComma || isDot) {
      if (!currentValue) {
        onChange("0.");
        event.preventDefault();
      }
      if ((currentValue == null ? void 0 : currentValue.includes(".")) || (currentValue == null ? void 0 : currentValue.includes(","))) {
        event.preventDefault();
      }
    }
    if (!isNumericKey && !allowedKeys.includes(event.key) && !isDot && !isComma) {
      event.preventDefault();
    }
  }
};
const erc20ABI = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
const NavigationUtil = {
  URLS: {
    FAQ: "https://walletconnect.com/faq"
  }
};
const ConstantsUtil$3 = {
  WC_NAME_SUFFIX: ".wcn.id",
  WC_NAMES_ALLOWED_DOMAINS: ["walletconnect.com"],
  BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  W3M_API_URL: "https://api.web3modal.org"
};
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}
const SECURE_SITE = "https://secure.walletconnect.com";
const ONRAMP_PROVIDERS = [
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: ""
  }
];
const ConstantsUtil$2 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  SWAP_SUPPORTED_NETWORKS: [
    "eip155:1",
    "eip155:42161",
    "eip155:10",
    "eip155:324",
    "eip155:8453",
    "eip155:56",
    "eip155:137",
    "eip155:100",
    "eip155:43114",
    "eip155:250",
    "eip155:8217",
    "eip155:1313161554"
  ],
  NATIVE_TOKEN_ADDRESS: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
  CONVERT_SLIPPAGE_TOLERANCE: 1
};
const CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network == null ? void 0 : network.id.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua2.includes("android");
  },
  isIos() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua2.includes("iphone") || ua2.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil$2.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil$2.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil$2.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next2() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next2, timeout);
    };
  },
  isHttpUrl(url2) {
    return url2.startsWith("http://") || url2.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target, features) {
    window.open(href, target, features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window.open(href, target, features || "noreferrer noopener");
  },
  async preloadImage(src2) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src2;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    var _a2;
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0.000";
    } else if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        formattedBalance = (_a2 = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : _a2[0];
      }
    }
    return formattedBalance ? `${formattedBalance} ${symbol ?? ""}` : `0.000 ${symbol ?? ""}`;
  },
  formatBalance2(balance, symbol) {
    var _a2;
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0";
    } else if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        formattedBalance = (_a2 = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : _a2[0];
      }
    }
    return {
      value: formattedBalance ?? "0",
      rest: formattedBalance === "0" ? "000" : "",
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil$3.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return ConstantsUtil$3.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil$3.PULSE_API_URL;
  },
  getUUID() {
    if (crypto == null ? void 0 : crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  },
  parseError(error) {
    var _a2, _b2;
    if (typeof error === "string") {
      return error;
    } else if (typeof ((_b2 = (_a2 = error == null ? void 0 : error.issues) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.message) === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id2, index) => {
        approvedIndexMap[id2] = index;
      });
      requestedNetworks.sort((a2, b2) => {
        const indexA = approvedIndexMap[a2.id];
        const indexB = approvedIndexMap[b2.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array2) {
    let sum = 0;
    for (const item of array2) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number2) {
    const roundedNumber = number2.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address) {
    if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
      return false;
    } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
      return true;
    }
    return false;
  },
  uniqueBy(arr, key) {
    const set2 = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key];
      if (set2.has(keyValue)) {
        return false;
      }
      set2.add(keyValue);
      return true;
    });
  }
};
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
class FetchUtil {
  constructor({ baseUrl: baseUrl2 }) {
    this.baseUrl = baseUrl2;
  }
  async get({ headers, signal, ...args }) {
    const url2 = this.createUrl(args);
    const response = await fetchData(url2, { method: "GET", headers, signal, cache: "no-cache" });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url2 = this.createUrl(args);
    const response = await fetchData(url2, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body, headers, signal, ...args }) {
    const url2 = this.createUrl(args);
    const response = await fetchData(url2, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body, headers, signal, ...args }) {
    const url2 = this.createUrl(args);
    const response = await fetchData(url2, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body, headers, signal, ...args }) {
    const url2 = this.createUrl(args);
    const response = await fetchData(url2, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url2 = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value2]) => {
        if (value2) {
          url2.searchParams.append(key, value2);
        }
      });
    }
    return url2;
  }
}
const state$i = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined"
});
const OptionsController = {
  state: state$i,
  subscribeKey(key, callback) {
    return subscribeKey(state$i, key, callback);
  },
  setProjectId(projectId) {
    state$i.projectId = projectId;
  },
  setAllWallets(allWallets) {
    state$i.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state$i.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state$i.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state$i.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state$i.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state$i.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state$i.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state$i.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state$i.isSiweEnabled = isSiweEnabled;
  },
  setEnableAnalytics(enableAnalytics) {
    state$i.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state$i.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state$i.metadata = metadata;
  },
  setOnrampEnabled(enableOnramp) {
    state$i.enableOnramp = enableOnramp;
  },
  setDisableAppend(disableAppend) {
    state$i.disableAppend = disableAppend;
  },
  getSnapshot() {
    return snapshot(state$i);
  }
};
const DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
const baseUrl$2 = CoreHelperUtil.getBlockchainApiUrl();
const api$2 = new FetchUtil({ baseUrl: baseUrl$2 });
const BlockchainApiController = {
  fetchIdentity({ address }) {
    return api$2.get({
      path: `/v1/identity/${address}`,
      params: {
        projectId: OptionsController.state.projectId
      }
    });
  },
  fetchTransactions({ account, projectId, cursor: cursor2, onramp, signal }) {
    const queryParams = cursor2 ? { cursor: cursor2 } : {};
    return api$2.get({
      path: `/v1/account/${account}/history?projectId=${projectId}${onramp ? `&onramp=${onramp}` : ""}`,
      params: queryParams,
      signal
    });
  },
  fetchSwapQuote({ projectId, amount, userAddress, from: from2, to: to2, gasPrice }) {
    return api$2.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        projectId,
        amount,
        userAddress,
        from: from2,
        to: to2,
        gasPrice
      }
    });
  },
  fetchSwapTokens({ projectId, chainId }) {
    return api$2.get({
      path: `/v1/convert/tokens?projectId=${projectId}&chainId=${chainId}`
    });
  },
  fetchTokenPrice({ projectId, addresses }) {
    return api$2.post({
      path: "/v1/fungible/price",
      body: {
        projectId,
        currency: "usd",
        addresses
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  fetchSwapAllowance({ projectId, tokenAddress, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return api$2.get({
      path: `/v1/convert/allowance?projectId=${projectId}&tokenAddress=${tokenAddress}&userAddress=${userAddress}`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      }
    });
  },
  fetchGasPrice({ projectId, chainId }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return api$2.get({
      path: `/v1/convert/gas-price`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId,
        chainId
      }
    });
  },
  generateSwapCalldata({ amount, from: from2, projectId, to: to2, userAddress }) {
    return api$2.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil$2.CONVERT_SLIPPAGE_TOLERANCE
        },
        from: from2,
        projectId,
        to: to2,
        userAddress
      }
    });
  },
  generateApproveCalldata({ from: from2, projectId, to: to2, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return api$2.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId,
        userAddress,
        from: from2,
        to: to2
      }
    });
  },
  async getBalance(address, chainId, forceUpdate) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return api$2.get({
      path: `/v1/account/${address}/balance`,
      headers: {
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        currency: "usd",
        projectId: OptionsController.state.projectId,
        chainId,
        forceUpdate
      }
    });
  },
  async lookupEnsName(name) {
    return api$2.get({
      path: `/v1/profile/account/${name}${ConstantsUtil$3.WC_NAME_SUFFIX}?projectId=${OptionsController.state.projectId}`
    });
  },
  async reverseLookupEnsName({ address }) {
    return api$2.get({
      path: `/v1/profile/reverse/${address}?projectId=${OptionsController.state.projectId}`
    });
  },
  async getEnsNameSuggestions(name) {
    return api$2.get({
      path: `/v1/profile/suggestions/${name}?projectId=${OptionsController.state.projectId}`
    });
  },
  async registerEnsName({ coinType, address, message, signature }) {
    return api$2.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    const response = await api$2.post({
      path: `/v1/generators/onrampurl?projectId=${OptionsController.state.projectId}`,
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    try {
      const response = await api$2.get({
        path: `/v1/onramp/options?projectId=${OptionsController.state.projectId}`
      });
      return response;
    } catch (e2) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    try {
      const response = await api$2.post({
        path: `/v1/onramp/quote?projectId=${OptionsController.state.projectId}`,
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e2) {
      return {
        coinbaseFee: { amount, currency: paymentCurrency.id },
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  }
};
const state$h = proxy({
  message: "",
  variant: "success",
  open: false
});
const SnackController = {
  state: state$h,
  subscribeKey(key, callback) {
    return subscribeKey(state$h, key, callback);
  },
  showLoading(message) {
    state$h.message = message;
    state$h.variant = "loading";
    state$h.open = true;
  },
  showSuccess(message) {
    state$h.message = message;
    state$h.variant = "success";
    state$h.open = true;
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    state$h.message = errorMessage;
    state$h.variant = "error";
    state$h.open = true;
  },
  hide() {
    state$h.open = false;
  }
};
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
const W3M_RECENT = "@w3m/recent";
const W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url";
const W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector";
const W3M_CONNECTED_SOCIAL = "@w3m/connected_social";
const W3M_CONNECTED_SOCIAL_USERNAME = "@w3m-storage/SOCIAL_USERNAME";
const StorageUtil = {
  setWalletConnectDeepLink({ href, name }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists2 = recentWallets.find((w2) => w2.id === wallet.id);
      if (!exists2) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedWalletImageUrl(imageUrl) {
    try {
      localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, imageUrl);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  removeConnectedWalletImageUrl() {
    try {
      localStorage.removeItem(W3M_CONNECTED_WALLET_IMAGE_URL);
    } catch {
      console.info("Unable to remove Connected Wallet Image Url");
    }
  },
  getConnectedWalletImageUrl() {
    try {
      return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
    return void 0;
  },
  setConnectedConnector(connectorType) {
    try {
      localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      localStorage.setItem(W3M_CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set Connected Social Provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get Connected Social Provider");
    }
    return void 0;
  },
  getConnectedSocialUsername() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get Connected Social Username");
    }
    return void 0;
  }
};
const baseUrl$1 = CoreHelperUtil.getAnalyticsUrl();
const api$1 = new FetchUtil({ baseUrl: baseUrl$1 });
const excluded = ["MODAL_CREATED"];
const state$g = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
const EventsController = {
  state: state$g,
  subscribe(callback) {
    return subscribe(state$g, () => callback(state$g));
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api$1.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data2) {
    state$g.timestamp = Date.now();
    state$g.data = data2;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state$g);
    }
  }
};
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = buffer.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!((_s = window.process) == null ? void 0 : _s.env)) {
    window.process = { env: {} };
  }
}
const W3mFrameConstants = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  SOCIAL: "@w3m/connected_social",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
};
const W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter"
  ],
  NOT_SAFE_RPC_METHODS: ["personal_sign", "eth_signTypedData_v4", "eth_sendTransaction"],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value2) => {
    if (typeof value2 === "bigint") {
      return value2.toString();
    }
    return value2;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t2 = typeof data2;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el2 = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value2 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value2) => ({ status: "dirty", value: value2 });
const OK = (value2) => ({ status: "valid", value: value2 });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value2, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value2;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value2, options) {
    return this._addCheck({
      kind: "includes",
      value: value2,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value2, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value2, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      } else if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape2 = this._def.shape();
    const keys = util.objectKeys(shape2);
    return this._cached = { shape: shape2, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape: shape2, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape2[key];
      const value2 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value2 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b2, _c2, _d2;
          const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask2) {
    const shape2 = {};
    util.objectKeys(mask2).forEach((key) => {
      if (mask2[key] && this.shape[key]) {
        shape2[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  omit(mask2) {
    const shape2 = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask2[key]) {
        shape2[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask2) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask2 && !mask2[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask2) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask2 && !mask2[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape2, params) => {
  return new ZodObject({
    shape: shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type3) => {
  if (type3 instanceof ZodLazy) {
    return getDiscriminator(type3.schema);
  } else if (type3 instanceof ZodEffects) {
    return getDiscriminator(type3.innerType());
  } else if (type3 instanceof ZodLiteral) {
    return [type3.value];
  } else if (type3 instanceof ZodEnum) {
    return type3.options;
  } else if (type3 instanceof ZodNativeEnum) {
    return Object.keys(type3.enum);
  } else if (type3 instanceof ZodDefault) {
    return getDiscriminator(type3._def.innerType);
  } else if (type3 instanceof ZodUndefined) {
    return [void 0];
  } else if (type3 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type3 of options) {
      const discriminatorValues = getDiscriminator(type3.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value2 of discriminatorValues) {
        if (optionsMap.has(value2)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
        }
        optionsMap.set(value2, type3);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value2], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          if (key.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value2 = pair.value;
        if (key.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type3, params) => {
  return new ZodOptional({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type3, params) => {
  return new ZodNullable({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type3, params) => {
  return new ZodDefault({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type3, params) => {
  return new ZodCatch({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type3, params) => {
  return new ZodReadonly({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a2, _b2;
      if (!check(data2)) {
        const p2 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data2) => data2 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$1 = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$1,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const zError = z$1.object({ message: z$1.string() });
function zType(key) {
  return z$1.literal(W3mFrameConstants[key]);
}
z$1.object({
  accessList: z$1.array(z$1.string()),
  blockHash: z$1.string().nullable(),
  blockNumber: z$1.string().nullable(),
  chainId: z$1.string(),
  from: z$1.string(),
  gas: z$1.string(),
  hash: z$1.string(),
  input: z$1.string().nullable(),
  maxFeePerGas: z$1.string(),
  maxPriorityFeePerGas: z$1.string(),
  nonce: z$1.string(),
  r: z$1.string(),
  s: z$1.string(),
  to: z$1.string(),
  transactionIndex: z$1.string().nullable(),
  type: z$1.string(),
  v: z$1.string(),
  value: z$1.string()
});
const AppSwitchNetworkRequest = z$1.object({ chainId: z$1.number() });
const AppConnectEmailRequest = z$1.object({ email: z$1.string().email() });
const AppConnectOtpRequest = z$1.object({ otp: z$1.string() });
const AppConnectSocialRequest = z$1.object({ uri: z$1.string() });
const AppGetUserRequest = z$1.object({
  chainId: z$1.optional(z$1.number()),
  preferredAccountType: z$1.optional(z$1.string())
});
const AppGetSocialRedirectUriRequest = z$1.object({
  provider: z$1.enum(["google", "github", "apple", "facebook", "x", "discord"])
});
const AppUpdateEmailRequest = z$1.object({ email: z$1.string().email() });
const AppUpdateEmailPrimaryOtpRequest = z$1.object({ otp: z$1.string() });
const AppUpdateEmailSecondaryOtpRequest = z$1.object({ otp: z$1.string() });
const AppSyncThemeRequest = z$1.object({
  themeMode: z$1.optional(z$1.enum(["light", "dark"])),
  themeVariables: z$1.optional(z$1.record(z$1.string(), z$1.string().or(z$1.number()))),
  w3mThemeVariables: z$1.optional(z$1.record(z$1.string(), z$1.string()))
});
const AppSyncDappDataRequest = z$1.object({
  metadata: z$1.object({
    name: z$1.string(),
    description: z$1.string(),
    url: z$1.string(),
    icons: z$1.array(z$1.string())
  }).optional(),
  sdkVersion: z$1.string(),
  projectId: z$1.string()
});
const AppSetPreferredAccountRequest = z$1.object({ type: z$1.string() });
const FrameConnectEmailResponse = z$1.object({
  action: z$1.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
});
const FrameConnectSocialResponse = z$1.object({
  email: z$1.string(),
  address: z$1.string(),
  chainId: z$1.number(),
  userName: z$1.string().optional()
});
const FrameUpdateEmailResponse = z$1.object({
  action: z$1.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"])
});
const FrameGetUserResponse = z$1.object({
  email: z$1.string().email(),
  address: z$1.string(),
  chainId: z$1.number(),
  smartAccountDeployed: z$1.optional(z$1.boolean()),
  preferredAccountType: z$1.optional(z$1.string())
});
const FrameGetSocialRedirectUriResponse = z$1.object({ uri: z$1.string() });
const FrameIsConnectedResponse = z$1.object({ isConnected: z$1.boolean() });
const FrameGetChainIdResponse = z$1.object({ chainId: z$1.number() });
const FrameSwitchNetworkResponse = z$1.object({ chainId: z$1.number() });
const FrameUpdateEmailSecondaryOtpResolver = z$1.object({ newEmail: z$1.string().email() });
const FrameGetSmartAccountEnabledNetworksResponse = z$1.object({
  smartAccountEnabledNetworks: z$1.array(z$1.number())
});
z$1.object({
  address: z$1.string(),
  isDeployed: z$1.boolean()
});
const FrameSetPreferredAccountResponse = z$1.object({ type: z$1.string(), address: z$1.string() });
const RpcResponse = z$1.any();
const RpcEthAccountsRequest = z$1.object({
  method: z$1.literal("eth_accounts")
});
const RpcEthBlockNumber = z$1.object({
  method: z$1.literal("eth_blockNumber")
});
const RpcEthCall = z$1.object({
  method: z$1.literal("eth_call"),
  params: z$1.array(z$1.any())
});
const RpcEthChainId = z$1.object({
  method: z$1.literal("eth_chainId")
});
const RpcEthEstimateGas = z$1.object({
  method: z$1.literal("eth_estimateGas"),
  params: z$1.array(z$1.any())
});
const RpcEthFeeHistory = z$1.object({
  method: z$1.literal("eth_feeHistory"),
  params: z$1.array(z$1.any())
});
const RpcEthGasPrice = z$1.object({
  method: z$1.literal("eth_gasPrice")
});
const RpcEthGetAccount = z$1.object({
  method: z$1.literal("eth_getAccount"),
  params: z$1.array(z$1.any())
});
const RpcEthGetBalance = z$1.object({
  method: z$1.literal("eth_getBalance"),
  params: z$1.array(z$1.any())
});
const RpcEthGetBlockyByHash = z$1.object({
  method: z$1.literal("eth_getBlockByHash"),
  params: z$1.array(z$1.any())
});
const RpcEthGetBlockByNumber = z$1.object({
  method: z$1.literal("eth_getBlockByNumber"),
  params: z$1.array(z$1.any())
});
const RpcEthGetBlockReceipts = z$1.object({
  method: z$1.literal("eth_getBlockReceipts"),
  params: z$1.array(z$1.any())
});
const RcpEthGetBlockTransactionCountByHash = z$1.object({
  method: z$1.literal("eth_getBlockTransactionCountByHash"),
  params: z$1.array(z$1.any())
});
const RcpEthGetBlockTransactionCountByNumber = z$1.object({
  method: z$1.literal("eth_getBlockTransactionCountByNumber"),
  params: z$1.array(z$1.any())
});
const RpcEthGetCode = z$1.object({
  method: z$1.literal("eth_getCode"),
  params: z$1.array(z$1.any())
});
const RpcEthGetFilter = z$1.object({
  method: z$1.literal("eth_getFilterChanges"),
  params: z$1.array(z$1.any())
});
const RpcEthGetFilterLogs = z$1.object({
  method: z$1.literal("eth_getFilterLogs"),
  params: z$1.array(z$1.any())
});
const RpcEthGetLogs = z$1.object({
  method: z$1.literal("eth_getLogs"),
  params: z$1.array(z$1.any())
});
const RpcEthGetProof = z$1.object({
  method: z$1.literal("eth_getProof"),
  params: z$1.array(z$1.any())
});
const RpcEthGetStorageAt = z$1.object({
  method: z$1.literal("eth_getStorageAt"),
  params: z$1.array(z$1.any())
});
const RpcEthGetTransactionByBlockHashAndIndex = z$1.object({
  method: z$1.literal("eth_getTransactionByBlockHashAndIndex"),
  params: z$1.array(z$1.any())
});
const RpcEthGetTransactionByBlockNumberAndIndex = z$1.object({
  method: z$1.literal("eth_getTransactionByBlockNumberAndIndex"),
  params: z$1.array(z$1.any())
});
const RpcEthGetTransactionByHash = z$1.object({
  method: z$1.literal("eth_getTransactionByHash"),
  params: z$1.array(z$1.any())
});
const RpcEthGetTransactionCount = z$1.object({
  method: z$1.literal("eth_getTransactionCount"),
  params: z$1.array(z$1.any())
});
const RpcEthGetTransactionReceipt = z$1.object({
  method: z$1.literal("eth_getTransactionReceipt"),
  params: z$1.array(z$1.any())
});
const RpcEthGetUncleCountByBlockHash = z$1.object({
  method: z$1.literal("eth_getUncleCountByBlockHash"),
  params: z$1.array(z$1.any())
});
const RpcEthGetUncleCountByBlockNumber = z$1.object({
  method: z$1.literal("eth_getUncleCountByBlockNumber"),
  params: z$1.array(z$1.any())
});
const RpcEthMaxPriorityFeePerGas = z$1.object({
  method: z$1.literal("eth_maxPriorityFeePerGas")
});
const RpcEthNewBlockFilter = z$1.object({
  method: z$1.literal("eth_newBlockFilter")
});
const RpcEthNewFilter = z$1.object({
  method: z$1.literal("eth_newFilter"),
  params: z$1.array(z$1.any())
});
const RpcEthNewPendingTransactionFilter = z$1.object({
  method: z$1.literal("eth_newPendingTransactionFilter")
});
const RpcEthSendRawTransaction = z$1.object({
  method: z$1.literal("eth_sendRawTransaction"),
  params: z$1.array(z$1.any())
});
const RpcEthSyncing = z$1.object({
  method: z$1.literal("eth_syncing"),
  params: z$1.array(z$1.any())
});
const RpcUnistallFilter = z$1.object({
  method: z$1.literal("eth_uninstallFilter"),
  params: z$1.array(z$1.any())
});
const RpcPersonalSignRequest = z$1.object({
  method: z$1.literal("personal_sign"),
  params: z$1.array(z$1.any())
});
const RpcEthSignTypedDataV4 = z$1.object({
  method: z$1.literal("eth_signTypedData_v4"),
  params: z$1.array(z$1.any())
});
const RpcEthSendTransactionRequest = z$1.object({
  method: z$1.literal("eth_sendTransaction"),
  params: z$1.array(z$1.any())
});
const FrameSession = z$1.object({
  token: z$1.string()
});
({
  appEvent: z$1.object({ type: zType("APP_SWITCH_NETWORK"), payload: AppSwitchNetworkRequest }).or(z$1.object({ type: zType("APP_CONNECT_EMAIL"), payload: AppConnectEmailRequest })).or(z$1.object({ type: zType("APP_CONNECT_DEVICE") })).or(z$1.object({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(z$1.object({ type: zType("APP_CONNECT_SOCIAL"), payload: AppConnectSocialRequest })).or(z$1.object({ type: zType("APP_GET_USER"), payload: z$1.optional(AppGetUserRequest) })).or(z$1.object({
    type: zType("APP_GET_SOCIAL_REDIRECT_URI"),
    payload: AppGetSocialRedirectUriRequest
  })).or(z$1.object({ type: zType("APP_SIGN_OUT") })).or(z$1.object({ type: zType("APP_IS_CONNECTED"), payload: z$1.optional(FrameSession) })).or(z$1.object({ type: zType("APP_GET_CHAIN_ID") })).or(z$1.object({ type: zType("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })).or(z$1.object({ type: zType("APP_INIT_SMART_ACCOUNT") })).or(z$1.object({ type: zType("APP_SET_PREFERRED_ACCOUNT"), payload: AppSetPreferredAccountRequest })).or(z$1.object({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcEthBlockNumber).or(RpcEthCall).or(RpcEthChainId).or(RpcEthEstimateGas).or(RpcEthFeeHistory).or(RpcEthGasPrice).or(RpcEthGetAccount).or(RpcEthGetBalance).or(RpcEthGetBlockyByHash).or(RpcEthGetBlockByNumber).or(RpcEthGetBlockReceipts).or(RcpEthGetBlockTransactionCountByHash).or(RcpEthGetBlockTransactionCountByNumber).or(RpcEthGetCode).or(RpcEthGetFilter).or(RpcEthGetFilterLogs).or(RpcEthGetLogs).or(RpcEthGetProof).or(RpcEthGetStorageAt).or(RpcEthGetTransactionByBlockHashAndIndex).or(RpcEthGetTransactionByBlockNumberAndIndex).or(RpcEthGetTransactionByHash).or(RpcEthGetTransactionCount).or(RpcEthGetTransactionReceipt).or(RpcEthGetUncleCountByBlockHash).or(RpcEthGetUncleCountByBlockNumber).or(RpcEthMaxPriorityFeePerGas).or(RpcEthNewBlockFilter).or(RpcEthNewFilter).or(RpcEthNewPendingTransactionFilter).or(RpcEthSendRawTransaction).or(RpcEthSyncing).or(RpcUnistallFilter).or(RpcPersonalSignRequest).or(RpcEthSignTypedDataV4).or(RpcEthSendTransactionRequest)
  })).or(z$1.object({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(z$1.object({
    type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
    payload: AppUpdateEmailPrimaryOtpRequest
  })).or(z$1.object({
    type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
    payload: AppUpdateEmailSecondaryOtpRequest
  })).or(z$1.object({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(z$1.object({ type: zType("APP_SYNC_DAPP_DATA"), payload: AppSyncDappDataRequest })),
  frameEvent: z$1.object({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(z$1.object({ type: zType("FRAME_SWITCH_NETWORK_SUCCESS"), payload: FrameSwitchNetworkResponse })).or(z$1.object({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_CONNECT_EMAIL_SUCCESS"), payload: FrameConnectEmailResponse })).or(z$1.object({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(z$1.object({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(z$1.object({
    type: zType("FRAME_CONNECT_SOCIAL_SUCCESS"),
    payload: FrameConnectSocialResponse
  })).or(z$1.object({
    type: zType("FRAME_CONNECT_SOCIAL_ERROR"),
    payload: zError
  })).or(z$1.object({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_GET_USER_SUCCESS"), payload: FrameGetUserResponse })).or(z$1.object({ type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"), payload: zError })).or(z$1.object({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
    payload: FrameGetSocialRedirectUriResponse
  })).or(z$1.object({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(z$1.object({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_IS_CONNECTED_SUCCESS"), payload: FrameIsConnectedResponse })).or(z$1.object({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_GET_CHAIN_ID_SUCCESS"), payload: FrameGetChainIdResponse })).or(z$1.object({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(z$1.object({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(z$1.object({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_UPDATE_EMAIL_SUCCESS"), payload: FrameUpdateEmailResponse })).or(z$1.object({ type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })).or(z$1.object({ type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"), payload: zError })).or(z$1.object({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
    payload: FrameUpdateEmailSecondaryOtpResolver
  })).or(z$1.object({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(z$1.object({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(z$1.object({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") })).or(z$1.object({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
    payload: FrameGetSmartAccountEnabledNetworksResponse
  })).or(z$1.object({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
    payload: zError
  })).or(z$1.object({ type: zType("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: zError })).or(z$1.object({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
    payload: FrameSetPreferredAccountResponse
  })).or(z$1.object({ type: zType("FRAME_SET_PREFERRED_ACCOUNT_ERROR"), payload: zError }))
});
const W3mFrameStorage = {
  set(key, value2) {
    if (W3mFrameHelpers.isClient) {
      localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key}`, value2);
    }
  },
  get(key) {
    if (W3mFrameHelpers.isClient) {
      return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
    }
    return null;
  },
  delete(key, social) {
    if (W3mFrameHelpers.isClient) {
      if (social) {
        localStorage.removeItem(key);
      } else {
        localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
      }
    }
  }
};
const RegexUtil = {
  address: /^0x(?:[A-Fa-f0-9]{40})$/u,
  transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
  signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u
};
const EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
const W3mFrameHelpers = {
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  },
  checkIfRequestExists(request) {
    const method = this.getRequestMethod(request);
    return W3mFrameRpcConstants.NOT_SAFE_RPC_METHODS.includes(method) || W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method);
  },
  getRequestMethod(request) {
    var _a2;
    return (_a2 = request == null ? void 0 : request.payload) == null ? void 0 : _a2.method;
  },
  getResponseType(response) {
    const { type: type3, payload } = response;
    const isError = type3 === W3mFrameConstants.FRAME_RPC_REQUEST_ERROR;
    if (isError) {
      return W3mFrameConstants.RPC_RESPONSE_TYPE_ERROR;
    }
    const isPayloadString = typeof payload === "string";
    const isTransactionHash = isPayloadString && (payload.match(RegexUtil.transactionHash) || payload.match(RegexUtil.signedMessage));
    if (isTransactionHash) {
      return W3mFrameConstants.RPC_RESPONSE_TYPE_TX;
    }
    return W3mFrameConstants.RPC_RESPONSE_TYPE_OBJECT;
  },
  checkIfRequestIsAllowed(request) {
    const method = this.getRequestMethod(request);
    return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method);
  },
  isClient: typeof window !== "undefined"
};
const state$f = proxy({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  loading: false,
  empty: false,
  next: void 0
});
const TransactionsController = {
  state: state$f,
  subscribe(callback) {
    return subscribe(state$f, () => callback(state$f));
  },
  async fetchTransactions(accountAddress, onramp) {
    const { projectId } = OptionsController.state;
    if (!projectId || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state$f.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId,
        cursor: state$f.next,
        onramp
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const filteredTransactions = [...state$f.transactions, ...nonSpamTransactions];
      state$f.loading = false;
      if (onramp === "coinbase") {
        state$f.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state$f.coinbaseTransactions, response.data);
      } else {
        state$f.transactions = filteredTransactions;
        state$f.transactionsByYear = this.groupTransactionsByYearAndMonth(state$f.transactionsByYear, nonSpamTransactions);
      }
      state$f.empty = filteredTransactions.length === 0;
      state$f.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId,
          cursor: state$f.next,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state$f.loading = false;
      state$f.empty = true;
      state$f.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a2, b2) => new Date(b2.metadata.minedAt).getTime() - new Date(a2.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => {
        var _a2;
        return ((_a2 = transfer.nft_info) == null ? void 0 : _a2.flags.is_spam) === true;
      });
      return !isAllSpam;
    });
  },
  clearCursor() {
    state$f.next = void 0;
  },
  resetTransactions() {
    state$f.transactions = [];
    state$f.transactionsByYear = {};
    state$f.loading = false;
    state$f.empty = false;
    state$f.next = void 0;
  }
};
const state$e = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
const ThemeController = {
  state: state$e,
  subscribe(callback) {
    return subscribe(state$e, () => callback(state$e));
  },
  setThemeMode(themeMode) {
    state$e.themeMode = themeMode;
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state$e.themeVariables = { ...state$e.themeVariables, ...themeVariables };
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariablesSnapshot = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state$e.themeVariables, state$e.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state$e);
  }
};
const state$d = proxy({
  connectors: []
});
const ConnectorController = {
  state: state$d,
  subscribeKey(key, callback) {
    return subscribeKey(state$d, key, callback);
  },
  setConnectors(connectors) {
    state$d.connectors = connectors.map((c2) => ref(c2));
  },
  addConnector(connector) {
    var _a2, _b2;
    state$d.connectors.push(ref(connector));
    if (connector.id === "w3mAuth") {
      const authConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      (_b2 = (_a2 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a2.syncDappData) == null ? void 0 : _b2.call(_a2, {
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId
      });
      authConnector.provider.syncTheme({
        themeMode,
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  },
  getAuthConnector() {
    return state$d.connectors.find((c2) => c2.type === "AUTH");
  },
  getAnnouncedConnectorRdns() {
    return state$d.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => {
      var _a2;
      return (_a2 = c2.info) == null ? void 0 : _a2.rdns;
    });
  },
  getConnectors() {
    return state$d.connectors;
  },
  getConnector(id2, rdns) {
    return state$d.connectors.find((c2) => {
      var _a2;
      return c2.explorerId === id2 || ((_a2 = c2.info) == null ? void 0 : _a2.rdns) === rdns;
    });
  }
};
const state$c = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0
});
const PublicStateController = {
  state: state$c,
  subscribe(callback) {
    return subscribe(state$c, () => callback(state$c));
  },
  set(newState) {
    Object.assign(state$c, { ...state$c, ...newState });
  }
};
const state$b = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false,
  smartAccountEnabledNetworks: []
});
const NetworkController = {
  state: state$b,
  subscribe(callback) {
    return subscribe(state$b, () => callback(state$b));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$b, key, callback);
  },
  _getClient() {
    if (!state$b._client) {
      throw new Error("NetworkController client not set");
    }
    return state$b._client;
  },
  setClient(client2) {
    state$b._client = ref(client2);
  },
  setCaipNetwork(caipNetwork) {
    state$b.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id });
    if (!this.state.allowUnsupportedChain) {
      this.checkIfSupportedNetwork();
    }
  },
  setDefaultCaipNetwork(caipNetwork) {
    state$b.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id });
    state$b.isDefaultCaipNetwork = true;
  },
  setRequestedCaipNetworks(requestedNetworks) {
    state$b.requestedCaipNetworks = requestedNetworks;
  },
  setAllowUnsupportedChain(allowUnsupportedChain) {
    state$b.allowUnsupportedChain = allowUnsupportedChain;
  },
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks) {
    state$b.smartAccountEnabledNetworks = smartAccountEnabledNetworks;
  },
  getRequestedCaipNetworks() {
    const { approvedCaipNetworkIds, requestedCaipNetworks } = state$b;
    const approvedIds = approvedCaipNetworkIds;
    const requestedNetworks = requestedCaipNetworks;
    return CoreHelperUtil.sortRequestedNetworks(approvedIds, requestedNetworks);
  },
  async getApprovedCaipNetworksData() {
    const data2 = await this._getClient().getApprovedCaipNetworksData();
    state$b.supportsAllNetworks = data2.supportsAllNetworks;
    state$b.approvedCaipNetworkIds = data2.approvedCaipNetworkIds;
  },
  async switchActiveNetwork(network) {
    await this._getClient().switchCaipNetwork(network);
    state$b.caipNetwork = network;
    if (network) {
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.id }
      });
    }
  },
  checkIfSupportedNetwork() {
    var _a2;
    state$b.isUnsupportedChain = !((_a2 = state$b.requestedCaipNetworks) == null ? void 0 : _a2.some((network) => {
      var _a3;
      return network.id === ((_a3 = state$b.caipNetwork) == null ? void 0 : _a3.id);
    }));
    if (state$b.isUnsupportedChain) {
      this.showUnsupportedChainUI();
    }
  },
  checkIfSmartAccountEnabled() {
    var _a2, _b2;
    const networkId = NetworkUtil.caipNetworkIdToNumber((_a2 = state$b.caipNetwork) == null ? void 0 : _a2.id);
    if (!networkId) {
      return false;
    }
    return Boolean((_b2 = state$b.smartAccountEnabledNetworks) == null ? void 0 : _b2.includes(networkId));
  },
  resetNetwork() {
    if (!state$b.isDefaultCaipNetwork) {
      state$b.caipNetwork = void 0;
    }
    state$b.approvedCaipNetworkIds = void 0;
    state$b.supportsAllNetworks = true;
    state$b.smartAccountEnabledNetworks = [];
  },
  showUnsupportedChainUI() {
    setTimeout(() => {
      ModalController.open({ view: "UnsupportedChain" });
    }, 300);
  }
};
const state$a = proxy({
  wcError: false,
  buffering: false
});
const ConnectionController = {
  state: state$a,
  subscribeKey(key, callback) {
    return subscribeKey(state$a, key, callback);
  },
  _getClient() {
    if (!state$a._client) {
      throw new Error("ConnectionController client not set");
    }
    return state$a._client;
  },
  setClient(client2) {
    state$a._client = ref(client2);
  },
  connectWalletConnect() {
    state$a.wcPromise = this._getClient().connectWalletConnect((uri) => {
      state$a.wcUri = uri;
      state$a.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
    StorageUtil.setConnectedConnector("WALLET_CONNECT");
  },
  async connectExternal(options) {
    var _a2, _b2;
    await ((_b2 = (_a2 = this._getClient()).connectExternal) == null ? void 0 : _b2.call(_a2, options));
    StorageUtil.setConnectedConnector(options.type);
  },
  async reconnectExternal(options) {
    var _a2, _b2;
    await ((_b2 = (_a2 = this._getClient()).reconnectExternal) == null ? void 0 : _b2.call(_a2, options));
    StorageUtil.setConnectedConnector(options.type);
  },
  async setPreferredAccountType(accountType) {
    var _a2;
    ModalController.setLoading(true);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    await (authConnector == null ? void 0 : authConnector.provider.setPreferredAccount(accountType));
    await this.reconnectExternal(authConnector);
    ModalController.setLoading(false);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: { accountType, network: ((_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id) || "" }
    });
  },
  async signMessage(message) {
    return this._getClient().signMessage(message);
  },
  parseUnits(value2, decimals) {
    return this._getClient().parseUnits(value2, decimals);
  },
  formatUnits(value2, decimals) {
    return this._getClient().formatUnits(value2, decimals);
  },
  async sendTransaction(args) {
    return this._getClient().sendTransaction(args);
  },
  async estimateGas(args) {
    return this._getClient().estimateGas(args);
  },
  async writeContract(args) {
    return this._getClient().writeContract(args);
  },
  async getEnsAddress(value2) {
    return this._getClient().getEnsAddress(value2);
  },
  async getEnsAvatar(value2) {
    return this._getClient().getEnsAvatar(value2);
  },
  checkInstalled(ids) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._getClient()).checkInstalled) == null ? void 0 : _b2.call(_a2, ids);
  },
  resetWcConnection() {
    state$a.wcUri = void 0;
    state$a.wcPairingExpiry = void 0;
    state$a.wcPromise = void 0;
    state$a.wcLinking = void 0;
    state$a.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state$a.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state$a.wcError = wcError;
    state$a.buffering = false;
  },
  setRecentWallet(wallet) {
    state$a.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state$a.buffering = buffering;
  },
  async disconnect() {
    await this._getClient().disconnect();
    StorageUtil.removeConnectedWalletImageUrl();
    this.resetWcConnection();
  }
};
const SwapApiUtil = {
  async getTokenList() {
    var _a2, _b2;
    const response = await BlockchainApiController.fetchSwapTokens({
      chainId: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
      projectId: OptionsController.state.projectId
    });
    const tokens = ((_b2 = response == null ? void 0 : response.tokens) == null ? void 0 : _b2.map((token2) => ({
      ...token2,
      eip2612: false,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    }))) || [];
    return tokens;
  },
  async fetchGasPrice() {
    const projectId = OptionsController.state.projectId;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return null;
    }
    return await BlockchainApiController.fetchGasPrice({
      projectId,
      chainId: caipNetwork.id
    });
  },
  async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
    const projectId = OptionsController.state.projectId;
    const response = await BlockchainApiController.fetchSwapAllowance({
      projectId,
      tokenAddress,
      userAddress
    });
    if ((response == null ? void 0 : response.allowance) && sourceTokenAmount && sourceTokenDecimals) {
      const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals);
      const hasAllowance = BigInt(response.allowance) >= parsedValue;
      return hasAllowance;
    }
    return false;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    const response = await BlockchainApiController.getBalance(address, caipNetwork.id, forceUpdate);
    const balances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
    AccountController.setTokenBalance(balances);
    return this.mapBalancesToSwapTokens(balances);
  },
  mapBalancesToSwapTokens(balances) {
    return (balances == null ? void 0 : balances.map((token2) => ({
      ...token2,
      address: (token2 == null ? void 0 : token2.address) ? token2.address : `${token2.chainId}:${ConstantsUtil$2.NATIVE_TOKEN_ADDRESS}`,
      decimals: parseInt(token2.quantity.decimals, 10),
      logoUri: token2.iconUrl,
      eip2612: false
    }))) || [];
  }
};
const state$9 = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
const RouterController = {
  state: state$9,
  subscribeKey(key, callback) {
    return subscribeKey(state$9, key, callback);
  },
  pushTransactionStack(action) {
    state$9.transactionStack.push(action);
  },
  popTransactionStack(cancel) {
    var _a2, _b2;
    const action = state$9.transactionStack.pop();
    if (!action) {
      return;
    }
    if (cancel) {
      this.goBack();
      (_a2 = action == null ? void 0 : action.onCancel) == null ? void 0 : _a2.call(action);
    } else {
      if (action.goBack) {
        this.goBack();
      } else if (action.view) {
        this.reset(action.view);
      }
      (_b2 = action == null ? void 0 : action.onSuccess) == null ? void 0 : _b2.call(action);
    }
  },
  push(view, data2) {
    if (view !== state$9.view) {
      state$9.view = view;
      state$9.history.push(view);
      state$9.data = data2;
    }
  },
  reset(view) {
    state$9.view = view;
    state$9.history = [view];
  },
  replace(view, data2) {
    if (state$9.history.length >= 1 && state$9.history.at(-1) !== view) {
      state$9.view = view;
      state$9.history[state$9.history.length - 1] = view;
      state$9.data = data2;
    }
  },
  goBack() {
    if (state$9.history.length > 1) {
      state$9.history.pop();
      const [last] = state$9.history.slice(-1);
      if (last) {
        state$9.view = last;
      }
    }
  },
  goBackToIndex(historyIndex) {
    if (state$9.history.length > 1) {
      state$9.history = state$9.history.slice(0, historyIndex + 1);
      const [last] = state$9.history.slice(-1);
      if (last) {
        state$9.view = last;
      }
    }
  }
};
const SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.multipliedBy(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).multipliedBy(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).dividedBy(inputValue).multipliedBy(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).dividedBy(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).isZero()) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).isGreaterThan(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    var _a2, _b2;
    const sourceTokenBalance = (_b2 = (_a2 = balance == null ? void 0 : balance.find((token2) => token2.address === sourceTokenAddress)) == null ? void 0 : _a2.quantity) == null ? void 0 : _b2.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").isLessThan(sourceTokenAmount);
    return isInSufficientBalance;
  },
  getToTokenAmount({ sourceToken, toToken, sourceTokenPrice, toTokenPrice, sourceTokenAmount }) {
    if (sourceTokenAmount === "0") {
      return "0";
    }
    if (!sourceToken || !toToken) {
      return "0";
    }
    const sourceTokenDecimals = sourceToken.decimals;
    const sourceTokenPriceInUSD = sourceTokenPrice;
    const toTokenDecimals = toToken.decimals;
    const toTokenPriceInUSD = toTokenPrice;
    if (toTokenPriceInUSD <= 0) {
      return "0";
    }
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(85e-4);
    const adjustedSourceTokenAmount = NumberUtil.bigNumber(sourceTokenAmount).minus(providerFee);
    const sourceAmountInSmallestUnit = adjustedSourceTokenAmount.multipliedBy(NumberUtil.bigNumber(10).pow(sourceTokenDecimals));
    const priceRatio = NumberUtil.bigNumber(sourceTokenPriceInUSD).dividedBy(toTokenPriceInUSD);
    const decimalDifference = sourceTokenDecimals - toTokenDecimals;
    const toTokenAmountInSmallestUnit = sourceAmountInSmallestUnit.multipliedBy(priceRatio).dividedBy(NumberUtil.bigNumber(10).pow(decimalDifference));
    const toTokenAmount = toTokenAmountInSmallestUnit.dividedBy(NumberUtil.bigNumber(10).pow(toTokenDecimals));
    const amount = toTokenAmount.toFixed(toTokenDecimals).toString();
    return amount;
  }
};
const INITIAL_GAS_LIMIT = 15e4;
const TO_AMOUNT_DECIMALS = 6;
const initialState = {
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  fetchError: false,
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  slippage: ConstantsUtil$2.CONVERT_SLIPPAGE_TOLERANCE,
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
const state$8 = proxy(initialState);
const SwapController = {
  state: state$8,
  subscribe(callback) {
    return subscribe(state$8, () => callback(state$8));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$8, key, callback);
  },
  getParams() {
    var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2, _i2;
    const { address } = AccountController.state;
    const networkAddress = `${(_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id}:${ConstantsUtil$2.NATIVE_TOKEN_ADDRESS}`;
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const caipAddress = AccountController.state.caipAddress;
    const invalidToToken = !((_b2 = state$8.toToken) == null ? void 0 : _b2.address) || !((_c2 = state$8.toToken) == null ? void 0 : _c2.decimals);
    const invalidSourceToken = !((_d2 = state$8.sourceToken) == null ? void 0 : _d2.address) || !((_e3 = state$8.sourceToken) == null ? void 0 : _e3.decimals) || !NumberUtil.bigNumber(state$8.sourceTokenAmount).isGreaterThan(0);
    const invalidSourceTokenAmount = !state$8.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: AccountController.state.caipAddress,
      sourceTokenAddress: (_f2 = state$8.sourceToken) == null ? void 0 : _f2.address,
      toTokenAddress: (_g2 = state$8.toToken) == null ? void 0 : _g2.address,
      toTokenAmount: state$8.toTokenAmount,
      toTokenDecimals: (_h2 = state$8.toToken) == null ? void 0 : _h2.decimals,
      sourceTokenAmount: state$8.sourceTokenAmount,
      sourceTokenDecimals: (_i2 = state$8.sourceToken) == null ? void 0 : _i2.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount
    };
  },
  setSourceToken(sourceToken) {
    if (!sourceToken) {
      state$8.sourceToken = sourceToken;
      state$8.sourceTokenAmount = "";
      state$8.sourceTokenPriceInUSD = 0;
      return;
    }
    state$8.sourceToken = sourceToken;
    this.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state$8.sourceTokenAmount = amount;
  },
  setToToken(toToken) {
    if (!toToken) {
      state$8.toToken = toToken;
      state$8.toTokenAmount = "";
      state$8.toTokenPriceInUSD = 0;
      return;
    }
    state$8.toToken = toToken;
    this.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state$8.toTokenAmount = amount ? NumberUtil.formatNumberToLocalString(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    const { availableToSwap } = this.getParams();
    let price = state$8.tokensPriceMap[address] || 0;
    if (!price) {
      state$8.loadingPrices = true;
      price = await this.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state$8.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state$8.toTokenPriceInUSD = price;
    }
    if (state$8.loadingPrices) {
      state$8.loadingPrices = false;
      if (availableToSwap) {
        this.swapTokens();
      }
    }
  },
  switchTokens() {
    if (state$8.initializing || !state$8.initialized) {
      return;
    }
    const newSourceToken = state$8.toToken ? { ...state$8.toToken } : void 0;
    const newToToken = state$8.sourceToken ? { ...state$8.sourceToken } : void 0;
    const newSourceTokenAmount = newSourceToken && state$8.toTokenAmount === "" ? "1" : state$8.toTokenAmount;
    this.setSourceToken(newSourceToken);
    this.setToToken(newToToken);
    this.setSourceTokenAmount(newSourceTokenAmount);
    this.setToTokenAmount("");
    this.swapTokens();
  },
  resetState() {
    state$8.myTokensWithBalance = initialState.myTokensWithBalance;
    state$8.tokensPriceMap = initialState.tokensPriceMap;
    state$8.initialized = initialState.initialized;
    state$8.sourceToken = initialState.sourceToken;
    state$8.sourceTokenAmount = initialState.sourceTokenAmount;
    state$8.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state$8.toToken = initialState.toToken;
    state$8.toTokenAmount = initialState.toTokenAmount;
    state$8.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state$8.networkPrice = initialState.networkPrice;
    state$8.networkTokenSymbol = initialState.networkTokenSymbol;
    state$8.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state$8.inputError = initialState.inputError;
  },
  resetValues() {
    var _a2;
    const { networkAddress } = this.getParams();
    const networkToken = (_a2 = state$8.tokens) == null ? void 0 : _a2.find((token2) => token2.address === networkAddress);
    this.setSourceToken(networkToken);
    this.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state$8.loadingApprovalTransaction;
  },
  clearError() {
    state$8.transactionError = void 0;
  },
  async initializeState() {
    if (state$8.initializing) {
      return;
    }
    state$8.initializing = true;
    if (!state$8.initialized) {
      try {
        await this.fetchTokens();
        state$8.initialized = true;
      } catch (error) {
        state$8.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state$8.initializing = false;
  },
  async fetchTokens() {
    var _a2;
    const { networkAddress } = this.getParams();
    await this.getTokenList();
    await this.getNetworkTokenPrice();
    await this.getMyTokensWithBalance();
    const networkToken = (_a2 = state$8.tokens) == null ? void 0 : _a2.find((token2) => token2.address === networkAddress);
    if (networkToken) {
      state$8.networkTokenSymbol = networkToken.symbol;
      this.setSourceToken(networkToken);
      this.setSourceTokenAmount("1");
    }
  },
  async getTokenList() {
    const tokens = await SwapApiUtil.getTokenList();
    state$8.tokens = tokens;
    state$8.popularTokens = tokens.sort((aTokenInfo, bTokenInfo) => {
      if (aTokenInfo.symbol < bTokenInfo.symbol) {
        return -1;
      }
      if (aTokenInfo.symbol > bTokenInfo.symbol) {
        return 1;
      }
      return 0;
    });
    state$8.suggestedTokens = tokens.filter((token2) => {
      if (ConstantsUtil$2.SWAP_SUGGESTED_TOKENS.includes(token2.symbol)) {
        return true;
      }
      return false;
    }, {});
  },
  async getAddressPrice(address) {
    var _a2, _b2;
    const existPrice = state$8.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [address]
    });
    const fungibles = response.fungibles || [];
    const allTokens = [...state$8.tokens || [], ...state$8.myTokensWithBalance || []];
    const symbol = (_a2 = allTokens == null ? void 0 : allTokens.find((token2) => token2.address === address)) == null ? void 0 : _a2.symbol;
    const price = ((_b2 = fungibles.find((p2) => p2.symbol.toLowerCase() === (symbol == null ? void 0 : symbol.toLowerCase()))) == null ? void 0 : _b2.price) || 0;
    const priceAsFloat = parseFloat(price.toString());
    state$8.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    var _a2;
    const { networkAddress } = this.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [networkAddress]
    });
    const token2 = (_a2 = response.fungibles) == null ? void 0 : _a2[0];
    const price = (token2 == null ? void 0 : token2.price.toString()) || "0";
    state$8.tokensPriceMap[networkAddress] = parseFloat(price);
    state$8.networkTokenSymbol = (token2 == null ? void 0 : token2.symbol) || "";
    state$8.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await SwapApiUtil.getMyTokensWithBalance(forceUpdate);
    if (!balances) {
      return;
    }
    await this.getInitialGasPrice();
    this.setBalances(balances);
  },
  setBalances(balances) {
    const { networkAddress } = this.getParams();
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token2) => token2.address === networkAddress);
    balances.forEach((token2) => {
      state$8.tokensPriceMap[token2.address] = token2.price || 0;
    });
    state$8.myTokensWithBalance = balances.filter((token2) => token2.address.startsWith(caipNetwork.id));
    state$8.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUsd: null };
    }
    const value2 = res.standard;
    const gasFee = BigInt(value2);
    const gasLimit = BigInt(INITIAL_GAS_LIMIT);
    const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state$8.networkPrice, gasLimit, gasFee);
    state$8.gasFee = value2;
    state$8.gasPriceInUSD = gasPrice;
    return { gasPrice: gasFee, gasPriceInUSD: state$8.gasPriceInUSD };
  },
  async swapTokens() {
    var _a2, _b2;
    const address = AccountController.state.address;
    const sourceToken = state$8.sourceToken;
    const toToken = state$8.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state$8.sourceTokenAmount).isGreaterThan(0);
    if (!toToken || !sourceToken || state$8.loadingPrices || !haveSourceTokenAmount) {
      return;
    }
    state$8.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state$8.sourceTokenAmount).multipliedBy(10 ** sourceToken.decimals);
    const quoteResponse = await BlockchainApiController.fetchSwapQuote({
      userAddress: address,
      projectId: OptionsController.state.projectId,
      from: sourceToken.address,
      to: toToken.address,
      gasPrice: state$8.gasFee,
      amount: amountDecimal.toString()
    });
    state$8.loadingQuote = false;
    const quoteToAmount = (_b2 = (_a2 = quoteResponse == null ? void 0 : quoteResponse.quotes) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.toAmount;
    if (!quoteToAmount) {
      return;
    }
    const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).dividedBy(10 ** toToken.decimals).toString();
    this.setToTokenAmount(toTokenAmount);
    const isInsufficientToken = this.hasInsufficientToken(state$8.sourceTokenAmount, sourceToken.address);
    if (isInsufficientToken) {
      state$8.inputError = "Insufficient balance";
    } else {
      state$8.inputError = void 0;
      this.setTransactionDetails();
    }
  },
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = this.getParams();
    const sourceToken = state$8.sourceToken;
    const toToken = state$8.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state$8.loadingQuote) {
      return void 0;
    }
    try {
      state$8.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state$8.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await this.createSwapTransaction();
      } else {
        transaction = await this.createAllowanceTransaction();
      }
      state$8.loadingBuildTransaction = false;
      state$8.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state$8.loadingBuildTransaction = false;
      state$8.approvalTransaction = void 0;
      state$8.swapTransaction = void 0;
      state$8.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, fromAddress, sourceTokenAddress, toTokenAddress } = this.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error(">>> createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        projectId: OptionsController.state.projectId,
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const gasLimit = await ConnectionController.estimateGas({
        address: fromAddress,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        data: response.tx.data
      });
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.from),
        gas: gasLimit,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state$8.toTokenAmount
      };
      state$8.swapTransaction = void 0;
      state$8.approvalTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state$8.approvalTransaction = void 0;
      state$8.swapTransaction = void 0;
      state$8.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = this.getParams();
    const sourceToken = state$8.sourceToken;
    const toToken = state$8.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals).toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        projectId: OptionsController.state.projectId,
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount) : BigInt("0"),
        toAmount: state$8.toTokenAmount
      };
      state$8.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$8.networkPrice, gas, gasPrice);
      state$8.approvalTransaction = void 0;
      state$8.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state$8.approvalTransaction = void 0;
      state$8.swapTransaction = void 0;
      state$8.fetchError = true;
      return void 0;
    }
  },
  async sendTransactionForApproval(data2) {
    const { fromAddress } = this.getParams();
    state$8.loadingApprovalTransaction = true;
    RouterController.pushTransactionStack({
      view: null,
      goBack: true,
      onSuccess() {
        SnackController.showLoading("Approving transaction...");
      }
    });
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        value: BigInt(data2.value),
        gasPrice: BigInt(data2.gasPrice)
      });
      await this.swapTokens();
      await this.getTransaction();
      state$8.approvalTransaction = void 0;
      state$8.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state$8.transactionError = error == null ? void 0 : error.shortMessage;
      state$8.loadingTransaction = false;
    }
  },
  async sendTransactionForSwap(data2) {
    var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2, _i2, _j2, _k2, _l2;
    if (!data2) {
      return void 0;
    }
    const { fromAddress, toTokenAmount } = this.getParams();
    state$8.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${(_a2 = state$8.sourceToken) == null ? void 0 : _a2.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_b2 = state$8.toToken) == null ? void 0 : _b2.symbol}`;
    const snackbarSuccessMessage = `Swapped ${(_c2 = state$8.sourceToken) == null ? void 0 : _c2.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_d2 = state$8.toToken) == null ? void 0 : _d2.symbol}`;
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false,
      onSuccess() {
        SnackController.showLoading(snackbarPendingMessage);
        SwapController.resetState();
      }
    });
    try {
      const forceUpdateAddresses = [(_e3 = state$8.sourceToken) == null ? void 0 : _e3.address, (_f2 = state$8.toToken) == null ? void 0 : _f2.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        gas: data2.gas,
        gasPrice: BigInt(data2.gasPrice),
        value: data2.value
      });
      state$8.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: ((_g2 = NetworkController.state.caipNetwork) == null ? void 0 : _g2.id) || "",
          swapFromToken: ((_h2 = this.state.sourceToken) == null ? void 0 : _h2.symbol) || "",
          swapToToken: ((_i2 = this.state.toToken) == null ? void 0 : _i2.symbol) || "",
          swapfromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SwapController.resetState();
      SwapController.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state$8.transactionError = error == null ? void 0 : error.shortMessage;
      state$8.loadingTransaction = false;
      SnackController.showError((error == null ? void 0 : error.shortMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          network: ((_j2 = NetworkController.state.caipNetwork) == null ? void 0 : _j2.id) || "",
          swapFromToken: ((_k2 = this.state.sourceToken) == null ? void 0 : _k2.symbol) || "",
          swapToToken: ((_l2 = this.state.toToken) == null ? void 0 : _l2.symbol) || "",
          swapfromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state$8.myTokensWithBalance);
    const insufficientNetworkTokenForGas = SwapCalculationUtil.isInsufficientNetworkTokenForGas(state$8.networkBalanceInUSD, state$8.gasPriceInUSD);
    return insufficientNetworkTokenForGas || isInsufficientSourceTokenForSwap;
  },
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = this.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state$8.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$8.networkPrice, BigInt(state$8.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state$8.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state$8.sourceTokenAmount,
      sourceTokenPriceInUSD: state$8.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state$8.toTokenPriceInUSD,
      toTokenAmount: state$8.toTokenAmount
    });
    state$8.maxSlippage = SwapCalculationUtil.getMaxSlippage(state$8.slippage, state$8.toTokenAmount);
    state$8.providerFee = SwapCalculationUtil.getProviderFee(state$8.sourceTokenAmount);
  }
};
const state$7 = proxy({
  isConnected: false,
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false
});
const AccountController = {
  state: state$7,
  subscribe(callback) {
    return subscribe(state$7, () => callback(state$7));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$7, key, callback);
  },
  setIsConnected(isConnected) {
    state$7.isConnected = isConnected;
  },
  setCaipAddress(caipAddress) {
    state$7.caipAddress = caipAddress;
    state$7.address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
  },
  setBalance(balance, balanceSymbol) {
    state$7.balance = balance;
    state$7.balanceSymbol = balanceSymbol;
  },
  setProfileName(profileName) {
    state$7.profileName = profileName;
  },
  setProfileImage(profileImage) {
    state$7.profileImage = profileImage;
  },
  setAddressExplorerUrl(explorerUrl) {
    state$7.addressExplorerUrl = explorerUrl;
  },
  setSmartAccountDeployed(isDeployed) {
    state$7.smartAccountDeployed = isDeployed;
  },
  setCurrentTab(currentTab) {
    state$7.currentTab = currentTab;
  },
  setTokenBalance(tokenBalance) {
    if (tokenBalance) {
      state$7.tokenBalance = ref(tokenBalance);
    }
  },
  setConnectedWalletInfo(connectedWalletInfo) {
    state$7.connectedWalletInfo = connectedWalletInfo;
  },
  setPreferredAccountType(preferredAccountType) {
    state$7.preferredAccountType = preferredAccountType;
  },
  setSocialProvider(socialProvider) {
    if (socialProvider) {
      state$7.socialProvider = socialProvider;
    }
  },
  setSocialWindow(socialWindow) {
    if (socialWindow) {
      state$7.socialWindow = ref(socialWindow);
    }
  },
  async fetchTokenBalance() {
    var _a2;
    const chainId = (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id;
    try {
      if (state$7.address && chainId) {
        const response = await BlockchainApiController.getBalance(state$7.address, chainId);
        const filteredBalances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
        this.setTokenBalance(filteredBalances);
        SwapController.setBalances(SwapApiUtil.mapBalancesToSwapTokens(response.balances));
      }
    } catch (error) {
      SnackController.showError("Failed to fetch token balance");
    }
  },
  resetAccount() {
    state$7.isConnected = false;
    state$7.smartAccountDeployed = false;
    state$7.currentTab = 0;
    state$7.caipAddress = void 0;
    state$7.address = void 0;
    state$7.balance = void 0;
    state$7.balanceSymbol = void 0;
    state$7.profileName = void 0;
    state$7.profileImage = void 0;
    state$7.addressExplorerUrl = void 0;
    state$7.tokenBalance = [];
    state$7.connectedWalletInfo = void 0;
    state$7.preferredAccountType = void 0;
    state$7.socialProvider = void 0;
    state$7.socialWindow = void 0;
  }
};
const state$6 = proxy({
  walletImages: {},
  networkImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
const AssetController = {
  state: state$6,
  subscribeNetworkImages(callback) {
    return subscribe(state$6.networkImages, () => callback(state$6.networkImages));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$6, key, callback);
  },
  subscribe(callback) {
    return subscribe(state$6, () => callback(state$6));
  },
  setWalletImage(key, value2) {
    state$6.walletImages[key] = value2;
  },
  setNetworkImage(key, value2) {
    state$6.networkImages[key] = value2;
  },
  setConnectorImage(key, value2) {
    state$6.connectorImages[key] = value2;
  },
  setTokenImage(key, value2) {
    state$6.tokenImages[key] = value2;
  },
  setCurrencyImage(key, value2) {
    state$6.currencyImages[key] = value2;
  }
};
const baseUrl = CoreHelperUtil.getApiUrl();
const api = new FetchUtil({ baseUrl });
const entries = "40";
const recommendedEntries = "4";
const state$5 = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: [],
  isAnalyticsEnabled: false
});
const ApiController = {
  state: state$5,
  subscribeKey(key, callback) {
    return subscribeKey(state$5, key, callback);
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api.baseUrl}/getWalletImage/${imageId}`;
    const blob2 = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob2));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob2 = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob2));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob2 = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob2));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob2 = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob2));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api.baseUrl}/public/getTokenImage/${symbol}`;
    const blob2 = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob2));
  },
  async fetchNetworkImages() {
    const { requestedCaipNetworks } = NetworkController.state;
    const ids = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id2) => ApiController._fetchNetworkImage(id2)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id2) => ApiController._fetchConnectorImage(id2)));
  },
  async fetchCurrencyImages(currencies = []) {
    await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
  },
  async fetchTokenImages(tokens = []) {
    await Promise.allSettled(tokens.map((token2) => ApiController._fetchTokenImage(token2)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds == null ? void 0 : featuredWalletIds.length) {
      const { data: data2 } = await api.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: (featuredWalletIds == null ? void 0 : featuredWalletIds.length) ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds == null ? void 0 : featuredWalletIds.join(",")
        }
      });
      data2.sort((a2, b2) => featuredWalletIds.indexOf(a2.id) - featuredWalletIds.indexOf(b2.id));
      const images = data2.map((d2) => d2.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id2) => ApiController._fetchWalletImage(id2)));
      state$5.featured = data2;
    }
  },
  async fetchRecommendedWallets() {
    var _a2;
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data: data2, count: count2 } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        entries: recommendedEntries,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude == null ? void 0 : exclude.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data2.map((d2) => d2.image_id).filter(Boolean);
    const recentImages = recent.map((r2) => r2.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id2) => ApiController._fetchWalletImage(id2)));
    state$5.recommended = data2;
    state$5.count = count2 ?? 0;
  },
  async fetchWallets({ page }) {
    var _a2;
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state$5.recommended.map(({ id: id2 }) => id2),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data: data2, count: count2 } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data2.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$5.wallets = CoreHelperUtil.uniqueBy([...state$5.wallets, ...data2], "id");
    state$5.count = count2 > state$5.count ? count2 : state$5.count;
    state$5.page = page;
  },
  async searchWallet({ search }) {
    var _a2;
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state$5.search = [];
    const { data: data2 } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search: search == null ? void 0 : search.trim(),
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: excludeWalletIds == null ? void 0 : excludeWalletIds.join(",")
      }
    });
    const images = data2.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$5.search = data2;
  },
  async reFetchWallets() {
    state$5.page = 1;
    state$5.wallets = [];
    await ApiController.fetchFeaturedWallets();
    await ApiController.fetchRecommendedWallets();
  },
  prefetch() {
    const promises = [
      ApiController.fetchFeaturedWallets(),
      ApiController.fetchRecommendedWallets(),
      ApiController.fetchNetworkImages(),
      ApiController.fetchConnectorImages()
    ];
    if (OptionsController.state.enableAnalytics === void 0) {
      promises.push(ApiController.fetchAnalyticsConfig());
    }
    state$5.prefetchPromise = Promise.race([Promise.allSettled(promises), CoreHelperUtil.wait(3e3)]);
  },
  async fetchAnalyticsConfig() {
    const { isAnalyticsEnabled } = await api.get({
      path: "/getAnalyticsConfig",
      headers: ApiController._getApiHeaders()
    });
    OptionsController.setEnableAnalytics(isAnalyticsEnabled);
  }
};
const state$4 = proxy({
  loading: false,
  open: false
});
const ModalController = {
  state: state$4,
  subscribe(callback) {
    return subscribe(state$4, () => callback(state$4));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$4, key, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    const connected = AccountController.state.isConnected;
    if (options == null ? void 0 : options.view) {
      RouterController.reset(options.view);
    } else if (connected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state$4.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected }
    });
  },
  close() {
    const connected = AccountController.state.isConnected;
    state$4.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_CLOSE",
      properties: { connected }
    });
  },
  setLoading(loading) {
    state$4.loading = loading;
    PublicStateController.set({ loading });
  }
};
const USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
const USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
const defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
const state$3 = proxy(defaultState);
const OnRampController = {
  state: state$3,
  subscribe(callback) {
    return subscribe(state$3, () => callback(state$3));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$3, key, callback);
  },
  setSelectedProvider(provider) {
    state$3.selectedProvider = provider;
  },
  setPurchaseCurrency(currency) {
    state$3.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state$3.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    this.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    this.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state$3.purchaseCurrencies = options.purchaseCurrencies;
    state$3.paymentCurrencies = options.paymentCurrencies;
    state$3.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state$3.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    var _a2, _b2;
    state$3.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state$3.purchaseCurrency,
        paymentCurrency: state$3.paymentCurrency,
        amount: ((_a2 = state$3.paymentAmount) == null ? void 0 : _a2.toString()) || "0",
        network: (_b2 = state$3.purchaseCurrency) == null ? void 0 : _b2.symbol
      });
      state$3.quotesLoading = false;
      state$3.purchaseAmount = Number(quote.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state$3.error = error.message;
      state$3.quotesLoading = false;
      return null;
    } finally {
      state$3.quotesLoading = false;
    }
  },
  resetState() {
    state$3.providers = ONRAMP_PROVIDERS;
    state$3.selectedProvider = null;
    state$3.error = null;
    state$3.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state$3.paymentCurrency = USD_CURRENCY_DEFAULT;
    state$3.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state$3.paymentCurrencies = [];
    state$3.paymentAmount = void 0;
    state$3.purchaseAmount = void 0;
    state$3.quotesLoading = false;
  }
};
const state$2 = proxy({
  loading: false
});
const SendController = {
  state: state$2,
  subscribe(callback) {
    return subscribe(state$2, () => callback(state$2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$2, key, callback);
  },
  setToken(token2) {
    if (token2) {
      state$2.token = ref(token2);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state$2.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state$2.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state$2.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state$2.receiverProfileName = receiverProfileName;
  },
  setGasPrice(gasPrice) {
    state$2.gasPrice = gasPrice;
  },
  setGasPriceInUsd(gasPriceInUSD) {
    state$2.gasPriceInUSD = gasPriceInUSD;
  },
  setLoading(loading) {
    state$2.loading = loading;
  },
  sendToken() {
    var _a2, _b2, _c2, _d2, _e3;
    if (((_a2 = this.state.token) == null ? void 0 : _a2.address) && this.state.sendTokenAmount && this.state.receiverAddress) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token.address,
          amount: this.state.sendTokenAmount,
          network: ((_b2 = NetworkController.state.caipNetwork) == null ? void 0 : _b2.id) || ""
        }
      });
      this.sendERC20Token({
        receiverAddress: this.state.receiverAddress,
        tokenAddress: this.state.token.address,
        sendTokenAmount: this.state.sendTokenAmount,
        decimals: this.state.token.quantity.decimals
      });
    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && ((_c2 = this.state.token) == null ? void 0 : _c2.quantity.decimals)) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: (_d2 = this.state.token) == null ? void 0 : _d2.symbol,
          amount: this.state.sendTokenAmount,
          network: ((_e3 = NetworkController.state.caipNetwork) == null ? void 0 : _e3.id) || ""
        }
      });
      this.sendNativeToken({
        receiverAddress: this.state.receiverAddress,
        sendTokenAmount: this.state.sendTokenAmount,
        gasPrice: this.state.gasPrice,
        decimals: this.state.token.quantity.decimals
      });
    }
  },
  async sendNativeToken(params) {
    var _a2, _b2, _c2, _d2;
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const to2 = params.receiverAddress;
    const address = AccountController.state.address;
    const value2 = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    const data2 = "0x";
    try {
      await ConnectionController.sendTransaction({
        to: to2,
        address,
        data: data2,
        value: value2,
        gasPrice: params.gasPrice
      });
      SnackController.showSuccess("Transaction started");
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_a2 = this.state.token) == null ? void 0 : _a2.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_b2 = NetworkController.state.caipNetwork) == null ? void 0 : _b2.id) || ""
        }
      });
      this.resetSend();
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_c2 = this.state.token) == null ? void 0 : _c2.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_d2 = NetworkController.state.caipNetwork) == null ? void 0 : _d2.id) || ""
        }
      });
      SnackController.showError("Something went wrong");
    }
  },
  async sendERC20Token(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    try {
      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
        await ConnectionController.writeContract({
          fromAddress: AccountController.state.address,
          tokenAddress: CoreHelperUtil.getPlainAddress(params.tokenAddress),
          receiverAddress: params.receiverAddress,
          tokenAmount: amount,
          method: "transfer",
          abi: erc20ABI
        });
        SnackController.showSuccess("Transaction started");
        this.resetSend();
      }
    } catch (error) {
      SnackController.showError("Something went wrong");
    }
  },
  resetSend() {
    state$2.token = void 0;
    state$2.sendTokenAmount = void 0;
    state$2.receiverAddress = void 0;
    state$2.receiverProfileImageUrl = void 0;
    state$2.receiverProfileName = void 0;
    state$2.loading = false;
  }
};
const state$1 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
const TooltipController = {
  state: state$1,
  subscribe(callback) {
    return subscribe(state$1, () => callback(state$1));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state$1, key, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state$1.open = true;
    state$1.message = message;
    state$1.triggerRect = triggerRect;
    state$1.variant = variant;
  },
  hide() {
    state$1.open = false;
    state$1.message = "";
    state$1.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
const SLIP44_MSB = 2147483648;
const EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};
const state = proxy({
  suggestions: [],
  loading: false
});
const EnsController = {
  state,
  subscribe(callback) {
    return subscribe(state, () => callback(state));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  async resolveName(name) {
    var _a2, _b2;
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e2) {
      const error = e2;
      throw new Error(((_b2 = (_a2 = error == null ? void 0 : error.reasons) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.description) || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(name) {
    try {
      state.loading = true;
      state.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(name);
      state.suggestions = response.suggestions.map((suggestion) => ({
        ...suggestion,
        name: suggestion.name.replace(ConstantsUtil$3.WC_NAME_SUFFIX, "")
      })) || [];
      return state.suggestions;
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = NetworkController.state.caipNetwork;
      if (!network) {
        return [];
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      return response;
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = NetworkController.state.caipNetwork;
    if (!network) {
      throw new Error("Network not found");
    }
    const address = AccountController.state.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    if (!this.isAllowedToRegisterName()) {
      throw new Error("Not allowed to register name");
    }
    state.loading = true;
    try {
      const message = JSON.stringify({
        name: `${name}${ConstantsUtil$3.WC_NAME_SUFFIX}`,
        attributes: {},
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        view: "RegisterAccountNameSuccess",
        goBack: false,
        replace: true,
        onCancel() {
          state.loading = false;
        }
      });
      const signature = await ConnectionController.signMessage(message);
      const networkId = NetworkUtil.caipNetworkIdToNumber(network.id);
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(networkId);
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature,
        message
      });
      AccountController.setProfileName(`${name}${ConstantsUtil$3.WC_NAME_SUFFIX}`);
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    var _a2, _b2;
    const ensError = error;
    return ((_b2 = (_a2 = ensError == null ? void 0 : ensError.reasons) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.description) || defaultError;
  },
  isAllowedToRegisterName() {
    var _a2;
    const emailConnector = ConnectorController.getAuthConnector();
    const email = (emailConnector == null ? void 0 : emailConnector.provider.getEmail()) || "";
    const domain = (_a2 = email.split("@")) == null ? void 0 : _a2[1];
    return domain && ConstantsUtil$3.WC_NAMES_ALLOWED_DOMAINS.includes(domain);
  }
};
const AssetUtil = {
  getWalletImage(wallet) {
    if (wallet == null ? void 0 : wallet.image_url) {
      return wallet == null ? void 0 : wallet.image_url;
    }
    if (wallet == null ? void 0 : wallet.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network == null ? void 0 : network.imageUrl) {
      return network == null ? void 0 : network.imageUrl;
    }
    if (network == null ? void 0 : network.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getConnectorImage(connector) {
    if (connector == null ? void 0 : connector.imageUrl) {
      return connector.imageUrl;
    }
    if (connector == null ? void 0 : connector.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  }
};
const RouterUtil = {
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  },
  navigateAfterNetworkSwitch() {
    const { history } = RouterController.state;
    const networkSelectIndex = history.findIndex((name) => name === "Networks");
    if (networkSelectIndex >= 1) {
      RouterController.goBackToIndex(networkSelectIndex - 1);
    } else {
      ModalController.close();
    }
  },
  navigateAfterPreferredAccountTypeSelect() {
    const { isSiweEnabled } = OptionsController.state;
    const { profileName } = AccountController.state;
    if (isSiweEnabled) {
      RouterController.push("ConnectingSiwe");
    } else if (profileName) {
      RouterController.push("Account");
    } else {
      RouterController.push("ChooseAccountName");
    }
  }
};
const ConstantsUtil$1 = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  AUTH_CONNECTOR_ID: "w3mAuth",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet"
  },
  VERSION: "5.0.0"
};
class StructError2 extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
}
function isIterable(x2) {
  return isObject(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject(x2) {
  return typeof x2 === "object" && x2 != null;
}
function print(value2) {
  return typeof value2 === "string" ? JSON.stringify(value2) : "" + value2;
}
function shiftIterator(input) {
  const {
    done,
    value: value2
  } = input.next();
  return done ? void 0 : value2;
}
function toFailure(result, context, struct2, value2) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type3
  } = struct2;
  const {
    refinement,
    message = "Expected a value of type `" + type3 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value2) + "`"
  } = result;
  return {
    value: value2,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value2) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure(r2, context, struct2, value2);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value2, struct2, options = {}) {
  const {
    path = [],
    branch = [value2],
    coerce: coerce2 = false,
    mask: mask2 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce2) {
    value2 = struct2.coercer(value2, ctx);
    if (mask2 && struct2.type !== "type" && isObject(struct2.schema) && isObject(value2) && !Array.isArray(value2)) {
      for (const key in value2) {
        if (struct2.schema[key] === void 0) {
          delete value2[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct2.validator(value2, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k2, v2, s2] of struct2.entries(value2, ctx)) {
    const ts = run(v2, s2, {
      path: k2 === void 0 ? path : [...path, k2],
      branch: k2 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2
    });
    for (const t2 of ts) {
      if (t2[0]) {
        valid = false;
        yield [t2[0], void 0];
      } else if (coerce2) {
        v2 = t2[1];
        if (k2 === void 0) {
          value2 = v2;
        } else if (value2 instanceof Map) {
          value2.set(k2, v2);
        } else if (value2 instanceof Set) {
          value2.add(v2);
        } else if (isObject(value2)) {
          value2[k2] = v2;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct2.refiner(value2, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value2];
  }
}
let Struct$1 = class Struct3 {
  constructor(props) {
    const {
      type: type3,
      schema,
      validator,
      refiner,
      coercer = (value2) => value2,
      entries: entries2 = function* () {
      }
    } = props;
    this.type = type3;
    this.schema = schema;
    this.entries = entries2;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value2, context) => {
        const result = validator(value2, context);
        return toFailures(result, context, this, value2);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value2, context) => {
        const result = refiner(value2, context);
        return toFailures(result, context, this, value2);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value2) {
    return assert$6(value2, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value2) {
    return create(value2, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value2) {
    return is(value2, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value2) {
    return mask(value2, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value2, options = {}) {
    return validate(value2, this, options);
  }
};
function assert$6(value2, struct2) {
  const result = validate(value2, struct2);
  if (result[0]) {
    throw result[0];
  }
}
function create(value2, struct2) {
  const result = validate(value2, struct2, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value2, struct2) {
  const result = validate(value2, struct2, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value2, struct2) {
  const result = validate(value2, struct2);
  return !result[0];
}
function validate(value2, struct2, options = {}) {
  const tuples = run(value2, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError2(tuple2[0], function* () {
      for (const t2 of tuples) {
        if (t2[0]) {
          yield t2[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function define(name, validator) {
  return new Struct$1({
    type: name,
    schema: null,
    validator
  });
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct$1({
    type: "array",
    schema: Element,
    *entries(value2) {
      if (Element && Array.isArray(value2)) {
        for (const [i2, v2] of value2.entries()) {
          yield [i2, v2, Element];
        }
      }
    },
    coercer(value2) {
      return Array.isArray(value2) ? value2.slice() : value2;
    },
    validator(value2) {
      return Array.isArray(value2) || "Expected an array value, but received: " + print(value2);
    }
  });
}
function boolean() {
  return define("boolean", (value2) => {
    return typeof value2 === "boolean";
  });
}
function instance(Class) {
  return define("instance", (value2) => {
    return value2 instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value2);
  });
}
function literal(constant) {
  const description = print(constant);
  const t2 = typeof constant;
  return new Struct$1({
    type: "literal",
    schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
    validator(value2) {
      return value2 === constant || "Expected the literal `" + description + "`, but received: " + print(value2);
    }
  });
}
function never() {
  return define("never", () => false);
}
function nullable(struct2) {
  return new Struct$1({
    ...struct2,
    validator: (value2, ctx) => value2 === null || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === null || struct2.refiner(value2, ctx)
  });
}
function number$1() {
  return define("number", (value2) => {
    return typeof value2 === "number" && !isNaN(value2) || "Expected a number, but received: " + print(value2);
  });
}
function optional(struct2) {
  return new Struct$1({
    ...struct2,
    validator: (value2, ctx) => value2 === void 0 || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === void 0 || struct2.refiner(value2, ctx)
  });
}
function record(Key, Value) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(value2) {
      if (isObject(value2)) {
        for (const k2 in value2) {
          const v2 = value2[k2];
          yield [k2, k2, Key];
          yield [k2, v2, Value];
        }
      }
    },
    validator(value2) {
      return isObject(value2) || "Expected an object, but received: " + print(value2);
    }
  });
}
function string() {
  return define("string", (value2) => {
    return typeof value2 === "string" || "Expected a string, but received: " + print(value2);
  });
}
function tuple(Elements) {
  const Never = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(value2) {
      if (Array.isArray(value2)) {
        const length2 = Math.max(Elements.length, value2.length);
        for (let i2 = 0; i2 < length2; i2++) {
          yield [i2, value2[i2], Elements[i2] || Never];
        }
      }
    },
    validator(value2) {
      return Array.isArray(value2) || "Expected an array, but received: " + print(value2);
    }
  });
}
function type2(schema) {
  const keys = Object.keys(schema);
  return new Struct$1({
    type: "type",
    schema,
    *entries(value2) {
      if (isObject(value2)) {
        for (const k2 of keys) {
          yield [k2, value2[k2], schema[k2]];
        }
      }
    },
    validator(value2) {
      return isObject(value2) || "Expected an object, but received: " + print(value2);
    }
  });
}
function union(Structs) {
  const description = Structs.map((s2) => s2.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    validator(value2, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value2, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value2), ...failures];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce(struct2, condition, coercer) {
  return new Struct$1({
    ...struct2,
    coercer: (value2, ctx) => {
      return is(value2, condition) ? struct2.coercer(coercer(value2, ctx), ctx) : struct2.coercer(value2, ctx);
    }
  });
}
var client = {};
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix2 = false;
  }
  function EE(fn2, context, once3) {
    this.fn = fn2;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn2, context, once3) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once3), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names = [], events2, name;
    if (this._eventsCount === 0) return names;
    for (name in events2 = this._events) {
      if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners2 = this._events[evt];
    if (!listeners2) return 0;
    if (listeners2.fn) return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners2[i2].once) this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
              args[j2 - 1] = arguments[j2];
            }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context) {
    return addListener2(this, event, fn2, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn2, context) {
    return addListener2(this, event, fn2, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context, once3) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length2 = listeners2.length; i2 < length2; i2++) {
        if (listeners2[i2].fn !== fn2 || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var utils$c = {};
Object.defineProperty(utils$c, "__esModule", { value: true });
utils$c.createError = utils$c.DefaultDataPack = void 0;
const errors = /* @__PURE__ */ new Map([
  [-32e3, "Event not provided"],
  [-32600, "Invalid Request"],
  [-32601, "Method not found"],
  [-32602, "Invalid params"],
  [-32603, "Internal error"],
  [-32604, "Params not found"],
  [-32605, "Method forbidden"],
  [-32606, "Event forbidden"],
  [-32700, "Parse error"]
]);
class DefaultDataPack {
  encode(value2) {
    return JSON.stringify(value2);
  }
  decode(value2) {
    return JSON.parse(value2);
  }
}
utils$c.DefaultDataPack = DefaultDataPack;
function createError(code2, details) {
  const error = {
    code: code2,
    message: errors.get(code2) || "Internal Server Error"
  };
  if (details)
    error["data"] = details;
  return error;
}
utils$c.createError = createError;
Object.defineProperty(client, "__esModule", { value: true });
const eventemitter3_1$1 = eventemitter3Exports;
const utils_1 = utils$c;
class CommonClient extends eventemitter3_1$1.EventEmitter {
  /**
   * Instantiate a Client class.
   * @constructor
   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
   * @param {String} address - url to a websocket server
   * @param {Object} options - ws options object with reconnect parameters
   * @param {Function} generate_request_id - custom generation request Id
   * @param {DataPack} dataPack - data pack contains encoder and decoder
   * @return {CommonClient}
   */
  constructor(webSocketFactory, address = "ws://localhost:8080", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack) {
    super();
    __publicField(this, "address");
    __publicField(this, "rpc_id");
    __publicField(this, "queue");
    __publicField(this, "options");
    __publicField(this, "autoconnect");
    __publicField(this, "ready");
    __publicField(this, "reconnect");
    __publicField(this, "reconnect_timer_id");
    __publicField(this, "reconnect_interval");
    __publicField(this, "max_reconnects");
    __publicField(this, "rest_options");
    __publicField(this, "current_reconnects");
    __publicField(this, "generate_request_id");
    __publicField(this, "socket");
    __publicField(this, "webSocketFactory");
    __publicField(this, "dataPack");
    this.webSocketFactory = webSocketFactory;
    this.queue = {};
    this.rpc_id = 0;
    this.address = address;
    this.autoconnect = autoconnect;
    this.ready = false;
    this.reconnect = reconnect;
    this.reconnect_timer_id = void 0;
    this.reconnect_interval = reconnect_interval;
    this.max_reconnects = max_reconnects;
    this.rest_options = rest_options;
    this.current_reconnects = 0;
    this.generate_request_id = generate_request_id || (() => ++this.rpc_id);
    if (!dataPack)
      this.dataPack = new utils_1.DefaultDataPack();
    else
      this.dataPack = dataPack;
    if (this.autoconnect)
      this._connect(this.address, {
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects,
        ...this.rest_options
      });
  }
  /**
   * Connects to a defined server if not connected already.
   * @method
   * @return {Undefined}
   */
  connect() {
    if (this.socket)
      return;
    this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
   * Calls a registered RPC method on server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object|Array} params - optional method parameters
   * @param {Number} timeout - RPC reply timeout value
   * @param {Object} ws_opts - options passed to ws
   * @return {Promise}
   */
  call(method, params, timeout, ws_opts) {
    if (!ws_opts && "object" === typeof timeout) {
      ws_opts = timeout;
      timeout = null;
    }
    return new Promise((resolve, reject) => {
      if (!this.ready)
        return reject(new Error("socket not ready"));
      const rpc_id = this.generate_request_id(method, params);
      const message = {
        jsonrpc: "2.0",
        method,
        params: params || void 0,
        id: rpc_id
      };
      this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
        if (error)
          return reject(error);
        this.queue[rpc_id] = { promise: [resolve, reject] };
        if (timeout) {
          this.queue[rpc_id].timeout = setTimeout(() => {
            delete this.queue[rpc_id];
            reject(new Error("reply timeout"));
          }, timeout);
        }
      });
    });
  }
  /**
   * Logins with the other side of the connection.
   * @method
   * @param {Object} params - Login credentials object
   * @return {Promise}
   */
  async login(params) {
    const resp = await this.call("rpc.login", params);
    if (!resp)
      throw new Error("authentication failed");
    return resp;
  }
  /**
   * Fetches a list of client's methods registered on server.
   * @method
   * @return {Array}
   */
  async listMethods() {
    return await this.call("__listMethods");
  }
  /**
   * Sends a JSON-RPC 2.0 notification to server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object} params - optional method parameters
   * @return {Promise}
   */
  notify(method, params) {
    return new Promise((resolve, reject) => {
      if (!this.ready)
        return reject(new Error("socket not ready"));
      const message = {
        jsonrpc: "2.0",
        method,
        params
      };
      this.socket.send(this.dataPack.encode(message), (error) => {
        if (error)
          return reject(error);
        resolve();
      });
    });
  }
  /**
   * Subscribes for a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async subscribe(event) {
    if (typeof event === "string")
      event = [event];
    const result = await this.call("rpc.on", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
    return result;
  }
  /**
   * Unsubscribes from a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async unsubscribe(event) {
    if (typeof event === "string")
      event = [event];
    const result = await this.call("rpc.off", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error("Failed unsubscribing from an event with: " + result);
    return result;
  }
  /**
   * Closes a WebSocket connection gracefully.
   * @method
   * @param {Number} code - socket close code
   * @param {String} data - optional data to be sent before closing
   * @return {Undefined}
   */
  close(code2, data2) {
    this.socket.close(code2 || 1e3, data2);
  }
  /**
   * Enable / disable automatic reconnection.
   * @method
   * @param {Boolean} reconnect - enable / disable reconnection
   * @return {Undefined}
   */
  setAutoReconnect(reconnect) {
    this.reconnect = reconnect;
  }
  /**
   * Set the interval between reconnection attempts.
   * @method
   * @param {Number} interval - reconnection interval in milliseconds
   * @return {Undefined}
   */
  setReconnectInterval(interval) {
    this.reconnect_interval = interval;
  }
  /**
   * Set the maximum number of reconnection attempts.
   * @method
   * @param {Number} max_reconnects - maximum reconnection attempts
   * @return {Undefined}
   */
  setMaxReconnects(max_reconnects) {
    this.max_reconnects = max_reconnects;
  }
  /**
   * Connection/Message handler.
   * @method
   * @private
   * @param {String} address - WebSocket API address
   * @param {Object} options - ws options object
   * @return {Undefined}
   */
  _connect(address, options) {
    clearTimeout(this.reconnect_timer_id);
    this.socket = this.webSocketFactory(address, options);
    this.socket.addEventListener("open", () => {
      this.ready = true;
      this.emit("open");
      this.current_reconnects = 0;
    });
    this.socket.addEventListener("message", ({ data: message }) => {
      if (message instanceof ArrayBuffer)
        message = Buffer.from(message).toString();
      try {
        message = this.dataPack.decode(message);
      } catch (error) {
        return;
      }
      if (message.notification && this.listeners(message.notification).length) {
        if (!Object.keys(message.params).length)
          return this.emit(message.notification);
        const args = [message.notification];
        if (message.params.constructor === Object)
          args.push(message.params);
        else
          for (let i2 = 0; i2 < message.params.length; i2++)
            args.push(message.params[i2]);
        return Promise.resolve().then(() => {
          this.emit.apply(this, args);
        });
      }
      if (!this.queue[message.id]) {
        if (message.method) {
          return Promise.resolve().then(() => {
            this.emit(message.method, message == null ? void 0 : message.params);
          });
        }
        return;
      }
      if ("error" in message === "result" in message)
        this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
      if (this.queue[message.id].timeout)
        clearTimeout(this.queue[message.id].timeout);
      if (message.error)
        this.queue[message.id].promise[1](message.error);
      else
        this.queue[message.id].promise[0](message.result);
      delete this.queue[message.id];
    });
    this.socket.addEventListener("error", (error) => this.emit("error", error));
    this.socket.addEventListener("close", ({ code: code2, reason }) => {
      if (this.ready)
        setTimeout(() => this.emit("close", code2, reason), 0);
      this.ready = false;
      this.socket = void 0;
      if (code2 === 1e3)
        return;
      this.current_reconnects++;
      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
        this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);
    });
  }
}
client.default = CommonClient;
var websocket_browser = {};
Object.defineProperty(websocket_browser, "__esModule", { value: true });
const eventemitter3_1 = eventemitter3Exports;
class WebSocketBrowserImpl extends eventemitter3_1.EventEmitter {
  /** Instantiate a WebSocket class
   * @constructor
   * @param {String} address - url to a websocket server
   * @param {(Object)} options - websocket options
   * @param {(String|Array)} protocols - a list of protocols
   * @return {WebSocketBrowserImpl} - returns a WebSocket instance
   */
  constructor(address, options, protocols) {
    super();
    __publicField(this, "socket");
    this.socket = new window.WebSocket(address, protocols);
    this.socket.onopen = () => this.emit("open");
    this.socket.onmessage = (event) => this.emit("message", event.data);
    this.socket.onerror = (error) => this.emit("error", error);
    this.socket.onclose = (event) => {
      this.emit("close", event.code, event.reason);
    };
  }
  /**
   * Sends data through a websocket connection
   * @method
   * @param {(String|Object)} data - data to be sent via websocket
   * @param {Object} optionsOrCallback - ws options
   * @param {Function} callback - a callback called once the data is sent
   * @return {Undefined}
   */
  send(data2, optionsOrCallback, callback) {
    const cb2 = callback || optionsOrCallback;
    try {
      this.socket.send(data2);
      cb2();
    } catch (error) {
      cb2(error);
    }
  }
  /**
   * Closes an underlying socket
   * @method
   * @param {Number} code - status code explaining why the connection is being closed
   * @param {String} reason - a description why the connection is closing
   * @return {Undefined}
   * @throws {Error}
   */
  close(code2, reason) {
    this.socket.close(code2, reason);
  }
  addEventListener(type3, listener, options) {
    this.socket.addEventListener(type3, listener, options);
  }
}
function default_1(address, options) {
  return new WebSocketBrowserImpl(address, options);
}
websocket_browser.default = default_1;
function isOnCurve(publicKey2) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
const toBuffer = (arr) => {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};
class Struct4 {
  constructor(properties2) {
    Object.assign(this, properties2);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(data2) {
    return deserialize_1(SOLANA_SCHEMA, this, data2);
  }
  static decodeUnchecked(data2) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, data2);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _class;
let _Symbol$toStringTag;
const MAX_SEED_LENGTH = 32;
const PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value2) {
  return value2._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey2 extends Struct4 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value2) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value2)) {
      this._bn = value2._bn;
    } else {
      if (typeof value2 === "string") {
        const decoded = bs58$1.decode(value2);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new BN$1(decoded);
      } else {
        this._bn = new BN$1(value2);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey2(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey2(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$1.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b2 = this._bn.toArrayLike(buffer.Buffer);
    if (b2.length === PUBLIC_KEY_LENGTH) {
      return b2;
    }
    const zeroPad = buffer.Buffer.alloc(32);
    b2.copy(zeroPad, 32 - b2.length);
    return zeroPad;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed2, programId) {
    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed2), programId.toBuffer()]);
    const publicKeyBytes = sha256$3(buffer$1);
    return new PublicKey2(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer$1 = buffer.Buffer.alloc(0);
    seeds.forEach(function(seed2) {
      if (seed2.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed2)]);
    });
    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256$3(buffer$1);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey2(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey2(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_class = PublicKey2;
PublicKey2.default = new _class("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey2, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey2("BPFLoader1111111111111111111111111111111111");
const SIGNATURE_LENGTH_IN_BYTES = 64;
const publicKey = (property = "publicKey") => {
  return blob(32, property);
};
const rustString = (property = "string") => {
  const rsl = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b2, offset2) => {
    const data2 = _decode(b2, offset2);
    return data2["chars"].toString();
  };
  rslShim.encode = (str, b2, offset2) => {
    const data2 = {
      chars: buffer.Buffer.from(str, "utf8")
    };
    return _encode(data2, b2, offset2);
  };
  rslShim.alloc = (str) => {
    return u32().span + u32().span + buffer.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
const authorized = (property = "authorized") => {
  return struct([publicKey("staker"), publicKey("withdrawer")], property);
};
const lockup = (property = "lockup") => {
  return struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], property);
};
const voteInit = (property = "voteInit") => {
  return struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], property);
};
const voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return struct([u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
new PublicKey2("SysvarC1ock11111111111111111111111111111111");
new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey2("Sysvar1nstructions1111111111111111111111111");
new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey2("SysvarRent111111111111111111111111111111111");
new PublicKey2("SysvarRewards111111111111111111111111111111");
new PublicKey2("SysvarS1otHashes111111111111111111111111111");
new PublicKey2("SysvarS1otHistory11111111111111111111111111");
new PublicKey2("SysvarStakeHistory1111111111111111111111111");
const FeeCalculatorLayout = nu64("lamportsPerSignature");
const NonceAccountLayout = struct([u32("version"), u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]);
NonceAccountLayout.span;
const encodeDecode = (layout) => {
  const decode3 = layout.decode.bind(layout);
  const encode4 = layout.encode.bind(layout);
  return {
    decode: decode3,
    encode: encode4
  };
};
const bigInt = (length2) => (property) => {
  const layout = blob(length2, property);
  const {
    encode: encode4,
    decode: decode3
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer$1, offset2) => {
    const src2 = decode3(buffer$1, offset2);
    return toBigIntLE_1(buffer.Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt2, buffer2, offset2) => {
    const src2 = toBufferLE_1(bigInt2, length2);
    return encode4(src2, buffer2, offset2);
  };
  return bigIntLayout;
};
const u64 = bigInt(8);
Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
new PublicKey2("11111111111111111111111111111111");
new PublicKey2("BPFLoader2111111111111111111111111111111111");
({
  index: 1,
  layout: struct([
    u32("typeIndex"),
    u64("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    // option
    seq(publicKey(), offset(u8(), -1), "authority")
  ])
});
const PublicKeyFromString = coerce(instance(PublicKey2), string(), (value2) => new PublicKey2(value2));
const RawAccountDataResult = tuple([string(), literal("base64")]);
const BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, (value2) => buffer.Buffer.from(value2[0], "base64"));
function createRpcResult(result) {
  return union([type2({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type2({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type2({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value2) => {
    if ("error" in value2) {
      return value2;
    } else {
      return {
        ...value2,
        result: create(value2.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value2) {
  return jsonRpcResult(type2({
    context: type2({
      slot: number$1()
    }),
    value: value2
  }));
}
function notificationResultAndContext(value2) {
  return type2({
    context: type2({
      slot: number$1()
    }),
    value: value2
  });
}
const GetInflationGovernorResult = type2({
  foundation: number$1(),
  foundationTerm: number$1(),
  initial: number$1(),
  taper: number$1(),
  terminal: number$1()
});
jsonRpcResult(array(nullable(type2({
  epoch: number$1(),
  effectiveSlot: number$1(),
  amount: number$1(),
  postBalance: number$1(),
  commission: optional(nullable(number$1()))
}))));
const GetRecentPrioritizationFeesResult = array(type2({
  slot: number$1(),
  prioritizationFee: number$1()
}));
const GetInflationRateResult = type2({
  total: number$1(),
  validator: number$1(),
  foundation: number$1(),
  epoch: number$1()
});
const GetEpochInfoResult = type2({
  epoch: number$1(),
  slotIndex: number$1(),
  slotsInEpoch: number$1(),
  absoluteSlot: number$1(),
  blockHeight: optional(number$1()),
  transactionCount: optional(number$1())
});
const GetEpochScheduleResult = type2({
  slotsPerEpoch: number$1(),
  leaderScheduleSlotOffset: number$1(),
  warmup: boolean(),
  firstNormalEpoch: number$1(),
  firstNormalSlot: number$1()
});
const GetLeaderScheduleResult = record(string(), array(number$1()));
const TransactionErrorResult = nullable(union([type2({}), string()]));
const SignatureStatusResult = type2({
  err: TransactionErrorResult
});
const SignatureReceivedResult = literal("receivedSignature");
type2({
  "solana-core": string(),
  "feature-set": optional(number$1())
});
jsonRpcResultAndContext(type2({
  err: nullable(union([type2({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type2({
    executable: boolean(),
    owner: string(),
    lamports: number$1(),
    data: array(string()),
    rentEpoch: optional(number$1())
  }))))),
  unitsConsumed: optional(number$1()),
  returnData: optional(nullable(type2({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
}));
jsonRpcResultAndContext(type2({
  byIdentity: record(string(), array(number$1())),
  range: type2({
    firstSlot: number$1(),
    lastSlot: number$1()
  })
}));
jsonRpcResult(GetInflationGovernorResult);
jsonRpcResult(GetInflationRateResult);
jsonRpcResult(GetRecentPrioritizationFeesResult);
jsonRpcResult(GetEpochInfoResult);
jsonRpcResult(GetEpochScheduleResult);
jsonRpcResult(GetLeaderScheduleResult);
jsonRpcResult(number$1());
jsonRpcResultAndContext(type2({
  total: number$1(),
  circulating: number$1(),
  nonCirculating: number$1(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
const TokenAmountResult = type2({
  amount: string(),
  uiAmount: nullable(number$1()),
  decimals: number$1(),
  uiAmountString: optional(string())
});
jsonRpcResultAndContext(array(type2({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number$1()),
  decimals: number$1(),
  uiAmountString: optional(string())
})));
jsonRpcResultAndContext(array(type2({
  pubkey: PublicKeyFromString,
  account: type2({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number$1(),
    data: BufferFromRawAccountData,
    rentEpoch: number$1()
  })
})));
const ParsedAccountDataResult = type2({
  program: string(),
  parsed: unknown(),
  space: number$1()
});
jsonRpcResultAndContext(array(type2({
  pubkey: PublicKeyFromString,
  account: type2({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number$1(),
    data: ParsedAccountDataResult,
    rentEpoch: number$1()
  })
})));
jsonRpcResultAndContext(array(type2({
  lamports: number$1(),
  address: PublicKeyFromString
})));
const AccountInfoResult = type2({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number$1(),
  data: BufferFromRawAccountData,
  rentEpoch: number$1()
});
type2({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value2) => {
  if (Array.isArray(value2)) {
    return create(value2, BufferFromRawAccountData);
  } else {
    return value2;
  }
});
const ParsedAccountInfoResult = type2({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number$1(),
  data: ParsedOrRawAccountData,
  rentEpoch: number$1()
});
type2({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
type2({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number$1(),
  inactive: number$1()
});
jsonRpcResult(array(type2({
  signature: string(),
  slot: number$1(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number$1()))
})));
jsonRpcResult(array(type2({
  signature: string(),
  slot: number$1(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number$1()))
})));
type2({
  subscription: number$1(),
  result: notificationResultAndContext(AccountInfoResult)
});
const ProgramAccountInfoResult = type2({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
type2({
  subscription: number$1(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
const SlotInfoResult = type2({
  parent: number$1(),
  slot: number$1(),
  root: number$1()
});
type2({
  subscription: number$1(),
  result: SlotInfoResult
});
const SlotUpdateResult = union([type2({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number$1(),
  timestamp: number$1()
}), type2({
  type: literal("createdBank"),
  parent: number$1(),
  slot: number$1(),
  timestamp: number$1()
}), type2({
  type: literal("frozen"),
  slot: number$1(),
  timestamp: number$1(),
  stats: type2({
    numTransactionEntries: number$1(),
    numSuccessfulTransactions: number$1(),
    numFailedTransactions: number$1(),
    maxTransactionsPerEntry: number$1()
  })
}), type2({
  type: literal("dead"),
  slot: number$1(),
  timestamp: number$1(),
  err: string()
})]);
type2({
  subscription: number$1(),
  result: SlotUpdateResult
});
type2({
  subscription: number$1(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
type2({
  subscription: number$1(),
  result: number$1()
});
type2({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
const VoteAccountInfoResult = type2({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number$1(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number$1(), number$1(), number$1()])),
  commission: number$1(),
  lastVote: number$1(),
  rootSlot: nullable(number$1())
});
jsonRpcResult(type2({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
const ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
const SignatureStatusResponse = type2({
  slot: number$1(),
  confirmations: nullable(number$1()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
jsonRpcResult(number$1());
const AddressTableLookupStruct = type2({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number$1()),
  readonlyIndexes: array(number$1())
});
const ConfirmedTransactionResult = type2({
  signatures: array(string()),
  message: type2({
    accountKeys: array(string()),
    header: type2({
      numRequiredSignatures: number$1(),
      numReadonlySignedAccounts: number$1(),
      numReadonlyUnsignedAccounts: number$1()
    }),
    instructions: array(type2({
      accounts: array(number$1()),
      data: string(),
      programIdIndex: number$1()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
const AnnotatedAccountKey = type2({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
const ConfirmedTransactionAccountsModeResult = type2({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
const ParsedInstructionResult = type2({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
const RawInstructionResult = type2({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
const InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
const UnknownInstructionResult = union([type2({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type2({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
const ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value2) => {
  if ("accounts" in value2) {
    return create(value2, RawInstructionResult);
  } else {
    return create(value2, ParsedInstructionResult);
  }
});
const ParsedConfirmedTransactionResult = type2({
  signatures: array(string()),
  message: type2({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
const TokenBalanceResult = type2({
  accountIndex: number$1(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = type2({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
const ConfirmedTransactionMetaResult = type2({
  err: TransactionErrorResult,
  fee: number$1(),
  innerInstructions: optional(nullable(array(type2({
    index: number$1(),
    instructions: array(type2({
      accounts: array(number$1()),
      data: string(),
      programIdIndex: number$1()
    }))
  })))),
  preBalances: array(number$1()),
  postBalances: array(number$1()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number$1())
});
const ParsedConfirmedTransactionMetaResult = type2({
  err: TransactionErrorResult,
  fee: number$1(),
  innerInstructions: optional(nullable(array(type2({
    index: number$1(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number$1()),
  postBalances: array(number$1()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number$1())
});
const TransactionVersionStruct = union([literal(0), literal("legacy")]);
const RewardsResult = type2({
  pubkey: string(),
  lamports: number$1(),
  postBalance: nullable(number$1()),
  rewardType: nullable(string()),
  commission: optional(nullable(number$1()))
});
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  transactions: array(type2({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  transactions: array(type2({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  transactions: array(type2({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  transactions: array(type2({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1()),
  blockHeight: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  transactions: array(type2({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$1(),
  signatures: array(string()),
  blockTime: nullable(number$1())
})));
jsonRpcResult(nullable(type2({
  slot: number$1(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number$1())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
jsonRpcResult(nullable(type2({
  slot: number$1(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number$1())),
  version: optional(TransactionVersionStruct)
})));
jsonRpcResultAndContext(type2({
  blockhash: string(),
  feeCalculator: type2({
    lamportsPerSignature: number$1()
  })
}));
jsonRpcResultAndContext(type2({
  blockhash: string(),
  lastValidBlockHeight: number$1()
}));
jsonRpcResultAndContext(boolean());
const PerfSampleResult = type2({
  slot: number$1(),
  numTransactions: number$1(),
  numSlots: number$1(),
  samplePeriodSecs: number$1()
});
jsonRpcResult(array(PerfSampleResult));
jsonRpcResultAndContext(nullable(type2({
  feeCalculator: type2({
    lamportsPerSignature: number$1()
  })
})));
jsonRpcResult(string());
jsonRpcResult(string());
const LogsResult = type2({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
type2({
  result: notificationResultAndContext(LogsResult),
  subscription: number$1()
});
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64(), seq(publicKey(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
new PublicKey2("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64("microLamports")])
  }
});
new PublicKey2("ComputeBudget111111111111111111111111111111");
struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey2("Ed25519SigVerify111111111111111111111111111");
secp256k1$1.utils.isValidPrivateKey;
secp256k1$1.getPublicKey;
struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
new PublicKey2("KeccakSecp256k11111111111111111111111111111");
var _class2;
new PublicKey2("StakeConfig11111111111111111111111111111111");
class Lockup2 {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
}
_class2 = Lockup2;
Lockup2.default = new _class2(0, 0, PublicKey2.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
new PublicKey2("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey2("Vote111111111111111111111111111111111111111");
new PublicKey2("Va1idator1nfo111111111111111111111111111111");
type2({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey2("Vote111111111111111111111111111111111111111");
struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  // votes.length
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  // authorizedVoters.length
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  // epochCredits.length
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, e$2 = t$1.ShadowRoot && (void 0 === t$1.ShadyCSS || t$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$1 = Symbol(), o$2 = /* @__PURE__ */ new WeakMap();
let n$3 = class n {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$1) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$2 && void 0 === t2) {
      const e2 = void 0 !== s2 && 1 === s2.length;
      e2 && (t2 = o$2.get(s2)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$2.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$4 = (t2) => new n$3("string" == typeof t2 ? t2 : t2 + "", void 0, s$1), i$2 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s2, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$) return t3.cssText;
    if ("number" == typeof t3) return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t2[o3 + 1], t2[0]);
  return new n$3(o2, t2, s$1);
}, S$1 = (s2, o2) => {
  if (e$2) s2.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else for (const e2 of o2) {
    const o3 = document.createElement("style"), n3 = t$1.litNonce;
    void 0 !== n3 && o3.setAttribute("nonce", n3), o3.textContent = e2.cssText, s2.appendChild(o3);
  }
}, c$2 = e$2 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s2 of t3.cssRules) e2 += s2.cssText;
  return r$4(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$1, defineProperty: e$1, getOwnPropertyDescriptor: r$3, getOwnPropertyNames: h$2, getOwnPropertySymbols: o$1, getPrototypeOf: n$2 } = Object, a = globalThis, c$1 = a.trustedTypes, l = c$1 ? c$1.emptyScript : "", p = a.reactiveElementPolyfillSupport, d = (t2, s2) => t2, u = { toAttribute(t2, s2) {
  switch (s2) {
    case Boolean:
      t2 = t2 ? l : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s2) {
  let i2 = t2;
  switch (s2) {
    case Boolean:
      i2 = null !== t2;
      break;
    case Number:
      i2 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i2 = JSON.parse(t2);
      } catch (t3) {
        i2 = null;
      }
  }
  return i2;
} }, f$3 = (t2, s2) => !i$1(t2, s2), y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f$3 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a.litPropertyMetadata ?? (a.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s2 = y) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.elementProperties.set(t2, s2), !s2.noAccessor) {
      const i2 = Symbol(), r2 = this.getPropertyDescriptor(t2, i2, s2);
      void 0 !== r2 && e$1(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s2, i2) {
    const { get: e2, set: h2 } = r$3(this.prototype, t2) ?? { get() {
      return this[s2];
    }, set(t3) {
      this[s2] = t3;
    } };
    return { get() {
      return e2 == null ? void 0 : e2.call(this);
    }, set(s3) {
      const r2 = e2 == null ? void 0 : e2.call(this);
      h2.call(this, s3), this.requestUpdate(t2, r2, i2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t2 = n$2(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t3 = this.properties, s2 = [...h$2(t3), ...o$1(t3)];
      for (const i2 of s2) this.createProperty(i2, t3[i2]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s2 = litPropertyMetadata.get(t2);
      if (void 0 !== s2) for (const [t3, i2] of s2) this.elementProperties.set(t3, i2);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s2] of this.elementProperties) {
      const i2 = this._$Eu(t3, s2);
      void 0 !== i2 && this._$Eh.set(i2, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i2 = [];
    if (Array.isArray(s2)) {
      const e2 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e2) i2.unshift(c$2(s3));
    } else void 0 !== s2 && i2.push(c$2(s2));
    return i2;
  }
  static _$Eu(t2, s2) {
    const i2 = s2.attribute;
    return false === i2 ? void 0 : "string" == typeof i2 ? i2 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var _a2;
    this._$ES = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (_a2 = this.constructor.l) == null ? void 0 : _a2.forEach((t2) => t2(this));
  }
  addController(t2) {
    var _a2;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && ((_a2 = t2.hostConnected) == null ? void 0 : _a2.call(t2));
  }
  removeController(t2) {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i2 of s2.keys()) this.hasOwnProperty(i2) && (t2.set(i2, this[i2]), delete this[i2]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    var _a2;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t2) => {
      var _a3;
      return (_a3 = t2.hostConnected) == null ? void 0 : _a3.call(t2);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t2) => {
      var _a3;
      return (_a3 = t2.hostDisconnected) == null ? void 0 : _a3.call(t2);
    });
  }
  attributeChangedCallback(t2, s2, i2) {
    this._$AK(t2, i2);
  }
  _$EC(t2, s2) {
    var _a2;
    const i2 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i2);
    if (void 0 !== e2 && true === i2.reflect) {
      const r2 = (void 0 !== ((_a2 = i2.converter) == null ? void 0 : _a2.toAttribute) ? i2.converter : u).toAttribute(s2, i2.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s2) {
    var _a2;
    const i2 = this.constructor, e2 = i2._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i2.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== ((_a2 = t3.converter) == null ? void 0 : _a2.fromAttribute) ? t3.converter : u;
      this._$Em = e2, this[e2] = r2.fromAttribute(s2, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s2, i2) {
    if (void 0 !== t2) {
      if (i2 ?? (i2 = this.constructor.getPropertyOptions(t2)), !(i2.hasChanged ?? f$3)(this[t2], s2)) return;
      this.P(t2, s2, i2);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t2, s2, i2) {
    this._$AL.has(t2) || this._$AL.set(t2, s2), true === i2.reflect && this._$Em !== t2 && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a2;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s3] of this._$Ep) this[t4] = s3;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0) for (const [s3, i2] of t3) true !== i2.wrapped || this._$AL.has(s3) || void 0 === this[s3] || this.P(s3, this[s3], i2);
    }
    let t2 = false;
    const s2 = this._$AL;
    try {
      t2 = this.shouldUpdate(s2), t2 ? (this.willUpdate(s2), (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t3) => {
        var _a3;
        return (_a3 = t3.hostUpdate) == null ? void 0 : _a3.call(t3);
      }), this.update(s2)) : this._$EU();
    } catch (s3) {
      throw t2 = false, this._$EU(), s3;
    }
    t2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t3) => {
      var _a3;
      return (_a3 = t3.hostUpdated) == null ? void 0 : _a3.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t3) => this._$EC(t3, this[t3]))), this._$EU();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p == null ? void 0 : p({ ReactiveElement: b }), (a.reactiveElementVersions ?? (a.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1 = globalThis, c = n$1.trustedTypes, h$1 = c ? c.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, f$2 = "$lit$", v = `lit$${Math.random().toFixed(9).slice(2)}$`, m = "?" + v, _ = `<${m}>`, w = document, lt$1 = () => w.createComment(""), st$1 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, g = Array.isArray, $$1 = (t2) => g(t2) || "function" == typeof (t2 == null ? void 0 : t2[Symbol.iterator]), x = "[ 	\n\f\r]", T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, E = /-->/g, k = />/g, O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), S = /'/g, j = /"/g, M = /^(?:script|style|textarea|title)$/i, P = (t2) => (i2, ...s2) => ({ _$litType$: t2, strings: i2, values: s2 }), ke$1 = P(1), Oe$1 = P(2), R = Symbol.for("lit-noChange"), D = Symbol.for("lit-nothing"), V$1 = /* @__PURE__ */ new WeakMap(), I = w.createTreeWalker(w, 129);
function N(t2, i2) {
  if (!g(t2) || !t2.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h$1 ? h$1.createHTML(i2) : i2;
}
const U$1 = (t2, i2) => {
  const s2 = t2.length - 1, e2 = [];
  let h2, o2 = 2 === i2 ? "<svg>" : 3 === i2 ? "<math>" : "", n3 = T;
  for (let i3 = 0; i3 < s2; i3++) {
    const s3 = t2[i3];
    let r2, l2, c2 = -1, a2 = 0;
    for (; a2 < s3.length && (n3.lastIndex = a2, l2 = n3.exec(s3), null !== l2); ) a2 = n3.lastIndex, n3 === T ? "!--" === l2[1] ? n3 = E : void 0 !== l2[1] ? n3 = k : void 0 !== l2[2] ? (M.test(l2[2]) && (h2 = RegExp("</" + l2[2], "g")), n3 = O) : void 0 !== l2[3] && (n3 = O) : n3 === O ? ">" === l2[0] ? (n3 = h2 ?? T, c2 = -1) : void 0 === l2[1] ? c2 = -2 : (c2 = n3.lastIndex - l2[2].length, r2 = l2[1], n3 = void 0 === l2[3] ? O : '"' === l2[3] ? j : S) : n3 === j || n3 === S ? n3 = O : n3 === E || n3 === k ? n3 = T : (n3 = O, h2 = void 0);
    const u2 = n3 === O && t2[i3 + 1].startsWith("/>") ? " " : "";
    o2 += n3 === T ? s3 + _ : c2 >= 0 ? (e2.push(r2), s3.slice(0, c2) + f$2 + s3.slice(c2) + v + u2) : s3 + v + (-2 === c2 ? i3 : u2);
  }
  return [N(t2, o2 + (t2[s2] || "<?>") + (2 === i2 ? "</svg>" : 3 === i2 ? "</math>" : "")), e2];
};
let B$1 = class B {
  constructor({ strings: t2, _$litType$: i2 }, s2) {
    let e2;
    this.parts = [];
    let h2 = 0, o2 = 0;
    const n3 = t2.length - 1, r2 = this.parts, [l2, a2] = U$1(t2, i2);
    if (this.el = B.createElement(l2, s2), I.currentNode = this.el.content, 2 === i2 || 3 === i2) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (e2 = I.nextNode()) && r2.length < n3; ) {
      if (1 === e2.nodeType) {
        if (e2.hasAttributes()) for (const t3 of e2.getAttributeNames()) if (t3.endsWith(f$2)) {
          const i3 = a2[o2++], s3 = e2.getAttribute(t3).split(v), n4 = /([.?@])?(.*)/.exec(i3);
          r2.push({ type: 1, index: h2, name: n4[2], strings: s3, ctor: "." === n4[1] ? Y$1 : "?" === n4[1] ? Z$1 : "@" === n4[1] ? q$1 : G$1 }), e2.removeAttribute(t3);
        } else t3.startsWith(v) && (r2.push({ type: 6, index: h2 }), e2.removeAttribute(t3));
        if (M.test(e2.tagName)) {
          const t3 = e2.textContent.split(v), i3 = t3.length - 1;
          if (i3 > 0) {
            e2.textContent = c ? c.emptyScript : "";
            for (let s3 = 0; s3 < i3; s3++) e2.append(t3[s3], lt$1()), I.nextNode(), r2.push({ type: 2, index: ++h2 });
            e2.append(t3[i3], lt$1());
          }
        }
      } else if (8 === e2.nodeType) if (e2.data === m) r2.push({ type: 2, index: h2 });
      else {
        let t3 = -1;
        for (; -1 !== (t3 = e2.data.indexOf(v, t3 + 1)); ) r2.push({ type: 7, index: h2 }), t3 += v.length - 1;
      }
      h2++;
    }
  }
  static createElement(t2, i2) {
    const s2 = w.createElement("template");
    return s2.innerHTML = t2, s2;
  }
};
function z(t2, i2, s2 = t2, e2) {
  var _a2, _b2;
  if (i2 === R) return i2;
  let h2 = void 0 !== e2 ? (_a2 = s2.o) == null ? void 0 : _a2[e2] : s2.l;
  const o2 = st$1(i2) ? void 0 : i2._$litDirective$;
  return (h2 == null ? void 0 : h2.constructor) !== o2 && ((_b2 = h2 == null ? void 0 : h2._$AO) == null ? void 0 : _b2.call(h2, false), void 0 === o2 ? h2 = void 0 : (h2 = new o2(t2), h2._$AT(t2, s2, e2)), void 0 !== e2 ? (s2.o ?? (s2.o = []))[e2] = h2 : s2.l = h2), void 0 !== h2 && (i2 = z(t2, h2._$AS(t2, i2.values), h2, e2)), i2;
}
let F$1 = class F {
  constructor(t2, i2) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i2 }, parts: s2 } = this._$AD, e2 = ((t2 == null ? void 0 : t2.creationScope) ?? w).importNode(i2, true);
    I.currentNode = e2;
    let h2 = I.nextNode(), o2 = 0, n3 = 0, r2 = s2[0];
    for (; void 0 !== r2; ) {
      if (o2 === r2.index) {
        let i3;
        2 === r2.type ? i3 = new et$1(h2, h2.nextSibling, this, t2) : 1 === r2.type ? i3 = new r2.ctor(h2, r2.name, r2.strings, this, t2) : 6 === r2.type && (i3 = new K$2(h2, this, t2)), this._$AV.push(i3), r2 = s2[++n3];
      }
      o2 !== (r2 == null ? void 0 : r2.index) && (h2 = I.nextNode(), o2++);
    }
    return I.currentNode = w, e2;
  }
  p(t2) {
    let i2 = 0;
    for (const s2 of this._$AV) void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t2, s2, i2), i2 += s2.strings.length - 2) : s2._$AI(t2[i2])), i2++;
  }
};
let et$1 = class et {
  get _$AU() {
    var _a2;
    return ((_a2 = this._$AM) == null ? void 0 : _a2._$AU) ?? this.v;
  }
  constructor(t2, i2, s2, e2) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t2, this._$AB = i2, this._$AM = s2, this.options = e2, this.v = (e2 == null ? void 0 : e2.isConnected) ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i2 = this._$AM;
    return void 0 !== i2 && 11 === (t2 == null ? void 0 : t2.nodeType) && (t2 = i2.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i2 = this) {
    t2 = z(this, t2, i2), st$1(t2) ? t2 === D || null == t2 || "" === t2 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t2 !== this._$AH && t2 !== R && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : $$1(t2) ? this.k(t2) : this._(t2);
  }
  O(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.O(t2));
  }
  _(t2) {
    this._$AH !== D && st$1(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(w.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    var _a2;
    const { values: i2, _$litType$: s2 } = t2, e2 = "number" == typeof s2 ? this._$AC(t2) : (void 0 === s2.el && (s2.el = B$1.createElement(N(s2.h, s2.h[0]), this.options)), s2);
    if (((_a2 = this._$AH) == null ? void 0 : _a2._$AD) === e2) this._$AH.p(i2);
    else {
      const t3 = new F$1(e2, this), s3 = t3.u(this.options);
      t3.p(i2), this.T(s3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i2 = V$1.get(t2.strings);
    return void 0 === i2 && V$1.set(t2.strings, i2 = new B$1(t2)), i2;
  }
  k(t2) {
    g(this._$AH) || (this._$AH = [], this._$AR());
    const i2 = this._$AH;
    let s2, e2 = 0;
    for (const h2 of t2) e2 === i2.length ? i2.push(s2 = new et(this.O(lt$1()), this.O(lt$1()), this, this.options)) : s2 = i2[e2], s2._$AI(h2), e2++;
    e2 < i2.length && (this._$AR(s2 && s2._$AB.nextSibling, e2), i2.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i2) {
    var _a2;
    for ((_a2 = this._$AP) == null ? void 0 : _a2.call(this, false, true, i2); t2 && t2 !== this._$AB; ) {
      const i3 = t2.nextSibling;
      t2.remove(), t2 = i3;
    }
  }
  setConnected(t2) {
    var _a2;
    void 0 === this._$AM && (this.v = t2, (_a2 = this._$AP) == null ? void 0 : _a2.call(this, t2));
  }
};
let G$1 = class G {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i2, s2, e2, h2) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t2, this.name = i2, this._$AM = e2, this.options = h2, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = D;
  }
  _$AI(t2, i2 = this, s2, e2) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2) t2 = z(this, t2, i2, 0), o2 = !st$1(t2) || t2 !== this._$AH && t2 !== R, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n3, r2;
      for (t2 = h2[0], n3 = 0; n3 < h2.length - 1; n3++) r2 = z(this, e3[s2 + n3], i2, n3), r2 === R && (r2 = this._$AH[n3]), o2 || (o2 = !st$1(r2) || r2 !== this._$AH[n3]), r2 === D ? t2 = D : t2 !== D && (t2 += (r2 ?? "") + h2[n3 + 1]), this._$AH[n3] = r2;
    }
    o2 && !e2 && this.j(t2);
  }
  j(t2) {
    t2 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
};
let Y$1 = class Y extends G$1 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === D ? void 0 : t2;
  }
};
let Z$1 = class Z extends G$1 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== D);
  }
};
let q$1 = class q extends G$1 {
  constructor(t2, i2, s2, e2, h2) {
    super(t2, i2, s2, e2, h2), this.type = 5;
  }
  _$AI(t2, i2 = this) {
    if ((t2 = z(this, t2, i2, 0) ?? D) === R) return;
    const s2 = this._$AH, e2 = t2 === D && s2 !== D || t2.capture !== s2.capture || t2.once !== s2.once || t2.passive !== s2.passive, h2 = t2 !== D && (s2 === D || e2);
    e2 && this.element.removeEventListener(this.name, this, s2), h2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var _a2;
    "function" == typeof this._$AH ? this._$AH.call(((_a2 = this.options) == null ? void 0 : _a2.host) ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
};
let K$2 = class K {
  constructor(t2, i2, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i2, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    z(this, t2);
  }
};
const Re$1 = n$1.litHtmlPolyfillSupport;
Re$1 == null ? void 0 : Re$1(B$1, et$1), (n$1.litHtmlVersions ?? (n$1.litHtmlVersions = [])).push("3.2.0");
const Q$1 = (t2, i2, s2) => {
  const e2 = (s2 == null ? void 0 : s2.renderBefore) ?? i2;
  let h2 = e2._$litPart$;
  if (void 0 === h2) {
    const t3 = (s2 == null ? void 0 : s2.renderBefore) ?? null;
    e2._$litPart$ = h2 = new et$1(i2.insertBefore(lt$1(), t3), t3, void 0, s2 ?? {});
  }
  return h2._$AI(t2), h2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class h extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var _a2;
    const t2 = super.createRenderRoot();
    return (_a2 = this.renderOptions).renderBefore ?? (_a2.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const e2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this.o = Q$1(e2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback(), (_a2 = this.o) == null ? void 0 : _a2.setConnected(true);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback(), (_a2 = this.o) == null ? void 0 : _a2.setConnected(false);
  }
  render() {
    return R;
  }
}
h._$litElement$ = true, h["finalized"] = true, (_t5 = globalThis.litElementHydrateSupport) == null ? void 0 : _t5.call(globalThis, { LitElement: h });
const f$1 = globalThis.litElementPolyfillSupport;
f$1 == null ? void 0 : f$1({ LitElement: h });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
let themeTag = void 0;
let darkModeTag = void 0;
let lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i$2`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix-strength"]) ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-font-family"]) || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-font-size-master"]) || "10px")};
        --w3m-border-radius-master: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-border-radius-master"]) || "4px")};
        --w3m-z-index: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-z-index"]) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
    light: i$2`
      :root {
        --w3m-color-mix: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || "#fff")};
        --w3m-accent: ${r$4(getW3mThemeVariables(themeVariables, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${r$4(getW3mThemeVariables(themeVariables, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;
      }
    `,
    dark: i$2`
      :root {
        --w3m-color-mix: ${r$4((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || "#000")};
        --w3m-accent: ${r$4(getW3mThemeVariables(themeVariables, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${r$4(getW3mThemeVariables(themeVariables, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);
      }
    `
  };
}
const resetStyles = i$2`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = i$2`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, color;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = i$2`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create3(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
const styles$23 = i$2`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$2C = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiCard = class WuiCard2 extends h {
  render() {
    return ke$1`<slot></slot>`;
  }
};
WuiCard.styles = [resetStyles, styles$23];
WuiCard = __decorate$2C([
  customElement("wui-card")
], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f$3 }, r$2 = (t2 = o, e2, r2) => {
  const { kind: n3, metadata: i2 } = r2;
  let s2 = globalThis.litPropertyMetadata.get(i2);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i2, s2 = /* @__PURE__ */ new Map()), s2.set(r2.name, t2), "accessor" === n3) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n4 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n4, t2);
    }, init(e3) {
      return void 0 !== e3 && this.P(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n3) {
    const { name: o2 } = r2;
    return function(r3) {
      const n4 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n4, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n3);
};
function n2(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$2(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(r2) {
  return n2({ ...r2, state: true, attribute: false });
}
const styles$22 = i$2`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
const addSvg = Oe$1`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#667dff"
  /></svg
>`;
const allWalletsSvg = Oe$1`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
const arrowBottomCircleSvg = Oe$1`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;
const appStoreSvg = Oe$1`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
const appleSvg = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const arrowBottomSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowLeftSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowRightSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowTopSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const bankSvg = Oe$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;
const browserSvg$1 = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const cardSvg = Oe$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;
const checkmarkBoldSvg = Oe$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.9576 2.23383C13.3807 2.58873 13.4361 3.21947 13.0812 3.64263L6.37159 11.6426C6.19161 11.8572 5.92989 11.9865 5.65009 11.999C5.3703 12.0115 5.09808 11.9062 4.89965 11.7085L0.979321 7.80331C0.588042 7.41354 0.586817 6.78038 0.976585 6.3891C1.36635 5.99782 1.99952 5.99659 2.3908 6.38636L5.53928 9.52268L11.5488 2.35742C11.9037 1.93426 12.5344 1.87893 12.9576 2.23383Z"
    clip-rule="evenodd"
  />
</svg>`;
const checkmarkSvg = Oe$1`<svg
  width="28"
  height="28"
  viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M25.5297 4.92733C26.1221 5.4242 26.1996 6.30724 25.7027 6.89966L12.2836 22.8997C12.0316 23.2001 11.6652 23.3811 11.2735 23.3986C10.8817 23.4161 10.5006 23.2686 10.2228 22.9919L2.38218 15.1815C1.83439 14.6358 1.83268 13.7494 2.37835 13.2016C2.92403 12.6538 3.81046 12.6521 4.35825 13.1978L11.1183 19.9317L23.5573 5.10036C24.0542 4.50794 24.9372 4.43047 25.5297 4.92733Z"
    fill="#26D962"/>
</svg>
`;
const chevronBottomSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronLeftSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronRightSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronTopSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chromeStoreSvg = Oe$1`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
const clockSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const closeSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const coinPlaceholderSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
const compassSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
const copySvg = Oe$1`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;
const cursorSvg = Oe$1` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
const cursorTransparentSvg = Oe$1`<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;
const desktopSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
const disconnectSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const discordSvg = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const etherscanSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
const extensionSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
const externalLinkSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const facebookSvg = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const filtersSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const githubSvg = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const googleSvg$1 = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`;
const helpCircleSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
const imageSvg = Oe$1`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path d="M4.98926 3.73932C4.2989 3.73932 3.73926 4.29896 3.73926 4.98932C3.73926 5.67968 4.2989 6.23932 4.98926 6.23932C5.67962 6.23932 6.23926 5.67968 6.23926 4.98932C6.23926 4.29896 5.67962 3.73932 4.98926 3.73932Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.60497 0.500001H6.39504C5.41068 0.499977 4.59185 0.499958 3.93178 0.571471C3.24075 0.64634 2.60613 0.809093 2.04581 1.21619C1.72745 1.44749 1.44749 1.72745 1.21619 2.04581C0.809093 2.60613 0.64634 3.24075 0.571471 3.93178C0.499958 4.59185 0.499977 5.41065 0.500001 6.39501V7.57815C0.499998 8.37476 0.499995 9.05726 0.534869 9.62725C0.570123 10.2034 0.644114 10.7419 0.828442 11.2302C0.925651 11.4877 1.05235 11.7287 1.21619 11.9542C1.44749 12.2726 1.72745 12.5525 2.04581 12.7838C2.60613 13.1909 3.24075 13.3537 3.93178 13.4285C4.59185 13.5001 5.41066 13.5 6.39503 13.5H7.60496C8.58933 13.5 9.40815 13.5001 10.0682 13.4285C10.7593 13.3537 11.3939 13.1909 11.9542 12.7838C12.2726 12.5525 12.5525 12.2726 12.7838 11.9542C13.1909 11.3939 13.3537 10.7593 13.4285 10.0682C13.5 9.40816 13.5 8.58935 13.5 7.60497V6.39505C13.5 5.41068 13.5 4.59185 13.4285 3.93178C13.3537 3.24075 13.1909 2.60613 12.7838 2.04581C12.5525 1.72745 12.2726 1.44749 11.9542 1.21619C11.3939 0.809093 10.7593 0.64634 10.0682 0.571471C9.40816 0.499958 8.58933 0.499977 7.60497 0.500001ZM3.22138 2.83422C3.38394 2.71612 3.62634 2.61627 4.14721 2.55984C4.68679 2.50138 5.39655 2.5 6.45 2.5H7.55C8.60345 2.5 9.31322 2.50138 9.8528 2.55984C10.3737 2.61627 10.6161 2.71612 10.7786 2.83422C10.9272 2.94216 11.0578 3.07281 11.1658 3.22138C11.2839 3.38394 11.3837 3.62634 11.4402 4.14721C11.4986 4.68679 11.5 5.39655 11.5 6.45V6.49703C10.9674 6.11617 10.386 5.84936 9.74213 5.81948C8.40536 5.75745 7.3556 6.73051 6.40509 7.84229C6.33236 7.92737 6.27406 7.98735 6.22971 8.02911L6.1919 8.00514L6.17483 7.99427C6.09523 7.94353 5.98115 7.87083 5.85596 7.80302C5.56887 7.64752 5.18012 7.4921 4.68105 7.4921C4.66697 7.4921 4.6529 7.49239 4.63884 7.49299C3.79163 7.52878 3.09922 8.1106 2.62901 8.55472C2.58751 8.59392 2.54594 8.6339 2.50435 8.6745C2.50011 8.34653 2.5 7.97569 2.5 7.55V6.45C2.5 5.39655 2.50138 4.68679 2.55984 4.14721C2.61627 3.62634 2.71612 3.38394 2.83422 3.22138C2.94216 3.07281 3.07281 2.94216 3.22138 2.83422ZM10.3703 8.14825C10.6798 8.37526 11.043 8.71839 11.4832 9.20889C11.4744 9.44992 11.4608 9.662 11.4402 9.8528C11.3837 10.3737 11.2839 10.6161 11.1658 10.7786C11.0578 10.9272 10.9272 11.0578 10.7786 11.1658C10.6161 11.2839 10.3737 11.3837 9.8528 11.4402C9.31322 11.4986 8.60345 11.5 7.55 11.5H6.45C5.39655 11.5 4.68679 11.4986 4.14721 11.4402C3.62634 11.3837 3.38394 11.2839 3.22138 11.1658C3.15484 11.1174 3.0919 11.0645 3.03298 11.0075C3.10126 10.9356 3.16806 10.8649 3.23317 10.7959L3.29772 10.7276C3.55763 10.4525 3.78639 10.2126 4.00232 10.0087C4.22016 9.80294 4.39412 9.66364 4.53524 9.57742C4.63352 9.51738 4.69022 9.49897 4.71275 9.49345C4.76387 9.49804 4.81803 9.51537 4.90343 9.56162C4.96409 9.59447 5.02355 9.63225 5.11802 9.69238L5.12363 9.69595C5.20522 9.74789 5.32771 9.82587 5.46078 9.89278C5.76529 10.0459 6.21427 10.186 6.74977 10.0158C7.21485 9.86796 7.59367 9.52979 7.92525 9.14195C8.91377 7.98571 9.38267 7.80495 9.64941 7.81733C9.7858 7.82366 10.0101 7.884 10.3703 8.14825Z" fill="currentColor"/>
</svg>`;
const infoCircleSvg = Oe$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const mailSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const mobileSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
const moreSvg = Oe$1`<svg fill="none" viewBox="0 0 41 40">
  <path
    style="fill: var(--wui-color-fg-100);"
    fill-opacity=".05"
    d="M.6 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z"
  />
  <path
    fill="#949E9E"
    d="M15.6 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM23.1 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM28.1 22.81a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"
  />
</svg>`;
const networkPlaceholderSvg = Oe$1`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
const nftPlaceholderSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const offSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
const playStoreSvg = Oe$1` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
const plusSvg = Oe$1`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
const qrCodeIcon = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
const recycleHorizontalSvg = Oe$1`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;
const refreshSvg = Oe$1`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
const searchSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
const sendSvg = Oe$1`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;
const swapHorizontalSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalBoldSvg = Oe$1`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalMediumSvg = Oe$1`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;
const swapHorizontalRoundedBoldSvg = Oe$1`<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
  <path 
    fill="currentColor"
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M8.3071 0.292893C8.69763 0.683417 8.69763 1.31658 8.3071 1.70711L6.41421 3.6H11.3404C13.8368 3.6 16.0533 5.1975 16.8427 7.56588L16.9487 7.88377C17.1233 8.40772 16.8402 8.97404 16.3162 9.14868C15.7923 9.32333 15.226 9.04017 15.0513 8.51623L14.9453 8.19834C14.4281 6.64664 12.976 5.6 11.3404 5.6H6.41421L8.3071 7.49289C8.69763 7.88342 8.69763 8.51658 8.3071 8.90711C7.91658 9.29763 7.28341 9.29763 6.89289 8.90711L3.29289 5.30711C2.90236 4.91658 2.90236 4.28342 3.29289 3.89289L6.89289 0.292893C7.28341 -0.0976311 7.91658 -0.0976311 8.3071 0.292893ZM3.68377 10.8513C4.20771 10.6767 4.77403 10.9598 4.94868 11.4838L5.05464 11.8017C5.57188 13.3534 7.024 14.4 8.65964 14.4L13.5858 14.4L11.6929 12.5071C11.3024 12.1166 11.3024 11.4834 11.6929 11.0929C12.0834 10.7024 12.7166 10.7024 13.1071 11.0929L16.7071 14.6929C17.0976 15.0834 17.0976 15.7166 16.7071 16.1071L13.1071 19.7071C12.7166 20.0976 12.0834 20.0976 11.6929 19.7071C11.3024 19.3166 11.3024 18.6834 11.6929 18.2929L13.5858 16.4L8.65964 16.4C6.16314 16.4 3.94674 14.8025 3.15728 12.4341L3.05131 12.1162C2.87667 11.5923 3.15983 11.026 3.68377 10.8513Z" 
  />
</svg>`;
const swapVerticalSvg = Oe$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const telegramSvg = Oe$1`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`;
const twitchSvg = Oe$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const twitterIconSvg = Oe$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
const verifySvg = Oe$1`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const verifyFilledSvg = Oe$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletPlaceholderSvg = Oe$1`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
const walletSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletConnectSvg = Oe$1`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
const warningCircleSvg = Oe$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const idSvg = Oe$1`<svg
 xmlns="http://www.w3.org/2000/svg"
 width="28"
 height="28"
 viewBox="0 0 28 28"
 fill="none">
  <path
    fill="#949E9E"
    fill-rule="evenodd"
    d="M7.974 2.975h12.052c1.248 0 2.296 0 3.143.092.89.096 1.723.307 2.461.844a4.9 4.9 0 0 1 1.084 1.084c.537.738.748 1.57.844 2.461.092.847.092 1.895.092 3.143v6.802c0 1.248 0 2.296-.092 3.143-.096.89-.307 1.723-.844 2.461a4.9 4.9 0 0 1-1.084 1.084c-.738.537-1.57.748-2.461.844-.847.092-1.895.092-3.143.092H7.974c-1.247 0-2.296 0-3.143-.092-.89-.096-1.723-.307-2.461-.844a4.901 4.901 0 0 1-1.084-1.084c-.537-.738-.748-1.571-.844-2.461C.35 19.697.35 18.649.35 17.4v-6.802c0-1.248 0-2.296.092-3.143.096-.89.307-1.723.844-2.461A4.9 4.9 0 0 1 2.37 3.91c.738-.537 1.571-.748 2.461-.844.847-.092 1.895-.092 3.143-.092ZM5.133 5.85c-.652.071-.936.194-1.117.326a2.1 2.1 0 0 0-.465.465c-.132.181-.255.465-.325 1.117-.074.678-.076 1.573-.076 2.917v6.65c0 1.344.002 2.239.076 2.917.07.652.193.936.325 1.117a2.1 2.1 0 0 0 .465.465c.181.132.465.255 1.117.326.678.073 1.574.075 2.917.075h11.9c1.344 0 2.239-.002 2.917-.075.652-.071.936-.194 1.117-.326.179-.13.335-.286.465-.465.132-.181.255-.465.326-1.117.073-.678.075-1.573.075-2.917v-6.65c0-1.344-.002-2.239-.075-2.917-.071-.652-.194-.936-.326-1.117a2.1 2.1 0 0 0-.465-.465c-.181-.132-.465-.255-1.117-.326-.678-.073-1.573-.075-2.917-.075H8.05c-1.343 0-2.239.002-2.917.075Zm.467 7.275a3.15 3.15 0 1 1 6.3 0 3.15 3.15 0 0 1-6.3 0Zm8.75-1.75a1.4 1.4 0 0 1 1.4-1.4h3.5a1.4 1.4 0 0 1 0 2.8h-3.5a1.4 1.4 0 0 1-1.4-1.4Zm0 5.25a1.4 1.4 0 0 1 1.4-1.4H21a1.4 1.4 0 1 1 0 2.8h-5.25a1.4 1.4 0 0 1-1.4-1.4Z"
    clip-rule="evenodd"/>
</svg>`;
const xSvg = Oe$1`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
var __decorate$2B = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const svgOptions$1 = {
  add: addSvg,
  allWallets: allWalletsSvg,
  arrowBottomCircle: arrowBottomCircleSvg,
  appStore: appStoreSvg,
  apple: appleSvg,
  arrowBottom: arrowBottomSvg,
  arrowLeft: arrowLeftSvg,
  arrowRight: arrowRightSvg,
  arrowTop: arrowTopSvg,
  bank: bankSvg,
  browser: browserSvg$1,
  card: cardSvg,
  checkmark: checkmarkSvg,
  checkmarkBold: checkmarkBoldSvg,
  chevronBottom: chevronBottomSvg,
  chevronLeft: chevronLeftSvg,
  chevronRight: chevronRightSvg,
  chevronTop: chevronTopSvg,
  chromeStore: chromeStoreSvg,
  clock: clockSvg,
  close: closeSvg,
  compass: compassSvg,
  coinPlaceholder: coinPlaceholderSvg,
  copy: copySvg,
  cursor: cursorSvg,
  cursorTransparent: cursorTransparentSvg,
  desktop: desktopSvg,
  disconnect: disconnectSvg,
  discord: discordSvg,
  etherscan: etherscanSvg,
  extension: extensionSvg,
  externalLink: externalLinkSvg,
  facebook: facebookSvg,
  filters: filtersSvg,
  github: githubSvg,
  google: googleSvg$1,
  helpCircle: helpCircleSvg,
  image: imageSvg,
  id: idSvg,
  infoCircle: infoCircleSvg,
  mail: mailSvg,
  mobile: mobileSvg,
  more: moreSvg,
  networkPlaceholder: networkPlaceholderSvg,
  nftPlaceholder: nftPlaceholderSvg,
  off: offSvg,
  playStore: playStoreSvg,
  plus: plusSvg,
  qrCode: qrCodeIcon,
  recycleHorizontal: recycleHorizontalSvg,
  refresh: refreshSvg,
  search: searchSvg,
  send: sendSvg,
  swapHorizontal: swapHorizontalSvg,
  swapHorizontalMedium: swapHorizontalMediumSvg,
  swapHorizontalBold: swapHorizontalBoldSvg,
  swapHorizontalRoundedBold: swapHorizontalRoundedBoldSvg,
  swapVertical: swapVerticalSvg,
  telegram: telegramSvg,
  twitch: twitchSvg,
  twitter: xSvg,
  twitterIcon: twitterIconSvg,
  verify: verifySvg,
  verifyFilled: verifyFilledSvg,
  wallet: walletSvg,
  walletConnect: walletConnectSvg,
  walletPlaceholder: walletPlaceholderSvg,
  warningCircle: warningCircleSvg,
  x: xSvg
};
let WuiIcon = class WuiIcon2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "copy";
    this.color = "fg-300";
  }
  render() {
    this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
    return ke$1`${svgOptions$1[this.name]}`;
  }
};
WuiIcon.styles = [resetStyles, colorStyles, styles$22];
__decorate$2B([
  n2()
], WuiIcon.prototype, "size", void 0);
__decorate$2B([
  n2()
], WuiIcon.prototype, "name", void 0);
__decorate$2B([
  n2()
], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$2B([
  customElement("wui-icon")
], WuiIcon);
const styles$21 = i$2`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$2A = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiImage = class WuiImage2 extends h {
  constructor() {
    super(...arguments);
    this.src = "./path/to/image.jpg";
    this.alt = "Image";
    this.size = void 0;
  }
  render() {
    this.style.cssText = `
      --local-width: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      --local-height: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      `;
    return ke$1`<img src=${this.src} alt=${this.alt} @error=${this.handleImageError} />`;
  }
  handleImageError() {
    this.dispatchEvent(new CustomEvent("onLoadError", { bubbles: true, composed: true }));
  }
};
WuiImage.styles = [resetStyles, colorStyles, styles$21];
__decorate$2A([
  n2()
], WuiImage.prototype, "src", void 0);
__decorate$2A([
  n2()
], WuiImage.prototype, "alt", void 0);
__decorate$2A([
  n2()
], WuiImage.prototype, "size", void 0);
WuiImage = __decorate$2A([
  customElement("wui-image")
], WuiImage);
const styles$20 = i$2`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2z = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLoadingHexagon = class WuiLoadingHexagon2 extends h {
  render() {
    return ke$1`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
WuiLoadingHexagon.styles = [resetStyles, styles$20];
WuiLoadingHexagon = __decorate$2z([
  customElement("wui-loading-hexagon")
], WuiLoadingHexagon);
const styles$1$ = i$2`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$2y = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLoadingSpinner = class WuiLoadingSpinner2 extends h {
  constructor() {
    super(...arguments);
    this.color = "accent-100";
    this.size = "lg";
  }
  render() {
    this.style.cssText = `--local-color: ${this.color === "inherit" ? "inherit" : `var(--wui-color-${this.color})`}`;
    this.dataset["size"] = this.size;
    return ke$1`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
WuiLoadingSpinner.styles = [resetStyles, styles$1$];
__decorate$2y([
  n2()
], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$2y([
  n2()
], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$2y([
  customElement("wui-loading-spinner")
], WuiLoadingSpinner);
const styles$1_ = i$2`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2x = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends h {
  constructor() {
    super(...arguments);
    this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const radius = this.radius > 50 ? 50 : this.radius;
    const standardValue = 36;
    const radiusFactor = standardValue - radius;
    const dashArrayStart = 116 + radiusFactor;
    const dashArrayEnd = 245 + radiusFactor;
    const dashOffset = 360 + radiusFactor * 1.75;
    return ke$1`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
  }
};
WuiLoadingThumbnail.styles = [resetStyles, styles$1_];
__decorate$2x([
  n2({ type: Number })
], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$2x([
  customElement("wui-loading-thumbnail")
], WuiLoadingThumbnail);
const styles$1Z = i$2`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  :host([variant='light']) {
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-150) 5%,
      var(--wui-color-bg-150) 48%,
      var(--wui-color-bg-200) 55%,
      var(--wui-color-bg-200) 60%,
      var(--wui-color-bg-200) calc(60% + 10px),
      var(--wui-color-bg-150) calc(60% + 12px),
      var(--wui-color-bg-150) 100%
    );
    background-size: 250%;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$2w = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiShimmer = class WuiShimmer2 extends h {
  constructor() {
    super(...arguments);
    this.width = "";
    this.height = "";
    this.borderRadius = "m";
    this.variant = "default";
  }
  render() {
    this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
    return ke$1`<slot></slot>`;
  }
};
WuiShimmer.styles = [styles$1Z];
__decorate$2w([
  n2()
], WuiShimmer.prototype, "width", void 0);
__decorate$2w([
  n2()
], WuiShimmer.prototype, "height", void 0);
__decorate$2w([
  n2()
], WuiShimmer.prototype, "borderRadius", void 0);
__decorate$2w([
  n2()
], WuiShimmer.prototype, "variant", void 0);
WuiShimmer = __decorate$2w([
  customElement("wui-shimmer")
], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
class i {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i2) {
    this.t = t2, this._$AM = e2, this.i = i2;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Rt = e(class extends i {
  constructor(s2) {
    var _a2;
    if (super(s2), s2.type !== t.ATTRIBUTE || "class" !== s2.name || ((_a2 = s2.strings) == null ? void 0 : _a2.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s2) => t2[s2]).join(" ") + " ";
  }
  update(t2, [s2]) {
    var _a2, _b2;
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t2.strings && (this.nt = new Set(t2.strings.join(" ").split(/\s/).filter((t3) => "" !== t3)));
      for (const t3 in s2) s2[t3] && !((_a2 = this.nt) == null ? void 0 : _a2.has(t3)) && this.st.add(t3);
      return this.render(s2);
    }
    const i2 = t2.element.classList;
    for (const t3 of this.st) t3 in s2 || (i2.remove(t3), this.st.delete(t3));
    for (const t3 in s2) {
      const r2 = !!s2[t3];
      r2 === this.st.has(t3) || ((_b2 = this.nt) == null ? void 0 : _b2.has(t3)) || (r2 ? (i2.add(t3), this.st.add(t3)) : (i2.remove(t3), this.st.delete(t3)));
    }
    return R;
  }
});
const styles$1Y = i$2`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-title-600 {
    font-size: var(--wui-font-size-medium-title);
    letter-spacing: var(--wui-letter-spacing-medium-title);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-400,
  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __decorate$2v = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiText = class WuiText2 extends h {
  constructor() {
    super(...arguments);
    this.variant = "paragraph-500";
    this.color = "fg-300";
    this.align = "left";
    this.lineClamp = void 0;
  }
  render() {
    const classes = {
      [`wui-font-${this.variant}`]: true,
      [`wui-color-${this.color}`]: true,
      [`wui-line-clamp-${this.lineClamp}`]: this.lineClamp ? true : false
    };
    this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
    return ke$1`<slot class=${Rt(classes)}></slot>`;
  }
};
WuiText.styles = [resetStyles, styles$1Y];
__decorate$2v([
  n2()
], WuiText.prototype, "variant", void 0);
__decorate$2v([
  n2()
], WuiText.prototype, "color", void 0);
__decorate$2v([
  n2()
], WuiText.prototype, "align", void 0);
__decorate$2v([
  n2()
], WuiText.prototype, "lineClamp", void 0);
WuiText = __decorate$2v([
  customElement("wui-text")
], WuiText);
const browserSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;
const daoSvg = Oe$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const defiSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;
const defiAltSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const ethSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const layersSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const lockSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const loginSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;
const networkSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;
const nftSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;
const nounSvg = Oe$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const profileSvg = Oe$1`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const systemSvg = Oe$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const coinbaseSvg = Oe$1`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40" fill="none">
  <g clip-path="url(#clip0_187_29)">
    <path d="M1.18187e-05 15.8055C1.18187e-05 9.8015 -5.19442e-07 6.91338 1.69991e-08 0C4.5 3.72236e-05 9.62249 0 16.5 0L23.5 4.31399e-05C29.9349 4.31399e-05 35.5 0.000206332 40 3.73468e-05C40 2.77754 40 9.36708 40 15.8055V22.8364C40 29.2647 40 33.7962 40 40C31.5 40 29.8337 40 23.4 40H16.6C10.5092 40 6.50004 40 4.04289e-05 40C3.05176e-05 32.2453 1.18187e-05 29.6382 1.18187e-05 22.8364V15.8055Z" fill="#0052FF"/>
    <path d="M20.0236 26.5C16.4342 26.5 13.5236 23.5931 13.5236 20C13.5236 16.4069 16.4342 13.5 20.0236 13.5C23.2411 13.5 25.9134 15.8472 26.4261 18.9167H32.9731C32.4206 12.2433 26.8342 7 20.02 7C12.8411 7 7.02002 12.8211 7.02002 20C7.02002 27.1789 12.8411 33 20.02 33C26.8342 33 32.4206 27.7567 32.9731 21.0833H26.4225C25.9061 24.1528 23.2411 26.5 20.0236 26.5Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_187_29">
      <rect width="40" height="40" fill="white"/>
    </clipPath>
  </defs>
</svg>`;
const moonpaySvg = Oe$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#7D00FF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M28.306 15.381a3.69 3.69 0 1 0 0-7.381 3.69 3.69 0 0 0 0 7.381ZM16.987 32a8.991 8.991 0 1 1 .016-17.983A8.991 8.991 0 0 1 16.988 32Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const stripeSvg = Oe$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#635BFF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M18.299 15.147c0-1.028.844-1.424 2.242-1.424 2.004 0 4.536.607 6.54 1.688V9.213C24.892 8.343 22.73 8 20.541 8c-5.354 0-8.915 2.796-8.915 7.464 0 7.279 10.022 6.118 10.022 9.257 0 1.213-1.055 1.609-2.531 1.609-2.19 0-4.985-.897-7.2-2.11v6.277a18.283 18.283 0 0 0 7.2 1.503c5.485 0 9.257-2.716 9.257-7.437-.027-7.86-10.075-6.462-10.075-9.416Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const paypalSvg = Oe$1`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#fff"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M18.606 12.642a.781.781 0 0 0-.771.66l-1.281 8.125a.78.78 0 0 1 .77-.66h3.755a7.668 7.668 0 0 0 7.57-6.49 6.26 6.26 0 0 0 .075-.843c-.96-.504-2.089-.792-3.325-.792h-6.793Z"
        fill="#001C64"
      />
      <path
        d="M28.724 13.434c-.006.282-.03.564-.075.843a7.668 7.668 0 0 1-7.57 6.491h-3.754a.78.78 0 0 0-.771.66l-1.916 12.15a.634.634 0 0 0 .626.734h4.075a.781.781 0 0 0 .77-.66l1.074-6.807a.781.781 0 0 1 .772-.66h2.4a7.668 7.668 0 0 0 7.57-6.491c.415-2.651-.92-5.064-3.201-6.26Z"
        fill="#0070E0"
      />
      <path
        d="M13.977 7.226a.78.78 0 0 0-.771.658l-3.198 20.277a.634.634 0 0 0 .626.733h4.742l1.178-7.467 1.281-8.125a.782.782 0 0 1 .771-.66H25.4c1.237 0 2.364.289 3.325.792.065-3.4-2.74-6.208-6.599-6.208h-8.148Z"
        fill="#003087"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const onrampCardSvg = Oe$1`<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`;
const googleSvg = Oe$1`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="64" rx="30" fill="#1DC956"/>
  <rect x="0.5" y="0.5" width="63" height="63" rx="29.5" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M32.4053 19.8031C35.3901 19.8031 38.0431 20.8349 40.1619 22.8247L45.9656 17.0211C42.4465 13.7416 37.8773 11.7333 32.4053 11.7333C24.4829 11.7333 17.6475 16.2841 14.3127 22.9168L21.056 28.1493C22.6589 23.359 27.136 19.8031 32.4053 19.8031Z" fill="#1DC956" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M32.4053 52.2667C37.8773 52.2667 42.465 50.4611 45.8182 47.3658L39.2407 42.2623C37.4351 43.4783 35.1321 44.2153 32.4053 44.2153C27.136 44.2153 22.6589 40.6594 21.056 35.8691L14.3127 41.1016C17.6475 47.7159 24.4829 52.2667 32.4053 52.2667Z" fill="#2BEE6C"/>
  <path d="M21.056 35.8507L19.5636 36.993L14.3127 41.0832M39.2407 42.2623L45.8182 47.3658C42.465 50.4611 37.8773 52.2667 32.4053 52.2667C24.4829 52.2667 17.6475 47.7159 14.3127 41.1016L21.056 35.8691C22.6589 40.6594 27.136 44.2153 32.4053 44.2153C35.1321 44.2153 37.4351 43.4783 39.2407 42.2623Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M51.8613 32.4606C51.8613 31.0235 51.7323 29.6417 51.4928 28.3151H32.4053V36.1638H43.3124C42.8334 38.688 41.3963 40.8252 39.2407 42.2623L45.8181 47.3658C49.6503 43.8283 51.8613 38.6327 51.8613 32.4606Z" fill="#1FAD7E" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" fill="#86F999"/>
  <path d="M21.056 35.8691L14.3127 41.1016M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
</svg>
`;
const pencilSvg = Oe$1`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31635)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58317 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58317 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9268C60.4784 58.4158 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4158 2.1019 55.9268C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#EB8B47"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M28.1042 49.2329L13.1024 51.2077L15.0772 36.2059L37.1015 14.1815C39.2441 12.039 40.3154 10.9677 41.5718 10.624C42.4205 10.3918 43.3159 10.3918 44.1645 10.624C45.421 10.9677 46.4922 12.039 48.6348 14.1815L50.1286 15.6753C52.2711 17.8179 53.3424 18.8891 53.6861 20.1456C53.9183 20.9942 53.9183 21.8896 53.6861 22.7383C53.3424 23.9947 52.2711 25.066 50.1286 27.2086L28.1042 49.2329Z" fill="#FF974C" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M38.5962 20.5376L22.4199 36.7139" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M43.7727 25.714L27.5964 41.8903" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M22.3703 36.7635C19.3258 39.808 16.0198 36.6395 16.2616 35.0324" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5466 41.9399C24.5034 44.9831 28.155 48.7098 29.2738 48.0475" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5468 41.9398C23.428 46.0586 18.2516 40.8822 22.3704 36.7634" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M15.8191 50.5214C15.4711 49.5823 14.728 48.8392 13.7889 48.4912" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M49.2862 29.5805L34.7275 15.0219" stroke="#E4E7E7" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31635">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const lightbulbSvg = Oe$1`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31636)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58318 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58318 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9269C60.4784 58.4159 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4159 2.1019 55.9269C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#794CFF"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M40 39.4595C44.7824 36.693 48 31.5222 48 25.6C48 16.7634 40.8366 9.59998 32 9.59998C23.1634 9.59998 16 16.7634 16 25.6C16 31.5222 19.2176 36.693 24 39.4595V45.8144H40V39.4595Z" fill="#906EF7"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#906EF7"/>
    <path d="M24 45.8144V39.4595C19.2176 36.693 16 31.5222 16 25.6C16 16.7634 23.1634 9.59998 32 9.59998C40.8366 9.59998 48 16.7634 48 25.6C48 31.5222 44.7824 36.693 40 39.4595V45.8144M24 45.8144H40M24 45.8144V49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#643CDD" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M29.6735 26.9101V29.1109H34.0753V26.9101C34.0753 25.6945 35.0607 24.7092 36.2762 24.7092C37.4917 24.7092 38.4771 25.6945 38.4771 26.9101C38.4771 28.1256 37.4917 29.1109 36.2762 29.1109H34.0753H29.6735H27.4726C26.2571 29.1109 25.2717 28.1256 25.2717 26.9101C25.2717 25.6945 26.2571 24.7092 27.4726 24.7092C28.6881 24.7092 29.6735 25.6945 29.6735 26.9101Z" fill="#906EF7"/>
    <path d="M29.6735 45.3183V26.9101C29.6735 25.6945 28.6881 24.7092 27.4726 24.7092V24.7092C26.2571 24.7092 25.2717 25.6945 25.2717 26.9101V26.9101C25.2717 28.1256 26.2571 29.1109 27.4726 29.1109H36.2762C37.4917 29.1109 38.4771 28.1256 38.4771 26.9101V26.9101C38.4771 25.6945 37.4917 24.7092 36.2762 24.7092V24.7092C35.0607 24.7092 34.0753 25.6945 34.0753 26.9101V45.3183" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31636">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const styles$1X = i$2`
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$2u = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const svgOptions = {
  browser: browserSvg,
  dao: daoSvg,
  defi: defiSvg,
  defiAlt: defiAltSvg,
  eth: ethSvg,
  layers: layersSvg,
  lock: lockSvg,
  login: loginSvg,
  network: networkSvg,
  nft: nftSvg,
  noun: nounSvg,
  profile: profileSvg,
  system: systemSvg,
  coinbase: coinbaseSvg,
  onrampCard: onrampCardSvg,
  moonpay: moonpaySvg,
  stripe: stripeSvg,
  paypal: paypalSvg,
  google: googleSvg,
  pencil: pencilSvg,
  lightbulb: lightbulbSvg
};
let WuiVisual = class WuiVisual2 extends h {
  constructor() {
    super(...arguments);
    this.name = "browser";
    this.size = "md";
  }
  render() {
    this.style.cssText = `
       --local-size: var(--wui-visual-size-${this.size});
   `;
    return ke$1`${svgOptions[this.name]}`;
  }
};
WuiVisual.styles = [resetStyles, styles$1X];
__decorate$2u([
  n2()
], WuiVisual.prototype, "name", void 0);
__decorate$2u([
  n2()
], WuiVisual.prototype, "size", void 0);
WuiVisual = __decorate$2u([
  customElement("wui-visual")
], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const to = (t2) => t2 ?? D;
const UiHelperUtil = {
  getSpacingStyles(spacing, index) {
    if (Array.isArray(spacing)) {
      return spacing[index] ? `var(--wui-spacing-${spacing[index]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  getHostName(url2) {
    try {
      const newUrl = new URL(url2);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string: string2, charsStart, charsEnd, truncate }) {
    if (string2.length <= charsStart + charsEnd) {
      return string2;
    }
    if (truncate === "end") {
      return `${string2.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string2.substring(string2.length - charsEnd)}`;
    }
    return `${string2.substring(0, Math.floor(charsStart))}...${string2.substring(string2.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash2 = address.toLowerCase().replace(/^0x/iu, "");
    const baseColor = hash2.substring(0, 6);
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius == null ? void 0 : masterBorderRadius.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors = [];
    for (let i2 = 0; i2 < 5; i2 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i2);
      colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g2 = bigint >> 8 & 255;
    const b2 = bigint & 255;
    return [r2, g2, b2];
  },
  tintColor(rgb, tint) {
    const [r2, g2, b2] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g2 + (255 - g2) * tint);
    const tintedB = Math.round(b2 + (255 - b2) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character2) {
    const regex2 = {
      number: /^[0-9]+$/u
    };
    return regex2.number.test(character2);
  },
  getColorTheme(theme) {
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts2 = input.split(".");
    if (parts2.length === 2) {
      return [parts2[0], parts2[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number2, threshold, fixed) {
    const roundedNumber = number2.toString().length >= threshold ? Number(number2).toFixed(fixed) : number2;
    return roundedNumber;
  },
  formatNumberToLocalString(value2, decimals = 2) {
    if (value2 === void 0) {
      return "0.00";
    }
    if (typeof value2 === "number") {
      return value2.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value2).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};
const styles$1W = i$2`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$2t = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiFlex = class WuiFlex2 extends h {
  render() {
    this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return ke$1`<slot></slot>`;
  }
};
WuiFlex.styles = [resetStyles, styles$1W];
__decorate$2t([
  n2()
], WuiFlex.prototype, "flexDirection", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "flexWrap", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "flexBasis", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "flexGrow", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "flexShrink", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "alignItems", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "justifyContent", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "columnGap", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "rowGap", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "gap", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "padding", void 0);
__decorate$2t([
  n2()
], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$2t([
  customElement("wui-flex")
], WuiFlex);
const styles$1V = i$2`
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$2s = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiAvatar = class WuiAvatar2 extends h {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.alt = void 0;
    this.address = void 0;
  }
  render() {
    return ke$1`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc) {
      this.dataset["variant"] = "image";
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
    } else if (this.address) {
      this.dataset["variant"] = "generated";
      const cssColors = UiHelperUtil.generateAvatarColors(this.address);
      this.style.cssText = cssColors;
      return null;
    }
    this.dataset["variant"] = "default";
    return null;
  }
};
WuiAvatar.styles = [resetStyles, styles$1V];
__decorate$2s([
  n2()
], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$2s([
  n2()
], WuiAvatar.prototype, "alt", void 0);
__decorate$2s([
  n2()
], WuiAvatar.prototype, "address", void 0);
WuiAvatar = __decorate$2s([
  customElement("wui-avatar")
], WuiAvatar);
const styles$1U = i$2`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-color-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$2r = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiIconBox = class WuiIconBox2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.background = "transparent";
    this.border = false;
    this.borderColor = "wui-color-bg-125";
    this.icon = "copy";
  }
  render() {
    const iconSize = this.iconSize || this.size;
    const isLg = this.size === "lg";
    const isXl = this.size === "xl";
    const bgMix = isLg ? "12%" : "16%";
    const borderRadius2 = isLg ? "xxs" : isXl ? "s" : "3xl";
    const isGray = this.background === "gray";
    const isOpaque = this.background === "opaque";
    const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
    let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
    if (isColorChange) {
      bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
    } else if (isGray) {
      bgValueVariable = `var(--wui-gray-${this.backgroundColor})`;
    }
    this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
    return ke$1` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
  }
};
WuiIconBox.styles = [resetStyles, elementStyles, styles$1U];
__decorate$2r([
  n2()
], WuiIconBox.prototype, "size", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "iconColor", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "iconSize", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "background", void 0);
__decorate$2r([
  n2({ type: Boolean })
], WuiIconBox.prototype, "border", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "borderColor", void 0);
__decorate$2r([
  n2()
], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$2r([
  customElement("wui-icon-box")
], WuiIconBox);
const styles$1T = i$2`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-color-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    background: var(--wui-color-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$2q = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiAccountButton = class WuiAccountButton2 extends h {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.balance = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
    this.address = "";
    this.profileName = "";
    this.charsStart = 4;
    this.charsEnd = 6;
  }
  render() {
    return ke$1`
      <button
        ?disabled=${this.disabled}
        class=${to(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${this.address ? UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : this.charsStart,
      charsEnd: this.profileName ? 0 : this.charsEnd,
      truncate: this.profileName ? "end" : "middle"
    }) : null}
          </wui-text>
        </wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.isUnsupportedChain) {
      return ke$1` <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
        <wui-text variant="paragraph-600" color="inherit"> Switch Network</wui-text>`;
    }
    if (this.balance) {
      const networkElement = this.networkSrc ? ke$1`<wui-image src=${this.networkSrc}></wui-image>` : ke$1`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
      return ke$1`
        ${networkElement}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance}</wui-text>
      `;
    }
    return null;
  }
};
WuiAccountButton.styles = [resetStyles, elementStyles, styles$1T];
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "balance", void 0);
__decorate$2q([
  n2({ type: Boolean })
], WuiAccountButton.prototype, "isUnsupportedChain", void 0);
__decorate$2q([
  n2({ type: Boolean })
], WuiAccountButton.prototype, "disabled", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "address", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "profileName", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$2q([
  n2()
], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$2q([
  customElement("wui-account-button")
], WuiAccountButton);
const styles$1S = i$2`
  :host {
    position: relative;
    background-color: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$2p = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiWalletImage = class WuiWalletImage2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "";
    this.installed = false;
    this.badgeSize = "xs";
  }
  render() {
    let borderRadius2 = "xxs";
    if (this.size === "lg") {
      borderRadius2 = "m";
    } else if (this.size === "md") {
      borderRadius2 = "xs";
    } else {
      borderRadius2 = "xxs";
    }
    this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
    if (this.walletIcon) {
      this.dataset["walletIcon"] = this.walletIcon;
    }
    return ke$1`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    } else if (this.walletIcon) {
      return ke$1`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
    }
    return ke$1`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiWalletImage.styles = [resetStyles, styles$1S];
__decorate$2p([
  n2()
], WuiWalletImage.prototype, "size", void 0);
__decorate$2p([
  n2()
], WuiWalletImage.prototype, "name", void 0);
__decorate$2p([
  n2()
], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$2p([
  n2()
], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$2p([
  n2({ type: Boolean })
], WuiWalletImage.prototype, "installed", void 0);
__decorate$2p([
  n2()
], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$2p([
  customElement("wui-wallet-image")
], WuiWalletImage);
const styles$1R = i$2`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$2o = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class WuiAllWalletsImage2 extends h {
  constructor() {
    super(...arguments);
    this.walletImages = [];
  }
  render() {
    const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
    return ke$1`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => ke$1`
            <wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${to(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => ke$1` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
  }
};
WuiAllWalletsImage.styles = [resetStyles, styles$1R];
__decorate$2o([
  n2({ type: Array })
], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$2o([
  customElement("wui-all-wallets-image")
], WuiAllWalletsImage);
const styles$1Q = i$2`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: none;
    border-radius: var(--local-border-radius);
    width: var(--local-width);
    white-space: nowrap;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
    height: 36px;
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='inverse'] {
    background-color: var(--wui-color-inverse-100);
    color: var(--wui-color-inverse-000);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='accent-error'] {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-error-glass-010);
  }

  button[data-variant='accent-success'] {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-success-glass-010);
  }

  button[data-variant='neutral'] {
    background: transparent;
    color: var(--wui-color-fg-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-variant='main']:focus-visible:enabled {
    background-color: var(--wui-color-accent-090);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='inverse']:focus-visible:enabled {
    background-color: var(--wui-color-inverse-100);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent']:focus-visible:enabled {
    background-color: var(--wui-color-accent-glass-010);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent-error']:focus-visible:enabled {
    background: var(--wui-color-error-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-error-100),
      0 0 0 4px var(--wui-color-error-glass-020);
  }
  button[data-variant='accent-success']:focus-visible:enabled {
    background: var(--wui-color-success-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-success-100),
      0 0 0 4px var(--wui-color-success-glass-020);
  }
  button[data-variant='neutral']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  button[data-variant='main']:hover:enabled {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='main']:active:enabled {
    background-color: var(--wui-color-accent-080);
  }

  button[data-variant='inverse']:hover:enabled {
    background-color: var(--wui-color-inverse-100);
  }

  button[data-variant='accent']:hover:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }

  button[data-variant='accent-error']:hover:enabled {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
  }

  button[data-variant='accent-success']:hover:enabled {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
  }

  button[data-variant='neutral']:hover:enabled {
    background: var(--wui-color-gray-glass-005);
  }

  button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
    padding-left: var(--wui-spacing-m);
  }

  button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
    padding-right: var(--wui-spacing-m);
  }

  /* -- Disabled state --------------------------------------------------- */
  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    color: var(--wui-color-gray-glass-020);
    cursor: not-allowed;
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$2n = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const SPINNER_COLOR_BY_VARIANT = {
  main: "inverse-100",
  inverse: "inverse-000",
  accent: "accent-100",
  "accent-error": "error-100",
  "accent-success": "success-100",
  neutral: "fg-100",
  disabled: "gray-glass-020"
};
const TEXT_VARIANT_BY_SIZE = {
  lg: "paragraph-600",
  md: "small-600"
};
const SPINNER_SIZE_BY_SIZE = {
  lg: "md",
  md: "md"
};
let WuiButton = class WuiButton2 extends h {
  constructor() {
    super(...arguments);
    this.size = "lg";
    this.disabled = false;
    this.fullWidth = false;
    this.loading = false;
    this.variant = "main";
    this.hasIconLeft = false;
    this.hasIconRight = false;
    this.borderRadius = "m";
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
    const textVariant = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
    return ke$1`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = true;
  }
  handleSlotRightChange() {
    this.hasIconRight = true;
  }
  loadingTemplate() {
    if (this.loading) {
      const size = SPINNER_SIZE_BY_SIZE[this.size];
      const color2 = this.disabled ? SPINNER_COLOR_BY_VARIANT["disabled"] : SPINNER_COLOR_BY_VARIANT[this.variant];
      return ke$1`<wui-loading-spinner color=${color2} size=${size}></wui-loading-spinner>`;
    }
    return ke$1``;
  }
};
WuiButton.styles = [resetStyles, elementStyles, styles$1Q];
__decorate$2n([
  n2()
], WuiButton.prototype, "size", void 0);
__decorate$2n([
  n2({ type: Boolean })
], WuiButton.prototype, "disabled", void 0);
__decorate$2n([
  n2({ type: Boolean })
], WuiButton.prototype, "fullWidth", void 0);
__decorate$2n([
  n2({ type: Boolean })
], WuiButton.prototype, "loading", void 0);
__decorate$2n([
  n2()
], WuiButton.prototype, "variant", void 0);
__decorate$2n([
  n2({ type: Boolean })
], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$2n([
  n2({ type: Boolean })
], WuiButton.prototype, "hasIconRight", void 0);
__decorate$2n([
  n2()
], WuiButton.prototype, "borderRadius", void 0);
__decorate$2n([
  n2()
], WuiButton.prototype, "textVariant", void 0);
WuiButton = __decorate$2n([
  customElement("wui-button")
], WuiButton);
const networkSvgMd = Oe$1`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
const styles$1P = i$2`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-color-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$2m = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiCardSelectLoader = class WuiCardSelectLoader2 extends h {
  constructor() {
    super(...arguments);
    this.type = "wallet";
  }
  render() {
    return ke$1`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
  }
  shimmerTemplate() {
    if (this.type === "network") {
      return ke$1` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvgMd}`;
    }
    return ke$1`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
};
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$1P];
__decorate$2m([
  n2()
], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$2m([
  customElement("wui-card-select-loader")
], WuiCardSelectLoader);
const networkSvgSm = Oe$1`
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`;
const networkSvgLg = Oe$1`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
const styles$1O = i$2`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-color-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-color-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$2l = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiNetworkImage = class WuiNetworkImage2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "uknown";
    this.selected = false;
  }
  render() {
    const networkImagesBySize = { sm: networkSvgSm, md: networkSvgMd, lg: networkSvgLg };
    this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-color-gray-glass-010)"};
      --local-path: var(--wui-path-network-${this.size});
      --local-width:  var(--wui-width-network-${this.size});
      --local-height:  var(--wui-height-network-${this.size});
      --local-icon-size:  var(--wui-icon-size-network-${this.size});
    `;
    return ke$1`${this.templateVisual()} ${networkImagesBySize[this.size]}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    }
    return ke$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiNetworkImage.styles = [resetStyles, styles$1O];
__decorate$2l([
  n2()
], WuiNetworkImage.prototype, "size", void 0);
__decorate$2l([
  n2()
], WuiNetworkImage.prototype, "name", void 0);
__decorate$2l([
  n2()
], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$2l([
  n2({ type: Boolean })
], WuiNetworkImage.prototype, "selected", void 0);
WuiNetworkImage = __decorate$2l([
  customElement("wui-network-image")
], WuiNetworkImage);
const styles$1N = i$2`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }
`;
var __decorate$2k = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiCardSelect = class WuiCardSelect2 extends h {
  constructor() {
    super(...arguments);
    this.name = "Unknown";
    this.type = "wallet";
    this.imageSrc = void 0;
    this.disabled = false;
    this.selected = false;
    this.installed = false;
  }
  render() {
    return ke$1`
      <button data-selected=${to(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (this.type === "network") {
      return ke$1`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${to(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      `;
    }
    return ke$1`
      <wui-wallet-image
        size="md"
        imageSrc=${to(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
};
WuiCardSelect.styles = [resetStyles, elementStyles, styles$1N];
__decorate$2k([
  n2()
], WuiCardSelect.prototype, "name", void 0);
__decorate$2k([
  n2()
], WuiCardSelect.prototype, "type", void 0);
__decorate$2k([
  n2()
], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$2k([
  n2({ type: Boolean })
], WuiCardSelect.prototype, "disabled", void 0);
__decorate$2k([
  n2({ type: Boolean })
], WuiCardSelect.prototype, "selected", void 0);
__decorate$2k([
  n2({ type: Boolean })
], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$2k([
  customElement("wui-card-select")
], WuiCardSelect);
const styles$1M = i$2`
  a {
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-success-glass-010);
    background-color: var(--wui-color-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='error'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-error-glass-010);
    background-color: var(--wui-color-error-glass-010);
    color: var(--wui-color-error-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'],
  a[data-variant='error'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child),
  a[data-variant='error']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image,
  a[data-variant='error'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon,
  a[data-variant='error'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-color-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-color-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-color-success-glass-015);
  }

  a[data-variant='error']:focus-visible {
    background-color: var(--wui-color-error-glass-015);
  }

  a.disabled {
    color: var(--wui-color-gray-glass-015);
    background-color: var(--wui-color-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-color-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-color-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-color-success-glass-015);
    }

    a[data-variant='error']:hover {
      background-color: var(--wui-color-error-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-color-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-color-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-color-success-glass-020);
  }

  a[data-variant='error']:active {
    background-color: var(--wui-color-error-glass-020);
  }
`;
var __decorate$2j = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiChip = class WuiChip2 extends h {
  constructor() {
    super(...arguments);
    this.variant = "fill";
    this.imageSrc = void 0;
    this.disabled = false;
    this.icon = "externalLink";
    this.href = "";
    this.text = void 0;
  }
  render() {
    const isSmall = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall";
    const textVariant = isSmall ? "small-600" : "paragraph-600";
    return ke$1`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return null;
  }
};
WuiChip.styles = [resetStyles, elementStyles, styles$1M];
__decorate$2j([
  n2()
], WuiChip.prototype, "variant", void 0);
__decorate$2j([
  n2()
], WuiChip.prototype, "imageSrc", void 0);
__decorate$2j([
  n2({ type: Boolean })
], WuiChip.prototype, "disabled", void 0);
__decorate$2j([
  n2()
], WuiChip.prototype, "icon", void 0);
__decorate$2j([
  n2()
], WuiChip.prototype, "href", void 0);
__decorate$2j([
  n2()
], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$2j([
  customElement("wui-chip")
], WuiChip);
const styles$1L = i$2`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-color-gray-glass-010);
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$2i = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiConnectButton = class WuiConnectButton2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.loading = false;
  }
  render() {
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return ke$1`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${textVariant} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    if (!this.loading) {
      return null;
    }
    return ke$1`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>`;
  }
};
WuiConnectButton.styles = [resetStyles, elementStyles, styles$1L];
__decorate$2i([
  n2()
], WuiConnectButton.prototype, "size", void 0);
__decorate$2i([
  n2({ type: Boolean })
], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$2i([
  customElement("wui-connect-button")
], WuiConnectButton);
const styles$1K = i$2`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2h = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiCtaButton = class WuiCtaButton2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.buttonLabel = "";
  }
  render() {
    return ke$1`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-chip-button size="sm" variant="shade" text=${this.buttonLabel} icon="chevronRight">
        </wui-chip-button>
      </wui-flex>
    `;
  }
};
WuiCtaButton.styles = [resetStyles, elementStyles, styles$1K];
__decorate$2h([
  n2({ type: Boolean })
], WuiCtaButton.prototype, "disabled", void 0);
__decorate$2h([
  n2()
], WuiCtaButton.prototype, "label", void 0);
__decorate$2h([
  n2()
], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$2h([
  customElement("wui-cta-button")
], WuiCtaButton);
const styles$1J = i$2`
  :host {
    display: block;
    padding: var(--wui-spacing-l) var(--wui-spacing-m);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
  }
`;
var __decorate$2g = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiDetailsGroup = class WuiDetailsGroup2 extends h {
  render() {
    return ke$1`
      <wui-flex gap="xl" flexDirection="column" justifyContent="space-between" alignItems="center">
        <slot></slot>
      </wui-flex>
    `;
  }
};
WuiDetailsGroup.styles = [resetStyles, elementStyles, styles$1J];
WuiDetailsGroup = __decorate$2g([
  customElement("wui-details-group")
], WuiDetailsGroup);
const styles$1I = i$2`
  :host {
    display: flex;
    flex-direction: row;
    gap: var(--wui-spacing-l);
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2f = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiDetailsGroupItem = class WuiDetailsGroupItem2 extends h {
  constructor() {
    super(...arguments);
    this.name = "";
  }
  render() {
    return ke$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">${this.name}</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <slot></slot>
        </wui-flex>
      </wui-flex>
    `;
  }
};
WuiDetailsGroupItem.styles = [resetStyles, elementStyles, styles$1I];
__decorate$2f([
  n2()
], WuiDetailsGroupItem.prototype, "name", void 0);
WuiDetailsGroupItem = __decorate$2f([
  customElement("wui-details-group-item")
], WuiDetailsGroupItem);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rt$1 = (o2) => void 0 === o2.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const mt$1 = (i2, t2) => {
  var _a2;
  const e2 = i2._$AN;
  if (void 0 === e2) return false;
  for (const i3 of e2) (_a2 = i3._$AO) == null ? void 0 : _a2.call(i3, t2, false), mt$1(i3, t2);
  return true;
}, _t$1 = (i2) => {
  let t2, e2;
  do {
    if (void 0 === (t2 = i2._$AM)) break;
    e2 = t2._$AN, e2.delete(i2), i2 = t2;
  } while (0 === (e2 == null ? void 0 : e2.size));
}, wt$1 = (i2) => {
  for (let t2; t2 = i2._$AM; i2 = t2) {
    let e2 = t2._$AN;
    if (void 0 === e2) t2._$AN = e2 = /* @__PURE__ */ new Set();
    else if (e2.has(i2)) break;
    e2.add(i2), gt$1(t2);
  }
};
function bt$1(i2) {
  void 0 !== this._$AN ? (_t$1(this), this._$AM = i2, wt$1(this)) : this._$AM = i2;
}
function yt$1(i2, t2 = false, e2 = 0) {
  const s2 = this._$AH, o2 = this._$AN;
  if (void 0 !== o2 && 0 !== o2.size) if (t2) if (Array.isArray(s2)) for (let i3 = e2; i3 < s2.length; i3++) mt$1(s2[i3], false), _t$1(s2[i3]);
  else null != s2 && (mt$1(s2, false), _t$1(s2));
  else mt$1(this, i2);
}
const gt$1 = (i2) => {
  i2.type == t.CHILD && (i2._$AP ?? (i2._$AP = yt$1), i2._$AQ ?? (i2._$AQ = bt$1));
};
let $t$1 = class $t extends i {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i2, t2, e2) {
    super._$AT(i2, t2, e2), wt$1(this), this.isConnected = i2._$AU;
  }
  _$AO(i2, t2 = true) {
    var _a2, _b2;
    i2 !== this.isConnected && (this.isConnected = i2, i2 ? (_a2 = this.reconnected) == null ? void 0 : _a2.call(this) : (_b2 = this.disconnected) == null ? void 0 : _b2.call(this)), t2 && (mt$1(this, i2), _t$1(this));
  }
  setValue(i2) {
    if (rt$1(this.t)) this.t._$AI(i2, this);
    else {
      const t2 = [...this.t._$AH];
      t2[this.i] = i2, this.t._$AI(t2, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ii = () => new Zt$1();
let Zt$1 = class Zt {
};
const qt$1 = /* @__PURE__ */ new WeakMap(), Kt$1 = e(class extends $t$1 {
  render(t2) {
    return D;
  }
  update(t2, [i2]) {
    var _a2;
    const s2 = i2 !== this.Y;
    return s2 && void 0 !== this.Y && this.rt(void 0), (s2 || this.lt !== this.ct) && (this.Y = i2, this.ht = (_a2 = t2.options) == null ? void 0 : _a2.host, this.rt(this.ct = t2.element)), D;
  }
  rt(t2) {
    if (this.isConnected || (t2 = void 0), "function" == typeof this.Y) {
      const i2 = this.ht ?? globalThis;
      let s2 = qt$1.get(i2);
      void 0 === s2 && (s2 = /* @__PURE__ */ new WeakMap(), qt$1.set(i2, s2)), void 0 !== s2.get(this.Y) && this.Y.call(this.ht, void 0), s2.set(this.Y, t2), void 0 !== t2 && this.Y.call(this.ht, t2);
    } else this.Y.value = t2;
  }
  get lt() {
    var _a2, _b2;
    return "function" == typeof this.Y ? (_a2 = qt$1.get(this.ht ?? globalThis)) == null ? void 0 : _a2.get(this.Y) : (_b2 = this.Y) == null ? void 0 : _b2.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
const styles$1H = i$2`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px var(--wui-spacing-3xl);
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  .wui-padding-right-xs {
    padding-right: var(--wui-spacing-xs);
  }

  .wui-padding-right-s {
    padding-right: var(--wui-spacing-s);
  }

  .wui-padding-right-m {
    padding-right: var(--wui-spacing-m);
  }

  .wui-padding-right-l {
    padding-right: var(--wui-spacing-l);
  }

  .wui-padding-right-xl {
    padding-right: var(--wui-spacing-xl);
  }

  .wui-padding-right-2xl {
    padding-right: var(--wui-spacing-2xl);
  }

  .wui-padding-right-3xl {
    padding-right: var(--wui-spacing-3xl);
  }

  .wui-padding-right-4xl {
    padding-right: var(--wui-spacing-4xl);
  }

  .wui-padding-right-5xl {
    padding-right: var(--wui-spacing-5xl);
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-m) 17.25px var(--wui-spacing-m);
  }
  wui-icon + .wui-size-mdl,
  wui-loading-spinner + .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-3xl) 17.25px 40px;
  }
  wui-icon[data-input='mdl'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$2e = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiInputText = class WuiInputText2 extends h {
  constructor() {
    super(...arguments);
    this.inputElementRef = ii();
    this.size = "md";
    this.disabled = false;
    this.placeholder = "";
    this.type = "text";
    this.value = "";
  }
  render() {
    const inputClass = `wui-padding-right-${this.inputRightPadding}`;
    const sizeClass = `wui-size-${this.size}`;
    const classes = {
      [sizeClass]: true,
      [inputClass]: Boolean(this.inputRightPadding)
    };
    return ke$1`${this.templateIcon()}
      <input
        ${Kt$1(this.inputElementRef)}
        class=${Rt(classes)}
        type=${this.type}
        enterkeyhint=${to(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        .value=${this.value || ""}
      />
      <slot></slot>`;
  }
  templateIcon() {
    if (this.icon) {
      return ke$1`<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
    }
    return null;
  }
  dispatchInputChangeEvent() {
    var _a2;
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: (_a2 = this.inputElementRef.value) == null ? void 0 : _a2.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputText.styles = [resetStyles, elementStyles, styles$1H];
__decorate$2e([
  n2()
], WuiInputText.prototype, "size", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "icon", void 0);
__decorate$2e([
  n2({ type: Boolean })
], WuiInputText.prototype, "disabled", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "placeholder", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "type", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "keyHint", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "value", void 0);
__decorate$2e([
  n2()
], WuiInputText.prototype, "inputRightPadding", void 0);
WuiInputText = __decorate$2e([
  customElement("wui-input-text")
], WuiInputText);
const styles$1G = i$2`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$2d = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiEmailInput = class WuiEmailInput2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return ke$1`
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="mdl"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    if (this.errorMessage) {
      return ke$1`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>`;
    }
    return null;
  }
};
WuiEmailInput.styles = [resetStyles, styles$1G];
__decorate$2d([
  n2()
], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$2d([
  n2({ type: Boolean })
], WuiEmailInput.prototype, "disabled", void 0);
__decorate$2d([
  n2()
], WuiEmailInput.prototype, "value", void 0);
WuiEmailInput = __decorate$2d([
  customElement("wui-email-input")
], WuiEmailInput);
const styles$1F = i$2`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  .error {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }

  .base-name {
    position: absolute;
    right: 45px;
    top: 15px;
    text-align: right;
  }
`;
var __decorate$2c = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiEnsInput = class WuiEnsInput2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.loading = false;
  }
  render() {
    return ke$1`
      <wui-input-text
        value=${to(this.value)}
        ?disabled=${this.disabled}
        .value=${this.value || ""}
        data-testId="wui-ens-input"
        inputRightPadding="5xl"
      >
        ${this.baseNameTemplate()} ${this.errorTemplate()}${this.loadingTemplate()}
      </wui-input-text>
    `;
  }
  baseNameTemplate() {
    return ke$1`<wui-text variant="paragraph-400" color="fg-200" class="base-name">
      ${ConstantsUtil$3.WC_NAME_SUFFIX}
    </wui-text>`;
  }
  loadingTemplate() {
    return this.loading ? ke$1`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  errorTemplate() {
    if (this.errorMessage) {
      return ke$1`<wui-text variant="tiny-500" color="error-100" class="error"
        >${this.errorMessage}</wui-text
      >`;
    }
    return null;
  }
};
WuiEnsInput.styles = [resetStyles, styles$1F];
__decorate$2c([
  n2()
], WuiEnsInput.prototype, "errorMessage", void 0);
__decorate$2c([
  n2({ type: Boolean })
], WuiEnsInput.prototype, "disabled", void 0);
__decorate$2c([
  n2()
], WuiEnsInput.prototype, "value", void 0);
__decorate$2c([
  n2({ type: Boolean })
], WuiEnsInput.prototype, "loading", void 0);
WuiEnsInput = __decorate$2c([
  customElement("wui-ens-input")
], WuiEnsInput);
const styles$1E = i$2`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$2b = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiIconLink = class WuiIconLink2 extends h {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.icon = "copy";
    this.iconColor = "inherit";
  }
  render() {
    const borderRadius2 = this.size === "lg" ? "--wui-border-radius-xs" : "--wui-border-radius-xxs";
    const padding2 = this.size === "lg" ? "--wui-spacing-1xs" : "--wui-spacing-2xs";
    this.style.cssText = `
    --local-border-radius: var(${borderRadius2});
    --local-padding: var(${padding2});
`;
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$1E];
__decorate$2b([
  n2()
], WuiIconLink.prototype, "size", void 0);
__decorate$2b([
  n2({ type: Boolean })
], WuiIconLink.prototype, "disabled", void 0);
__decorate$2b([
  n2()
], WuiIconLink.prototype, "icon", void 0);
__decorate$2b([
  n2()
], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$2b([
  customElement("wui-icon-link")
], WuiIconLink);
const styles$1D = i$2`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var __decorate$2a = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiInputElement = class WuiInputElement2 extends h {
  constructor() {
    super(...arguments);
    this.icon = "copy";
  }
  render() {
    return ke$1`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiInputElement.styles = [resetStyles, elementStyles, styles$1D];
__decorate$2a([
  n2()
], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$2a([
  customElement("wui-input-element")
], WuiInputElement);
const styles$1C = i$2`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
    background: var(--wui-color-gray-glass-005);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }
`;
var __decorate$29 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiInputNumeric = class WuiInputNumeric2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.value = "";
  }
  render() {
    return ke$1`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
  }
};
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$1C];
__decorate$29([
  n2({ type: Boolean })
], WuiInputNumeric.prototype, "disabled", void 0);
__decorate$29([
  n2({ type: String })
], WuiInputNumeric.prototype, "value", void 0);
WuiInputNumeric = __decorate$29([
  customElement("wui-input-numeric")
], WuiInputNumeric);
const styles$1B = i$2`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-color-gray-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$28 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLink = class WuiLink2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
WuiLink.styles = [resetStyles, elementStyles, styles$1B];
__decorate$28([
  n2({ type: Boolean })
], WuiLink.prototype, "disabled", void 0);
__decorate$28([
  n2()
], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$28([
  customElement("wui-link")
], WuiLink);
const styles$1A = i$2`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      color var(--wui-ease-out-power-1) var(--wui-duration-md),
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: color, background-color;
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$27 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListItem = class WuiListItem2 extends h {
  constructor() {
    super(...arguments);
    this.variant = "icon";
    this.disabled = false;
    this.imageSrc = void 0;
    this.alt = void 0;
    this.chevron = false;
    this.loading = false;
  }
  render() {
    return ke$1`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${to(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
    }
    if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
      return ke$1`<wui-icon name=${this.icon}></wui-icon>`;
    }
    if (this.variant === "icon" && this.icon && this.iconVariant) {
      const color2 = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
      const size = this.iconVariant === "square-blue" ? "mdl" : "md";
      const iconSize = this.iconSize ? this.iconSize : size;
      return ke$1`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color2}
          backgroundColor=${color2}
          size=${size}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    if (this.loading) {
      return ke$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return ke$1``;
  }
  chevronTemplate() {
    if (this.chevron) {
      return ke$1`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
    }
    return null;
  }
};
WuiListItem.styles = [resetStyles, elementStyles, styles$1A];
__decorate$27([
  n2()
], WuiListItem.prototype, "icon", void 0);
__decorate$27([
  n2()
], WuiListItem.prototype, "iconSize", void 0);
__decorate$27([
  n2()
], WuiListItem.prototype, "variant", void 0);
__decorate$27([
  n2()
], WuiListItem.prototype, "iconVariant", void 0);
__decorate$27([
  n2({ type: Boolean })
], WuiListItem.prototype, "disabled", void 0);
__decorate$27([
  n2()
], WuiListItem.prototype, "imageSrc", void 0);
__decorate$27([
  n2()
], WuiListItem.prototype, "alt", void 0);
__decorate$27([
  n2({ type: Boolean })
], WuiListItem.prototype, "chevron", void 0);
__decorate$27([
  n2({ type: Boolean })
], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$27([
  customElement("wui-list-item")
], WuiListItem);
var TransactionTypePastTense;
(function(TransactionTypePastTense2) {
  TransactionTypePastTense2["approve"] = "approved";
  TransactionTypePastTense2["bought"] = "bought";
  TransactionTypePastTense2["borrow"] = "borrowed";
  TransactionTypePastTense2["burn"] = "burnt";
  TransactionTypePastTense2["cancel"] = "canceled";
  TransactionTypePastTense2["claim"] = "claimed";
  TransactionTypePastTense2["deploy"] = "deployed";
  TransactionTypePastTense2["deposit"] = "deposited";
  TransactionTypePastTense2["execute"] = "executed";
  TransactionTypePastTense2["mint"] = "minted";
  TransactionTypePastTense2["receive"] = "received";
  TransactionTypePastTense2["repay"] = "repaid";
  TransactionTypePastTense2["send"] = "sent";
  TransactionTypePastTense2["sell"] = "sold";
  TransactionTypePastTense2["stake"] = "staked";
  TransactionTypePastTense2["trade"] = "swapped";
  TransactionTypePastTense2["unstake"] = "unstaked";
  TransactionTypePastTense2["withdraw"] = "withdrawn";
})(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$1z = i$2`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$26 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTransactionVisual = class WuiTransactionVisual2 extends h {
  constructor() {
    super(...arguments);
    this.images = [];
    this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [firstImage, secondImage] = this.images;
    const isLeftNFT = (firstImage == null ? void 0 : firstImage.type) === "NFT";
    const isRightNFT = (secondImage == null ? void 0 : secondImage.url) ? secondImage.type === "NFT" : isLeftNFT;
    const leftRadius = isLeftNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    const rightRadius = isRightNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
    return ke$1`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
  }
  templateVisual() {
    const [firstImage, secondImage] = this.images;
    const firstImageType = firstImage == null ? void 0 : firstImage.type;
    const haveTwoImages = this.images.length === 2;
    if (haveTwoImages && ((firstImage == null ? void 0 : firstImage.url) || (secondImage == null ? void 0 : secondImage.url))) {
      return ke$1`<div class="swap-images-container">
        ${(firstImage == null ? void 0 : firstImage.url) ? ke$1`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>` : null}
        ${(secondImage == null ? void 0 : secondImage.url) ? ke$1`<wui-image src=${secondImage.url} alt="Transaction image"></wui-image>` : null}
      </div>`;
    } else if (firstImage == null ? void 0 : firstImage.url) {
      return ke$1`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`;
    } else if (firstImageType === "NFT") {
      return ke$1`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>`;
    }
    return ke$1`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
  }
  templateIcon() {
    let color2 = "accent-100";
    let icon = void 0;
    icon = this.getIcon();
    if (this.status) {
      color2 = this.getStatusColor();
    }
    if (!icon) {
      return null;
    }
    return ke$1`
      <wui-icon-box
        size="xxs"
        iconColor=${color2}
        backgroundColor=${color2}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    `;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return void 0;
    }
  }
  getIcon() {
    if (this.onlyDirectionIcon) {
      return this.getDirectionIcon();
    }
    if (this.type === "trade") {
      return "swapHorizontalBold";
    } else if (this.type === "approve") {
      return "checkmark";
    } else if (this.type === "cancel") {
      return "close";
    }
    return this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
WuiTransactionVisual.styles = [styles$1z];
__decorate$26([
  n2()
], WuiTransactionVisual.prototype, "type", void 0);
__decorate$26([
  n2()
], WuiTransactionVisual.prototype, "status", void 0);
__decorate$26([
  n2()
], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$26([
  n2({ type: Boolean })
], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$26([
  n2({ type: Array })
], WuiTransactionVisual.prototype, "images", void 0);
__decorate$26([
  n2({ type: Object })
], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$26([
  customElement("wui-transaction-visual")
], WuiTransactionVisual);
const styles$1y = i$2`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-xs) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$25 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTransactionListItem = class WuiTransactionListItem2 extends h {
  constructor() {
    super(...arguments);
    this.type = "approve";
    this.onlyDirectionIcon = false;
    this.images = [];
    this.price = [];
    this.amount = [];
    this.symbol = [];
  }
  render() {
    return ke$1`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${to(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${to(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type] || this.type}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
  }
  templateDescription() {
    var _a2;
    const description = (_a2 = this.descriptions) == null ? void 0 : _a2[0];
    return description ? ke$1`
          <wui-text variant="small-500" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
  templateSecondDescription() {
    var _a2;
    const description = (_a2 = this.descriptions) == null ? void 0 : _a2[1];
    return description ? ke$1`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
};
WuiTransactionListItem.styles = [resetStyles, styles$1y];
__decorate$25([
  n2()
], WuiTransactionListItem.prototype, "type", void 0);
__decorate$25([
  n2({ type: Array })
], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$25([
  n2()
], WuiTransactionListItem.prototype, "date", void 0);
__decorate$25([
  n2({ type: Boolean })
], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$25([
  n2()
], WuiTransactionListItem.prototype, "status", void 0);
__decorate$25([
  n2()
], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$25([
  n2({ type: Array })
], WuiTransactionListItem.prototype, "images", void 0);
__decorate$25([
  n2({ type: Array })
], WuiTransactionListItem.prototype, "price", void 0);
__decorate$25([
  n2({ type: Array })
], WuiTransactionListItem.prototype, "amount", void 0);
__decorate$25([
  n2({ type: Array })
], WuiTransactionListItem.prototype, "symbol", void 0);
WuiTransactionListItem = __decorate$25([
  customElement("wui-transaction-list-item")
], WuiTransactionListItem);
const styles$1x = i$2`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$24 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTransactionListItemLoader = class WuiTransactionListItemLoader2 extends h {
  render() {
    return ke$1`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
  }
};
WuiTransactionListItemLoader.styles = [resetStyles, styles$1x];
WuiTransactionListItemLoader = __decorate$24([
  customElement("wui-transaction-list-item-loader")
], WuiTransactionListItemLoader);
const styles$1w = i$2`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-color-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 11px 5px !important;
  }

  :host([data-size='lg']) > wui-text {
    transform: translateY(2%);
  }
`;
var __decorate$23 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTag = class WuiTag2 extends h {
  constructor() {
    super(...arguments);
    this.variant = "main";
    this.size = "lg";
  }
  render() {
    this.dataset["variant"] = this.variant;
    this.dataset["size"] = this.size;
    const textVariant = this.size === "md" ? "mini-700" : "micro-700";
    return ke$1`
      <wui-text data-variant=${this.variant} variant=${textVariant} color="inherit">
        <slot></slot>
      </wui-text>
    `;
  }
};
WuiTag.styles = [resetStyles, styles$1w];
__decorate$23([
  n2()
], WuiTag.prototype, "variant", void 0);
__decorate$23([
  n2()
], WuiTag.prototype, "size", void 0);
WuiTag = __decorate$23([
  customElement("wui-tag")
], WuiTag);
const styles$1v = i$2`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }
`;
var __decorate$22 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListWallet = class WuiListWallet2 extends h {
  constructor() {
    super(...arguments);
    this.walletImages = [];
    this.imageSrc = "";
    this.name = "";
    this.installed = false;
    this.disabled = false;
    this.showAllWallets = false;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    if (this.showAllWallets && this.imageSrc) {
      return ke$1` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
    } else if (this.showAllWallets && this.walletIcon) {
      return ke$1` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
    }
    return null;
  }
  templateWalletImage() {
    if (!this.showAllWallets && this.imageSrc) {
      return ke$1`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
    } else if (!this.showAllWallets && !this.imageSrc) {
      return ke$1`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
    }
    return null;
  }
  templateStatus() {
    if (this.tagLabel && this.tagVariant) {
      return ke$1`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
    } else if (this.icon) {
      return ke$1`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
    }
    return null;
  }
};
WuiListWallet.styles = [resetStyles, elementStyles, styles$1v];
__decorate$22([
  n2({ type: Array })
], WuiListWallet.prototype, "walletImages", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "name", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "icon", void 0);
__decorate$22([
  n2()
], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$22([
  n2({ type: Boolean })
], WuiListWallet.prototype, "installed", void 0);
__decorate$22([
  n2({ type: Boolean })
], WuiListWallet.prototype, "disabled", void 0);
__decorate$22([
  n2({ type: Boolean })
], WuiListWallet.prototype, "showAllWallets", void 0);
WuiListWallet = __decorate$22([
  customElement("wui-list-wallet")
], WuiListWallet);
const styles$1u = i$2`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$21 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLogo = class WuiLogo2 extends h {
  constructor() {
    super(...arguments);
    this.logo = "google";
  }
  render() {
    return ke$1`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
  }
};
WuiLogo.styles = [resetStyles, styles$1u];
__decorate$21([
  n2()
], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$21([
  customElement("wui-logo")
], WuiLogo);
const styles$1t = i$2`
  :host {
    display: block;
    width: 100%;
  }

  button {
    width: 100%;
    height: 56px;
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$20 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiLogoSelect = class WuiLogoSelect2 extends h {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.disabled = false;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
  }
};
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$1t];
__decorate$20([
  n2()
], WuiLogoSelect.prototype, "logo", void 0);
__decorate$20([
  n2({ type: Boolean })
], WuiLogoSelect.prototype, "disabled", void 0);
WuiLogoSelect = __decorate$20([
  customElement("wui-logo-select")
], WuiLogoSelect);
const styles$1s = i$2`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }
`;
var __decorate$1$ = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiNetworkButton = class WuiNetworkButton2 extends h {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.isUnsupportedChain) {
      return ke$1`
        <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
      `;
    }
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return ke$1`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$1s];
__decorate$1$([
  n2()
], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$1$([
  n2({ type: Boolean })
], WuiNetworkButton.prototype, "isUnsupportedChain", void 0);
__decorate$1$([
  n2({ type: Boolean })
], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$1$([
  customElement("wui-network-button")
], WuiNetworkButton);
const styles$1r = i$2`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$1_ = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiOtp = class WuiOtp2 extends h {
  constructor() {
    super(...arguments);
    this.length = 6;
    this.otp = "";
    this.values = Array.from({ length: this.length }).map(() => "");
    this.numerics = [];
    this.shouldInputBeEnabled = (index) => {
      const previousInputs = this.values.slice(0, index);
      return previousInputs.every((input) => input !== "");
    };
    this.handleKeyDown = (e2, index) => {
      const inputElement = e2.target;
      const input = this.getInputElement(inputElement);
      const keyArr = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!input) {
        return;
      }
      if (keyArr.includes(e2.key)) {
        e2.preventDefault();
      }
      const currentCaretPos = input.selectionStart;
      switch (e2.key) {
        case "ArrowLeft":
          if (currentCaretPos) {
            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
          }
          this.focusInputField("prev", index);
          break;
        case "ArrowRight":
          this.focusInputField("next", index);
          break;
        case "Shift":
          this.focusInputField("next", index);
          break;
        case "Delete":
          if (input.value === "") {
            this.focusInputField("prev", index);
          } else {
            this.updateInput(input, index, "");
          }
          break;
        case "Backspace":
          if (input.value === "") {
            this.focusInputField("prev", index);
          } else {
            this.updateInput(input, index, "");
          }
          break;
      }
    };
    this.focusInputField = (dir, index) => {
      if (dir === "next") {
        const nextIndex = index + 1;
        if (!this.shouldInputBeEnabled(nextIndex)) {
          return;
        }
        const numeric2 = this.numerics[nextIndex < this.length ? nextIndex : index];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.disabled = false;
          input.focus();
        }
      }
      if (dir === "prev") {
        const nextIndex = index - 1;
        const numeric2 = this.numerics[nextIndex > -1 ? nextIndex : index];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.focus();
        }
      }
    };
  }
  firstUpdated() {
    var _a2, _b2;
    if (this.otp) {
      this.values = this.otp.split("");
    }
    const numericElements = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelectorAll("wui-input-numeric");
    if (numericElements) {
      this.numerics = Array.from(numericElements);
    }
    (_b2 = this.numerics[0]) == null ? void 0 : _b2.focus();
  }
  render() {
    return ke$1`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_2, index) => ke$1`
            <wui-input-numeric
              @input=${(e2) => this.handleInput(e2, index)}
              @click=${(e2) => this.selectInput(e2)}
              @keydown=${(e2) => this.handleKeyDown(e2, index)}
              .disabled=${!this.shouldInputBeEnabled(index)}
              .value=${this.values[index] || ""}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
  }
  updateInput(element, index, value2) {
    const numeric2 = this.numerics[index];
    const input = element || (numeric2 ? this.getInputElement(numeric2) : void 0);
    if (input) {
      input.value = value2;
      this.values = this.values.map((val, i2) => i2 === index ? value2 : val);
    }
  }
  selectInput(e2) {
    const targetElement = e2.target;
    if (targetElement) {
      const inputElement = this.getInputElement(targetElement);
      inputElement == null ? void 0 : inputElement.select();
    }
  }
  handleInput(e2, index) {
    const inputElement = e2.target;
    const input = this.getInputElement(inputElement);
    if (input) {
      const inputValue = input.value;
      if (e2.inputType === "insertFromPaste") {
        this.handlePaste(input, inputValue, index);
      } else {
        const isValid3 = UiHelperUtil.isNumber(inputValue);
        if (isValid3 && e2.data) {
          this.updateInput(input, index, e2.data);
          this.focusInputField("next", index);
        } else {
          this.updateInput(input, index, "");
        }
      }
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(input, inputValue, index) {
    const value2 = inputValue[0];
    const isValid3 = value2 && UiHelperUtil.isNumber(value2);
    if (isValid3) {
      this.updateInput(input, index, value2);
      const inputString = inputValue.substring(1);
      if (index + 1 < this.length && inputString.length) {
        const nextNumeric = this.numerics[index + 1];
        const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : void 0;
        if (nextInput) {
          this.handlePaste(nextInput, inputString, index + 1);
        }
      } else {
        this.focusInputField("next", index);
      }
    } else {
      this.updateInput(input, index, "");
    }
  }
  getInputElement(el2) {
    var _a2;
    if ((_a2 = el2.shadowRoot) == null ? void 0 : _a2.querySelector("input")) {
      return el2.shadowRoot.querySelector("input");
    }
    return null;
  }
  dispatchInputChangeEvent() {
    const value2 = this.values.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: value2,
      bubbles: true,
      composed: true
    }));
  }
};
WuiOtp.styles = [resetStyles, styles$1r];
__decorate$1_([
  n2({ type: Number })
], WuiOtp.prototype, "length", void 0);
__decorate$1_([
  n2({ type: String })
], WuiOtp.prototype, "otp", void 0);
__decorate$1_([
  r$1()
], WuiOtp.prototype, "values", void 0);
WuiOtp = __decorate$1_([
  customElement("wui-otp")
], WuiOtp);
var browser = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$b = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$b.getSymbolSize = function getSymbolSize(version2) {
  if (!version2) throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$b.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$b.getBCHDigit = function(data2) {
  let digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
utils$b.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$b.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$b.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports) {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from2(value2, defaultValue) {
    if (exports.isValid(value2)) {
      return value2;
    }
    try {
      return fromString(value2);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index) {
    const bufIndex = Math.floor(index / 8);
    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
  },
  put: function(num, length2) {
    for (let i2 = 0; i2 < length2; i2++) {
      this.putBit((num >>> length2 - i2 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size) {
  if (!size || size < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size;
  this.data = new Uint8Array(size * size);
  this.reservedBit = new Uint8Array(size * size);
}
BitMatrix$1.prototype.set = function(row, col, value2, reserved) {
  const index = row * this.size + col;
  this.data[index] = value2;
  if (reserved) this.reservedBit[index] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value2) {
  this.data[row * this.size + col] ^= value2;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports) {
  const getSymbolSize3 = utils$b.getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1) return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size = getSymbolSize3(version2);
    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
    const positions = [size - 7];
    for (let i2 = 1; i2 < posCount - 1; i2++) {
      positions[i2] = positions[i2 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions2(version2) {
    const coords = [];
    const pos = exports.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i2 = 0; i2 < posLength; i2++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i2 === 0 && j2 === 0 || // top-left
        i2 === 0 && j2 === posLength - 1 || // bottom-left
        i2 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i2], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize2 = utils$b.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  const size = getSymbolSize2(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid3(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports.from = function from2(value2) {
    return exports.isValid(value2) ? parseInt(value2, 10) : void 0;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data2) {
    const size = data2.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size; col++) {
        let module = data2.get(row, col);
        if (module === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module;
          sameCountCol = 1;
        }
        module = data2.get(col, row);
        if (module === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data2) {
    const size = data2.size;
    let points = 0;
    for (let row = 0; row < size - 1; row++) {
      for (let col = 0; col < size - 1; col++) {
        const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last === 4 || last === 0) points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data2) {
    const size = data2.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data2) {
    let darkCount = 0;
    const modulesCount = data2.data.length;
    for (let i2 = 0; i2 < modulesCount; i2++) darkCount += data2.data[i2];
    const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i2, j2) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i2 + j2) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i2 % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i2 + j2) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i2 * j2 % 2 + i2 * j2 % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports.applyMask = function applyMask(pattern, data2) {
    const size = data2.size;
    for (let col = 0; col < size; col++) {
      for (let row = 0; row < size; row++) {
        if (data2.isReserved(row, col)) continue;
        data2.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports.applyMask(p2, data2);
      const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
      exports.applyMask(p2, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i2 = 0; i2 < 255; i2++) {
    EXP_TABLE[i2] = x2;
    LOG_TABLE[x2] = i2;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i2 = 255; i2 < 512; i2++) {
    EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
  }
})();
galoisField.log = function log(n3) {
  if (n3 < 1) throw new Error("log(" + n3 + ")");
  return LOG_TABLE[n3];
};
galoisField.exp = function exp(n3) {
  return EXP_TABLE[n3];
};
galoisField.mul = function mul(x2, y2) {
  if (x2 === 0 || y2 === 0) return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports) {
  const GF = galoisField;
  exports.mul = function mul2(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i2 = 0; i2 < p1.length; i2++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
      }
    }
    return coeff;
  };
  exports.mod = function mod2(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i2 = 0; i2 < divisor.length; i2++) {
        result[i2] ^= GF.mul(divisor[i2], coeff);
      }
      let offset2 = 0;
      while (offset2 < result.length && result[offset2] === 0) offset2++;
      result = result.slice(offset2);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i2 = 0; i2 < degree; i2++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree) this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode3(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data2.length + this.degree);
  paddedData.set(data2);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid2(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
    else if (version2 < 27) return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr)) return exports.KANJI;
    else return exports.BYTE;
  };
  exports.toString = function toString2(mode2) {
    if (mode2 && mode2.id) return mode2.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports.from = function from2(value2, defaultValue) {
    if (exports.isValid(value2)) {
      return value2;
    }
    try {
      return fromString(value2);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports) {
  const Utils2 = utils$b;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data2) {
      const reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length2 = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports.from = function from2(value2, defaultValue) {
    if (VersionCheck.isValid(value2)) {
      return parseInt(value2, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined") mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED) return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version);
var formatInfo = {};
const Utils$3 = utils$b;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask2) {
  const data2 = errorCorrectionLevel2.bit << 3 | mask2;
  let d2 = data2 << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data2 << 10 | d2) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length2) {
  return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer2) {
  let i2, group, value2;
  for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
    group = this.data.substr(i2, 3);
    value2 = parseInt(group, 10);
    bitBuffer2.put(value2, 10);
  }
  const remainingNum = this.data.length - i2;
  if (remainingNum > 0) {
    group = this.data.substr(i2);
    value2 = parseInt(group, 10);
    bitBuffer2.put(value2, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length2) {
  return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write2(bitBuffer2) {
  let i2;
  for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
    let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
    value2 += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
    bitBuffer2.put(value2, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
  }
};
var alphanumericData = AlphanumericData;
var encodeUtf8$1 = function encodeUtf8(input) {
  var result = [];
  var size = input.length;
  for (var index = 0; index < size; index++) {
    var point = input.charCodeAt(index);
    if (point >= 55296 && point <= 56319 && size > index + 1) {
      var second = input.charCodeAt(index + 1);
      if (second >= 56320 && second <= 57343) {
        point = (point - 55296) * 1024 + second - 56320 + 65536;
        index += 1;
      }
    }
    if (point < 128) {
      result.push(point);
      continue;
    }
    if (point < 2048) {
      result.push(point >> 6 | 192);
      result.push(point & 63 | 128);
      continue;
    }
    if (point < 55296 || point >= 57344 && point < 65536) {
      result.push(point >> 12 | 224);
      result.push(point >> 6 & 63 | 128);
      result.push(point & 63 | 128);
      continue;
    }
    if (point >= 65536 && point <= 1114111) {
      result.push(point >> 18 | 240);
      result.push(point >> 12 & 63 | 128);
      result.push(point >> 6 & 63 | 128);
      result.push(point & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const encodeUtf82 = encodeUtf8$1;
const Mode$2 = mode;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  if (typeof data2 === "string") {
    data2 = encodeUtf82(data2);
  }
  this.data = new Uint8Array(data2);
}
ByteData.getBitsLength = function getBitsLength5(length2) {
  return length2 * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
    bitBuffer2.put(this.data[i2], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$b;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length2) {
  return length2 * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i2;
  for (i2 = 0; i2 < this.data.length; i2++) {
    let value2 = Utils$2.toSJIS(this.data[i2]);
    if (value2 >= 33088 && value2 <= 40956) {
      value2 -= 33088;
    } else if (value2 >= 57408 && value2 <= 60351) {
      value2 -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
      );
    }
    value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
    bitBuffer2.put(value2, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d2) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s2, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d2
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key;
        opts = opts || {};
        for (key in T2) {
          if (T2.hasOwnProperty(key)) {
            t2[key] = T2[key];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value2, cost) {
        var item = { value: value2, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module.exports = dijkstra2;
  }
})(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(exports) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$b;
  const dijkstra2 = dijkstraExports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length2, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length2);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length2);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length2);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length2);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i2 = 0; i2 < segs.length; i2++) {
      const seg = segs[i2];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const nodeGroup = nodes[i2];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node2 = nodeGroup[j2];
        const key = "" + i2 + j2;
        currentNodeIds.push(key);
        table[key] = { node: node2, lastCount: 0 };
        graph[key] = {};
        for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
          const prevNodeId = prevNodeIds[n3];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
            table[prevNodeId].lastCount += node2.length;
          } else {
            if (table[prevNodeId]) table[prevNodeId].lastCount = node2.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode2.getCharCountIndicator(node2.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
      graph[prevNodeIds[n3]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports.fromArray = function fromArray(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString(data2, version2) {
    const segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i2 = 1; i2 < path.length - 1; i2++) {
      optimizedSegs.push(graph.table[path[i2]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data2) {
    return exports.fromArray(
      getSegmentsFromString(data2, Utils2.isKanjiModeEnabled())
    );
  };
})(segments);
const Utils$1 = utils$b;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix, version2) {
  const size = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i2 = 0; i2 < pos.length; i2++) {
    const row = pos[i2][0];
    const col = pos[i2][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size <= row + r2) continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size <= col + c2) continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size = matrix.size;
  for (let r2 = 8; r2 < size - 8; r2++) {
    const value2 = r2 % 2 === 0;
    matrix.set(r2, 6, value2, true);
    matrix.set(6, r2, value2, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i2 = 0; i2 < pos.length; i2++) {
    const row = pos[i2][0];
    const col = pos[i2][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod2;
  for (let i2 = 0; i2 < 18; i2++) {
    row = Math.floor(i2 / 3);
    col = i2 % 3 + size - 8 - 3;
    mod2 = (bits >> i2 & 1) === 1;
    matrix.set(row, col, mod2, true);
    matrix.set(col, row, mod2, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i2, mod2;
  for (i2 = 0; i2 < 15; i2++) {
    mod2 = (bits >> i2 & 1) === 1;
    if (i2 < 6) {
      matrix.set(i2, 8, mod2, true);
    } else if (i2 < 8) {
      matrix.set(i2 + 1, 8, mod2, true);
    } else {
      matrix.set(size - 15 + i2, 8, mod2, true);
    }
    if (i2 < 8) {
      matrix.set(8, size - i2 - 1, mod2, true);
    } else if (i2 < 9) {
      matrix.set(8, 15 - i2 - 1 + 1, mod2, true);
    } else {
      matrix.set(8, 15 - i2 - 1, mod2, true);
    }
  }
  matrix.set(size - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  const size = matrix.size;
  let inc = -1;
  let row = size - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark2 = false;
          if (byteIndex < data2.length) {
            dark2 = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark2);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i2 = 0; i2 < remainingByte; i2++) {
    buffer2.put(i2 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset2 = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset2, offset2 + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset2 += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data2 = new Uint8Array(totalCodewords);
  let index = 0;
  let i2, r2;
  for (i2 = 0; i2 < maxDataSize; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i2 < dcData[r2].length) {
        data2[index++] = dcData[r2][i2];
      }
    }
  }
  for (i2 = 0; i2 < ecCount; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data2[index++] = ecData[r2][i2];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create2(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask2 = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask2);
};
var canvas = {};
var utils$a = {};
(function(exports) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6) hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options) options = {};
    if (!options.color) options.color = {};
    const margin2 = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width2 = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width: width2,
      scale: width2 ? 4 : scale,
      margin: margin2,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale2(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size = qr.modules.size;
    const data2 = qr.modules.data;
    const scale = exports.getScale(size, opts);
    const symbolSize = Math.floor((size + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i2 = 0; i2 < symbolSize; i2++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i2 * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i2 - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$a);
(function(exports) {
  const Utils2 = utils$a;
  function clearCanvas(ctx, canvas2, size) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style) canvas2.style = {};
    canvas2.height = size;
    canvas2.width = size;
    canvas2.style.height = size + "px";
    canvas2.style.width = size + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render2(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size, size);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts) opts = {};
    const canvasEl = exports.render(qrData, canvas2, opts);
    const type3 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type3, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils$a;
function getColorAttrib(color2, attrib) {
  const alpha2 = color2.a / 255;
  const str = attrib + '="' + color2.hex + '"';
  return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined") str += " " + y2;
  return str;
}
function qrToPath(data2, size, margin2) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i2 = 0; i2 < data2.length; i2++) {
    const col = Math.floor(i2 % size);
    const row = Math.floor(i2 / size);
    if (!col && !newRow) newRow = true;
    if (data2[i2]) {
      lineLength++;
      if (!(i2 > 0 && col > 0 && data2[i2 - 1])) {
        path += newRow ? svgCmd("M", col + margin2, 0.5 + row + margin2) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size && data2[i2 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb2) {
  const opts = Utils.getOptions(options);
  const size = qrData.modules.size;
  const data2 = qrData.modules.data;
  const qrcodesize = size + opts.margin * 2;
  const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width2 = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width2 + viewBox + ' shape-rendering="crispEdges">' + bg2 + path + "</svg>\n";
  if (typeof cb2 === "function") {
    cb2(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb2) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb2 = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb2 === "undefined") {
        cb2 = opts;
        opts = void 0;
      } else {
        cb2 = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data2 = QRCode.create(text, opts);
        resolve(renderFunc(data2, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data2 = QRCode.create(text, opts);
    cb2(null, renderFunc(data2, canvas2, opts));
  } catch (e2) {
    cb2(e2);
  }
}
browser.create = QRCode.create;
browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser.toString = renderCanvas.bind(null, function(data2, _2, opts) {
  return SvgRenderer.render(data2, opts);
});
const CONNECTING_ERROR_MARGIN = 0.1;
const CIRCLE_SIZE_MODIFIER = 2.5;
const QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value2, errorCorrectionLevel2) {
  const arr = Array.prototype.slice.call(browser.create(value2, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key, index) => (index % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
}
const QrCodeUtil = {
  generate(uri, size, logoSize) {
    const dotColor = "#141414";
    const edgeColor = "transparent";
    const strokeWidth = 5;
    const dots = [];
    const matrix = getMatrix(uri, "Q");
    const cellSize = size / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y2 }) => {
      const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x2;
      const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y2;
      const borderRadius2 = 0.45;
      for (let i2 = 0; i2 < qrList.length; i2 += 1) {
        const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i2 * 2);
        dots.push(Oe$1`
            <rect
              fill=${i2 === 2 ? dotColor : edgeColor}
              width=${i2 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i2 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              ry= ${i2 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              stroke=${dotColor}
              stroke-width=${i2 === 0 ? strokeWidth : 0}
              height=${i2 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i2 === 0 ? y1 + cellSize * i2 + strokeWidth / 2 : y1 + cellSize * i2}
              y= ${i2 === 0 ? x1 + cellSize * i2 + strokeWidth / 2 : x1 + cellSize * i2}
            />
          `);
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    const circles = [];
    matrix.forEach((row, i2) => {
      row.forEach((_2, j2) => {
        if (matrix[i2][j2]) {
          if (!(i2 < QRCODE_MATRIX_MARGIN && j2 < QRCODE_MATRIX_MARGIN || i2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j2 < QRCODE_MATRIX_MARGIN || i2 < QRCODE_MATRIX_MARGIN && j2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
            if (!(i2 > matrixMiddleStart && i2 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              const cx = i2 * cellSize + cellSize / 2;
              const cy = j2 * cellSize + cellSize / 2;
              circles.push([cx, cy]);
            }
          }
        }
      });
    });
    const circlesToConnect = {};
    circles.forEach(([cx, cy]) => {
      var _a2;
      if (circlesToConnect[cx]) {
        (_a2 = circlesToConnect[cx]) == null ? void 0 : _a2.push(cy);
      } else {
        circlesToConnect[cx] = [cy];
      }
    });
    Object.entries(circlesToConnect).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).forEach(([cx, cys]) => {
      cys.forEach((cy) => {
        dots.push(Oe$1`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
      });
    });
    Object.entries(circlesToConnect).filter(([_2, cys]) => cys.length > 1).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).map(([cx, cys]) => {
      cys.sort((a2, b2) => a2 < b2 ? -1 : 1);
      const groups = [];
      for (const cy of cys) {
        const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
        if (group) {
          group.push(cy);
        } else {
          groups.push([cy]);
        }
      }
      return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
    }).forEach(([cx, groups]) => {
      groups.forEach(([y1, y2]) => {
        dots.push(Oe$1`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y2}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    });
    return dots;
  }
};
const styles$1q = i$2`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$1Z = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiQrCode = class WuiQrCode2 extends h {
  constructor() {
    super(...arguments);
    this.uri = "";
    this.size = 0;
    this.theme = "dark";
    this.imageSrc = void 0;
    this.alt = void 0;
    this.arenaClear = void 0;
  }
  render() {
    this.dataset["theme"] = this.theme;
    this.dataset["clear"] = String(this.arenaClear);
    this.style.cssText = `--local-size: ${this.size}px`;
    return ke$1`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const size = this.theme === "light" ? this.size : this.size - 16 * 2;
    return Oe$1`
      <svg height=${size} width=${size}>
        ${QrCodeUtil.generate(this.uri, size, this.arenaClear ? 0 : size / 4)}
      </svg>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>`;
    }
    return ke$1`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
  }
};
WuiQrCode.styles = [resetStyles, styles$1q];
__decorate$1Z([
  n2()
], WuiQrCode.prototype, "uri", void 0);
__decorate$1Z([
  n2({ type: Number })
], WuiQrCode.prototype, "size", void 0);
__decorate$1Z([
  n2()
], WuiQrCode.prototype, "theme", void 0);
__decorate$1Z([
  n2()
], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$1Z([
  n2()
], WuiQrCode.prototype, "alt", void 0);
__decorate$1Z([
  n2({ type: Boolean })
], WuiQrCode.prototype, "arenaClear", void 0);
WuiQrCode = __decorate$1Z([
  customElement("wui-qr-code")
], WuiQrCode);
const styles$1p = i$2`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$1Y = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiSearchBar = class WuiSearchBar2 extends h {
  constructor() {
    super(...arguments);
    this.inputComponentRef = ii();
  }
  render() {
    return ke$1`
      <wui-input-text
        ${Kt$1(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
  }
  clearValue() {
    const inputComponent = this.inputComponentRef.value;
    const inputElement = inputComponent == null ? void 0 : inputComponent.inputElementRef.value;
    if (inputElement) {
      inputElement.value = "";
      inputElement.focus();
      inputElement.dispatchEvent(new Event("input"));
    }
  }
};
WuiSearchBar.styles = [resetStyles, styles$1p];
WuiSearchBar = __decorate$1Y([
  customElement("wui-search-bar")
], WuiSearchBar);
const styles$1o = i$2`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    box-sizing: border-box;
    max-height: 40px;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }

  :host wui-loading-spinner {
    margin-left: var(--wui-spacing-3xs);
  }
`;
var __decorate$1X = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiSnackbar = class WuiSnackbar2 extends h {
  constructor() {
    super(...arguments);
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "checkmark";
    this.message = "";
    this.loading = false;
  }
  render() {
    return ke$1`
      ${this.loading ? ke$1`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : ke$1`<wui-icon-box
            size="sm"
            iconSize="xs"
            iconColor=${this.iconColor}
            backgroundColor=${this.backgroundColor}
            icon=${this.icon}
            background="opaque"
          ></wui-icon-box>`}
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
  }
};
WuiSnackbar.styles = [resetStyles, styles$1o];
__decorate$1X([
  n2()
], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$1X([
  n2()
], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$1X([
  n2()
], WuiSnackbar.prototype, "icon", void 0);
__decorate$1X([
  n2()
], WuiSnackbar.prototype, "message", void 0);
__decorate$1X([
  n2()
], WuiSnackbar.prototype, "loading", void 0);
WuiSnackbar = __decorate$1X([
  customElement("wui-snackbar")
], WuiSnackbar);
const styles$1n = i$2`
  :host {
    display: inline-flex;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: color var(--wui-e ase-out-power-1) var(--wui-duration-md);
    will-change: color;
  }

  button {
    width: var(--local-tab-width);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$1W = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTabs = class WuiTabs2 extends h {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.onTabChange = () => null;
    this.buttons = [];
    this.disabled = false;
    this.localTabWidth = "100px";
    this.activeTab = 0;
    this.isDense = false;
  }
  render() {
    this.isDense = this.tabs.length > 3;
    this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
    this.dataset["type"] = this.isDense ? "flex" : "block";
    return this.tabs.map((tab, index) => {
      var _a2;
      const isActive = index === this.activeTab;
      return ke$1`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index)}
          data-active=${isActive}
          data-testid="tab-${(_a2 = tab.label) == null ? void 0 : _a2.toLowerCase()}"
        >
          ${this.iconTemplate(tab)}
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    if (this.shadowRoot && this.isDense) {
      this.buttons = [...this.shadowRoot.querySelectorAll("button")];
      setTimeout(() => {
        this.animateTabs(0, true);
      }, 0);
    }
  }
  iconTemplate(tab) {
    if (tab.icon) {
      return ke$1`<wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>`;
    }
    return null;
  }
  onTabClick(index) {
    if (this.buttons) {
      this.animateTabs(index, false);
    }
    this.activeTab = index;
    this.onTabChange(index);
  }
  animateTabs(index, initialAnimation) {
    const passiveBtn = this.buttons[this.activeTab];
    const activeBtn = this.buttons[index];
    const passiveBtnText = passiveBtn == null ? void 0 : passiveBtn.querySelector("wui-text");
    const activeBtnText = activeBtn == null ? void 0 : activeBtn.querySelector("wui-text");
    const activeBtnBounds = activeBtn == null ? void 0 : activeBtn.getBoundingClientRect();
    const activeBtnTextBounds = activeBtnText == null ? void 0 : activeBtnText.getBoundingClientRect();
    if (passiveBtn && passiveBtnText && !initialAnimation && index !== this.activeTab) {
      passiveBtnText.animate([{ opacity: 0 }], {
        duration: 50,
        easing: "ease",
        fill: "forwards"
      });
      passiveBtn.animate([{ width: `34px` }], {
        duration: 500,
        easing: "ease",
        fill: "forwards"
      });
    }
    if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
      if (index !== this.activeTab || initialAnimation) {
        this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
        activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
          duration: initialAnimation ? 0 : 500,
          fill: "forwards",
          easing: "ease"
        });
        activeBtnText.animate([{ opacity: 1 }], {
          duration: initialAnimation ? 0 : 125,
          delay: initialAnimation ? 0 : 200,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
};
WuiTabs.styles = [resetStyles, elementStyles, styles$1n];
__decorate$1W([
  n2({ type: Array })
], WuiTabs.prototype, "tabs", void 0);
__decorate$1W([
  n2()
], WuiTabs.prototype, "onTabChange", void 0);
__decorate$1W([
  n2({ type: Array })
], WuiTabs.prototype, "buttons", void 0);
__decorate$1W([
  n2({ type: Boolean })
], WuiTabs.prototype, "disabled", void 0);
__decorate$1W([
  n2()
], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$1W([
  r$1()
], WuiTabs.prototype, "activeTab", void 0);
__decorate$1W([
  r$1()
], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$1W([
  customElement("wui-tabs")
], WuiTabs);
const styles$1m = i$2`
  :host {
    display: block;
  }

  :host > button {
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-1xs);
    height: 40px;
    border-radius: var(--wui-border-radius-l);
    background: var(--wui-color-gray-glass-002);
    border-width: 0px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
  }

  :host > button wui-image {
    width: 24px;
    height: 24px;
    border-radius: var(--wui-border-radius-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$1V = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTokenButton = class WuiTokenButton2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return ke$1`
      <button ontouchstart>
        ${this.tokenTemplate()}
        <wui-text variant="paragraph-600" color="fg-100">${this.text}</wui-text>
      </button>
    `;
  }
  tokenTemplate() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return ke$1`
      <wui-icon-box
        size="sm"
        iconColor="fg-200"
        backgroundColor="fg-300"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiTokenButton.styles = [resetStyles, elementStyles, styles$1m];
__decorate$1V([
  n2()
], WuiTokenButton.prototype, "imageSrc", void 0);
__decorate$1V([
  n2()
], WuiTokenButton.prototype, "text", void 0);
WuiTokenButton = __decorate$1V([
  customElement("wui-token-button")
], WuiTokenButton);
const styles$1l = i$2`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);

    color: var(--wui-color-bg-100);
    position: relative;
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$1U = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTooltip = class WuiTooltip2 extends h {
  constructor() {
    super(...arguments);
    this.placement = "top";
    this.variant = "fill";
    this.message = "";
  }
  render() {
    this.dataset["variant"] = this.variant;
    return ke$1`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name=${this.variant === "fill" ? "cursor" : "cursorTransparent"}
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
  }
};
WuiTooltip.styles = [resetStyles, elementStyles, styles$1l];
__decorate$1U([
  n2()
], WuiTooltip.prototype, "placement", void 0);
__decorate$1U([
  n2()
], WuiTooltip.prototype, "variant", void 0);
__decorate$1U([
  n2()
], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$1U([
  customElement("wui-tooltip")
], WuiTooltip);
const styles$1k = i$2`
  :host {
    height: 60px;
    min-height: 60px;
  }

  :host > wui-flex {
    cursor: pointer;
    height: 100%;
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-l);
    width: 100%;
    background-color: transparent;
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition: background-color 0.2s linear;
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  :host([disabled]) > wui-flex {
    opacity: 0.6;
  }

  :host([disabled]) > wui-flex:hover {
    background-color: transparent;
  }

  :host > wui-flex > wui-flex {
    flex: 1;
  }

  :host > wui-flex > wui-image,
  :host > wui-flex > .token-item-image-placeholder {
    width: 40px;
    max-width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    position: relative;
  }

  :host > wui-flex > .token-item-image-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host > wui-flex > wui-image::after,
  :host > wui-flex > .token-item-image-placeholder::after {
    position: absolute;
    content: '';
    inset: 0;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-l);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }
`;
var __decorate$1T = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTokenListItem = class WuiTokenListItem2 extends h {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.imageSrc = void 0;
    this.name = void 0;
    this.symbol = void 0;
    this.price = void 0;
    this.amount = void 0;
    this.visible = false;
    this.imageError = false;
    this.observer = new IntersectionObserver((entries2) => {
      entries2.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.1 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    var _a2;
    if (!this.visible) {
      return null;
    }
    const value2 = this.amount && this.price ? (_a2 = NumberUtil.multiply(this.price, this.amount)) == null ? void 0 : _a2.toFixed(3) : null;
    return ke$1`
      <wui-flex alignItems="center">
        ${this.visualTemplate()}
        <wui-flex flexDirection="column" gap="3xs">
          <wui-flex justifyContent="space-between">
            <wui-text variant="paragraph-500" color="fg-100" lineClamp="1">${this.name}</wui-text>
            ${value2 ? ke$1`
                  <wui-text variant="paragraph-500" color="fg-100">
                    $${UiHelperUtil.formatNumberToLocalString(value2, 3)}
                  </wui-text>
                ` : null}
          </wui-flex>
          <wui-flex justifyContent="space-between">
            <wui-text variant="small-400" color="fg-200" lineClamp="1">${this.symbol}</wui-text>
            ${this.amount ? ke$1`<wui-text variant="small-400" color="fg-200">
                  ${UiHelperUtil.formatNumberToLocalString(this.amount, 4)}
                </wui-text>` : null}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  visualTemplate() {
    if (this.imageError) {
      return ke$1`<wui-flex class="token-item-image-placeholder">
        <wui-icon name="image" color="inherit"></wui-icon>
      </wui-flex>`;
    }
    if (this.imageSrc) {
      return ke$1`<wui-image
        width="40"
        height="40"
        src=${this.imageSrc}
        @onLoadError=${this.imageLoadError}
      ></wui-image>`;
    }
    return null;
  }
  imageLoadError() {
    this.imageError = true;
  }
};
WuiTokenListItem.styles = [resetStyles, elementStyles, styles$1k];
__decorate$1T([
  n2()
], WuiTokenListItem.prototype, "imageSrc", void 0);
__decorate$1T([
  n2()
], WuiTokenListItem.prototype, "name", void 0);
__decorate$1T([
  n2()
], WuiTokenListItem.prototype, "symbol", void 0);
__decorate$1T([
  n2()
], WuiTokenListItem.prototype, "price", void 0);
__decorate$1T([
  n2()
], WuiTokenListItem.prototype, "amount", void 0);
__decorate$1T([
  r$1()
], WuiTokenListItem.prototype, "visible", void 0);
__decorate$1T([
  r$1()
], WuiTokenListItem.prototype, "imageError", void 0);
WuiTokenListItem = __decorate$1T([
  customElement("wui-token-list-item")
], WuiTokenListItem);
const styles$1j = i$2`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$1S = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiVisualThumbnail = class WuiVisualThumbnail2 extends h {
  render() {
    this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`;
    return ke$1`${this.templateVisual()}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>`;
    }
    return ke$1`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiVisualThumbnail.styles = [resetStyles, styles$1j];
__decorate$1S([
  n2()
], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$1S([
  n2()
], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$1S([
  n2({ type: Boolean })
], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$1S([
  customElement("wui-visual-thumbnail")
], WuiVisualThumbnail);
const styles$1i = i$2`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-color-accent-glass-020) !important;
  }
`;
var __decorate$1R = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiNoticeCard = class WuiNoticeCard2 extends h {
  constructor() {
    super(...arguments);
    this.label = "";
    this.description = "";
    this.icon = "wallet";
  }
  render() {
    return ke$1`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
};
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$1i];
__decorate$1R([
  n2()
], WuiNoticeCard.prototype, "label", void 0);
__decorate$1R([
  n2()
], WuiNoticeCard.prototype, "description", void 0);
__decorate$1R([
  n2()
], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$1R([
  customElement("wui-notice-card")
], WuiNoticeCard);
const styles$1h = i$2`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-150), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$1Q = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class WuiListAccordion2 extends h {
  constructor() {
    super(...arguments);
    this.textTitle = "";
    this.overflowedContent = "";
    this.toggled = false;
    this.enableAccordion = false;
    this.scrollElement = void 0;
    this.scrollHeightElement = 0;
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("textTitle") || changedProperties.has("overflowedContent")) {
      setTimeout(() => {
        this.checkHeight();
      }, 1);
    }
  }
  checkHeight() {
    this.updateComplete.then(() => {
      var _a2, _b2;
      const heightElement = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(".heightContent");
      const textElement = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector(".textContent");
      if (heightElement && textElement) {
        this.scrollElement = heightElement;
        const scrollHeight = textElement == null ? void 0 : textElement.scrollHeight;
        if (scrollHeight && scrollHeight > MAX_HEIGHT) {
          this.enableAccordion = true;
          this.scrollHeightElement = scrollHeight;
          this.requestUpdate();
        }
      }
    });
  }
  render() {
    return ke$1`
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text class="textContent" variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    var _a2;
    const icon = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-icon");
    if (this.enableAccordion) {
      this.toggled = !this.toggled;
      this.requestUpdate();
      if (this.scrollElement) {
        this.scrollElement.animate([
          { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
          { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
      if (icon) {
        icon.animate([
          { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
          { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
  chevronTemplate() {
    if (this.enableAccordion) {
      return ke$1` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>`;
    }
    return null;
  }
};
WuiListAccordion.styles = [resetStyles, elementStyles, styles$1h];
__decorate$1Q([
  n2()
], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$1Q([
  n2()
], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$1Q([
  customElement("wui-list-accordion")
], WuiListAccordion);
const styles$1g = i$2`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$1P = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListContent = class WuiListContent2 extends h {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.textTitle = "";
    this.textValue = void 0;
  }
  render() {
    return ke$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
  }
  templateContent() {
    if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>`;
    } else if (this.textValue) {
      return ke$1` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>`;
    }
    return ke$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListContent.styles = [resetStyles, elementStyles, styles$1g];
__decorate$1P([
  n2()
], WuiListContent.prototype, "imageSrc", void 0);
__decorate$1P([
  n2()
], WuiListContent.prototype, "textTitle", void 0);
__decorate$1P([
  n2()
], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$1P([
  customElement("wui-list-content")
], WuiListContent);
const styles$1f = i$2`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button[data-transparent='true'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$1O = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListNetwork = class WuiListNetwork2 extends h {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.name = "";
    this.disabled = false;
    this.transparent = false;
  }
  render() {
    return ke$1`
      <button data-transparent=${this.transparent} ?disabled=${this.disabled} ontouchstart>
        ${this.templateNetworkImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
      </button>
    `;
  }
  templateNetworkImage() {
    if (this.imageSrc) {
      return ke$1`<wui-network-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
      ></wui-network-image>`;
    }
    if (!this.imageSrc) {
      return ke$1`<wui-network-image size="sm" name=${this.name}></wui-network-image>`;
    }
    return null;
  }
};
WuiListNetwork.styles = [resetStyles, elementStyles, styles$1f];
__decorate$1O([
  n2()
], WuiListNetwork.prototype, "imageSrc", void 0);
__decorate$1O([
  n2()
], WuiListNetwork.prototype, "name", void 0);
__decorate$1O([
  n2({ type: Boolean })
], WuiListNetwork.prototype, "disabled", void 0);
__decorate$1O([
  n2({ type: Boolean })
], WuiListNetwork.prototype, "transparent", void 0);
WuiListNetwork = __decorate$1O([
  customElement("wui-list-network")
], WuiListNetwork);
const styles$1e = i$2`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$1N = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListWalletTransaction = class WuiListWalletTransaction2 extends h {
  constructor() {
    super(...arguments);
    this.amount = "";
    this.networkCurreny = "";
    this.networkImageUrl = "";
    this.receiverAddress = "";
    this.addressExplorerUrl = "";
  }
  render() {
    return ke$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.addressExplorerUrl}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
  }
  templateNetworkVisual() {
    if (this.networkImageUrl) {
      return ke$1`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>`;
    }
    return ke$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$1e];
__decorate$1N([
  n2()
], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$1N([
  n2()
], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$1N([
  n2()
], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$1N([
  n2()
], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
__decorate$1N([
  n2()
], WuiListWalletTransaction.prototype, "addressExplorerUrl", void 0);
WuiListWalletTransaction = __decorate$1N([
  customElement("wui-list-wallet-transaction")
], WuiListWalletTransaction);
const styles$1d = i$2`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;
var __decorate$1M = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiOnRampActivityItem = class WuiOnRampActivityItem2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "Bought";
    this.purchaseValue = "";
    this.purchaseCurrency = "";
    this.date = "";
    this.completed = false;
    this.inProgress = false;
    this.failed = false;
    this.onClick = null;
    this.symbol = "";
  }
  firstUpdated() {
    if (!this.icon) {
      this.fetchTokenImage();
    }
  }
  render() {
    return ke$1`
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress ? ke$1`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : ke$1`<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `;
  }
  async fetchTokenImage() {
    await ApiController._fetchTokenImage(this.purchaseCurrency);
  }
  statusIconTemplate() {
    if (this.inProgress) {
      return null;
    }
    return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
  }
  errorIconTemplate() {
    return ke$1`<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
  imageTemplate() {
    const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
    return ke$1`<wui-flex class="purchase-image-container">
      <wui-image src=${icon}></wui-image>
    </wui-flex>`;
  }
  boughtIconTemplate() {
    return ke$1`<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
};
WuiOnRampActivityItem.styles = [resetStyles, elementStyles, styles$1d];
__decorate$1M([
  n2({ type: Boolean })
], WuiOnRampActivityItem.prototype, "disabled", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "color", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "label", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "date", void 0);
__decorate$1M([
  n2({ type: Boolean })
], WuiOnRampActivityItem.prototype, "completed", void 0);
__decorate$1M([
  n2({ type: Boolean })
], WuiOnRampActivityItem.prototype, "inProgress", void 0);
__decorate$1M([
  n2({ type: Boolean })
], WuiOnRampActivityItem.prototype, "failed", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "onClick", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "symbol", void 0);
__decorate$1M([
  n2()
], WuiOnRampActivityItem.prototype, "icon", void 0);
WuiOnRampActivityItem = __decorate$1M([
  customElement("wui-onramp-activity-item")
], WuiOnRampActivityItem);
const styles$1c = i$2`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: box-shadow;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$1L = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiOnRampProviderItem = class WuiOnRampProviderItem2 extends h {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "";
    this.feeRange = "";
    this.loading = false;
    this.onClick = null;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${to(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading ? ke$1`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : ke$1`<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `;
  }
  networksTemplate() {
    var _a2;
    const networks = NetworkController.getRequestedCaipNetworks();
    const slicedNetworks = (_a2 = networks == null ? void 0 : networks.filter((network) => network == null ? void 0 : network.imageId)) == null ? void 0 : _a2.slice(0, 5);
    return ke$1`
      <wui-flex class="networks">
        ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => ke$1`
            <wui-flex class="network-icon">
              <wui-image src=${to(AssetUtil.getNetworkImage(network))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
WuiOnRampProviderItem.styles = [resetStyles, elementStyles, styles$1c];
__decorate$1L([
  n2({ type: Boolean })
], WuiOnRampProviderItem.prototype, "disabled", void 0);
__decorate$1L([
  n2()
], WuiOnRampProviderItem.prototype, "color", void 0);
__decorate$1L([
  n2()
], WuiOnRampProviderItem.prototype, "name", void 0);
__decorate$1L([
  n2()
], WuiOnRampProviderItem.prototype, "label", void 0);
__decorate$1L([
  n2()
], WuiOnRampProviderItem.prototype, "feeRange", void 0);
__decorate$1L([
  n2({ type: Boolean })
], WuiOnRampProviderItem.prototype, "loading", void 0);
__decorate$1L([
  n2()
], WuiOnRampProviderItem.prototype, "onClick", void 0);
WuiOnRampProviderItem = __decorate$1L([
  customElement("wui-onramp-provider-item")
], WuiOnRampProviderItem);
const styles$1b = i$2`
  button {
    display: flex;
    gap: var(--wui-spacing-3xs);
    align-items: center;
    padding: 6.25px var(--wui-spacing-xs) 7.25px var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-090);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-060);
    transition: background-color var(--wui-duration-md) var(--wui-ease-inout-power-1);
    will-change: background-color;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-080);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-060);
    }
  }
`;
var __decorate$1K = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiPromo = class WuiPromo2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return ke$1`<button ontouchstart>
      <wui-text variant="small-600" color="bg-100">${this.text}</wui-text>
      <wui-icon color="bg-100" size="xs" name="arrowRight"></wui-icon>
    </button>`;
  }
};
WuiPromo.styles = [resetStyles, elementStyles, styles$1b];
__decorate$1K([
  n2()
], WuiPromo.prototype, "text", void 0);
WuiPromo = __decorate$1K([
  customElement("wui-promo")
], WuiPromo);
const styles$1a = i$2`
  span {
    font-weight: 500;
    font-size: 40px;
    color: var(--wui-color-fg-100);
    line-height: 130%; /* 52px */
    letter-spacing: -1.6px;
    text-align: center;
  }

  .pennies {
    color: var(--wui-color-fg-200);
  }
`;
var __decorate$1J = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiBalance = class WuiBalance2 extends h {
  constructor() {
    super(...arguments);
    this.dollars = "0";
    this.pennies = "00";
  }
  render() {
    return ke$1`<span>$${this.dollars}<span class="pennies">.${this.pennies}</span></span>`;
  }
};
WuiBalance.styles = [resetStyles, styles$1a];
__decorate$1J([
  n2()
], WuiBalance.prototype, "dollars", void 0);
__decorate$1J([
  n2()
], WuiBalance.prototype, "pennies", void 0);
WuiBalance = __decorate$1J([
  customElement("wui-balance")
], WuiBalance);
const styles$19 = i$2`
  button {
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-color-gray-glass-005);
  }

  wui-icon-box,
  wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;
var __decorate$1I = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiProfileButton = class WuiProfileButton2 extends h {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.profileName = "";
    this.address = "";
    this.icon = "chevronBottom";
  }
  render() {
    return ke$1`<button ontouchstart data-testid="wui-profile-button">
      <wui-flex gap="xs" alignItems="center">
        <wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></wui-avatar>
        ${this.networkImageTemplate()}
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
          </wui-text>
          <wui-icon size="sm" color="fg-200" name=${this.icon}></wui-icon>
        </wui-flex>
      </wui-flex>
    </button>`;
  }
  networkImageTemplate() {
    if (this.networkSrc) {
      return ke$1`<wui-image src=${this.networkSrc}></wui-image>`;
    }
    return ke$1`
      <wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiProfileButton.styles = [resetStyles, elementStyles, styles$19];
__decorate$1I([
  n2()
], WuiProfileButton.prototype, "networkSrc", void 0);
__decorate$1I([
  n2()
], WuiProfileButton.prototype, "avatarSrc", void 0);
__decorate$1I([
  n2()
], WuiProfileButton.prototype, "profileName", void 0);
__decorate$1I([
  n2()
], WuiProfileButton.prototype, "address", void 0);
__decorate$1I([
  n2()
], WuiProfileButton.prototype, "icon", void 0);
WuiProfileButton = __decorate$1I([
  customElement("wui-profile-button")
], WuiProfileButton);
const styles$18 = i$2`
  button {
    border: none;
    border-radius: var(--wui-border-radius-3xl);
  }

  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='gray'] {
    background-color: transparent;
    color: var(--wui-color-fg-200);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='shade'] {
    background-color: transparent;
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-size='sm'] {
    height: 32px;
    padding: 0 var(--wui-spacing-s);
  }

  button[data-size='md'] {
    height: 40px;
    padding: 0 var(--wui-spacing-l);
  }

  button[data-size='sm'] > wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-size='sm'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='md'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > wui-icon,
  button.disabled > wui-image {
    filter: grayscale(1);
  }

  button[data-variant='main'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > wui-image,
  button[data-variant='gray'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:focus-visible {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='shade']:focus-visible,
    button[data-variant='gray']:focus-visible,
    button[data-variant='shade']:hover,
    button[data-variant='gray']:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    button[data-variant='gray']:active,
    button[data-variant='shade']:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  button.disabled {
    color: var(--wui-color-gray-glass-020);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    pointer-events: none;
  }
`;
var __decorate$1H = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiChipButton = class WuiChipButton2 extends h {
  constructor() {
    super(...arguments);
    this.variant = "accent";
    this.imageSrc = "";
    this.disabled = false;
    this.icon = "externalLink";
    this.size = "md";
    this.text = "";
  }
  render() {
    const textVariant = this.size === "sm" ? "small-600" : "paragraph-600";
    return ke$1`
      <button
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
        data-size=${this.size}
      >
        ${this.imageSrc ? ke$1`<wui-image src=${this.imageSrc}></wui-image>` : null}
        <wui-text variant=${textVariant} color="inherit"> ${this.text} </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </button>
    `;
  }
};
WuiChipButton.styles = [resetStyles, elementStyles, styles$18];
__decorate$1H([
  n2()
], WuiChipButton.prototype, "variant", void 0);
__decorate$1H([
  n2()
], WuiChipButton.prototype, "imageSrc", void 0);
__decorate$1H([
  n2({ type: Boolean })
], WuiChipButton.prototype, "disabled", void 0);
__decorate$1H([
  n2()
], WuiChipButton.prototype, "icon", void 0);
__decorate$1H([
  n2()
], WuiChipButton.prototype, "size", void 0);
__decorate$1H([
  n2()
], WuiChipButton.prototype, "text", void 0);
WuiChipButton = __decorate$1H([
  customElement("wui-chip-button")
], WuiChipButton);
const styles$17 = i$2`
  button {
    display: flex;
    gap: var(--wui-spacing-xl);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-m) var(--wui-spacing-s);
  }

  wui-text {
    width: 100%;
  }

  wui-flex {
    width: auto;
  }

  .network-icon {
    width: var(--wui-spacing-2l);
    height: var(--wui-spacing-2l);
    border-radius: calc(var(--wui-spacing-2l) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$1G = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiCompatibleNetwork = class WuiCompatibleNetwork2 extends h {
  constructor() {
    super(...arguments);
    this.networkImages = [""];
    this.text = "";
  }
  render() {
    return ke$1`
      <button ontouchstart>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
        <wui-flex gap="3xs" alignItems="center">
          ${this.networksTemplate()}
          <wui-icon name="chevronRight" size="sm" color="fg-200"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
  networksTemplate() {
    const slicedNetworks = this.networkImages.slice(0, 5);
    return ke$1` <wui-flex class="networks">
      ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => ke$1` <wui-flex class="network-icon"> <wui-image src=${network}></wui-image> </wui-flex>`)}
    </wui-flex>`;
  }
};
WuiCompatibleNetwork.styles = [resetStyles, elementStyles, styles$17];
__decorate$1G([
  n2({ type: Array })
], WuiCompatibleNetwork.prototype, "networkImages", void 0);
__decorate$1G([
  n2()
], WuiCompatibleNetwork.prototype, "text", void 0);
WuiCompatibleNetwork = __decorate$1G([
  customElement("wui-compatible-network")
], WuiCompatibleNetwork);
const styles$16 = i$2`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;
var __decorate$1F = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiBanner = class WuiBanner2 extends h {
  constructor() {
    super(...arguments);
    this.icon = "externalLink";
    this.text = "";
  }
  render() {
    return ke$1`
      <wui-flex gap="1xs" alignItems="center">
        <wui-icon-box
          size="sm"
          iconcolor="fg-200"
          backgroundcolor="fg-200"
          icon=${this.icon}
          background="transparent"
        ></wui-icon-box>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
      </wui-flex>
    `;
  }
};
WuiBanner.styles = [resetStyles, elementStyles, styles$16];
__decorate$1F([
  n2()
], WuiBanner.prototype, "icon", void 0);
__decorate$1F([
  n2()
], WuiBanner.prototype, "text", void 0);
WuiBanner = __decorate$1F([
  customElement("wui-banner")
], WuiBanner);
const styles$15 = i$2`
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-image,
  wui-icon {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$1E = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListToken = class WuiListToken2 extends h {
  constructor() {
    super(...arguments);
    this.tokenName = "";
    this.tokenImageUrl = "";
    this.tokenValue = 0;
    this.tokenAmount = "0.0";
    this.tokenCurrency = "";
    this.clickable = false;
  }
  render() {
    return ke$1`
      <button data-clickable=${String(this.clickable)} ontouchstart>
        <wui-flex gap="s" alignItems="center">
          ${this.visualTemplate()}
          <wui-flex flexDirection="column" justifyContent="spaceBetween">
            <wui-text variant="paragraph-500" color="fg-100">${this.tokenName}</wui-text>
            <wui-text variant="small-400" color="fg-200">
              ${UiHelperUtil.formatNumberToLocalString(this.tokenAmount, 4)} ${this.tokenCurrency}
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-text variant="paragraph-500" color="fg-100">$${this.tokenValue.toFixed(2)}</wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.tokenName && this.tokenImageUrl) {
      return ke$1`<wui-image alt=${this.tokenName} src=${this.tokenImageUrl}></wui-image>`;
    }
    return ke$1`<wui-icon name="coinPlaceholder" color="fg-100"></wui-icon>`;
  }
};
WuiListToken.styles = [resetStyles, elementStyles, styles$15];
__decorate$1E([
  n2()
], WuiListToken.prototype, "tokenName", void 0);
__decorate$1E([
  n2()
], WuiListToken.prototype, "tokenImageUrl", void 0);
__decorate$1E([
  n2({ type: Number })
], WuiListToken.prototype, "tokenValue", void 0);
__decorate$1E([
  n2()
], WuiListToken.prototype, "tokenAmount", void 0);
__decorate$1E([
  n2()
], WuiListToken.prototype, "tokenCurrency", void 0);
__decorate$1E([
  n2({ type: Boolean })
], WuiListToken.prototype, "clickable", void 0);
WuiListToken = __decorate$1E([
  customElement("wui-list-token")
], WuiListToken);
const styles$14 = i$2`
  button {
    width: 100%;
    display: flex;
    gap: var(--wui-spacing-s);
    align-items: center;
    justify-content: flex-start;
    padding: var(--wui-spacing-s) var(--wui-spacing-m) var(--wui-spacing-s) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon-box {
    width: var(--wui-spacing-2xl);
    height: var(--wui-spacing-2xl);
  }

  wui-flex {
    width: auto;
  }
`;
var __decorate$1D = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListDescription = class WuiListDescription2 extends h {
  constructor() {
    super(...arguments);
    this.icon = "card";
    this.text = "";
    this.description = "";
    this.tag = void 0;
    this.iconBackgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.disabled = false;
  }
  render() {
    return ke$1`
      <button ontouchstart ?disabled=${this.disabled}>
        <wui-icon-box
          iconColor=${this.iconColor}
          backgroundColor=${this.iconBackgroundColor}
          size="inherit"
          icon=${this.icon}
          iconSize="md"
        ></wui-icon-box>
        <wui-flex flexDirection="column" justifyContent="spaceBetween">
          ${this.titleTemplate()}
          <wui-text variant="small-400" color="fg-200"> ${this.description}</wui-text></wui-flex
        >
      </button>
    `;
  }
  titleTemplate() {
    if (this.tag) {
      return ke$1` <wui-flex alignItems="center" gap="xxs"
        ><wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text
        ><wui-tag tagType="main" size="md">${this.tag}</wui-tag>
      </wui-flex>`;
    }
    return ke$1`<wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>`;
  }
};
WuiListDescription.styles = [resetStyles, elementStyles, styles$14];
__decorate$1D([
  n2()
], WuiListDescription.prototype, "icon", void 0);
__decorate$1D([
  n2()
], WuiListDescription.prototype, "text", void 0);
__decorate$1D([
  n2()
], WuiListDescription.prototype, "description", void 0);
__decorate$1D([
  n2()
], WuiListDescription.prototype, "tag", void 0);
__decorate$1D([
  n2()
], WuiListDescription.prototype, "iconBackgroundColor", void 0);
__decorate$1D([
  n2()
], WuiListDescription.prototype, "iconColor", void 0);
__decorate$1D([
  n2({ type: Boolean })
], WuiListDescription.prototype, "disabled", void 0);
WuiListDescription = __decorate$1D([
  customElement("wui-list-description")
], WuiListDescription);
const styles$13 = i$2`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    background: transparent;
    width: 100%;
    height: auto;
    font-family: var(--wui-font-family);
    color: var(--wui-color-fg-100);

    font-feature-settings: 'case' on;
    font-size: 32px;
    font-weight: var(--wui-font-weight-light);
    caret-color: var(--wui-color-accent-100);
    line-height: 130%;
    letter-spacing: -1.28px;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }
`;
const specialCharactersRegex = /[.*+?^${}()|[\]\\]/gu;
const numbersRegex = /[0-9,.]/u;
var __decorate$1C = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiInputAmount = class WuiInputAmount2 extends h {
  constructor() {
    super(...arguments);
    this.inputElementRef = ii();
    this.disabled = false;
    this.value = "";
    this.placeholder = "0";
  }
  render() {
    var _a2;
    if (((_a2 = this.inputElementRef) == null ? void 0 : _a2.value) && this.value) {
      this.inputElementRef.value.value = this.value;
    }
    return ke$1`<input
      ${Kt$1(this.inputElementRef)}
      type="text"
      inputmode="decimal"
      pattern="[0-9,.]*"
      placeholder=${this.placeholder}
      ?disabled=${this.disabled}
      autofocus
      value=${this.value ?? ""}
      @input=${this.dispatchInputChangeEvent.bind(this)}
    /> `;
  }
  dispatchInputChangeEvent(e2) {
    var _a2, _b2;
    const inputChar = e2.data;
    if (inputChar && ((_a2 = this.inputElementRef) == null ? void 0 : _a2.value)) {
      if (inputChar === ",") {
        const inputValue = this.inputElementRef.value.value.replace(",", ".");
        this.inputElementRef.value.value = inputValue;
        this.value = `${this.value}${inputValue}`;
      } else if (!numbersRegex.test(inputChar)) {
        this.inputElementRef.value.value = this.value.replace(new RegExp(inputChar.replace(specialCharactersRegex, "\\$&"), "gu"), "");
      }
    }
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: (_b2 = this.inputElementRef.value) == null ? void 0 : _b2.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputAmount.styles = [resetStyles, elementStyles, styles$13];
__decorate$1C([
  n2({ type: Boolean })
], WuiInputAmount.prototype, "disabled", void 0);
__decorate$1C([
  n2({ type: String })
], WuiInputAmount.prototype, "value", void 0);
__decorate$1C([
  n2({ type: String })
], WuiInputAmount.prototype, "placeholder", void 0);
WuiInputAmount = __decorate$1C([
  customElement("wui-input-amount")
], WuiInputAmount);
const styles$12 = i$2`
  :host {
    display: flex;
    gap: var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-xs) var(--wui-spacing-2xs)
      var(--wui-spacing-s);
    align-items: center;
  }

  wui-avatar,
  wui-icon,
  wui-image {
    width: 32px;
    height: 32px;
    border: 1px solid var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1B = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiPreviewItem = class WuiPreviewItem2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
    this.address = "";
    this.isAddress = false;
  }
  render() {
    return ke$1`<wui-text variant="large-500" color="fg-100">${this.text}</wui-text>
      ${this.imageTemplate()}`;
  }
  imageTemplate() {
    if (this.isAddress) {
      return ke$1`<wui-avatar address=${this.address} .imageSrc=${this.imageSrc}></wui-avatar>`;
    } else if (this.imageSrc) {
      return ke$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return ke$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiPreviewItem.styles = [resetStyles, elementStyles, styles$12];
__decorate$1B([
  n2()
], WuiPreviewItem.prototype, "text", void 0);
__decorate$1B([
  n2()
], WuiPreviewItem.prototype, "address", void 0);
__decorate$1B([
  n2()
], WuiPreviewItem.prototype, "imageSrc", void 0);
__decorate$1B([
  n2({ type: Boolean })
], WuiPreviewItem.prototype, "isAddress", void 0);
WuiPreviewItem = __decorate$1B([
  customElement("wui-preview-item")
], WuiPreviewItem);
const styles$11 = i$2`
  :host {
    position: relative;
  }

  button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 48px;
    width: 100%;
    background-color: var(--wui-color-accent-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-accent-glass-010);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  wui-tooltip {
    padding: 7px var(--wui-spacing-s) 8px var(--wui-spacing-s);
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translate(-50%, -100%);
    opacity: 0;
    display: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }
  }
`;
var __decorate$1A = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiIconButton = class WuiIconButton2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
    this.icon = "card";
  }
  render() {
    return ke$1`<button>
      <wui-icon color="accent-100" name=${this.icon} size="lg"></wui-icon>
    </button>`;
  }
};
WuiIconButton.styles = [resetStyles, elementStyles, styles$11];
__decorate$1A([
  n2()
], WuiIconButton.prototype, "text", void 0);
__decorate$1A([
  n2()
], WuiIconButton.prototype, "icon", void 0);
WuiIconButton = __decorate$1A([
  customElement("wui-icon-button")
], WuiIconButton);
const styles$10 = i$2`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 16.5px var(--wui-spacing-l) 16.5px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
    justify-content: center;
    align-items: center;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1z = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListButton = class WuiListButton2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
    this.disabled = false;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-text align="center" variant="paragraph-500" color="inherit">${this.text}</wui-text>
      </button>
    `;
  }
};
WuiListButton.styles = [resetStyles, elementStyles, styles$10];
__decorate$1z([
  n2()
], WuiListButton.prototype, "text", void 0);
__decorate$1z([
  n2({ type: Boolean })
], WuiListButton.prototype, "disabled", void 0);
WuiListButton = __decorate$1z([
  customElement("wui-list-button")
], WuiListButton);
const styles$$ = i$2`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    justify-content: flex-start;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-text[data-align='left'] {
    display: flex;
    flex: 1;
  }

  wui-text[data-align='center'] {
    display: flex;
    flex: 1;
    justify-content: center;
  }

  .invisible {
    opacity: 0;
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1y = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiListSocial = class WuiListSocial2 extends h {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.name = "Continue with google";
    this.align = "left";
    this.disabled = false;
  }
  render() {
    return ke$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
        <wui-text
          data-align=${this.align}
          variant="paragraph-500"
          color="inherit"
          align=${this.align}
          >${this.name}</wui-text
        >
        ${this.templatePlacement()}
      </button>
    `;
  }
  templatePlacement() {
    if (this.align === "center") {
      return ke$1` <wui-logo class="invisible" logo=${this.logo}></wui-logo>`;
    }
    return null;
  }
};
WuiListSocial.styles = [resetStyles, elementStyles, styles$$];
__decorate$1y([
  n2()
], WuiListSocial.prototype, "logo", void 0);
__decorate$1y([
  n2()
], WuiListSocial.prototype, "name", void 0);
__decorate$1y([
  n2()
], WuiListSocial.prototype, "align", void 0);
__decorate$1y([
  n2({ type: Boolean })
], WuiListSocial.prototype, "disabled", void 0);
WuiListSocial = __decorate$1y([
  customElement("wui-list-social")
], WuiListSocial);
const styles$_ = i$2`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1x = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiGrid = class WuiGrid2 extends h {
  render() {
    this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return ke$1`<slot></slot>`;
  }
};
WuiGrid.styles = [resetStyles, styles$_];
__decorate$1x([
  n2()
], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "justifyItems", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "alignItems", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "justifyContent", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "alignContent", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "columnGap", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "rowGap", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "gap", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "padding", void 0);
__decorate$1x([
  n2()
], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$1x([
  customElement("wui-grid")
], WuiGrid);
const styles$Z = i$2`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-color-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var __decorate$1w = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiSeparator = class WuiSeparator2 extends h {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return ke$1`${this.template()}`;
  }
  template() {
    if (this.text) {
      return ke$1`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>`;
    }
    return null;
  }
};
WuiSeparator.styles = [resetStyles, styles$Z];
__decorate$1w([
  n2()
], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$1w([
  customElement("wui-separator")
], WuiSeparator);
const MathUtil = {
  interpolate(inputRange, outputRange, value2) {
    if (inputRange.length !== 2 || outputRange.length !== 2) {
      throw new Error("inputRange and outputRange must be an array of length 2");
    }
    const originalRangeMin = inputRange[0] || 0;
    const originalRangeMax = inputRange[1] || 0;
    const newRangeMin = outputRange[0] || 0;
    const newRangeMax = outputRange[1] || 0;
    if (value2 < originalRangeMin) {
      return newRangeMin;
    }
    if (value2 > originalRangeMax) {
      return newRangeMax;
    }
    return (newRangeMax - newRangeMin) / (originalRangeMax - originalRangeMin) * (value2 - originalRangeMin) + newRangeMin;
  }
};
const FLOAT_FIXED_VALUE = 3;
const plusTypes = ["receive", "deposit", "borrow", "claim"];
const minusTypes = ["withdraw", "repay", "burn"];
const TransactionUtil = {
  getMonthName(monthNumber) {
    const date = /* @__PURE__ */ new Date();
    date.setMonth(monthNumber);
    return date.toLocaleString("en-US", {
      month: "long"
    });
  },
  getTransactionGroupTitle(year, month) {
    const currentYear = DateUtil.getYear();
    const monthName = this.getMonthName(month);
    const isCurrentYear = year === currentYear;
    const groupTitle = isCurrentYear ? monthName : `${monthName} ${year}`;
    return groupTitle;
  },
  getTransactionImages(transfers) {
    const [transfer, secondTransfer] = transfers;
    const isAllNFT = Boolean(transfer) && (transfers == null ? void 0 : transfers.every((item) => Boolean(item.nft_info)));
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransactionImage(item));
    }
    return [this.getTransactionImage(transfer)];
  },
  getTransactionImage(transfer) {
    return {
      type: TransactionUtil.getTransactionTransferTokenType(transfer),
      url: TransactionUtil.getTransactionImageURL(transfer)
    };
  },
  getTransactionImageURL(transfer) {
    var _a2, _b2, _c2, _d2, _e3;
    let imageURL = void 0;
    const isNFT = Boolean(transfer == null ? void 0 : transfer.nft_info);
    const isFungible = Boolean(transfer == null ? void 0 : transfer.fungible_info);
    if (transfer && isNFT) {
      imageURL = (_c2 = (_b2 = (_a2 = transfer == null ? void 0 : transfer.nft_info) == null ? void 0 : _a2.content) == null ? void 0 : _b2.preview) == null ? void 0 : _c2.url;
    } else if (transfer && isFungible) {
      imageURL = (_e3 = (_d2 = transfer == null ? void 0 : transfer.fungible_info) == null ? void 0 : _d2.icon) == null ? void 0 : _e3.url;
    }
    return imageURL;
  },
  getTransactionTransferTokenType(transfer) {
    if (transfer == null ? void 0 : transfer.fungible_info) {
      return "FUNGIBLE";
    } else if (transfer == null ? void 0 : transfer.nft_info) {
      return "NFT";
    }
    return void 0;
  },
  getTransactionDescriptions(transaction) {
    var _a2, _b2, _c2;
    const type3 = (_a2 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a2.operationType;
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const haveTransfer = ((_b2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b2.length) > 0;
    const haveMultipleTransfers = ((_c2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c2.length) > 1;
    const isFungible = haveTransfer && (transfers == null ? void 0 : transfers.every((transfer) => Boolean(transfer == null ? void 0 : transfer.fungible_info)));
    const [firstTransfer, secondTransfer] = transfers;
    let firstDescription = this.getTransferDescription(firstTransfer);
    let secondDescription = this.getTransferDescription(secondTransfer);
    if (!haveTransfer) {
      const isSendOrReceive = type3 === "send" || type3 === "receive";
      if (isSendOrReceive && isFungible) {
        firstDescription = UiHelperUtil.getTruncateString({
          string: transaction == null ? void 0 : transaction.metadata.sentFrom,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        secondDescription = UiHelperUtil.getTruncateString({
          string: transaction == null ? void 0 : transaction.metadata.sentTo,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        return [firstDescription, secondDescription];
      }
      return [transaction.metadata.status];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransferDescription(item));
    }
    let prefix2 = "";
    if (plusTypes.includes(type3)) {
      prefix2 = "+";
    } else if (minusTypes.includes(type3)) {
      prefix2 = "-";
    }
    firstDescription = prefix2.concat(firstDescription);
    return [firstDescription];
  },
  getTransferDescription(transfer) {
    var _a2;
    let description = "";
    if (!transfer) {
      return description;
    }
    if (transfer == null ? void 0 : transfer.nft_info) {
      description = ((_a2 = transfer == null ? void 0 : transfer.nft_info) == null ? void 0 : _a2.name) || "-";
    } else if (transfer == null ? void 0 : transfer.fungible_info) {
      description = this.getFungibleTransferDescription(transfer) || "-";
    }
    return description;
  },
  getFungibleTransferDescription(transfer) {
    var _a2;
    if (!transfer) {
      return null;
    }
    const quantity = this.getQuantityFixedValue(transfer == null ? void 0 : transfer.quantity.numeric);
    const description = [quantity, (_a2 = transfer == null ? void 0 : transfer.fungible_info) == null ? void 0 : _a2.symbol].join(" ").trim();
    return description;
  },
  getQuantityFixedValue(value2) {
    if (!value2) {
      return null;
    }
    const parsedValue = parseFloat(value2);
    return parsedValue.toFixed(FLOAT_FIXED_VALUE);
  }
};
var __decorate$1v = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountButton = class W3mAccountButton2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.address = AccountController.state.address;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = NetworkController.state.caipNetwork;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          this.address = val.address;
          this.balanceVal = val.balance;
          this.profileName = val.profileName;
          this.profileImage = val.profileImage;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          this.address = "";
          this.balanceVal = "";
          this.profileName = "";
          this.profileImage = "";
          this.balanceSymbol = "";
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => this.isUnsupportedChain = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const networkImage = AssetUtil.getNetworkImage(this.network);
    const showBalance = this.balance === "show";
    return ke$1`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        address=${to(this.address)}
        profileName=${to(this.profileName)}
        networkSrc=${to(networkImage)}
        avatarSrc=${to(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    if (this.isUnsupportedChain) {
      ModalController.open({ view: "UnsupportedChain" });
    } else {
      ModalController.open();
    }
  }
};
__decorate$1v([
  n2({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate$1v([
  n2()
], W3mAccountButton.prototype, "balance", void 0);
__decorate$1v([
  n2()
], W3mAccountButton.prototype, "charsStart", void 0);
__decorate$1v([
  n2()
], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "address", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "network", void 0);
__decorate$1v([
  r$1()
], W3mAccountButton.prototype, "isUnsupportedChain", void 0);
W3mAccountButton = __decorate$1v([
  customElement("w3m-account-button")
], W3mAccountButton);
const styles$Y = i$2`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1u = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mButton = class W3mButton2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.isAccount = AccountController.state.isConnected;
    this.isLoading = ModalController.state.loading;
    this.unsubscribe.push(AccountController.subscribeKey("isConnected", (val) => {
      this.isAccount = val;
    }), ModalController.subscribeKey("loading", (val) => {
      this.isLoading = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.isAccount && !this.isLoading ? ke$1`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${to(this.balance)}
            .charsStart=${to(this.charsStart)}
            .charsEnd=${to(this.charsEnd)}
          >
          </w3m-account-button>
        ` : ke$1`
          <w3m-connect-button
            size=${to(this.size)}
            label=${to(this.label)}
            loadingLabel=${to(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
W3mButton.styles = styles$Y;
__decorate$1u([
  n2({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "balance", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "size", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "label", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "charsStart", void 0);
__decorate$1u([
  n2()
], W3mButton.prototype, "charsEnd", void 0);
__decorate$1u([
  r$1()
], W3mButton.prototype, "isAccount", void 0);
__decorate$1u([
  r$1()
], W3mButton.prototype, "isLoading", void 0);
W3mButton = __decorate$1u([
  customElement("w3m-button")
], W3mButton);
var __decorate$1t = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectButton = class W3mConnectButton2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return ke$1`
      <wui-connect-button
        size=${to(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate$1t([
  n2()
], W3mConnectButton.prototype, "size", void 0);
__decorate$1t([
  n2()
], W3mConnectButton.prototype, "label", void 0);
__decorate$1t([
  n2()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate$1t([
  r$1()
], W3mConnectButton.prototype, "open", void 0);
__decorate$1t([
  r$1()
], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate$1t([
  customElement("w3m-connect-button")
], W3mConnectButton);
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/sway-examples/pr-preview/pr-4/counter/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.all(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const styles$X = i$2`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host(.open) {
    opacity: 1;
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: var(--w3m-modal-width);
    width: 100%;
    position: relative;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var __decorate$1s = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const SCROLL_LOCK = "scroll-lock";
let W3mModal = class W3mModal2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.abortController = void 0;
    this.open = ModalController.state.open;
    this.caipAddress = AccountController.state.caipAddress;
    this.isSiweEnabled = OptionsController.state.isSiweEnabled;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.initializeTheming();
    ApiController.prefetch();
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => val ? this.onOpen() : this.onClose()), ModalController.subscribeKey("loading", (val) => {
      this.loading = val;
      this.onNewAddress(AccountController.state.caipAddress);
    }), AccountController.subscribeKey("isConnected", (val) => this.connected = val), AccountController.subscribeKey("caipAddress", (val) => this.onNewAddress(val)), OptionsController.subscribeKey("isSiweEnabled", (val) => this.isSiweEnabled = val));
    EventsController.sendEvent({ type: "track", event: "MODAL_LOADED" });
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.onRemoveKeyboardListener();
  }
  render() {
    return this.open ? ke$1`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
          <w3m-tooltip></w3m-tooltip>
        ` : null;
  }
  async onOverlayClick(event) {
    if (event.target === event.currentTarget) {
      await this.handleClose();
    }
  }
  async handleClose() {
    if (this.isSiweEnabled) {
      const { SIWEController } = await __vitePreload(async () => {
        const { SIWEController: SIWEController2 } = await import("./index-DFMQ5ukk.js");
        return { SIWEController: SIWEController2 };
      }, true ? [] : void 0);
      if (SIWEController.state.status !== "success" && this.connected) {
        await ConnectionController.disconnect();
      }
    }
    ModalController.close();
  }
  initializeTheming() {
    const { themeVariables, themeMode } = ThemeController.state;
    const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
    initializeTheming(themeVariables, defaultThemeMode);
  }
  onClose() {
    this.open = false;
    this.classList.remove("open");
    this.onScrollUnlock();
    SnackController.hide();
    this.onRemoveKeyboardListener();
  }
  onOpen() {
    this.open = true;
    this.classList.add("open");
    this.onScrollLock();
    this.onAddKeyboardListener();
  }
  onScrollLock() {
    const styleTag = document.createElement("style");
    styleTag.dataset["w3m"] = SCROLL_LOCK;
    styleTag.textContent = `
      body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
    document.head.appendChild(styleTag);
  }
  onScrollUnlock() {
    const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
    if (styleTag) {
      styleTag.remove();
    }
  }
  onAddKeyboardListener() {
    var _a2;
    this.abortController = new AbortController();
    const card = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-card");
    card == null ? void 0 : card.focus();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        this.handleClose();
      } else if (event.key === "Tab") {
        const { tagName } = event.target;
        if (tagName && !tagName.includes("W3M-") && !tagName.includes("WUI-")) {
          card == null ? void 0 : card.focus();
        }
      }
    }, this.abortController);
  }
  onRemoveKeyboardListener() {
    var _a2;
    (_a2 = this.abortController) == null ? void 0 : _a2.abort();
    this.abortController = void 0;
  }
  async onNewAddress(caipAddress) {
    var _a2, _b2;
    if (!this.connected || this.loading) {
      return;
    }
    const previousAddress = CoreHelperUtil.getPlainAddress(this.caipAddress);
    const newAddress = CoreHelperUtil.getPlainAddress(caipAddress);
    const previousNetworkId = CoreHelperUtil.getNetworkId(this.caipAddress);
    const newNetworkId = CoreHelperUtil.getNetworkId(caipAddress);
    this.caipAddress = caipAddress;
    if (this.isSiweEnabled) {
      const { SIWEController } = await __vitePreload(async () => {
        const { SIWEController: SIWEController2 } = await import("./index-DFMQ5ukk.js");
        return { SIWEController: SIWEController2 };
      }, true ? [] : void 0);
      const session = await SIWEController.getSession();
      if (session && previousAddress && newAddress && previousAddress !== newAddress) {
        if ((_a2 = SIWEController.state._client) == null ? void 0 : _a2.options.signOutOnAccountChange) {
          await SIWEController.signOut();
          this.onSiweNavigation();
        }
        return;
      }
      if (session && previousNetworkId && newNetworkId && previousNetworkId !== newNetworkId) {
        if ((_b2 = SIWEController.state._client) == null ? void 0 : _b2.options.signOutOnNetworkChange) {
          await SIWEController.signOut();
          this.onSiweNavigation();
        }
        return;
      }
      this.onSiweNavigation();
    }
  }
  onSiweNavigation() {
    if (this.open) {
      RouterController.push("ConnectingSiwe");
    } else {
      ModalController.open({
        view: "ConnectingSiwe"
      });
    }
  }
};
W3mModal.styles = styles$X;
__decorate$1s([
  r$1()
], W3mModal.prototype, "open", void 0);
__decorate$1s([
  r$1()
], W3mModal.prototype, "caipAddress", void 0);
__decorate$1s([
  r$1()
], W3mModal.prototype, "isSiweEnabled", void 0);
__decorate$1s([
  r$1()
], W3mModal.prototype, "connected", void 0);
__decorate$1s([
  r$1()
], W3mModal.prototype, "loading", void 0);
W3mModal = __decorate$1s([
  customElement("w3m-modal")
], W3mModal);
const styles$W = i$2`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1r = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mNetworkButton = class W3mNetworkButton2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = NetworkController.state.caipNetwork;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
    this.unsubscribe.push(...[
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val),
      AccountController.subscribeKey("isConnected", (val) => this.connected = val),
      ModalController.subscribeKey("loading", (val) => this.loading = val),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => this.isUnsupportedChain = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    return ke$1`
      <wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        imageSrc=${to(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.isUnsupportedChain ? "Switch Network" : ((_a2 = this.network) == null ? void 0 : _a2.name) ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `;
  }
  onClick() {
    if (!this.loading) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButton.styles = styles$W;
__decorate$1r([
  n2({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate$1r([
  r$1()
], W3mNetworkButton.prototype, "network", void 0);
__decorate$1r([
  r$1()
], W3mNetworkButton.prototype, "connected", void 0);
__decorate$1r([
  r$1()
], W3mNetworkButton.prototype, "loading", void 0);
__decorate$1r([
  r$1()
], W3mNetworkButton.prototype, "isUnsupportedChain", void 0);
W3mNetworkButton = __decorate$1r([
  customElement("w3m-network-button")
], W3mNetworkButton);
const styles$V = i$2`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var __decorate$1q = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mRouter = class W3mRouter2 extends h {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(async ([content]) => {
      const height2 = `${content == null ? void 0 : content.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        await this.animate([{ height: this.prevHeight }, { height: height2 }], {
          duration: 150,
          easing: "ease",
          fill: "forwards"
        }).finished;
        this.style.height = "auto";
      }
      this.prevHeight = height2;
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`<div>${this.viewTemplate()}</div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "Account":
        return ke$1`<w3m-account-view></w3m-account-view>`;
      case "AccountSettings":
        return ke$1`<w3m-account-settings-view></w3m-account-settings-view>`;
      case "AllWallets":
        return ke$1`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "ApproveTransaction":
        return ke$1`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "BuyInProgress":
        return ke$1`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
      case "ChooseAccountName":
        return ke$1`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
      case "Connect":
        return ke$1`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return ke$1`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return ke$1`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return ke$1`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "ConnectWallets":
        return ke$1`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
      case "ConnectSocials":
        return ke$1`<w3m-connect-socials-view></w3m-connect-socials-view>`;
      case "ConnectingSocial":
        return ke$1`<w3m-connecting-social-view></w3m-connecting-social-view>`;
      case "Downloads":
        return ke$1`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return ke$1`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return ke$1`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "Networks":
        return ke$1`<w3m-networks-view></w3m-networks-view>`;
      case "RegisterAccountName":
        return ke$1`<w3m-register-account-name-view></w3m-register-account-name-view>`;
      case "RegisterAccountNameSuccess":
        return ke$1`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
      case "SwitchNetwork":
        return ke$1`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "GetWallet":
        return ke$1`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Transactions":
        return ke$1`<w3m-transactions-view></w3m-transactions-view>`;
      case "OnRampProviders":
        return ke$1`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
      case "OnRampActivity":
        return ke$1`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
      case "OnRampTokenSelect":
        return ke$1`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
      case "OnRampFiatSelect":
        return ke$1`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
      case "UpgradeEmailWallet":
        return ke$1`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpgradeToSmartAccount":
        return ke$1`<w3m-upgrade-to-smart-account-view></w3m-upgrade-to-smart-account-view>`;
      case "UpdateEmailWallet":
        return ke$1`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailPrimaryOtp":
        return ke$1`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
      case "UpdateEmailSecondaryOtp":
        return ke$1`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
      case "UnsupportedChain":
        return ke$1`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
      case "WalletReceive":
        return ke$1`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
      case "WalletCompatibleNetworks":
        return ke$1`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
      case "Swap":
        return ke$1`<w3m-swap-view></w3m-swap-view>`;
      case "SwapSelectToken":
        return ke$1`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
      case "SwapPreview":
        return ke$1`<w3m-swap-preview-view></w3m-swap-preview-view>`;
      case "WalletSend":
        return ke$1`<w3m-wallet-send-view></w3m-wallet-send-view>`;
      case "WalletSendSelectToken":
        return ke$1`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
      case "WalletSendPreview":
        return ke$1`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
      case "WhatIsABuy":
        return ke$1`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
      case "WhatIsANetwork":
        return ke$1`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "WhatIsAWallet":
        return ke$1`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      default:
        return ke$1`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  async onViewChange(newView) {
    TooltipController.hide();
    const { history } = RouterController.state;
    let xOut = -10;
    let xIn = 10;
    if (history.length < this.prevHistoryLength) {
      xOut = 10;
      xIn = -10;
    }
    this.prevHistoryLength = history.length;
    await this.animate([
      { opacity: 1, transform: "translateX(0px)" },
      { opacity: 0, transform: `translateX(${xOut}px)` }
    ], { duration: 150, easing: "ease", fill: "forwards" }).finished;
    this.view = newView;
    await this.animate([
      { opacity: 0, transform: `translateX(${xIn}px)` },
      { opacity: 1, transform: "translateX(0px)" }
    ], { duration: 150, easing: "ease", fill: "forwards", delay: 50 }).finished;
  }
  getWrapper() {
    var _a2;
    return (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("div");
  }
};
W3mRouter.styles = styles$V;
__decorate$1q([
  r$1()
], W3mRouter.prototype, "view", void 0);
W3mRouter = __decorate$1q([
  customElement("w3m-router")
], W3mRouter);
const styles$U = i$2`
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;
var __decorate$1p = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const PAYMENT_CURRENCY_SYMBOLS = {
  USD: "$",
  EUR: "€",
  GBP: "£"
};
const BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
let W3mOnrampWidget = class W3mOnrampWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.paymentCurrency = OnRampController.state.paymentCurrency;
    this.paymentAmount = OnRampController.state.paymentAmount;
    this.purchaseAmount = OnRampController.state.purchaseAmount;
    this.quoteLoading = OnRampController.state.quotesLoading;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("isConnected", (val) => {
        this.connected = val;
      }),
      ModalController.subscribeKey("loading", (val) => {
        this.loading = val;
      }),
      OnRampController.subscribe((val) => {
        this.paymentCurrency = val.paymentCurrency;
        this.paymentAmount = val.paymentAmount;
        this.purchaseAmount = val.purchaseAmount;
        this.quoteLoading = val.quotesLoading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-onramp-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-onramp-input>
          <w3m-onramp-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-onramp-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map((amount) => {
      var _a2;
      return ke$1`<wui-button
                  variant=${this.paymentAmount === amount ? "accent" : "neutral"}
                  size="md"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[((_a2 = this.paymentCurrency) == null ? void 0 : _a2.id) || "USD"]} ${amount}`}</wui-button
                >`;
    })}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateButton() {
    return this.connected ? ke$1`<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="main"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>` : ke$1`<wui-button
          @click=${this.openModal.bind(this)}
          variant="accent"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`;
  }
  getQuotes() {
    if (!this.loading) {
      ModalController.open({ view: "OnRampProviders" });
    }
  }
  openModal() {
    ModalController.open({ view: "Connect" });
  }
  async onPaymentAmountChange(event) {
    OnRampController.setPaymentAmount(Number(event.detail));
    await OnRampController.getQuote();
  }
  async selectPresetAmount(amount) {
    OnRampController.setPaymentAmount(amount);
    await OnRampController.getQuote();
  }
};
W3mOnrampWidget.styles = styles$U;
__decorate$1p([
  n2({ type: Boolean })
], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "connected", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "loading", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate$1p([
  r$1()
], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate$1p([
  customElement("w3m-onramp-widget")
], W3mOnrampWidget);
const styles$T = i$2`
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }
`;
var __decorate$1o = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountSettingsView = class W3mAccountSettingsView2 extends h {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = NetworkController.state.caipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.disconnecting = false;
    this.loading = false;
    this.switched = false;
    this.text = "";
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => {
        if (val == null ? void 0 : val.id) {
          this.network = val;
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2, _b2;
    if (!this.address) {
      throw new Error("w3m-account-settings-view: No account provided");
    }
    const networkImage = this.networkImages[((_a2 = this.network) == null ? void 0 : _a2.imageId) ?? ""];
    return ke$1`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          .imageSrc=${this.profileImage || ""}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100" data-testid="account-settings-address">
              ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${["0", "l", "m", "l"]}>
          ${this.authCardTemplate()}
          <w3m-account-auth-button></w3m-account-auth-button>
          <wui-list-item
            .variant=${networkImage ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${to(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${((_b2 = this.network) == null ? void 0 : _b2.name) ?? "Unknown"}
            </wui-text>
          </wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  chooseNameButtonTemplate() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const isAllowed = EnsController.isAllowedToRegisterName();
    if (!authConnector || type3 !== "AUTH" || this.profileName || !isAllowed) {
      return null;
    }
    return ke$1`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="id"
        iconSize="sm"
        ?chevron=${true}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <wui-text variant="paragraph-500" color="fg-100">Choose account name </wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type3 !== "AUTH" || origin.includes(ConstantsUtil$2.SECURE_SITE)) {
      return null;
    }
    return ke$1`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks } = NetworkController.state;
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id: id2 }) => {
      var _a2;
      return id2 === ((_a2 = this.network) == null ? void 0 : _a2.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  togglePreferredAccountBtnTemplate() {
    const networkEnabled = NetworkController.checkIfSmartAccountEnabled();
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type3 !== "AUTH" || !networkEnabled) {
      return null;
    }
    if (!this.switched) {
      this.text = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    }
    return ke$1`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${true}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>
      </wui-list-item>
    `;
  }
  onChooseName() {
    RouterController.push("ChooseAccountName");
  }
  async changePreferredAccountType() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    const accountTypeTarget = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT || !smartAccountEnabled ? W3mFrameRpcConstants.ACCOUNT_TYPES.EOA : W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    this.loading = true;
    await ConnectionController.setPreferredAccountType(accountTypeTarget);
    this.text = accountTypeTarget === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    this.switched = true;
    SendController.resetSend();
    this.loading = false;
    this.requestUpdate();
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountSettingsView.styles = styles$T;
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "address", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "network", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "preferredAccountType", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "disconnecting", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "loading", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "switched", void 0);
__decorate$1o([
  r$1()
], W3mAccountSettingsView.prototype, "text", void 0);
W3mAccountSettingsView = __decorate$1o([
  customElement("w3m-account-settings-view")
], W3mAccountSettingsView);
var __decorate$1n = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountView = class W3mAccountView2 extends h {
  render() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    return ke$1`
      ${(authConnector == null ? void 0 : authConnector.walletFeatures) && type3 === "AUTH" ? this.walletFeaturesTemplate() : this.defaultTemplate()}
    `;
  }
  walletFeaturesTemplate() {
    return ke$1`<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
  }
  defaultTemplate() {
    return ke$1`<w3m-account-default-widget></w3m-account-default-widget>`;
  }
};
W3mAccountView = __decorate$1n([
  customElement("w3m-account-view")
], W3mAccountView);
var __decorate$1m = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAllWalletsView = class W3mAllWalletsView2 extends h {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value2) => {
      this.search = value2;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return ke$1`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? ke$1`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : ke$1`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return ke$1`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$1m([
  r$1()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate$1m([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);
const styles$S = i$2`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;
var __decorate$1l = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mBuyInProgressView = class W3mBuyInProgressView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.uri = ConnectionController.state.wcUri;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.error = false;
    this.startTime = null;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      })
    ]);
    this.watchTransactions();
  }
  disconnectedCallback() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  render() {
    var _a2, _b2;
    let label = "Continue in external window";
    if (this.error) {
      label = "Buy failed";
    } else if (this.selectedOnRampProvider) {
      label = `Buy in ${(_a2 = this.selectedOnRampProvider) == null ? void 0 : _a2.label}`;
    }
    const subLabel = this.error ? "Buy can be declined from your side or due to and error on the provider app" : `We’ll notify you once your Buy is processed`;
    return ke$1`
      <wui-flex
        data-error=${to(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${to((_b2 = this.selectedOnRampProvider) == null ? void 0 : _b2.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `;
  }
  watchTransactions() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    switch (this.selectedOnRampProvider.name) {
      case "coinbase":
        this.startTime = Date.now();
        this.initializeCoinbaseTransactions();
        break;
    }
  }
  async initializeCoinbaseTransactions() {
    await this.watchCoinbaseTransactions();
    this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4e3);
  }
  async watchCoinbaseTransactions() {
    try {
      const address = AccountController.state.address;
      const projectId = OptionsController.state.projectId;
      if (!address) {
        throw new Error("No address found");
      }
      const coinbaseResponse = await BlockchainApiController.fetchTransactions({
        account: address,
        onramp: "coinbase",
        projectId
      });
      const newTransactions = coinbaseResponse.data.filter((tx) => new Date(tx.metadata.minedAt) > new Date(this.startTime) || tx.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
      if (newTransactions.length) {
        clearInterval(this.intervalId);
        RouterController.replace("OnRampActivity");
      } else if (this.startTime && Date.now() - this.startTime >= 18e4) {
        clearInterval(this.intervalId);
        this.error = true;
      }
    } catch (error) {
      SnackController.showError(error);
    }
  }
  onTryAgain() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    this.error = false;
    CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
  }
  tryAgainTemplate() {
    var _a2;
    if (!((_a2 = this.selectedOnRampProvider) == null ? void 0 : _a2.url)) {
      return null;
    }
    return ke$1`<wui-button size="md" variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return ke$1`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    var _a2;
    if (!((_a2 = this.selectedOnRampProvider) == null ? void 0 : _a2.url)) {
      SnackController.showError("No link found");
      RouterController.goBack();
      return;
    }
    try {
      CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
      SnackController.showSuccess("Link copied");
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mBuyInProgressView.styles = styles$S;
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "error", void 0);
__decorate$1l([
  r$1()
], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate$1l([
  n2({ type: Boolean })
], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate$1l([
  n2()
], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate$1l([
  customElement("w3m-buy-in-progress-view")
], W3mBuyInProgressView);
const styles$R = i$2`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }
`;
var __decorate$1k = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectView = class W3mConnectView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["3xs", "s", "s", "s"]}>
        <w3m-email-login-widget></w3m-email-login-widget>
        <w3m-social-login-widget></w3m-social-login-widget>
        ${this.walletListTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletListTemplate() {
    const authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    if (authConnector == null ? void 0 : authConnector.socials) {
      if (authConnector == null ? void 0 : authConnector.showWallets) {
        return ke$1`
          <wui-flex flexDirection="column" gap="xs" .margin=${["xs", "0", "0", "0"]}>
            <w3m-connect-walletconnect-widget></w3m-connect-walletconnect-widget>
            <w3m-connect-recent-widget></w3m-connect-recent-widget>
            <w3m-connect-announced-widget></w3m-connect-announced-widget>
            <w3m-connect-injected-widget></w3m-connect-injected-widget>
            <w3m-connect-featured-widget></w3m-connect-featured-widget>
            <w3m-connect-custom-widget></w3m-connect-custom-widget>
            <w3m-connect-coinbase-widget></w3m-connect-coinbase-widget>
            <w3m-connect-recommended-widget></w3m-connect-recommended-widget>
            <wui-flex class="all-wallets" .margin=${["xs", "0", "0", "0"]}>
              <w3m-all-wallets-widget></w3m-all-wallets-widget>
            </wui-flex>
          </wui-flex>
        `;
      }
      return ke$1` <wui-list-button
        @click=${this.onContinueWalletClick.bind(this)}
        text="Continue with a wallet"
      ></wui-list-button>`;
    }
    return ke$1`<w3m-wallet-login-list></w3m-wallet-login-list>`;
  }
  onContinueWalletClick() {
    RouterController.push("ConnectWallets");
  }
};
W3mConnectView.styles = styles$R;
__decorate$1k([
  r$1()
], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate$1k([
  customElement("w3m-connect-view")
], W3mConnectView);
const styles$Q = i$2`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$1j = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class W3mConnectingWidget extends h {
  constructor() {
    var _a2, _b2, _c2, _d2;
    super();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    this.connector = (_b2 = RouterController.state.data) == null ? void 0 : _b2.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = ((_c2 = this.wallet) == null ? void 0 : _c2.name) ?? ((_d2 = this.connector) == null ? void 0 : _d2.name) ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        var _a3;
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          (_a3 = this.onConnect) == null ? void 0 : _a3.call(this);
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    var _a2;
    (_a2 = this.onAutoConnect) == null ? void 0 : _a2.call(this);
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    var _a2;
    (_a2 = this.onRender) == null ? void 0 : _a2.call(this);
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return ke$1`
      <wui-flex
        data-error=${to(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${to(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          size="md"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? ke$1`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    var _a2;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var _a2, _b2;
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        (_a2 = this.onRetry) == null ? void 0 : _a2.call(this);
      } else {
        (_b2 = this.onConnect) == null ? void 0 : _b2.call(this);
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return ke$1`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
}
W3mConnectingWidget.styles = styles$Q;
__decorate$1j([
  r$1()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$1j([
  r$1()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate$1j([
  r$1()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$1j([
  r$1()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$1j([
  r$1()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$1j([
  n2({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$1j([
  n2()
], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$1i = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: "browser"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.imageUrl) {
          StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl);
        }
        if (this.connector.id !== ConstantsUtil$1.COINBASE_SDK_CONNECTOR_ID || !this.error) {
          await ConnectionController.connectExternal(this.connector);
          if (OptionsController.state.isSiweEnabled) {
            RouterController.push("ConnectingSiwe");
          } else {
            ModalController.close();
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: this.connector.name || "Unknown" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate$1i([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);
var __decorate$1h = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcView = class W3mConnectingWcView2 extends h {
  constructor() {
    var _a2;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$2.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return ke$1`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    this.determinePlatforms();
    return ke$1`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry = false) {
    try {
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        ConnectionController.connectWalletConnect();
        if (this.wallet) {
          const url2 = AssetUtil.getWalletImage(this.wallet);
          if (url2) {
            StorageUtil.setConnectedWalletImageUrl(url2);
          }
        } else {
          const connectors = ConnectorController.state.connectors;
          const connector = connectors.find((c2) => c2.type === "WALLET_CONNECT");
          const url2 = AssetUtil.getConnectorImage(connector);
          if (url2) {
            StorageUtil.setConnectedWalletImageUrl(url2);
          }
        }
        await ConnectionController.state.wcPromise;
        this.finalizeConnection();
        if (OptionsController.state.isSiweEnabled) {
          const { SIWEController } = await __vitePreload(async () => {
            const { SIWEController: SIWEController2 } = await import("./index-DFMQ5ukk.js");
            return { SIWEController: SIWEController2 };
          }, true ? [] : void 0);
          if (SIWEController.state.status === "success") {
            ModalController.close();
          } else {
            RouterController.push("ConnectingSiwe");
          }
        } else {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    var _a2;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setWeb3ModalRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: ((_a2 = this.wallet) == null ? void 0 : _a2.name) || "Unknown"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
    const injectedIds = injected == null ? void 0 : injected.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = rdns ? [rdns] : injectedIds ?? [];
    const isBrowser2 = browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser2 && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser2) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return ke$1`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return ke$1`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return ke$1`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return ke$1`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return ke$1`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return ke$1`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return ke$1`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    var _a2;
    const container = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate$1h([
  r$1()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$1h([
  r$1()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate$1h([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);
const styles$P = i$2`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1g = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mChooseAccountNameView = class W3mChooseAccountNameView2 extends h {
  constructor() {
    super(...arguments);
    this.loading = false;
  }
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more about names
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return ke$1` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          icon="id"
          size="xl"
          iconSize="xxl"
          iconColor="fg-200"
          backgroundColor="fg-200"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Choose your account name
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return ke$1`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </wui-button>
    </wui-flex>`;
  }
  handleContinue() {
    RouterController.push("RegisterAccountName");
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_ENS_FLOW",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
W3mChooseAccountNameView.styles = styles$P;
__decorate$1g([
  r$1()
], W3mChooseAccountNameView.prototype, "loading", void 0);
W3mChooseAccountNameView = __decorate$1g([
  customElement("w3m-choose-account-name-view")
], W3mChooseAccountNameView);
var __decorate$1f = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mDownloadsView = class W3mDownloadsView2 extends h {
  constructor() {
    var _a2;
    super(...arguments);
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return ke$1`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.chrome_store)) {
      return null;
    }
    return ke$1`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.app_store)) {
      return null;
    }
    return ke$1`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.play_store)) {
      return null;
    }
    return ke$1`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.homepage)) {
      return null;
    }
    return ke$1`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate$1f([
  customElement("w3m-downloads-view")
], W3mDownloadsView);
var __decorate$1e = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class W3mGetWalletView2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => ke$1`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${to(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate$1e([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);
const styles$O = i$2`
  wui-flex {
    width: 100%;
  }

  .suggestion {
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  .suggestion:hover {
    background-color: var(--wui-gray-glass-005);
    cursor: pointer;
  }

  .suggested-name {
    max-width: 75%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  form {
    width: 100%;
  }

  wui-icon-link {
    position: absolute;
    right: 20px;
    transform: translateY(11px);
  }
`;
var __decorate$1d = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mRegisterAccountNameView = class W3mRegisterAccountNameView2 extends h {
  constructor() {
    super();
    this.formRef = ii();
    this.usubscribe = [];
    this.name = "";
    this.error = "";
    this.loading = EnsController.state.loading;
    this.suggestions = EnsController.state.suggestions;
    this.registered = false;
    this.onDebouncedNameInputChange = CoreHelperUtil.debounce((value2) => {
      if (EnsController.validateName(value2)) {
        this.error = "";
        this.name = value2;
        EnsController.getSuggestions(value2);
        EnsController.isNameRegistered(value2).then((registered) => {
          this.registered = registered;
        });
      } else if (value2.length < 4) {
        this.error = "Name must be at least 4 characters long";
      } else {
        this.error = "Can only contain letters, numbers and - characters";
      }
    });
    this.usubscribe.push(...[
      EnsController.subscribe((val) => {
        this.suggestions = val.suggestions;
        this.loading = val.loading;
      })
    ]);
  }
  firstUpdated() {
    var _a2;
    (_a2 = this.formRef.value) == null ? void 0 : _a2.addEventListener("keydown", this.onEnterKey.bind(this));
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    this.usubscribe.forEach((unsub) => unsub());
    (_a2 = this.formRef.value) == null ? void 0 : _a2.removeEventListener("keydown", this.onEnterKey.bind(this));
  }
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="m"
        .padding=${["0", "s", "m", "s"]}
      >
        <form ${Kt$1(this.formRef)} @submit=${this.onSubmitName.bind(this)}>
          <wui-ens-input
            @inputChange=${this.onNameInputChange.bind(this)}
            .errorMessage=${this.error}
            .value=${this.name}
          >
          </wui-ens-input>
          ${this.submitButtonTemplate()}
          <input type="submit" hidden />
        </form>
        ${this.templateSuggestions()}
      </wui-flex>
    `;
  }
  submitButtonTemplate() {
    const showSubmit = this.isAllowedToSubmit();
    return showSubmit ? ke$1`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitName.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  onSelectSuggestion(name) {
    return () => {
      this.name = name;
      this.registered = false;
      this.requestUpdate();
    };
  }
  onNameInputChange(event) {
    this.onDebouncedNameInputChange(event.detail);
  }
  nameSuggestionTagTemplate() {
    if (this.loading) {
      return ke$1`<wui-loading-spinner size="lg" color="fg-100"></wui-loading-spinner>`;
    }
    return this.registered ? ke$1`<wui-tag variant="shade" size="lg">Registered</wui-tag>` : ke$1`<wui-tag variant="success" size="lg">Available</wui-tag>`;
  }
  templateSuggestions() {
    if (!this.name || this.name.length < 4 || this.error) {
      return null;
    }
    const suggestions = this.registered ? this.suggestions.filter((s2) => s2.name !== this.name) : [];
    return ke$1`<wui-flex flexDirection="column" gap="xxs" alignItems="center">
      <wui-flex
        .padding=${["m", "m", "m", "m"]}
        justifyContent="space-between"
        class="suggestion"
      >
        <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
          ${this.name}</wui-text
        >${this.nameSuggestionTagTemplate()}
      </wui-flex>
      ${suggestions.map((suggestion) => this.availableNameTemplate(suggestion.name))}
    </wui-flex>`;
  }
  availableNameTemplate(suggestion) {
    return ke$1` <wui-flex
      .padding=${["m", "m", "m", "m"]}
      justifyContent="space-between"
      class="suggestion"
      @click=${this.onSelectSuggestion(suggestion)}
    >
      <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
        ${suggestion}
      </wui-text>
      <wui-tag variant="success" size="lg">Available</wui-tag>
    </wui-flex>`;
  }
  isAllowedToSubmit() {
    return !this.loading && !this.registered && !this.error && EnsController.validateName(this.name);
  }
  async onSubmitName() {
    try {
      if (!this.isAllowedToSubmit()) {
        return;
      }
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name
        }
      });
      await EnsController.registerName(this.name);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name
        }
      });
    } catch (error) {
      SnackController.showError(error.message);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name,
          error: (error == null ? void 0 : error.message) || "Unknown error"
        }
      });
    }
  }
  onEnterKey(event) {
    if (event.key === "Enter" && this.isAllowedToSubmit()) {
      this.onSubmitName();
    }
  }
};
W3mRegisterAccountNameView.styles = styles$O;
__decorate$1d([
  n2()
], W3mRegisterAccountNameView.prototype, "errorMessage", void 0);
__decorate$1d([
  r$1()
], W3mRegisterAccountNameView.prototype, "name", void 0);
__decorate$1d([
  r$1()
], W3mRegisterAccountNameView.prototype, "error", void 0);
__decorate$1d([
  r$1()
], W3mRegisterAccountNameView.prototype, "loading", void 0);
__decorate$1d([
  r$1()
], W3mRegisterAccountNameView.prototype, "suggestions", void 0);
__decorate$1d([
  r$1()
], W3mRegisterAccountNameView.prototype, "registered", void 0);
W3mRegisterAccountNameView = __decorate$1d([
  customElement("w3m-register-account-name-view")
], W3mRegisterAccountNameView);
const styles$N = i$2`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1c = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mRegisterAccountNameSuccess = class W3mRegisterAccountNameSuccess2 extends h {
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return ke$1` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          size="xl"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Account name chosen successfully
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          You can now fund your account and trade crypto
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return ke$1`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button fullWidth size="lg" borderRadius="xs" @click=${this.redirectToAccount.bind(this)}
        >Let's Go!
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.replace("Account");
  }
};
W3mRegisterAccountNameSuccess.styles = styles$N;
W3mRegisterAccountNameSuccess = __decorate$1c([
  customElement("w3m-register-account-name-success-view")
], W3mRegisterAccountNameSuccess);
const styles$M = i$2`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$1b = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends h {
  constructor() {
    var _a2;
    super();
    this.network = (_a2 = RouterController.state.data) == null ? void 0 : _a2.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.getLabel();
    const subLabel = this.getSubLabel();
    return ke$1`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${to(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : ke$1`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="accent"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  getSubLabel() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type3 === "AUTH") {
      return "";
    }
    return this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
  }
  getLabel() {
    var _a2;
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type3 === "AUTH") {
      return `Switching to ${((_a2 = this.network) == null ? void 0 : _a2.name) ?? "Unknown"} network...`;
    }
    return this.error ? "Switch declined" : "Approve in wallet";
  }
  onShowRetry() {
    var _a2;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
        if (!OptionsController.state.isSiweEnabled) {
          RouterUtil.navigateAfterNetworkSwitch();
        }
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles$M;
__decorate$1b([
  r$1()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$1b([
  r$1()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$1b([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);
const styles$L = i$2`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1a = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mNetworksView = class W3mNetworksView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks, supportsAllNetworks } = NetworkController.state;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    return sortedNetworks == null ? void 0 : sortedNetworks.map((network) => {
      var _a2;
      return ke$1`
        <wui-card-select
          .selected=${((_a2 = this.caipNetwork) == null ? void 0 : _a2.id) === network.id}
          imageSrc=${to(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !(approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id))}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-card-select>
      `;
    });
  }
  async onSwitchNetwork(network) {
    const { isConnected } = AccountController.state;
    const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
    const { data: data2 } = RouterController.state;
    if (isConnected && (caipNetwork == null ? void 0 : caipNetwork.id) !== network.id) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        RouterUtil.navigateAfterNetworkSwitch();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...data2, network });
      }
    } else if (!isConnected) {
      NetworkController.setCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mNetworksView.styles = styles$L;
__decorate$1a([
  r$1()
], W3mNetworksView.prototype, "caipNetwork", void 0);
W3mNetworksView = __decorate$1a([
  customElement("w3m-networks-view")
], W3mNetworksView);
const styles$K = i$2`
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;
var __decorate$19 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const LOADING_ITEM_COUNT$1 = 7;
let W3mOnRampActivityView = class W3mOnRampActivityView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.loading = false;
    this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val),
      () => {
        clearTimeout(this.refetchTimeout);
      },
      TransactionsController.subscribe((val) => {
        this.coinbaseTransactions = { ...val.coinbaseTransactions };
      })
    ]);
    TransactionsController.clearCursor();
    this.fetchTransactions();
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `;
  }
  templateTransactions(transactions) {
    return transactions == null ? void 0 : transactions.map((transaction) => {
      var _a2, _b2, _c2;
      const date = DateUtil.formatDate((_a2 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a2.minedAt);
      const transfer = transaction.transfers[0];
      const fungibleInfo = transfer == null ? void 0 : transfer.fungible_info;
      if (!fungibleInfo) {
        return null;
      }
      const icon = ((_b2 = fungibleInfo == null ? void 0 : fungibleInfo.icon) == null ? void 0 : _b2.url) || ((_c2 = this.tokenImages) == null ? void 0 : _c2[fungibleInfo.symbol || ""]);
      return ke$1`
        <wui-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${to(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${to(icon)}
          symbol=${to(fungibleInfo.symbol)}
        ></wui-onramp-activity-item>
      `;
    });
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        var _a2;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = (_a2 = this.coinbaseTransactions[yearInt]) == null ? void 0 : _a2[month];
        if (!transactions) {
          return null;
        }
        return ke$1`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  async fetchTransactions() {
    {
      await this.fetchCoinbaseTransactions();
    }
  }
  async fetchCoinbaseTransactions() {
    const address = AccountController.state.address;
    const projectId = OptionsController.state.projectId;
    if (!address) {
      throw new Error("No address found");
    }
    if (!projectId) {
      throw new Error("No projectId found");
    }
    this.loading = true;
    await TransactionsController.fetchTransactions(address, "coinbase");
    this.loading = false;
    this.refetchLoadingTransactions();
  }
  refetchLoadingTransactions() {
    var _a2;
    const today = /* @__PURE__ */ new Date();
    const currentMonthTxs = ((_a2 = this.coinbaseTransactions[today.getFullYear()]) == null ? void 0 : _a2[today.getMonth()]) || [];
    const loadingTransactions = currentMonthTxs.filter((transaction) => transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
    if (loadingTransactions.length === 0) {
      clearTimeout(this.refetchTimeout);
      return;
    }
    this.refetchTimeout = setTimeout(async () => {
      const address = AccountController.state.address;
      await TransactionsController.fetchTransactions(address, "coinbase");
      this.refetchLoadingTransactions();
    }, 3e3);
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT$1).fill(ke$1` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
};
W3mOnRampActivityView.styles = styles$K;
__decorate$19([
  r$1()
], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate$19([
  r$1()
], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate$19([
  r$1()
], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate$19([
  r$1()
], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate$19([
  customElement("w3m-onramp-activity-view")
], W3mOnRampActivityView);
const styles$J = i$2`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$18 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.paymentCurrency;
    this.currencies = OnRampController.state.paymentCurrencies;
    this.currencyImages = AssetController.state.currencyImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.paymentCurrency;
        this.currencies = val.paymentCurrencies;
      }),
      AssetController.subscribeKey("currencyImages", (val) => this.currencyImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.currencies.map((currency) => {
      var _a2;
      return ke$1`
        <wui-list-item
          imageSrc=${to((_a2 = this.currencyImages) == null ? void 0 : _a2[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
        >
          <wui-text variant="paragraph-500" color="fg-100">${currency.id}</wui-text>
        </wui-list-item>
      `;
    });
  }
  selectCurrency(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPaymentCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampFiatSelectView.styles = styles$J;
__decorate$18([
  r$1()
], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate$18([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate$18([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
W3mOnrampFiatSelectView = __decorate$18([
  customElement("w3m-onramp-fiat-select-view")
], W3mOnrampFiatSelectView);
var __decorate$17 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mOnRampProvidersView = class W3mOnRampProvidersView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.providers = OnRampController.state.providers;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("providers", (val) => {
        this.providers = val;
      })
    ]);
  }
  firstUpdated() {
    const urlPromises = this.providers.map(async (provider) => {
      if (provider.name === "coinbase") {
        return await this.getCoinbaseOnRampURL();
      }
      return Promise.resolve(provider == null ? void 0 : provider.url);
    });
    Promise.all(urlPromises).then((urls) => {
      this.providers = this.providers.map((provider, index) => ({
        ...provider,
        url: urls[index] || ""
      }));
    });
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `;
  }
  onRampProvidersTemplate() {
    return this.providers.map((provider) => ke$1`
        <wui-onramp-provider-item
          label=${provider.label}
          name=${provider.name}
          feeRange=${provider.feeRange}
          @click=${() => {
      this.onClickProvider(provider);
    }}
          ?disabled=${!provider.url}
        ></wui-onramp-provider-item>
      `);
  }
  onClickProvider(provider) {
    OnRampController.setSelectedProvider(provider);
    RouterController.push("BuyInProgress");
    CoreHelperUtil.openHref(provider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_PROVIDER",
      properties: {
        provider: provider.name,
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
  async getCoinbaseOnRampURL() {
    const address = AccountController.state.address;
    const network = NetworkController.state.caipNetwork;
    if (!address) {
      throw new Error("No address found");
    }
    if (!(network == null ? void 0 : network.name)) {
      throw new Error("No network found");
    }
    const defaultNetwork = ConstantsUtil$2.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil$2.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
    const purchaseCurrency = OnRampController.state.purchaseCurrency;
    const assets = purchaseCurrency ? [purchaseCurrency.symbol] : OnRampController.state.purchaseCurrencies.map((currency) => currency.symbol);
    return await BlockchainApiController.generateOnRampURL({
      defaultNetwork,
      destinationWallets: [
        { address, blockchains: ConstantsUtil$2.WC_COINBASE_PAY_SDK_CHAINS, assets }
      ],
      partnerUserId: address,
      purchaseAmount: OnRampController.state.purchaseAmount
    });
  }
};
__decorate$17([
  r$1()
], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate$17([
  customElement("w3m-onramp-providers-view")
], W3mOnRampProvidersView);
const styles$I = i$2`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$16 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mOnrampTokensView = class W3mOnrampTokensView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.purchaseCurrencies;
    this.tokens = OnRampController.state.purchaseCurrencies;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.purchaseCurrencies;
        this.tokens = val.purchaseCurrencies;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.tokens.map((token2) => {
      var _a2;
      return ke$1`
        <wui-list-item
          imageSrc=${to((_a2 = this.tokenImages) == null ? void 0 : _a2[token2.symbol])}
          @click=${() => this.selectToken(token2)}
          variant="image"
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${token2.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${token2.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `;
    });
  }
  selectToken(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPurchaseCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampTokensView.styles = styles$I;
__decorate$16([
  r$1()
], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate$16([
  r$1()
], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate$16([
  r$1()
], W3mOnrampTokensView.prototype, "tokenImages", void 0);
W3mOnrampTokensView = __decorate$16([
  customElement("w3m-onramp-token-select-view")
], W3mOnrampTokensView);
const styles$H = i$2`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .action-button {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }

  .action-button:disabled {
    border-color: 1px solid var(--wui-color-gray-glass-005);
  }

  .swap-inputs-container {
    position: relative;
  }

  .replace-tokens-button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    gap: var(--wui-spacing-1xs);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-modal-bg-base);
    padding: var(--wui-spacing-xxs);
  }

  .replace-tokens-button-container > button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    padding: var(--wui-spacing-xs);
    border: none;
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: background-color;
    z-index: 20;
  }

  .replace-tokens-button-container > button:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$15 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSwapView = class W3mSwapView2 extends h {
  constructor() {
    var _a2;
    super();
    this.unsubscribe = [];
    this.detailsOpen = false;
    this.caipNetworkId = (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id;
    this.initialized = SwapController.state.initialized;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingPrices = SwapController.state.loadingPrices;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.fetchError = SwapController.state.fetchError;
    this.onDebouncedGetSwapCalldata = CoreHelperUtil.debounce(async () => {
      await SwapController.swapTokens();
    }, 200);
    NetworkController.subscribeKey("caipNetwork", (newCaipNetwork) => {
      if (this.caipNetworkId !== (newCaipNetwork == null ? void 0 : newCaipNetwork.id)) {
        this.caipNetworkId = newCaipNetwork == null ? void 0 : newCaipNetwork.id;
        SwapController.resetState();
        SwapController.initializeState();
      }
    });
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          SwapController.resetState();
        }
      }),
      RouterController.subscribeKey("view", (newRoute) => {
        if (!newRoute.includes("Swap")) {
          SwapController.resetValues();
        }
      }),
      SwapController.subscribe((newState) => {
        this.initialized = newState.initialized;
        this.loadingQuote = newState.loadingQuote;
        this.loadingPrices = newState.loadingPrices;
        this.loadingTransaction = newState.loadingTransaction;
        this.sourceToken = newState.sourceToken;
        this.sourceTokenAmount = newState.sourceTokenAmount;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.fetchError = newState.fetchError;
      })
    ]);
  }
  firstUpdated() {
    SwapController.initializeState();
    this.watchTokensAndValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.initialized ? this.templateSwap() : this.templateLoading()}
      </wui-flex>
    `;
  }
  watchTokensAndValues() {
    this.interval = setInterval(() => {
      SwapController.getNetworkTokenPrice();
      SwapController.getMyTokensWithBalance();
      SwapController.swapTokens();
    }, 1e4);
  }
  templateSwap() {
    return ke$1`
      <wui-flex flexDirection="column" gap="s">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          ${this.templateTokenInput("sourceToken", this.sourceToken)}
          ${this.templateTokenInput("toToken", this.toToken)} ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateDetails()} ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  actionButtonLabel() {
    if (this.fetchError) {
      return "Swap";
    }
    if (!this.sourceToken || !this.toToken) {
      return "Select token";
    }
    if (!this.sourceTokenAmount) {
      return "Enter amount";
    }
    if (this.inputError) {
      return this.inputError;
    }
    return "Review swap";
  }
  templateReplaceTokensButton() {
    return ke$1`
      <wui-flex class="replace-tokens-button-container">
        <button @click=${this.onSwitchTokens.bind(this)}>
          <wui-icon name="recycleHorizontal" color="fg-250" size="lg"></wui-icon>
        </button>
      </wui-flex>
    `;
  }
  templateLoading() {
    return ke$1`
      <wui-flex flexDirection="column" gap="l">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          <w3m-swap-input-skeleton target="sourceToken"></w3m-swap-input-skeleton>
          <w3m-swap-input-skeleton target="toToken"></w3m-swap-input-skeleton>
          ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  templateTokenInput(target, token2) {
    var _a2, _b2;
    const myToken = (_a2 = SwapController.state.myTokensWithBalance) == null ? void 0 : _a2.find((ct2) => (ct2 == null ? void 0 : ct2.address) === (token2 == null ? void 0 : token2.address));
    const amount = target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount;
    const price = target === "toToken" ? this.toTokenPriceInUSD : this.sourceTokenPriceInUSD;
    let value2 = parseFloat(amount) * price;
    if (target === "toToken") {
      value2 -= this.gasPriceInUSD || 0;
    }
    return ke$1`<w3m-swap-input
      .value=${target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount}
      ?disabled=${this.loadingQuote && target === "toToken"}
      .onSetAmount=${this.handleChangeAmount.bind(this)}
      target=${target}
      .token=${token2}
      .balance=${(_b2 = myToken == null ? void 0 : myToken.quantity) == null ? void 0 : _b2.numeric}
      .price=${myToken == null ? void 0 : myToken.price}
      .marketValue=${value2}
      .onSetMaxValue=${this.onSetMaxValue.bind(this)}
    ></w3m-swap-input>`;
  }
  onSetMaxValue(target, balance) {
    const token2 = target === "sourceToken" ? this.sourceToken : this.toToken;
    const isNetworkToken = (token2 == null ? void 0 : token2.address) === ConstantsUtil$2.NATIVE_TOKEN_ADDRESS;
    let value2 = "0";
    if (!balance) {
      value2 = "0";
      this.handleChangeAmount(target, value2);
      return;
    }
    if (!this.gasPriceInUSD) {
      value2 = balance;
      this.handleChangeAmount(target, value2);
      return;
    }
    const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).dividedBy(this.sourceTokenPriceInUSD);
    const maxValue = isNetworkToken ? NumberUtil.bigNumber(balance).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(balance);
    this.handleChangeAmount(target, maxValue.isGreaterThan(0) ? maxValue.toFixed(20) : "0");
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return ke$1`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  handleChangeAmount(target, value2) {
    SwapController.clearError();
    if (target === "sourceToken") {
      SwapController.setSourceTokenAmount(value2);
    } else {
      SwapController.setToTokenAmount(value2);
    }
    this.onDebouncedGetSwapCalldata();
  }
  templateActionButton() {
    const haveNoTokenSelected = !this.toToken || !this.sourceToken;
    const haveNoAmount = !this.sourceTokenAmount;
    const loading = this.loadingQuote || this.loadingPrices || this.loadingTransaction;
    const disabled = loading || haveNoTokenSelected || haveNoAmount || this.inputError;
    return ke$1` <wui-flex gap="xs">
      <wui-button
        class="action-button"
        fullWidth
        size="lg"
        borderRadius="xs"
        variant=${haveNoTokenSelected ? "neutral" : "main"}
        .loading=${loading}
        .disabled=${disabled}
        @click=${this.onSwapPreview.bind(this)}
      >
        ${this.actionButtonLabel()}
      </wui-button>
    </wui-flex>`;
  }
  onSwitchTokens() {
    SwapController.switchTokens();
  }
  onSwapPreview() {
    var _a2, _b2;
    if (this.fetchError) {
      SwapController.swapTokens();
      return;
    }
    EventsController.sendEvent({
      type: "track",
      event: "INITIATE_SWAP",
      properties: {
        network: this.caipNetworkId || "",
        swapFromToken: ((_a2 = this.sourceToken) == null ? void 0 : _a2.symbol) || "",
        swapToToken: ((_b2 = this.toToken) == null ? void 0 : _b2.symbol) || "",
        swapfromAmount: this.sourceTokenAmount || "",
        swapToAmount: this.toTokenAmount || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("SwapPreview");
  }
};
W3mSwapView.styles = styles$H;
__decorate$15([
  r$1()
], W3mSwapView.prototype, "interval", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "detailsOpen", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "caipNetworkId", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "initialized", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "loadingQuote", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "loadingPrices", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "loadingTransaction", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "sourceToken", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "sourceTokenAmount", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "toToken", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "toTokenAmount", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "toTokenPriceInUSD", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "inputError", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "gasPriceInUSD", void 0);
__decorate$15([
  r$1()
], W3mSwapView.prototype, "fetchError", void 0);
W3mSwapView = __decorate$15([
  customElement("w3m-swap-view")
], W3mSwapView);
const styles$G = i$2`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  .preview-container,
  .details-container {
    width: 100%;
  }

  .token-image {
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: 12px;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .token-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    height: 40px;
    border: none;
    border-radius: 80px;
    background: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    cursor: pointer;
    transition: background 0.2s linear;
  }

  .token-item:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .preview-token-details-container {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }

  .action-buttons-container {
    width: 100%;
    gap: var(--wui-spacing-xs);
  }

  .action-buttons-container > button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    height: 48px;
    border-radius: var(--wui-border-radius-xs);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  .action-buttons-container > button:disabled {
    opacity: 0.8;
    cursor: not-allowed;
  }

  .action-button > wui-loading-spinner {
    display: inline-block;
  }

  .cancel-button:hover,
  .action-button:hover {
    cursor: pointer;
  }

  .action-buttons-container > wui-button.cancel-button {
    flex: 2;
  }

  .action-buttons-container > wui-button.action-button {
    flex: 4;
  }

  .action-buttons-container > button.action-button > wui-text {
    color: white;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$14 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSwapPreviewView = class W3mSwapPreviewView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = true;
    this.approvalTransaction = SwapController.state.approvalTransaction;
    this.swapTransaction = SwapController.state.swapTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount ?? "";
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount ?? "";
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingApprovalTransaction = SwapController.state.loadingApprovalTransaction;
    this.loadingBuildTransaction = SwapController.state.loadingBuildTransaction;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("balanceSymbol", (newBalanceSymbol) => {
        if (this.balanceSymbol !== newBalanceSymbol) {
          RouterController.goBack();
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (newCaipNetwork) => {
        if (this.caipNetwork !== newCaipNetwork) {
          this.caipNetwork = newCaipNetwork;
        }
      }),
      SwapController.subscribe((newState) => {
        this.approvalTransaction = newState.approvalTransaction;
        this.swapTransaction = newState.swapTransaction;
        this.sourceToken = newState.sourceToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toToken = newState.toToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.sourceTokenAmount = newState.sourceTokenAmount ?? "";
        this.toTokenAmount = newState.toTokenAmount ?? "";
        this.inputError = newState.inputError;
        if (newState.inputError) {
          RouterController.goBack();
        }
        this.loadingQuote = newState.loadingQuote;
        this.loadingApprovalTransaction = newState.loadingApprovalTransaction;
        this.loadingBuildTransaction = newState.loadingBuildTransaction;
        this.loadingTransaction = newState.loadingTransaction;
      })
    ]);
  }
  firstUpdated() {
    SwapController.getTransaction();
    this.refreshTransaction();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.templateSwap()}
      </wui-flex>
    `;
  }
  refreshTransaction() {
    this.interval = setInterval(() => {
      if (!SwapController.getApprovalLoadingState()) {
        SwapController.getTransaction();
      }
    }, 1e4);
  }
  templateSwap() {
    var _a2, _b2, _c2, _d2;
    const sourceTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.sourceTokenAmount))} ${(_a2 = this.sourceToken) == null ? void 0 : _a2.symbol}`;
    const toTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.toTokenAmount))} ${(_b2 = this.toToken) == null ? void 0 : _b2.symbol}`;
    const sourceTokenValue = parseFloat(this.sourceTokenAmount) * this.sourceTokenPriceInUSD;
    const toTokenValue = parseFloat(this.toTokenAmount) * this.toTokenPriceInUSD - (this.gasPriceInUSD || 0);
    const sentPrice = UiHelperUtil.formatNumberToLocalString(sourceTokenValue);
    const receivePrice = UiHelperUtil.formatNumberToLocalString(toTokenValue);
    const loading = this.loadingQuote || this.loadingBuildTransaction || this.loadingTransaction || this.loadingApprovalTransaction;
    return ke$1`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        <wui-flex class="preview-container" flexDirection="column" alignItems="flex-start" gap="l">
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Send</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${sentPrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${sourceTokenText}
              imageSrc=${(_c2 = this.sourceToken) == null ? void 0 : _c2.logoUri}
            >
            </wui-token-button>
          </wui-flex>
          <wui-icon name="recycleHorizontal" color="fg-200" size="md"></wui-icon>
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Receive</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${receivePrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${toTokenText}
              imageSrc=${(_d2 = this.toToken) == null ? void 0 : _d2.logoUri}
            >
            </wui-token-button>
          </wui-flex>
        </wui-flex>

        ${this.templateDetails()}

        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="xs">
          <wui-icon size="sm" color="fg-200" name="infoCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>

        <wui-flex
          class="action-buttons-container"
          flexDirection="row"
          alignItems="center"
          justifyContent="space-between"
          gap="xs"
        >
          <wui-button
            class="cancel-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="neutral"
            @click=${this.onCancelTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="fg-200">Cancel</wui-text>
          </wui-button>
          <wui-button
            class="action-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="main"
            ?loading=${loading}
            ?disabled=${loading}
            @click=${this.onSendTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="inverse-100">
              ${this.actionButtonLabel()}
            </wui-text>
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return ke$1`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  actionButtonLabel() {
    if (this.loadingApprovalTransaction) {
      return "Approving...";
    }
    if (this.approvalTransaction) {
      return "Approve";
    }
    return "Swap";
  }
  onCancelTransaction() {
    RouterController.goBack();
  }
  onSendTransaction() {
    if (this.approvalTransaction) {
      SwapController.sendTransactionForApproval(this.approvalTransaction);
    } else {
      SwapController.sendTransactionForSwap(this.swapTransaction);
    }
  }
};
W3mSwapPreviewView.styles = styles$G;
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "interval", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "detailsOpen", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "approvalTransaction", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "swapTransaction", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "sourceToken", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenAmount", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "toToken", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenAmount", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenPriceInUSD", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "caipNetwork", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "balanceSymbol", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "inputError", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "loadingQuote", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "loadingApprovalTransaction", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "loadingBuildTransaction", void 0);
__decorate$14([
  r$1()
], W3mSwapPreviewView.prototype, "loadingTransaction", void 0);
W3mSwapPreviewView = __decorate$14([
  customElement("w3m-swap-preview-view")
], W3mSwapPreviewView);
const styles$F = i$2`
  :host {
    --tokens-scroll--top-opacity: 0;
    --tokens-scroll--bottom-opacity: 1;
    --suggested-tokens-scroll--left-opacity: 0;
    --suggested-tokens-scroll--right-opacity: 1;
  }

  :host > wui-flex:first-child {
    overflow-y: hidden;
    overflow-x: hidden;
    scrollbar-width: none;
    scrollbar-height: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .suggested-tokens-container {
    overflow-x: auto;
    mask-image: linear-gradient(
      to right,
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--suggested-tokens-scroll--right-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--right-opacity))) 100%
    );
  }

  .suggested-tokens-container::-webkit-scrollbar {
    display: none;
  }

  .tokens-container {
    border-top: 1px solid var(--wui-color-gray-glass-005);
    height: 100%;
    max-height: 390px;
  }

  .tokens {
    width: 100%;
    overflow-y: auto;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--tokens-scroll--top-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--tokens-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--bottom-opacity))) 100%
    );
  }

  .network-search-input,
  .select-network-button {
    height: 40px;
  }

  .select-network-button {
    border: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: transparent;
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-xs);
    align-items: center;
    transition: background-color 0.2s linear;
  }

  .select-network-button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .select-network-button > wui-image {
    width: 26px;
    height: 26px;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$13 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSwapSelectTokenView = class W3mSwapSelectTokenView2 extends h {
  constructor() {
    var _a2;
    super();
    this.unsubscribe = [];
    this.targetToken = (_a2 = RouterController.state.data) == null ? void 0 : _a2.target;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.toToken = SwapController.state.toToken;
    this.myTokensWithBalance = SwapController.state.myTokensWithBalance;
    this.popularTokens = SwapController.state.popularTokens;
    this.searchValue = "";
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.myTokensWithBalance = newState.myTokensWithBalance;
      })
    ]);
  }
  updated() {
    var _a2, _b2;
    const suggestedTokensContainer = (_a2 = this.renderRoot) == null ? void 0 : _a2.querySelector(".suggested-tokens-container");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.addEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    const tokensList = (_b2 = this.renderRoot) == null ? void 0 : _b2.querySelector(".tokens");
    tokensList == null ? void 0 : tokensList.addEventListener("scroll", this.handleTokenListScroll.bind(this));
  }
  disconnectedCallback() {
    var _a2, _b2;
    super.disconnectedCallback();
    const suggestedTokensContainer = (_a2 = this.renderRoot) == null ? void 0 : _a2.querySelector(".suggested-tokens-container");
    const tokensList = (_b2 = this.renderRoot) == null ? void 0 : _b2.querySelector(".tokens");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.removeEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    tokensList == null ? void 0 : tokensList.removeEventListener("scroll", this.handleTokenListScroll.bind(this));
    clearInterval(this.interval);
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" gap="s">
        ${this.templateSearchInput()} ${this.templateSuggestedTokens()} ${this.templateTokens()}
      </wui-flex>
    `;
  }
  onSelectToken(token2) {
    if (this.targetToken === "sourceToken") {
      SwapController.setSourceToken(token2);
    } else {
      SwapController.setToToken(token2);
      if (this.sourceToken && this.sourceTokenAmount) {
        SwapController.swapTokens();
      }
    }
    RouterController.goBack();
  }
  templateSearchInput() {
    return ke$1`
      <wui-flex .padding=${["3xs", "s", "0", "s"]} gap="xs">
        <wui-input-text
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
          .value=${this.searchValue}
          @inputChange=${this.onSearchInputChange.bind(this)}
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    const yourTokens = this.myTokensWithBalance ? Object.values(this.myTokensWithBalance) : [];
    const tokens = this.popularTokens ? this.popularTokens : [];
    const filteredYourTokens = this.filterTokensWithText(yourTokens, this.searchValue);
    const filteredTokens = this.filterTokensWithText(tokens, this.searchValue);
    return ke$1`
      <wui-flex class="tokens-container">
        <wui-flex class="tokens" .padding=${["0", "s", "s", "s"]} flexDirection="column">
          ${(filteredYourTokens == null ? void 0 : filteredYourTokens.length) > 0 ? ke$1`
                <wui-flex justifyContent="flex-start" padding="s">
                  <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
                </wui-flex>
                ${filteredYourTokens.map((token2) => {
      var _a2, _b2, _c2;
      const selected = token2.symbol === ((_a2 = this.sourceToken) == null ? void 0 : _a2.symbol) || token2.symbol === ((_b2 = this.toToken) == null ? void 0 : _b2.symbol);
      return ke$1`
                    <wui-token-list-item
                      name=${token2.name}
                      ?disabled=${selected}
                      symbol=${token2.symbol}
                      price=${token2 == null ? void 0 : token2.price}
                      amount=${(_c2 = token2 == null ? void 0 : token2.quantity) == null ? void 0 : _c2.numeric}
                      imageSrc=${token2.logoUri}
                      @click=${() => {
        if (!selected) {
          this.onSelectToken(token2);
        }
      }}
                    >
                    </wui-token-list-item>
                  `;
    })}
              ` : null}

          <wui-flex justifyContent="flex-start" padding="s">
            <wui-text variant="paragraph-500" color="fg-200">Tokens</wui-text>
          </wui-flex>
          ${(filteredTokens == null ? void 0 : filteredTokens.length) > 0 ? filteredTokens.map((token2) => ke$1`
                  <wui-token-list-item
                    name=${token2.name}
                    symbol=${token2.symbol}
                    imageSrc=${token2.logoUri}
                    @click=${() => this.onSelectToken(token2)}
                  >
                  </wui-token-list-item>
                `) : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateSuggestedTokens() {
    const tokens = SwapController.state.suggestedTokens ? SwapController.state.suggestedTokens.slice(0, 8) : null;
    if (!tokens) {
      return null;
    }
    return ke$1`
      <wui-flex class="suggested-tokens-container" .padding=${["0", "s", "0", "s"]} gap="xs">
        ${tokens.map((token2) => ke$1`
            <wui-token-button
              text=${token2.symbol}
              imageSrc=${token2.logoUri}
              @click=${() => this.onSelectToken(token2)}
            >
            </wui-token-button>
          `)}
      </wui-flex>
    `;
  }
  onSearchInputChange(event) {
    this.searchValue = event.detail;
  }
  handleSuggestedTokensScroll() {
    var _a2;
    const container = (_a2 = this.renderRoot) == null ? void 0 : _a2.querySelector(".suggested-tokens-container");
    if (!container) {
      return;
    }
    container.style.setProperty("--suggested-tokens-scroll--left-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollLeft).toString());
    container.style.setProperty("--suggested-tokens-scroll--right-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollWidth - container.scrollLeft - container.offsetWidth).toString());
  }
  handleTokenListScroll() {
    var _a2;
    const container = (_a2 = this.renderRoot) == null ? void 0 : _a2.querySelector(".tokens");
    if (!container) {
      return;
    }
    container.style.setProperty("--tokens-scroll--top-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollTop).toString());
    container.style.setProperty("--tokens-scroll--bottom-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollHeight - container.scrollTop - container.offsetHeight).toString());
  }
  filterTokensWithText(tokens, text) {
    return tokens.filter((token2) => `${token2.symbol} ${token2.name} ${token2.address}`.toLowerCase().includes(text.toLowerCase()));
  }
};
W3mSwapSelectTokenView.styles = styles$F;
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "interval", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "targetToken", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceToken", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceTokenAmount", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "toToken", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "myTokensWithBalance", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "popularTokens", void 0);
__decorate$13([
  r$1()
], W3mSwapSelectTokenView.prototype, "searchValue", void 0);
W3mSwapSelectTokenView = __decorate$13([
  customElement("w3m-swap-select-token-view")
], W3mSwapSelectTokenView);
const styles$E = i$2`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$12 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mTransactionsView = class W3mTransactionsView2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" .padding=${["0", "m", "m", "m"]} gap="s">
        <w3m-activity-list page="activity"></w3m-activity-list>
      </wui-flex>
    `;
  }
};
W3mTransactionsView.styles = styles$E;
W3mTransactionsView = __decorate$12([
  customElement("w3m-transactions-view")
], W3mTransactionsView);
var __decorate$11 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const data$1 = [
  {
    images: ["network", "layers", "system"],
    title: "The system’s nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends h {
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="main"
          size="md"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate$11([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);
var __decorate$10 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const data = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends h {
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="main" size="md" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate$10([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);
var __decorate$$ = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWhatIsABuyView = class W3mWhatIsABuyView2 extends h {
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs" alignItems="center">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </wui-text>
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsABuyView = __decorate$$([
  customElement("w3m-what-is-a-buy-view")
], W3mWhatIsABuyView);
const styles$D = i$2`
  wui-loading-spinner {
    margin: 9px auto;
  }
`;
var __decorate$_ = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const OTP_LENGTH = 6;
let W3mEmailOtpWidget = class W3mEmailOtpWidget2 extends h {
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  constructor() {
    var _a2;
    super();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
    this.email = (_a2 = RouterController.state.data) == null ? void 0 : _a2.email;
    this.authConnector = ConnectorController.getAuthConnector();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-otp-widget: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    const footerLabels = this.getFooterLabels(isResendDisabled);
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">Enter the code we sent to</wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? ke$1`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : ke$1` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? ke$1`
                    <wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  ` : null}
            </wui-flex>`}

        <wui-flex alignItems="center" gap="xs">
          <wui-text variant="small-400" color="fg-200">${footerLabels.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    var _a2;
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.authConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await ((_a2 = this.onOtpSubmit) == null ? void 0 : _a2.call(this, this.otp));
        }
      }
    } catch (error) {
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (this.onOtpResend) {
        if (!this.loading && !this.timeoutTimeLeft) {
          this.error = "";
          this.otp = "";
          const authConnector = ConnectorController.getAuthConnector();
          if (!authConnector || !this.email) {
            throw new Error("w3m-email-otp-widget: Unable to resend email");
          }
          this.loading = true;
          await this.onOtpResend(this.email);
          this.startOTPTimeout();
          SnackController.showSuccess("Code email resent");
        }
      } else if (this.onStartOver) {
        this.onStartOver();
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
  getFooterLabels(isResendDisabled) {
    if (this.onStartOver) {
      return {
        title: "Something wrong?",
        action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ""}`
      };
    }
    return {
      title: `Didn't receive it?`,
      action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}`
    };
  }
};
W3mEmailOtpWidget.styles = styles$D;
__decorate$_([
  r$1()
], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate$_([
  r$1()
], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate$_([
  r$1()
], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate$_([
  customElement("w3m-email-otp-widget")
], W3mEmailOtpWidget);
var __decorate$Z = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super();
    this.unsubscribe = [];
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
          await this.authConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          await ConnectionController.connectExternal(this.authConnector);
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email", name: this.authConnector.name || "Unknown" }
          });
          if (smartAccountEnabled && !this.smartAccountDeployed) {
            RouterController.push("UpgradeToSmartAccount");
          } else {
            ModalController.close();
          }
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onOtpResend = async (email) => {
      if (this.authConnector) {
        await this.authConnector.provider.connectEmail({ email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      }
    };
    this.unsubscribe.push(AccountController.subscribeKey("smartAccountDeployed", (val) => {
      this.smartAccountDeployed = val;
    }));
  }
};
__decorate$Z([
  r$1()
], W3mEmailVerifyOtpView.prototype, "smartAccountDeployed", void 0);
W3mEmailVerifyOtpView = __decorate$Z([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);
const styles$C = i$2`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$Y = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends h {
  constructor() {
    var _a2;
    super();
    this.email = (_a2 = RouterController.state.data) == null ? void 0 : _a2.email;
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.authConnector) {
      throw new Error("w3m-email-verify-device-view: No auth connector provided");
    }
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section" gap="xs">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.authConnector) {
      try {
        await this.authConnector.provider.connectDevice();
        EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.replace("EmailVerifyOtp", { email: this.email });
      } catch (error) {
        RouterController.goBack();
      }
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.authConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.authConnector.provider.connectEmail({ email: this.email });
        this.listenForDeviceApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles$C;
__decorate$Y([
  r$1()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$Y([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);
const styles$B = i$2`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$X = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const PAGE_HEIGHT = 400;
const PAGE_WIDTH = 360;
const HEADER_HEIGHT = 64;
let W3mApproveTransactionView = class W3mApproveTransactionView2 extends h {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          this.onHideIframe();
          RouterController.popTransactionStack();
        }
      })
    ]);
  }
  disconnectedCallback() {
    var _a2;
    this.onHideIframe();
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a2 = this.bodyObserver) == null ? void 0 : _a2.unobserve(window.document.body);
  }
  async firstUpdated() {
    await this.syncTheme();
    this.iframe.style.display = "block";
    this.bodyObserver = new ResizeObserver((entries2) => {
      var _a2, _b2;
      const contentBoxSize = (_a2 = entries2 == null ? void 0 : entries2[0]) == null ? void 0 : _a2.contentBoxSize;
      const width2 = (_b2 = contentBoxSize == null ? void 0 : contentBoxSize[0]) == null ? void 0 : _b2.inlineSize;
      this.iframe.style.height = `${PAGE_HEIGHT}px`;
      if (width2 && width2 <= 430) {
        this.iframe.style.width = "100%";
        this.iframe.style.left = "0px";
        this.iframe.style.bottom = "0px";
        this.iframe.style.top = "unset";
      } else {
        this.iframe.style.width = `${PAGE_WIDTH}px`;
        this.iframe.style.left = `calc(50% - ${PAGE_WIDTH / 2}px)`;
        this.iframe.style.top = `calc(50% - ${PAGE_HEIGHT / 2}px + ${HEADER_HEIGHT / 2}px)`;
        this.iframe.style.bottom = "unset";
      }
      this.ready = true;
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    if (this.ready) {
      this.onShowIframe();
    }
    return ke$1`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.animate([
      { opacity: 0, transform: isMobile ? "translateY(50px)" : "scale(.95)" },
      { opacity: 1, transform: isMobile ? "translateY(0)" : "scale(1)" }
    ], { duration: 200, easing: "ease", fill: "forwards" });
  }
  async onHideIframe() {
    this.iframe.style.display = "none";
    await this.iframe.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
  }
  async syncTheme() {
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector) {
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      await authConnector.provider.syncTheme({
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  }
};
W3mApproveTransactionView.styles = styles$B;
__decorate$X([
  r$1()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$X([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);
var __decorate$W = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$2.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$2.SECURE_SITE_FAVICON}
          data-testid="w3m-secure-website-button"
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate$W([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);
var __decorate$V = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUpgradeToSmartAccountView = class W3mUpgradeToSmartAccountView2 extends h {
  constructor() {
    super(...arguments);
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.setPreferSmartAccount = async () => {
      if (this.authConnector) {
        try {
          this.loading = true;
          await ConnectionController.setPreferredAccountType(W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT);
          this.loading = false;
          RouterUtil.navigateAfterPreferredAccountTypeSelect();
        } catch (e2) {
          SnackController.showError("Error upgrading to smart account");
        }
      }
    };
  }
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return ke$1` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-visual name="google"></wui-visual>
        <wui-visual name="pencil"></wui-visual>
        <wui-visual name="lightbulb"></wui-visual>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Discover Smart Accounts
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Access advanced features such as username, social login, improved security and a smoother
          user experience!
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return ke$1`<wui-flex .padding=${["0", "2l", "0", "2l"]} gap="s">
      <wui-button
        variant="accent"
        @click=${this.redirectToAccount.bind(this)}
        size="lg"
        borderRadius="xs"
      >
        Do it later
      </wui-button>
      <wui-button
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.setPreferSmartAccount.bind(this)}
        >Continue
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.push("Account");
  }
};
__decorate$V([
  r$1()
], W3mUpgradeToSmartAccountView.prototype, "authConnector", void 0);
__decorate$V([
  r$1()
], W3mUpgradeToSmartAccountView.prototype, "loading", void 0);
W3mUpgradeToSmartAccountView = __decorate$V([
  customElement("w3m-upgrade-to-smart-account-view")
], W3mUpgradeToSmartAccountView);
const styles$A = i$2`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$U = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends h {
  constructor() {
    var _a2;
    super(...arguments);
    this.formRef = ii();
    this.initialEmail = ((_a2 = RouterController.state.data) == null ? void 0 : _a2.email) ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    var _a2;
    (_a2 = this.formRef.value) == null ? void 0 : _a2.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
    return ke$1`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${Kt$1(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="neutral" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="main"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-update-email-wallet: Auth connector not found");
      }
      const response = await authConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      if (response.action === "VERIFY_SECONDARY_OTP") {
        RouterController.push("UpdateEmailSecondaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      } else {
        RouterController.push("UpdateEmailPrimaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      }
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles$A;
__decorate$U([
  r$1()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$U([
  r$1()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$U([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);
var __decorate$T = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a2;
    super();
    this.email = (_a2 = RouterController.state.data) == null ? void 0 : _a2.email;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailPrimaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data);
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailPrimaryOtpView = __decorate$T([
  customElement("w3m-update-email-primary-otp-view")
], W3mUpdateEmailPrimaryOtpView);
var __decorate$S = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a2;
    super();
    this.email = (_a2 = RouterController.state.data) == null ? void 0 : _a2.newEmail;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailSecondaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.reset("Account");
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailSecondaryOtpView = __decorate$S([
  customElement("w3m-update-email-secondary-otp-view")
], W3mUpdateEmailSecondaryOtpView);
const styles$z = i$2`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$R = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mUnsupportedChainView = class W3mUnsupportedChainView2 extends h {
  constructor() {
    var _a2;
    super(...arguments);
    this.swapUnsupportedChain = (_a2 = RouterController.state.data) == null ? void 0 : _a2.swapUnsupportedChain;
    this.disconecting = false;
  }
  render() {
    return ke$1`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          ${this.descriptionTemplate()}
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  descriptionTemplate() {
    if (this.swapUnsupportedChain) {
      return ke$1`
        <wui-text variant="small-400" color="fg-200" align="center">
          The swap feature doesn’t support your current network. Switch to an available option to
          continue.
        </wui-text>
      `;
    }
    return ke$1`
      <wui-text variant="small-400" color="fg-200" align="center">
        This app doesn’t support your current network. Switch to an available option to continue.
      </wui-text>
    `;
  }
  networksTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks } = NetworkController.state;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = this.swapUnsupportedChain ? sortedNetworks.filter((network) => ConstantsUtil$2.SWAP_SUPPORTED_NETWORKS.includes(network.id)) : sortedNetworks;
    return filteredNetworks.map((network) => ke$1`
        <wui-list-network
          imageSrc=${to(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </wui-list-network>
      `);
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  async onSwitchNetwork(network) {
    const { isConnected } = AccountController.state;
    const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
    const { data: data2 } = RouterController.state;
    if (isConnected && (caipNetwork == null ? void 0 : caipNetwork.id) !== network.id) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        RouterUtil.navigateAfterNetworkSwitch();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...data2, network });
      }
    } else if (!isConnected) {
      NetworkController.setCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mUnsupportedChainView.styles = styles$z;
__decorate$R([
  r$1()
], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate$R([
  customElement("w3m-unsupported-chain-view")
], W3mUnsupportedChainView);
const styles$y = i$2`
  wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;
var __decorate$Q = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletReceiveView = class W3mWalletReceiveView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileName = AccountController.state.profileName;
    this.network = NetworkController.state.caipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          SnackController.showError("Account not found");
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-wallet-receive-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return ke$1` <wui-flex
      flexDirection="column"
      .padding=${["0", "l", "l", "l"]}
      alignItems="center"
    >
      <wui-chip-button
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        icon="copy"
        size="sm"
        imageSrc=${networkImage ? networkImage : ""}
        variant="gray"
      ></wui-chip-button>
      <wui-flex
        flexDirection="column"
        .padding=${["l", "0", "0", "0"]}
        alignItems="center"
        gap="s"
      >
        <wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          data-testid="wui-qr-code"
        ></wui-qr-code>
        <wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </wui-text>
      </wui-flex>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    var _a2;
    const networks = NetworkController.getRequestedCaipNetworks();
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    const caipNetwork = NetworkController.state.caipNetwork;
    if (this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && isNetworkEnabledForSmartAccounts) {
      if (!caipNetwork) {
        return null;
      }
      return ke$1`<wui-compatible-network
        @click=${this.onReceiveClick.bind(this)}
        text="Only receive assets on this network"
        .networkImages=${[AssetUtil.getNetworkImage(caipNetwork) ?? ""]}
      ></wui-compatible-network>`;
    }
    const slicedNetworks = (_a2 = networks == null ? void 0 : networks.filter((network) => network == null ? void 0 : network.imageId)) == null ? void 0 : _a2.slice(0, 5);
    const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
    return ke$1`<wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></wui-compatible-network>`;
  }
  onReceiveClick() {
    RouterController.push("WalletCompatibleNetworks");
  }
  onCopyClick() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mWalletReceiveView.styles = styles$y;
__decorate$Q([
  r$1()
], W3mWalletReceiveView.prototype, "address", void 0);
__decorate$Q([
  r$1()
], W3mWalletReceiveView.prototype, "profileName", void 0);
__decorate$Q([
  r$1()
], W3mWalletReceiveView.prototype, "network", void 0);
__decorate$Q([
  r$1()
], W3mWalletReceiveView.prototype, "preferredAccountType", void 0);
W3mWalletReceiveView = __decorate$Q([
  customElement("w3m-wallet-receive-view")
], W3mWalletReceiveView);
const styles$x = i$2`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$P = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(AccountController.subscribeKey("preferredAccountType", (val) => {
      this.preferredAccountType = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1` <wui-flex
      flexDirection="column"
      .padding=${["xs", "s", "m", "s"]}
      gap="xs"
    >
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks, caipNetwork } = NetworkController.state;
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    let sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (isNetworkEnabledForSmartAccounts && this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      if (!caipNetwork) {
        return null;
      }
      sortedNetworks = [caipNetwork];
    }
    return sortedNetworks.map((network) => ke$1`
        <wui-list-network
          imageSrc=${to(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          ?transparent=${true}
        >
        </wui-list-network>
      `);
  }
};
W3mWalletCompatibleNetworksView.styles = styles$x;
__decorate$P([
  r$1()
], W3mWalletCompatibleNetworksView.prototype, "preferredAccountType", void 0);
W3mWalletCompatibleNetworksView = __decorate$P([
  customElement("w3m-wallet-compatible-networks-view")
], W3mWalletCompatibleNetworksView);
const styles$w = i$2`
  :host {
    display: block;
  }

  wui-flex {
    position: relative;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1;
  }

  wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;
var __decorate$O = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletSendView = class W3mWalletSendView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.loading = SendController.state.loading;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.message = "Preview Send";
    this.fetchNetworkPrice();
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.loading = val.loading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.getMessage();
    return ke$1` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
          .gasPriceInUSD=${this.gasPriceInUSD}
        ></w3m-input-token>
        <wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></wui-icon-box>
        <w3m-input-address
          .value=${this.receiverProfileName ? this.receiverProfileName : this.receiverAddress}
        ></w3m-input-address>
      </wui-flex>
      <wui-flex .margin=${["l", "0", "0", "0"]}>
        <wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith("Preview Send")}
          size="lg"
          variant="main"
          ?loading=${this.loading}
          fullWidth
        >
          ${this.message}
        </wui-button>
      </wui-flex>
    </wui-flex>`;
  }
  async fetchNetworkPrice() {
    await SwapController.getNetworkTokenPrice();
    const gas = await SwapController.getInitialGasPrice();
    if ((gas == null ? void 0 : gas.gasPrice) && (gas == null ? void 0 : gas.gasPriceInUSD)) {
      SendController.setGasPrice(gas.gasPrice);
      SendController.setGasPriceInUsd(gas.gasPriceInUSD);
    }
  }
  onButtonClick() {
    RouterController.push("WalletSendPreview");
  }
  getMessage() {
    var _a2;
    this.message = "Preview Send";
    if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress)) {
      this.message = "Invalid Address";
    }
    if (!this.receiverAddress) {
      this.message = "Add Address";
    }
    if (this.sendTokenAmount && this.token && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
      this.message = "Insufficient Funds";
    }
    if (!this.sendTokenAmount) {
      this.message = "Add Amount";
    }
    if (this.sendTokenAmount && ((_a2 = this.token) == null ? void 0 : _a2.price)) {
      const value2 = this.sendTokenAmount * this.token.price;
      if (!value2) {
        this.message = "Incorrect Value";
      }
    }
    if (!this.token) {
      this.message = "Select Token";
    }
  }
};
W3mWalletSendView.styles = styles$w;
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "token", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "receiverAddress", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "receiverProfileName", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "loading", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "gasPriceInUSD", void 0);
__decorate$O([
  r$1()
], W3mWalletSendView.prototype, "message", void 0);
W3mWalletSendView = __decorate$O([
  customElement("w3m-wallet-send-view")
], W3mWalletSendView);
const styles$v = i$2`
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;
var __decorate$N = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSendSelectTokenView = class W3mSendSelectTokenView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value2) => {
      this.search = value2;
    });
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column">
        ${this.templateSearchInput()} <wui-separator></wui-separator> ${this.templateTokens()}
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return ke$1`
      <wui-flex gap="xs" padding="s">
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    var _a2, _b2;
    this.tokens = (_a2 = this.tokenBalance) == null ? void 0 : _a2.filter((token2) => {
      var _a3;
      return token2.chainId === ((_a3 = NetworkController.state.caipNetwork) == null ? void 0 : _a3.id);
    });
    if (this.search) {
      this.filteredTokens = (_b2 = this.tokenBalance) == null ? void 0 : _b2.filter((token2) => token2.name.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredTokens = this.tokens;
    }
    return ke$1`
      <wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${["0", "s", "0", "s"]}
      >
        <wui-flex justifyContent="flex-start" .padding=${["m", "s", "s", "s"]}>
          <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.filteredTokens && this.filteredTokens.length > 0 ? this.filteredTokens.map((token2) => ke$1`<wui-list-token
                    @click=${this.handleTokenClick.bind(this, token2)}
                    ?clickable=${true}
                    tokenName=${token2.name}
                    tokenImageUrl=${token2.iconUrl}
                    tokenAmount=${token2.quantity.numeric}
                    tokenValue=${token2.value}
                    tokenCurrency=${token2.symbol}
                  ></wui-list-token>`) : ke$1`<wui-flex
                .padding=${["4xl", "0", "0", "0"]}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></wui-icon-box>
                <wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </wui-flex>
                <wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>
              </wui-flex>`}
        </wui-flex>
      </wui-flex>
    `;
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  handleTokenClick(token2) {
    SendController.setToken(token2);
    SendController.setTokenAmount(void 0);
    RouterController.goBack();
  }
};
W3mSendSelectTokenView.styles = styles$v;
__decorate$N([
  r$1()
], W3mSendSelectTokenView.prototype, "tokenBalance", void 0);
__decorate$N([
  r$1()
], W3mSendSelectTokenView.prototype, "tokens", void 0);
__decorate$N([
  r$1()
], W3mSendSelectTokenView.prototype, "filteredTokens", void 0);
__decorate$N([
  r$1()
], W3mSendSelectTokenView.prototype, "search", void 0);
W3mSendSelectTokenView = __decorate$N([
  customElement("w3m-wallet-send-select-token-view")
], W3mSendSelectTokenView);
const styles$u = i$2`
  wui-avatar,
  wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;
var __decorate$M = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletSendPreviewView = class W3mWalletSendPreviewView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.receiverProfileImageUrl = SendController.state.receiverProfileImageUrl;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.receiverProfileImageUrl = val.receiverProfileImageUrl;
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2, _b2;
    return ke$1` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex gap="xs" flexDirection="column" .padding=${["0", "xs", "0", "xs"]}>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-flex flexDirection="column" gap="4xs">
            <wui-text variant="small-400" color="fg-150">Send</wui-text>
            ${this.sendValueTemplate()}
          </wui-flex>
          <wui-preview-item
            text="${this.sendTokenAmount ? UiHelperUtil.roundNumber(this.sendTokenAmount, 6, 5) : "unknown"} ${(_a2 = this.token) == null ? void 0 : _a2.symbol}"
            .imageSrc=${(_b2 = this.token) == null ? void 0 : _b2.iconUrl}
          ></wui-preview-item>
        </wui-flex>
        <wui-flex>
          <wui-icon color="fg-200" size="md" name="arrowBottom"></wui-icon>
        </wui-flex>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-text variant="small-400" color="fg-150">To</wui-text>
          <wui-preview-item
            text="${this.receiverProfileName ? UiHelperUtil.getTruncateString({
      string: this.receiverProfileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.receiverAddress ? this.receiverAddress : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}"
            address=${this.receiverAddress ?? ""}
            .imageSrc=${this.receiverProfileImageUrl ?? void 0}
            .isAddress=${true}
          ></wui-preview-item>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" .padding=${["xxl", "0", "0", "0"]}>
        <w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
          .networkFee=${this.gasPriceInUSD}
        ></w3m-wallet-send-details>
        <wui-flex justifyContent="center" gap="xxs" .padding=${["s", "0", "0", "0"]}>
          <wui-icon size="sm" color="fg-200" name="warningCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>
        <wui-flex justifyContent="center" gap="s" .padding=${["l", "0", "0", "0"]}>
          <wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="neutral"
          >
            Cancel
          </wui-button>
          <wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="main"
          >
            Send
          </wui-button>
        </wui-flex>
      </wui-flex></wui-flex
    >`;
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return ke$1`<wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
    }
    return null;
  }
  onSendClick() {
    SendController.sendToken();
  }
  onCancelClick() {
    RouterController.goBack();
  }
};
W3mWalletSendPreviewView.styles = styles$u;
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "token", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileName", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileImageUrl", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$M([
  r$1()
], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
W3mWalletSendPreviewView = __decorate$M([
  customElement("w3m-wallet-send-preview-view")
], W3mWalletSendPreviewView);
const styles$t = i$2`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$L = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectWalletsView = class W3mConnectWalletsView2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-wallet-login-list></w3m-wallet-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectWalletsView.styles = styles$t;
W3mConnectWalletsView = __decorate$L([
  customElement("w3m-connect-wallets-view")
], W3mConnectWalletsView);
const styles$s = i$2`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$K = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectSocialsView = class W3mConnectSocialsView2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-social-login-list></w3m-social-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectSocialsView.styles = styles$s;
W3mConnectSocialsView = __decorate$K([
  customElement("w3m-connect-socials-view")
], W3mConnectSocialsView);
const styles$r = i$2`
  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }
  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }
  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }
  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }
  .capitalize {
    text-transform: capitalize;
  }
`;
var define_process_env_default = { GITHUB_STATE: "/home/runner/work/_temp/_runner_file_commands/save_state_f718650a-ff98-4302-80d8-5fcdb4473af9", DEPLOYMENT_BASEPATH: "/opt/runner", DOTNET_NOLOGO: "1", STATS_TRP: "true", USER: "runner", npm_config_user_agent: "pnpm/8.15.7 npm/? node/v18.20.4 linux x64", CI: "true", VITE_APP_WC_PROJECT_ID: "e64002d84b020b9ae5eda323dd191093", npm_package_scripts_fuels_build: "fuels build", GITHUB_ENV: "/home/runner/work/_temp/_runner_file_commands/set_env_f718650a-ff98-4302-80d8-5fcdb4473af9", PIPX_HOME: "/opt/pipx", RUNNER_ENVIRONMENT: "github-hosted", npm_package_dependencies__fuels_connectors: "0.25.0", npm_package_devDependencies_vite: "^5.3.4", npm_node_execpath: "/usr/local/bin/node", JAVA_HOME_8_X64: "/usr/lib/jvm/temurin-8-jdk-amd64", SHLVL: "1", npm_package_scripts_fuels_typegen: "fuels typegen -i ./sway-programs/contract/out/debug/test-contract-abi.json -o ./src/sway-api/contracts", HOME: "/home/runner", VITE_PUBLIC_TESTNET_COUNTER_CONTRACT_ID: "0xd9377acd88d5ea4c498770b5210dad7ea87992652e2867d2713efc542caebb22", npm_package_devDependencies__typescript_eslint_parser: "^7.15.0", GITHUB_EVENT_PATH: "/home/runner/work/_temp/_github_workflow/event.json", RUNNER_TEMP: "/home/runner/work/_temp", npm_package_scripts_build_all: "NODE_ENV=production run-s build", npm_package_devDependencies_vite_plugin_static_copy: "^1.0.1", GITHUB_REPOSITORY_OWNER: "FuelLabs", JAVA_HOME_11_X64: "/usr/lib/jvm/temurin-11-jdk-amd64", PIPX_BIN_DIR: "/opt/pipx_bin", npm_config_auto_install_peers: "true", ANDROID_NDK_LATEST_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_RETENTION_DAYS: "90", GRADLE_HOME: "/usr/share/gradle-8.10", JAVA_HOME_21_X64: "/usr/lib/jvm/temurin-21-jdk-amd64", STATS_RDCL: "true", AZURE_EXTENSION_DIR: "/opt/az/azcliextensions", GITHUB_HEAD_REF: "rishabh/counter", GITHUB_REPOSITORY_OWNER_ID: "55993183", POWERSHELL_DISTRIBUTION_CHANNEL: "GitHub-Actions-ubuntu22", NFT_DIST: "/home/runner/work/sway-examples/sway-examples/dist/nft/", SYSTEMD_EXEC_PID: "471", npm_package_scripts_fuels_run: "run-s fuels:build fuels:typegen fuels:deploy", npm_package_scripts_fuels_deploy: "fuels deploy", npm_package_dependencies_dotenv: "^16.4.5", npm_package_devDependencies_eslint_plugin_react_hooks: "^4.6.2", GITHUB_GRAPHQL_URL: "https://api.github.com/graphql", NFT_BASE_URL: "/nft/", npm_package_dependencies_react_router_dom: "^6.25.1", npm_package_devDependencies_tailwindcss: "^3.4.6", npm_package_devDependencies_typescript: "^5.2.2", GOROOT_1_20_X64: "/opt/hostedtoolcache/go/1.20.14/x64", NVM_DIR: "/home/runner/.nvm", npm_package_devDependencies__types_react_dom: "^18.3.0", DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "1", GOROOT_1_21_X64: "/opt/hostedtoolcache/go/1.21.13/x64", ImageVersion: "20240901.1.0", JAVA_HOME_17_X64: "/usr/lib/jvm/temurin-17-jdk-amd64", npm_package_scripts_fuels_node: "fuels node", npm_package_scripts_dev: "vite", GITHUB_API_URL: "https://api.github.com", GOROOT_1_22_X64: "/opt/hostedtoolcache/go/1.22.6/x64", RUNNER_OS: "Linux", SWIFT_PATH: "/usr/share/swift/usr/bin", npm_package_type: "module", npm_package_dependencies_fuels: "0.93.0", npm_package_devDependencies__vitejs_plugin_react: "^4.3.1", CHROMEWEBDRIVER: "/usr/local/share/chromedriver-linux64", GITHUB_WORKFLOW: "Deploy PR preview", JOURNAL_STREAM: "8:18384", RUNNER_USER: "runner", STATS_V3PS: "true", _: "/home/runner/setup-pnpm/node_modules/.bin/pnpm", npm_package_private: "true", npm_package_dependencies__emotion_react: "^11.11.4", npm_package_devDependencies_autoprefixer: "^10.4.19", VITE_PUBLIC_DAPP_ENVIRONMENT: "testnet", npm_package_scripts_lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0", npm_package_devDependencies__typescript_eslint_eslint_plugin: "^7.15.0", npm_config_registry: "https://registry.npmjs.org/", ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE: "/opt/actionarchivecache", GITHUB_RUN_ID: "10743692800", STATS_D: "false", STATS_VMFE: "true", BOOTSTRAP_HASKELL_NONINTERACTIVE: "1", GITHUB_BASE_REF: "master", GITHUB_REF_TYPE: "branch", GITHUB_WORKFLOW_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", ImageOS: "ubuntu22", npm_package_devDependencies_eslint_plugin_react_refresh: "^0.4.7", GITHUB_ACTION_REPOSITORY: "", GITHUB_WORKFLOW_REF: "FuelLabs/sway-examples/.github/workflows/preview.yml@refs/pull/4/merge", PERFLOG_LOCATION_SETTING: "RUNNER_PERFLOG", npm_config_node_gyp: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node_modules/node-gyp/bin/node-gyp.js", PATH: "/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/counter/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/dist/node-gyp-bin:/home/runner/work/sway-examples/sway-examples/node_modules/.bin:/home/runner/setup-pnpm/node_modules/.bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin", ANT_HOME: "/usr/share/ant", DOTNET_MULTILEVEL_LOOKUP: "0", INVOCATION_ID: "3b7e075b7e964240a53b54fd8e14c923", NODE: "/usr/local/bin/node", RUNNER_TOOL_CACHE: "/opt/hostedtoolcache", RUNNER_TRACKING_ID: "github_f78c3bd0-5916-4b6d-b102-cb79e51f2dec", TURBO_HASH: "aa8c12d69faaf243", npm_package_name: "counter-dapp", npm_package_dependencies__mui_material: "^5.16.5", AGENT_TOOLSDIRECTORY: "/opt/hostedtoolcache", GITHUB_ACTION: "__run", GITHUB_RUN_NUMBER: "76", GITHUB_TRIGGERING_ACTOR: "rishabhkeshan", RUNNER_ARCH: "X64", XDG_RUNTIME_DIR: "/run/user/1001", npm_package_dependencies_react_hot_toast: "^2.4.1", npm_config_frozen_lockfile: "", LANG: "C.UTF-8", VCPKG_INSTALLATION_ROOT: "/usr/local/share/vcpkg", npm_package_dependencies_react_dom: "^18.3.1", npm_package_devDependencies_eslint: "^8.57.0", CONDA: "/usr/share/miniconda", GITHUB_REF_NAME: "4/merge", GITHUB_REPOSITORY: "FuelLabs/sway-examples", RUNNER_NAME: "GitHub Actions 22", STATS_D_D: "false", STATS_VMD: "true", VITE_BASE_URL: "/sway-examples/pr-preview/pr-4", XDG_CONFIG_HOME: "/home/runner/.config", npm_lifecycle_script: "pnpm run fuels:build && tsc -b && vite build", ANDROID_NDK_ROOT: "/usr/local/lib/android/sdk/ndk/27.0.12077973", DEBIAN_FRONTEND: "noninteractive", GITHUB_ACTION_REF: "", STATS_UE: "true", GITHUB_ACTIONS: "true", GITHUB_REPOSITORY_ID: "820020030", NODE_PATH: "/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules/vite/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/vite@5.4.3_@types+node@20.16.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/run-s/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules/npm-run-all/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/npm-run-all@4.1.5/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/bin/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules/turbo/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/turbo@1.13.4/node_modules:/home/runner/work/sway-examples/sway-examples/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules:/home/runner/setup-pnpm/node_modules/.pnpm/node_modules", npm_package_version: "0.0.0", npm_package_devDependencies__types_react: "^18.3.3", npm_lifecycle_event: "build", GITHUB_REF_PROTECTED: "false", npm_package_scripts_fuels_dev: "fuels dev", npm_package_scripts_build: "pnpm run fuels:build && tsc -b && vite build", npm_package_dependencies_app_commons: "workspace:*", ACCEPT_EULA: "Y", GITHUB_JOB: "deploy-preview", GITHUB_WORKSPACE: "/home/runner/work/sway-examples/sway-examples", RUNNER_PERFLOG: "/home/runner/perflog", TURBO_INVOCATION_DIR: "/home/runner/work/sway-examples/sway-examples", npm_config_node_version: "20.11.0", COUNTER_DIST: "/home/runner/work/sway-examples/sway-examples/dist/counter/", GITHUB_RUN_ATTEMPT: "1", GITHUB_SHA: "bec416ae783a85a15e6fc3709702a9eddeebf8aa", npm_package_dependencies__fuels_react: "^0.25.0", npm_package_dependencies__tanstack_react_query: "^5.29.2", ANDROID_SDK_ROOT: "/usr/local/lib/android/sdk", COUNTER_BASE_URL: "/counter/", GITHUB_ACTOR: "rishabhkeshan", GITHUB_REF: "refs/pull/4/merge", npm_config_save_exact: "true", LEIN_HOME: "/usr/local/lib/lein", npm_package_dependencies__mui_icons_material: "^5.16.5", GITHUB_ACTOR_ID: "58903797", GITHUB_PATH: "/home/runner/work/_temp/_runner_file_commands/add_path_f718650a-ff98-4302-80d8-5fcdb4473af9", JAVA_HOME: "/usr/lib/jvm/temurin-11-jdk-amd64", PWD: "/home/runner/work/sway-examples/sway-examples/counter", RUNNER_WORKSPACE: "/home/runner/work/sway-examples", VITE_PINATA_JWT: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJkODEwNDc5Zi1lYjk5LTQyNmMtOGMzMy02ZmU1Yjk1ZTVjYTIiLCJlbWFpbCI6Im1kYXVlcjMzM0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJpZCI6IkZSQTEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX0seyJpZCI6Ik5ZQzEiLCJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MX1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNjY0NzllYmFiMDFlOTEwMWJhYmUiLCJzY29wZWRLZXlTZWNyZXQiOiJmMDhiODk1NjVmNDQ0NjE5ZWZiMmM1NGNjOTEwN2E1ZWQ5NTI5OTgwYmZiMTAzOGYwZjc1NGVjNTkxNTE3OGY1IiwiaWF0IjoxNzE3MDE0NzQ1fQ.GvOu2LjeyyP4zE9_d9v8XUNV_Wgh595QTEy2kZa6Psk", npm_package_dependencies__emotion_styled: "^11.11.0", npm_package_dependencies__wagmi_connectors: "5.0.26", npm_package_dependencies_vite_plugin_vercel: "^8.0.0", npm_execpath: "/home/runner/setup-pnpm/node_modules/.pnpm/pnpm@8.15.7/node_modules/pnpm/bin/pnpm.cjs", ANDROID_HOME: "/usr/local/lib/android/sdk", GECKOWEBDRIVER: "/usr/local/share/gecko_driver", GHCUP_INSTALL_BASE_PREFIX: "/usr/local", GITHUB_EVENT_NAME: "pull_request", GITHUB_OUTPUT: "/home/runner/work/_temp/_runner_file_commands/set_output_f718650a-ff98-4302-80d8-5fcdb4473af9", GITHUB_SERVER_URL: "https://github.com", HOMEBREW_CLEANUP_PERIODIC_FULL_DAYS: "3650", HOMEBREW_NO_AUTO_UPDATE: "1", LEIN_JAR: "/usr/local/lib/lein/self-installs/leiningen-2.11.2-standalone.jar", STATS_TIS: "mining", VITE_PUBLIC_GATEWAY_URL: "https://fuchsia-bizarre-butterfly-560.mypinata.cloud", EDGEWEBDRIVER: "/usr/local/share/edge_driver", PNPM_SCRIPT_SRC_DIR: "/home/runner/work/sway-examples/sway-examples/counter", STATS_EXT: "true", npm_package_dependencies__wagmi_core: "2.12.2", npm_package_devDependencies_postcss: "^8.4.39", npm_command: "run-script", ANDROID_NDK: "/usr/local/lib/android/sdk/ndk/27.0.12077973", CHROME_BIN: "/usr/bin/google-chrome", SGX_AESM_ADDR: "1", npm_package_scripts_preview: "vite preview", PNPM_HOME: "/home/runner/setup-pnpm/node_modules/.bin", SELENIUM_JAR_PATH: "/usr/share/java/selenium-server.jar", STATS_EXTP: "https://provjobdsettingscdn.blob.core.windows.net/settings/provjobdsettings-0.5.181+6/provjobd.data", NODE_ENV: "production", npm_package_dependencies_react_use: "^17.5.0", npm_package_devDependencies_npm_run_all: "^4.1.5", ANDROID_NDK_HOME: "/usr/local/lib/android/sdk/ndk/27.0.12077973", GITHUB_STEP_SUMMARY: "/home/runner/work/_temp/_runner_file_commands/step_summary_f718650a-ff98-4302-80d8-5fcdb4473af9", INIT_CWD: "/home/runner/work/sway-examples/sway-examples/counter", npm_package_dependencies_react: "^18.3.1" };
const ConstantsUtil = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: define_process_env_default["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] || "https://secure.walletconnect.com"
};
var __decorate$J = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingSocialView = class W3mConnectingSocialView2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = AccountController.state.socialProvider;
    this.socialWindow = AccountController.state.socialWindow;
    this.error = false;
    this.connecting = false;
    this.message = "Connect in the provider window";
    this.authConnector = ConnectorController.getAuthConnector();
    this.handleSocialConnection = async (event) => {
      var _a2;
      if ((_a2 = event.data) == null ? void 0 : _a2.resultUri) {
        if (event.origin === ConstantsUtil.SECURE_SITE_ORIGIN) {
          window.removeEventListener("message", this.handleSocialConnection, false);
          try {
            if (this.authConnector && !this.connecting) {
              if (this.socialWindow) {
                this.socialWindow.close();
                AccountController.setSocialWindow(void 0);
              }
              this.connecting = true;
              this.updateMessage();
              const uri = event.data.resultUri;
              await this.authConnector.provider.connectSocial(uri);
              if (this.socialProvider) {
                StorageUtil.setConnectedSocialProvider(this.socialProvider);
                await ConnectionController.connectExternal(this.authConnector);
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_SUCCESS",
                  properties: { provider: this.socialProvider }
                });
              }
            }
          } catch (error) {
            this.error = true;
            this.updateMessage();
            if (this.socialProvider) {
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: this.socialProvider }
              });
            }
          }
        } else {
          RouterController.goBack();
          SnackController.showError("Untrusted Origin");
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: this.socialProvider }
            });
          }
        }
      }
    };
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.socialProvider) {
          this.socialProvider = val.socialProvider;
        }
        if (val.socialWindow) {
          this.socialWindow = val.socialWindow;
        }
        if (val.address) {
          if (ModalController.state.open) {
            ModalController.close();
          }
        }
      })
    ]);
    if (this.authConnector) {
      this.connectSocial();
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    window.removeEventListener("message", this.handleSocialConnection, false);
  }
  render() {
    return ke$1`
      <wui-flex
        data-error=${to(this.error)}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo=${to(this.socialProvider)}></wui-logo>
          ${this.error ? null : this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >Log in with
            <span class="capitalize">${this.socialProvider ?? "Social"}</span></wui-text
          >
          <wui-text align="center" variant="small-400" color=${this.error ? "error-100" : "fg-200"}
            >${this.message}</wui-text
          ></wui-flex
        >
      </wui-flex>
    `;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return ke$1`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  connectSocial() {
    window.addEventListener("message", this.handleSocialConnection, false);
  }
  updateMessage() {
    if (this.error) {
      this.message = "Something went wrong";
    } else if (this.connecting) {
      this.message = "Retrieving user data";
    } else {
      this.message = "Connect in the provider window";
    }
  }
};
W3mConnectingSocialView.styles = styles$r;
__decorate$J([
  r$1()
], W3mConnectingSocialView.prototype, "socialProvider", void 0);
__decorate$J([
  r$1()
], W3mConnectingSocialView.prototype, "socialWindow", void 0);
__decorate$J([
  r$1()
], W3mConnectingSocialView.prototype, "error", void 0);
__decorate$J([
  r$1()
], W3mConnectingSocialView.prototype, "connecting", void 0);
__decorate$J([
  r$1()
], W3mConnectingSocialView.prototype, "message", void 0);
W3mConnectingSocialView = __decorate$J([
  customElement("w3m-connecting-social-view")
], W3mConnectingSocialView);
const styles$q = i$2`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function markWalletsAsInstalled(wallets) {
  const { connectors } = ConnectorController.state;
  const installedConnectors = connectors.filter((c2) => c2.type === "ANNOUNCED").reduce((acum, val) => {
    var _a2;
    if (!((_a2 = val.info) == null ? void 0 : _a2.rdns)) {
      return acum;
    }
    acum[val.info.rdns] = true;
    return acum;
  }, {});
  const walletsWithInstalled = wallets.map((wallet) => ({
    ...wallet,
    installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
  }));
  const sortedWallets = walletsWithInstalled.sort((a2, b2) => Number(b2.installed) - Number(a2.installed));
  return sortedWallets;
}
var __decorate$I = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const PAGINATOR_ID$1 = "local-paginator";
let W3mAllWalletsList = class W3mAllWalletsList2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    var _a2;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a2 = this.paginationObserver) == null ? void 0 : _a2.disconnect();
  }
  render() {
    return ke$1`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    var _a2;
    const gridEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id2) {
    return [...Array(items)].map(() => ke$1`
        <wui-card-select-loader type="wallet" id=${to(id2)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => ke$1`
        <wui-card-select
          imageSrc=${to(AssetUtil.getWalletImage(wallet))}
          type="wallet"
          name=${wallet.name}
          @click=${() => this.onConnectWallet(wallet)}
          .installed=${wallet.installed}
        ></wui-card-select>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count: count2 } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count2 === 0 && featured.length > 0) {
      return null;
    }
    if (count2 === 0 || [...featured, ...wallets, ...recommended].length < count2) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID$1);
    }
    return null;
  }
  createPaginationObserver() {
    var _a2;
    const loaderEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(`#${PAGINATOR_ID$1}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if ((element == null ? void 0 : element.isIntersecting) && !this.initial) {
          const { page, count: count2, wallets } = ApiController.state;
          if (wallets.length < count2) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles$q;
__decorate$I([
  r$1()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate$I([
  r$1()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$I([
  r$1()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$I([
  r$1()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$I([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);
const styles$p = i$2`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$H = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends h {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? ke$1`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query.trim() !== this.prevQuery.trim()) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets = markWalletsAsInstalled(search);
    if (!search.length) {
      return ke$1`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return ke$1`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets.map((wallet) => ke$1`
            <wui-card-select
              imageSrc=${to(AssetUtil.getWalletImage(wallet))}
              type="wallet"
              name=${wallet.name}
              @click=${() => this.onConnectWallet(wallet)}
              .installed=${wallet.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles$p;
__decorate$H([
  r$1()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$H([
  n2()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate$H([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);
var __decorate$G = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingHeader = class W3mConnectingHeader2 extends h {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return ke$1`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index) {
    var _a2;
    const tab = this.platformTabs[index];
    if (tab) {
      (_a2 = this.onSelectPlatfrom) == null ? void 0 : _a2.call(this, tab);
    }
  }
};
__decorate$G([
  n2({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$G([
  n2()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$G([
  r$1()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$G([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);
var __decorate$F = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    var _a2;
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const announcedConnector = connectors.find((c2) => {
        var _a3, _b2;
        return c2.type === "ANNOUNCED" && ((_a3 = c2.info) == null ? void 0 : _a3.rdns) === ((_b2 = this.wallet) == null ? void 0 : _b2.rdns);
      });
      const injectedConnector = connectors.find((c2) => c2.type === "INJECTED");
      if (announcedConnector) {
        await ConnectionController.connectExternal(announcedConnector);
      } else if (injectedConnector) {
        await ConnectionController.connectExternal(injectedConnector);
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser", name: ((_a2 = this.wallet) == null ? void 0 : _a2.name) || "Unknown" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate$F([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);
var __decorate$E = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.timeout = setTimeout(() => {
        var _a2;
        (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
      }, 200);
    }
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.desktop_link) && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate$E([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);
var __decorate$D = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    var _a2;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
    }
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.mobile_link) && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if ((document == null ? void 0 : document.visibilityState) === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate$D([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);
const styles$o = i$2`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$C = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    var _a2;
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a2 = this.wallet) == null ? void 0 : _a2.name) ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return ke$1` <wui-qr-code
      size=${size}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${to(AssetUtil.getWalletImage(this.wallet))}
      alt=${to(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return ke$1`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles$o;
W3mConnectingWcQrcode = __decorate$C([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);
var __decorate$B = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends h {
  constructor() {
    var _a2;
    super();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return ke$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${to(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate$B([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);
var __decorate$A = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.webapp_link) && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate$A([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);
const styles$n = i$2`
  :host {
    width: 100%;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    cursor: pointer;
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    padding-top: 0px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-1xs);
    border-radius: calc(var(--wui-border-radius-5xs) + var(--wui-border-radius-4xs));
    background: var(--wui-color-gray-glass-002);
  }

  .details-row-title {
    white-space: nowrap;
  }

  .details-row.provider-free-row {
    padding-right: var(--wui-spacing-xs);
  }
`;
var __decorate$z = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const slippageRate = ConstantsUtil$2.CONVERT_SLIPPAGE_TOLERANCE;
let WuiSwapDetails = class WuiSwapDetails2 extends h {
  constructor() {
    var _a2;
    super();
    this.unsubscribe = [];
    this.networkName = (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.name;
    this.detailsOpen = false;
    this.sourceToken = SwapController.state.sourceToken;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.priceImpact = SwapController.state.priceImpact;
    this.maxSlippage = SwapController.state.maxSlippage;
    this.networkTokenSymbol = SwapController.state.networkTokenSymbol;
    this.inputError = SwapController.state.inputError;
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.priceImpact = newState.priceImpact;
        this.maxSlippage = newState.maxSlippage;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
      })
    ]);
  }
  render() {
    const minReceivedAmount = this.toTokenAmount && this.maxSlippage ? NumberUtil.bigNumber(this.toTokenAmount).minus(this.maxSlippage).toString() : null;
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    const toTokenSwappedAmount = this.sourceTokenPriceInUSD && this.toTokenPriceInUSD ? 1 / this.toTokenPriceInUSD * this.sourceTokenPriceInUSD : 0;
    return ke$1`
      <wui-flex flexDirection="column" alignItems="center" gap="1xs" class="details-container">
        <wui-flex flexDirection="column">
          <button @click=${this.toggleDetails.bind(this)}>
            <wui-flex justifyContent="space-between" .padding=${["0", "xs", "0", "xs"]}>
              <wui-flex justifyContent="flex-start" flexGrow="1" gap="xs">
                <wui-text variant="small-400" color="fg-100">
                  1 ${this.sourceToken.symbol} =
                  ${UiHelperUtil.formatNumberToLocalString(toTokenSwappedAmount, 3)}
                  ${this.toToken.symbol}
                </wui-text>
                <wui-text variant="small-400" color="fg-200">
                  $${UiHelperUtil.formatNumberToLocalString(this.sourceTokenPriceInUSD)}
                </wui-text>
              </wui-flex>
              <wui-icon name="chevronBottom"></wui-icon>
            </wui-flex>
          </button>
          ${this.detailsOpen ? ke$1`
                <wui-flex flexDirection="column" gap="xs" class="details-content-container">
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Network cost
                        </wui-text>
                        <w3m-tooltip-trigger
                          text=${`Network cost is paid in ${this.networkTokenSymbol} on the ${this.networkName} network in order to execute transaction.`}
                        >
                          <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                        </w3m-tooltip-trigger>
                      </wui-flex>
                      <wui-text variant="small-400" color="fg-100">
                        $${UiHelperUtil.formatNumberToLocalString(this.gasPriceInUSD, 3)}
                      </wui-text>
                    </wui-flex>
                  </wui-flex>
                  ${this.priceImpact ? ke$1` <wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Price impact
                            </wui-text>
                            <w3m-tooltip-trigger
                              text="Price impact reflects the change in market price due to your trade"
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.priceImpact, 3)}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  ${this.maxSlippage && this.sourceToken.symbol ? ke$1`<wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Max. slippage
                            </wui-text>
                            <w3m-tooltip-trigger
                              text=${`Max slippage sets the minimum amount you must receive for the transaction to proceed. ${minReceivedAmount ? `Transaction will be reversed if you receive less than ${UiHelperUtil.formatNumberToLocalString(minReceivedAmount, 6)} ${this.toToken.symbol} due to price changes.` : ""}`}
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.maxSlippage, 6)}
                              ${this.toToken.symbol} ${slippageRate}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row provider-free-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Provider fee
                        </wui-text>
                      </wui-flex>
                      <wui-flex>
                        <wui-text variant="small-400" color="fg-200">0.85%</wui-text>
                      </wui-flex>
                    </wui-flex>
                  </wui-flex>
                </wui-flex>
              ` : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  toggleDetails() {
    this.detailsOpen = !this.detailsOpen;
  }
};
WuiSwapDetails.styles = [styles$n];
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "networkName", void 0);
__decorate$z([
  n2()
], WuiSwapDetails.prototype, "detailsOpen", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "sourceToken", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "toToken", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "toTokenAmount", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "toTokenPriceInUSD", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "gasPriceInUSD", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "priceImpact", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "maxSlippage", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "networkTokenSymbol", void 0);
__decorate$z([
  r$1()
], WuiSwapDetails.prototype, "inputError", void 0);
WuiSwapDetails = __decorate$z([
  customElement("w3m-swap-details")
], WuiSwapDetails);
const styles$m = i$2`
  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    position: relative;
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host wui-flex.focus {
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-005);
  }

  :host > wui-flex .swap-input,
  :host > wui-flex .swap-token-button {
    z-index: 10;
  }

  :host > wui-flex .swap-input {
    -webkit-mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  :host > wui-flex .swap-input input {
    background: none;
    border: none;
    height: 42px;
    width: 100%;
    font-size: 32px;
    font-style: normal;
    font-weight: 400;
    line-height: 130%;
    letter-spacing: -1.28px;
    outline: none;
    caret-color: var(--wui-color-accent-100);
    color: var(--wui-color-fg-100);
    padding: 0px;
  }

  :host > wui-flex .swap-input input:focus-visible {
    outline: none;
  }

  :host > wui-flex .swap-input input::-webkit-outer-spin-button,
  :host > wui-flex .swap-input input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .max-value-button {
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--wui-color-gray-glass-020);
    padding-left: 0px;
  }

  .market-value {
    min-height: 18px;
  }
`;
var __decorate$y = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const MINIMUM_USD_VALUE_TO_CONVERT = 5e-5;
let W3mSwapInput = class W3mSwapInput2 extends h {
  constructor() {
    super(...arguments);
    this.focused = false;
    this.price = 0;
    this.target = "sourceToken";
    this.onSetAmount = null;
    this.onSetMaxValue = null;
  }
  render() {
    const marketValue = this.marketValue || "0";
    const isMarketValueGreaterThanZero = NumberUtil.bigNumber(marketValue).isGreaterThan("0");
    return ke$1`
      <wui-flex class="${this.focused ? "focus" : ""}" justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
        >
          <input
            @focusin=${() => this.onFocusChange(true)}
            @focusout=${() => this.onFocusChange(false)}
            ?disabled=${this.disabled}
            .value=${this.value}
            @input=${this.dispatchInputChangeEvent}
            @keydown=${this.handleKeydown}
            placeholder="0"
            type="text"
            inputmode="decimal"
          />
          <wui-text class="market-value" variant="small-400" color="fg-200">
            ${isMarketValueGreaterThanZero ? `$${UiHelperUtil.formatNumberToLocalString(this.marketValue, 3)}` : null}
          </wui-text>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  handleKeydown(event) {
    return InputUtil.numericInputKeyDown(event, this.value, (value2) => {
      var _a2;
      return (_a2 = this.onSetAmount) == null ? void 0 : _a2.call(this, this.target, value2);
    });
  }
  dispatchInputChangeEvent(event) {
    if (!this.onSetAmount) {
      return;
    }
    const value2 = event.target.value.replace(/[^0-9.]/gu, "");
    if (value2 === "," || value2 === ".") {
      this.onSetAmount(this.target, "0.");
    } else if (value2.endsWith(",")) {
      this.onSetAmount(this.target, value2.replace(",", "."));
    } else {
      this.onSetAmount(this.target, value2);
    }
  }
  setMaxValueToInput() {
    var _a2;
    (_a2 = this.onSetMaxValue) == null ? void 0 : _a2.call(this, this.target, this.balance);
  }
  templateTokenSelectButton() {
    if (!this.token) {
      return ke$1` <wui-button
        class="swap-token-button"
        size="md"
        variant="accent"
        @click=${this.onSelectToken.bind(this)}
      >
        Select token
      </wui-button>`;
    }
    return ke$1`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-token-button
          text=${this.token.symbol}
          imageSrc=${this.token.logoUri}
          @click=${this.onSelectToken.bind(this)}
        >
        </wui-token-button>
        <wui-flex alignItems="center" gap="xxs"> ${this.tokenBalanceTemplate()} </wui-flex>
      </wui-flex>
    `;
  }
  tokenBalanceTemplate() {
    const balanceValueInUSD = NumberUtil.multiply(this.balance, this.price);
    const haveBalance = balanceValueInUSD ? balanceValueInUSD == null ? void 0 : balanceValueInUSD.isGreaterThan(MINIMUM_USD_VALUE_TO_CONVERT) : false;
    return ke$1`
      ${haveBalance ? ke$1`<wui-text variant="small-400" color="fg-200">
            ${UiHelperUtil.formatNumberToLocalString(this.balance, 3)}
          </wui-text>` : null}
      ${this.target === "sourceToken" ? this.tokenActionButtonTemplate(haveBalance) : null}
    `;
  }
  tokenActionButtonTemplate(haveBalance) {
    if (haveBalance) {
      return ke$1` <button class="max-value-button" @click=${this.setMaxValueToInput.bind(this)}>
        <wui-text color="accent-100" variant="small-600">Max</wui-text>
      </button>`;
    }
    return ke$1` <button class="max-value-button" @click=${this.onBuyToken.bind(this)}>
      <wui-text color="accent-100" variant="small-600">Buy</wui-text>
    </button>`;
  }
  onFocusChange(state2) {
    this.focused = state2;
  }
  onSelectToken() {
    EventsController.sendEvent({ type: "track", event: "CLICK_SELECT_TOKEN_TO_SWAP" });
    RouterController.push("SwapSelectToken", {
      target: this.target
    });
  }
  onBuyToken() {
    RouterController.push("OnRampProviders");
  }
};
W3mSwapInput.styles = [styles$m];
__decorate$y([
  n2()
], W3mSwapInput.prototype, "focused", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "balance", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "value", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "price", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "marketValue", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "disabled", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "target", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "token", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "onSetAmount", void 0);
__decorate$y([
  n2()
], W3mSwapInput.prototype, "onSetMaxValue", void 0);
W3mSwapInput = __decorate$y([
  customElement("w3m-swap-input")
], W3mSwapInput);
const styles$l = i$2`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    position: relative;
  }

  wui-shimmer.market-value {
    opacity: 0;
  }

  :host > wui-flex > svg.input_mask {
    position: absolute;
    inset: 0;
    z-index: 5;
  }

  :host wui-flex .input_mask__border,
  :host wui-flex .input_mask__background {
    transition: fill var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: fill;
  }

  :host wui-flex .input_mask__border {
    fill: var(--wui-color-gray-glass-020);
  }

  :host wui-flex .input_mask__background {
    fill: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$x = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSwapInputSkeleton = class W3mSwapInputSkeleton2 extends h {
  constructor() {
    super(...arguments);
    this.target = "sourceToken";
  }
  render() {
    return ke$1`
      <wui-flex class justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
          gap="xxs"
        >
          <wui-shimmer width="80px" height="40px" borderRadius="xxs" variant="light"></wui-shimmer>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  templateTokenSelectButton() {
    return ke$1`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-shimmer width="80px" height="40px" borderRadius="3xl" variant="light"></wui-shimmer>
      </wui-flex>
    `;
  }
};
W3mSwapInputSkeleton.styles = [styles$l];
__decorate$x([
  n2()
], W3mSwapInputSkeleton.prototype, "target", void 0);
W3mSwapInputSkeleton = __decorate$x([
  customElement("w3m-swap-input-skeleton")
], W3mSwapInputSkeleton);
const styles$k = i$2`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var __decorate$w = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const BETA_SCREENS = ["Swap", "SwapSelectToken", "SwapPreview"];
function headings() {
  var _a2, _b2, _c2, _d2, _e3, _f2, _g2;
  const connectorName = (_b2 = (_a2 = RouterController.state.data) == null ? void 0 : _a2.connector) == null ? void 0 : _b2.name;
  const walletName = (_d2 = (_c2 = RouterController.state.data) == null ? void 0 : _c2.wallet) == null ? void 0 : _d2.name;
  const networkName = (_f2 = (_e3 = RouterController.state.data) == null ? void 0 : _e3.network) == null ? void 0 : _f2.name;
  const name = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && ((_g2 = connectors[0]) == null ? void 0 : _g2.id) === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    ConnectingExternal: name ?? "Connect Wallet",
    ConnectingWalletConnect: name ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Networks: "Choose Network",
    SwitchNetwork: networkName ?? "Switch Network",
    AllWallets: "All Wallets",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    GetWallet: "Get a wallet",
    Downloads: name ? `Get ${name}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    ApproveTransaction: "Approve Transaction",
    Transactions: "Activity",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpgradeToSmartAccount: void 0,
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    UnsupportedChain: "Switch Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    WhatIsABuy: "What is Buy?",
    BuyInProgress: "Buy",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social"
  };
}
let W3mHeader = class W3mHeader2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.buffering = false;
    this.showBack = false;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      this.onViewChange(val);
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    if (OptionsController.state.isSiweEnabled) {
      const { SIWEController } = await __vitePreload(async () => {
        const { SIWEController: SIWEController2 } = await import("./index-DFMQ5ukk.js");
        return { SIWEController: SIWEController2 };
      }, true ? [] : void 0);
      if (SIWEController.state.status !== "success") {
        await ConnectionController.disconnect();
      }
    }
    ModalController.close();
  }
  titleTemplate() {
    const isBeta = BETA_SCREENS.includes(RouterController.state.view);
    return ke$1`
      <wui-flex class="w3m-header-title" alignItems="center" gap="xs">
        <wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>
        ${isBeta ? ke$1`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
  }
  dynamicButtonTemplate() {
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    const isUpgradeToSmartAccounts = view === "UpgradeToSmartAccount";
    const isConnectingSIWEView = view === "ConnectingSiwe";
    const shouldHideBack = isApproveTransaction || isUpgradeToSmartAccounts || isConnectingSIWEView;
    if (this.showBack && !shouldHideBack) {
      return ke$1`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return ke$1`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["l", "2l", "0", "2l"];
  }
  async onViewChange(view) {
    var _a2;
    const headingEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-flex.w3m-header-title");
    if (headingEl) {
      const preset = headings()[view];
      await headingEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.heading = preset;
      headingEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onHistoryChange() {
    var _a2;
    const { history } = RouterController.state;
    const buttonEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    RouterController.goBack();
  }
};
W3mHeader.styles = [styles$k];
__decorate$w([
  r$1()
], W3mHeader.prototype, "heading", void 0);
__decorate$w([
  r$1()
], W3mHeader.prototype, "buffering", void 0);
__decorate$w([
  r$1()
], W3mHeader.prototype, "showBack", void 0);
W3mHeader = __decorate$w([
  customElement("w3m-header")
], W3mHeader);
var __decorate$v = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mHelpWidget = class W3mHelpWidget2 extends h {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return ke$1`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => ke$1`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => ke$1`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate$v([
  n2({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$v([
  customElement("w3m-help-widget")
], W3mHelpWidget);
const styles$j = i$2`
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;
var __decorate$u = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mInputCurrency = class W3mInputCurrency2 extends h {
  constructor() {
    var _a2;
    super();
    this.unsubscribe = [];
    this.type = "Token";
    this.value = 0;
    this.currencies = [];
    this.selectedCurrency = (_a2 = this.currencies) == null ? void 0 : _a2[0];
    this.currencyImages = AssetController.state.currencyImages;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", (val) => {
      if (!val || this.type === "Fiat") {
        return;
      }
      this.selectedCurrency = this.formatPurchaseCurrency(val);
    }), OnRampController.subscribeKey("paymentCurrency", (val) => {
      if (!val || this.type === "Token") {
        return;
      }
      this.selectedCurrency = this.formatPaymentCurrency(val);
    }), OnRampController.subscribe((val) => {
      if (this.type === "Fiat") {
        this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
      } else {
        this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
      }
    }), AssetController.subscribe((val) => {
      this.currencyImages = { ...val.currencyImages };
      this.tokenImages = { ...val.tokenImages };
    }));
  }
  firstUpdated() {
    OnRampController.getAvailableCurrencies();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    const symbol = ((_a2 = this.selectedCurrency) == null ? void 0 : _a2.symbol) || "";
    const image = this.currencyImages[symbol] || this.tokenImages[symbol];
    return ke$1`<wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? ke$1` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <wui-image src=${to(image)}></wui-image>
            <wui-text color="fg-100">${this.selectedCurrency.symbol}</wui-text>
          </wui-flex>` : ke$1`<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`;
  }
  formatPaymentCurrency(currency) {
    return {
      name: currency.id,
      symbol: currency.id
    };
  }
  formatPurchaseCurrency(currency) {
    return {
      name: currency.name,
      symbol: currency.symbol
    };
  }
};
W3mInputCurrency.styles = styles$j;
__decorate$u([
  n2({ type: String })
], W3mInputCurrency.prototype, "type", void 0);
__decorate$u([
  n2({ type: Number })
], W3mInputCurrency.prototype, "value", void 0);
__decorate$u([
  r$1()
], W3mInputCurrency.prototype, "currencies", void 0);
__decorate$u([
  r$1()
], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate$u([
  r$1()
], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate$u([
  r$1()
], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate$u([
  customElement("w3m-onramp-input")
], W3mInputCurrency);
const styles$i = i$2`
  wui-flex {
    background-color: var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$t = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mLegalFooter = class W3mLegalFooter2 extends h {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return ke$1`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return ke$1`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return ke$1`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles$i];
W3mLegalFooter = __decorate$t([
  customElement("w3m-legal-footer")
], W3mLegalFooter);
const styles$h = i$2`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$s = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends h {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return ke$1`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return ke$1`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return ke$1`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return ke$1`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles$h];
__decorate$s([
  n2({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$s([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);
const styles$g = i$2`
  wui-flex {
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;
var __decorate$r = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter2 extends h {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return ke$1`
      <wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `;
  }
  howDoesItWorkTemplate() {
    return ke$1` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
  }
  onWhatIsBuy() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WHAT_IS_A_BUY",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WhatIsABuy");
  }
};
W3mOnRampProvidersFooter.styles = [styles$g];
W3mOnRampProvidersFooter = __decorate$r([
  customElement("w3m-onramp-providers-footer")
], W3mOnRampProvidersFooter);
const styles$f = i$2`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$q = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const presets = {
  loading: void 0,
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let W3mSnackBar = class W3mSnackBar2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return ke$1`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${preset == null ? void 0 : preset.iconColor}
        icon=${preset == null ? void 0 : preset.icon}
        .loading=${variant === "loading"}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles$f;
__decorate$q([
  r$1()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$q([
  customElement("w3m-snackbar")
], W3mSnackBar);
const styles$e = i$2`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }
`;
var __decorate$p = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = ii();
    this.connectors = ConnectorController.state.connectors;
    this.email = "";
    this.loading = false;
    this.error = "";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    var _a2;
    (_a2 = this.formRef.value) == null ? void 0 : _a2.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const connector = this.connectors.find((c2) => c2.type === "AUTH");
    const multipleConnectors = this.connectors.length > 1;
    if (!(connector == null ? void 0 : connector.email)) {
      return null;
    }
    return ke$1`
      <form ${Kt$1(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${connector.socials || !multipleConnectors ? null : ke$1`<wui-flex .padding=${["xxs", "0", "0", "0"]}>
            <wui-separator text="or"></wui-separator>
          </wui-flex>`}
    `;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? ke$1`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? ke$1`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(event) {
    this.email = event.detail.trim();
    this.error = "";
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-email-login-widget: Auth connector not found");
      }
      const { action } = await authConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError == null ? void 0 : parsedError.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles$e;
__decorate$p([
  r$1()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate$p([
  r$1()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate$p([
  r$1()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate$p([
  r$1()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate$p([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);
const styles$d = i$2`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: 24px;
    transaction: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;
var __decorate$o = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountDefaultWidget = class W3mAccountDefaultWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = NetworkController.state.caipNetwork;
    this.disconnecting = false;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.balance = val.balance;
          this.balanceSymbol = val.balanceSymbol;
        } else if (!this.disconnecting) {
          SnackController.showError("Account not found");
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return ke$1`<wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${to(this.address)}
          address=${to(this.address)}
          imageSrc=${to(this.profileImage === null ? void 0 : this.profileImage)}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="medium-title-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address ? this.address : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-text variant="paragraph-500" color="fg-200"
            >${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}</wui-text
          >
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.authCardTemplate()} <w3m-account-auth-button></w3m-account-auth-button>

        <wui-list-item
          .variant=${networkImage ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${to(networkImage)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${((_a2 = this.network) == null ? void 0 : _a2.name) ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        ${this.onrampTemplate()}
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalMedium"
          iconSize="sm"
          ?chevron=${true}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
  }
  onrampTemplate() {
    const { enableOnramp } = OptionsController.state;
    if (!enableOnramp) {
      return null;
    }
    return ke$1`
      <wui-list-item
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy crypto</wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type3 !== "AUTH" || origin.includes(ConstantsUtil$2.SECURE_SITE)) {
      return null;
    }
    return ke$1`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  handleClickPay() {
    RouterController.push("OnRampProviders");
  }
  explorerBtnTemplate() {
    const { addressExplorerUrl } = AccountController.state;
    if (!addressExplorerUrl) {
      return null;
    }
    return ke$1`
      <wui-button size="md" variant="neutral" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks } = NetworkController.state;
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id: id2 }) => {
      var _a2;
      return id2 === ((_a2 = this.network) == null ? void 0 : _a2.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      RouterController.push("Networks");
    }
  }
  onTransactions() {
    EventsController.sendEvent({
      type: "track",
      event: "CLICK_TRANSACTIONS",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onExplorer() {
    const { addressExplorerUrl } = AccountController.state;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountDefaultWidget.styles = styles$d;
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "address", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileName", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "network", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "balance", void 0);
__decorate$o([
  r$1()
], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
W3mAccountDefaultWidget = __decorate$o([
  customElement("w3m-account-default-widget")
], W3mAccountDefaultWidget);
const styles$c = i$2`
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: calc(-1 * var(--wui-spacing-2l));
  }

  wui-promo + wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$n = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const TABS = 3;
const TABS_PADDING = 48;
const MODAL_MOBILE_VIEW_PX = 430;
let W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.network = NetworkController.state.caipNetwork;
    this.currentTab = AccountController.state.currentTab;
    this.tokenBalance = AccountController.state.tokenBalance;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.currentTab = val.currentTab;
          this.tokenBalance = val.tokenBalance;
          this.smartAccountDeployed = val.smartAccountDeployed;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      })
    ], NetworkController.subscribe((val) => {
      this.network = val.caipNetwork;
    }));
    this.watchSwapValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearInterval(this.watchTokenBalance);
  }
  firstUpdated() {
    AccountController.fetchTokenBalance();
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return ke$1`<wui-flex
      flexDirection="column"
      .padding=${["0", "xl", "m", "xl"]}
      alignItems="center"
      gap="m"
    >
      ${this.activateAccountTemplate()}
      <wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${to(this.address)}
        networkSrc=${to(networkImage)}
        icon="chevronBottom"
        avatarSrc=${to(this.profileImage ? this.profileImage : void 0)}
        profileName=${this.profileName}
        data-testid="w3m-profile-button"
      ></wui-profile-button>
      ${this.tokenBalanceTemplate()}
      <wui-flex gap="s">
        <w3m-tooltip-trigger text="Buy">
          <wui-icon-button @click=${this.onBuyClick.bind(this)} icon="card"></wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Swap">
          <wui-icon-button @click=${this.onSwapClick.bind(this)} icon="recycleHorizontal">
          </wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Receive">
          <wui-icon-button @click=${this.onReceiveClick.bind(this)} icon="arrowBottomCircle">
          </wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Send">
          <wui-icon-button @click=${this.onSendClick.bind(this)} icon="send"></wui-icon-button>
        </w3m-tooltip-trigger>
      </wui-flex>

      <wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth=${CoreHelperUtil.isMobile() && window.innerWidth < MODAL_MOBILE_VIEW_PX ? `${(window.innerWidth - TABS_PADDING) / TABS}px` : "104px"}
        .tabs=${ConstantsUtil.ACCOUNT_TABS}
      ></wui-tabs>
      ${this.listContentTemplate()}
    </wui-flex>`;
  }
  watchSwapValues() {
    this.watchTokenBalance = setInterval(() => AccountController.fetchTokenBalance(), 1e4);
  }
  listContentTemplate() {
    if (this.currentTab === 0) {
      return ke$1`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
    }
    if (this.currentTab === 1) {
      return ke$1`<w3m-account-nfts-widget></w3m-account-nfts-widget>`;
    }
    if (this.currentTab === 2) {
      return ke$1`<w3m-account-activity-widget></w3m-account-activity-widget>`;
    }
    return ke$1`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
  }
  tokenBalanceTemplate() {
    var _a2;
    if (this.tokenBalance && ((_a2 = this.tokenBalance) == null ? void 0 : _a2.length) >= 0) {
      const value2 = CoreHelperUtil.calculateBalance(this.tokenBalance);
      const { dollars = "0", pennies = "00" } = CoreHelperUtil.formatTokenBalance(value2);
      return ke$1`<wui-balance dollars=${dollars} pennies=${pennies}></wui-balance>`;
    }
    return ke$1`<wui-balance dollars="0" pennies="00"></wui-balance>`;
  }
  activateAccountTemplate() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    if (!smartAccountEnabled || this.preferredAccountType !== W3mFrameRpcConstants.ACCOUNT_TYPES.EOA || this.smartAccountDeployed) {
      return null;
    }
    return ke$1` <wui-promo
      text=${"Activate your account"}
      @click=${this.onUpdateToSmartAccount.bind(this)}
      data-testid="activate-smart-account-promo"
    ></wui-promo>`;
  }
  onTabChange(index) {
    AccountController.setCurrentTab(index);
  }
  onProfileButtonClick() {
    RouterController.push("AccountSettings");
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onSwapClick() {
    var _a2, _b2, _c2;
    if (((_a2 = this.network) == null ? void 0 : _a2.id) && !ConstantsUtil$2.SWAP_SUPPORTED_NETWORKS.includes((_b2 = this.network) == null ? void 0 : _b2.id)) {
      RouterController.push("UnsupportedChain", {
        swapUnsupportedChain: true
      });
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "OPEN_SWAP",
        properties: {
          network: ((_c2 = this.network) == null ? void 0 : _c2.id) || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      RouterController.push("Swap");
    }
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onSendClick() {
    var _a2;
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_SEND",
      properties: {
        network: ((_a2 = this.network) == null ? void 0 : _a2.id) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WalletSend");
  }
  onUpdateToSmartAccount() {
    RouterController.push("UpgradeToSmartAccount");
  }
};
W3mAccountWalletFeaturesWidget.styles = styles$c;
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "watchTokenBalance", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "smartAccountDeployed", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
__decorate$n([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "preferredAccountType", void 0);
W3mAccountWalletFeaturesWidget = __decorate$n([
  customElement("w3m-account-wallet-features-widget")
], W3mAccountWalletFeaturesWidget);
const styles$b = i$2`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$m = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountActivityWidget = class W3mAccountActivityWidget2 extends h {
  render() {
    return ke$1`<w3m-activity-list page="account"></w3m-activity-list>`;
  }
};
W3mAccountActivityWidget.styles = styles$b;
W3mAccountActivityWidget = __decorate$m([
  customElement("w3m-account-activity-widget")
], W3mAccountActivityWidget);
const styles$a = i$2`
  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$l = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountNftsWidget = class W3mAccountNftsWidget2 extends h {
  render() {
    return ke$1`${this.nftTemplate()}`;
  }
  nftTemplate() {
    return ke$1` <wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">Coming soon</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Stay tuned for our upcoming NFT feature</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Receive funds</wui-link>
    </wui-flex>`;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
};
W3mAccountNftsWidget.styles = styles$a;
W3mAccountNftsWidget = __decorate$l([
  customElement("w3m-account-nfts-widget")
], W3mAccountNftsWidget);
const styles$9 = i$2`
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$k = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountTokensWidget = class W3mAccountTokensWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1`${this.tokenTemplate()}`;
  }
  tokenTemplate() {
    var _a2;
    if (this.tokenBalance && ((_a2 = this.tokenBalance) == null ? void 0 : _a2.length) > 0) {
      return ke$1`<wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </wui-flex>`;
    }
    return ke$1` <wui-flex flexDirection="column" gap="xs"
      ><wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
      ></wui-list-description
      ><wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
      ></wui-list-description
    ></wui-flex>`;
  }
  tokenItemTemplate() {
    var _a2;
    return (_a2 = this.tokenBalance) == null ? void 0 : _a2.map((token2) => ke$1`<wui-list-token
          tokenName=${token2.name}
          tokenImageUrl=${token2.iconUrl}
          tokenAmount=${token2.quantity.numeric}
          tokenValue=${token2.value}
          tokenCurrency=${token2.symbol}
        ></wui-list-token>`);
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onBuyClick() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_CRYPTO",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("OnRampProviders");
  }
};
W3mAccountTokensWidget.styles = styles$9;
__decorate$k([
  r$1()
], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
W3mAccountTokensWidget = __decorate$k([
  customElement("w3m-account-tokens-widget")
], W3mAccountTokensWidget);
const styles$8 = i$2`
  :host {
    min-height: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;
var __decorate$j = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const PAGINATOR_ID = "last-transaction";
const LOADING_ITEM_COUNT = 7;
let W3mActivityList = class W3mActivityList2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.page = "activity";
    this.address = AccountController.state.address;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    TransactionsController.clearCursor();
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          if (this.address !== val.address) {
            this.address = val.address;
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val.address);
          }
        }
      }),
      TransactionsController.subscribe((val) => {
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    TransactionsController.fetchTransactions(this.address);
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return ke$1` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year, index) => {
      const isLastGroup = index === sortedYearKeys.length - 1;
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        var _a2;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = (_a2 = this.transactionsByYear[yearInt]) == null ? void 0 : _a2[month];
        if (!transactions) {
          return null;
        }
        return ke$1`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type: type3 } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return ke$1`
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type3}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index === transfers.length - 1;
        return ke$1` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type3}
          .onlyDirectionIcon=${true}
          .images=${[images[index]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return ke$1`
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
        status=${status}
        type=${type3}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index) => {
      const isLastTransaction = isLastGroup && index === transactions.length - 1;
      return ke$1`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  emptyStateActivity() {
    return ke$1`<wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="gray-glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
  }
  emptyStateAccount() {
    return ke$1`<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
  }
  templateEmpty() {
    if (this.page === "account") {
      return ke$1`${this.emptyStateAccount()}`;
    }
    return ke$1`${this.emptyStateActivity()}`;
  }
  templateLoading() {
    if (this.page === "activity") {
      return Array(LOADING_ITEM_COUNT).fill(ke$1` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
    }
    return null;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
        TransactionsController.fetchTransactions(this.address);
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: this.address,
            projectId,
            cursor: this.next,
            isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    var _a2, _b2, _c2;
    (_a2 = this.paginationObserver) == null ? void 0 : _a2.disconnect();
    const lastItem = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector(`#${PAGINATOR_ID}`);
    if (lastItem) {
      (_c2 = this.paginationObserver) == null ? void 0 : _c2.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    var _a2, _b2, _c2, _d2, _e3;
    const date = DateUtil.formatDate((_a2 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a2.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const transfer = (_b2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b2[0];
    const isAllNFT = Boolean(transfer) && ((_c2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c2.every((item) => Boolean(item.nft_info)));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer == null ? void 0 : transfer.direction,
      descriptions,
      isAllNFT,
      images,
      status: (_d2 = transaction.metadata) == null ? void 0 : _d2.status,
      transfers,
      type: (_e3 = transaction.metadata) == null ? void 0 : _e3.operationType
    };
  }
};
W3mActivityList.styles = styles$8;
__decorate$j([
  n2()
], W3mActivityList.prototype, "page", void 0);
__decorate$j([
  r$1()
], W3mActivityList.prototype, "address", void 0);
__decorate$j([
  r$1()
], W3mActivityList.prototype, "transactionsByYear", void 0);
__decorate$j([
  r$1()
], W3mActivityList.prototype, "loading", void 0);
__decorate$j([
  r$1()
], W3mActivityList.prototype, "empty", void 0);
__decorate$j([
  r$1()
], W3mActivityList.prototype, "next", void 0);
W3mActivityList = __decorate$j([
  customElement("w3m-activity-list")
], W3mActivityList);
const styles$7 = i$2`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  wui-input-amount {
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  .totalValue {
    width: 100%;
  }
`;
var __decorate$i = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mInputToken = class W3mInputToken2 extends h {
  render() {
    return ke$1` <wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${["xl", "s", "l", "l"]}
    >
      <wui-flex alignItems="center">
        <wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ""}
        ></wui-input-amount>
        ${this.buttonTemplate()}
      </wui-flex>
      <wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>`;
  }
  buttonTemplate() {
    if (this.token) {
      return ke$1`<wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
      >
      </wui-token-button>`;
    }
    return ke$1`<wui-button
      size="md"
      variant="accent"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
  }
  handleSelectButtonClick() {
    RouterController.push("WalletSendSelectToken");
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return ke$1`<wui-text class="totalValue" variant="small-400" color="fg-200"
        >${totalValue ? `$${UiHelperUtil.formatNumberToLocalString(totalValue, 2)}` : "Incorrect value"}</wui-text
      >`;
    }
    return null;
  }
  maxAmountTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return ke$1` <wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </wui-text>`;
      }
      return ke$1` <wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </wui-text>`;
    }
    return null;
  }
  actionTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return ke$1`<wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>`;
      }
      return ke$1`<wui-link @click=${this.onMaxClick.bind(this)}>Max</wui-link>`;
    }
    return null;
  }
  onInputChange(event) {
    SendController.setTokenAmount(event.detail);
  }
  onMaxClick() {
    if (this.token && this.gasPriceInUSD) {
      const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).dividedBy(this.token.price);
      const isNetworkToken = this.token.address === void 0;
      const maxValue = isNetworkToken ? NumberUtil.bigNumber(this.token.quantity.numeric).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(this.token.quantity.numeric);
      SendController.setTokenAmount(Number(maxValue.toFixed(20)));
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
};
W3mInputToken.styles = styles$7;
__decorate$i([
  n2({ type: Object })
], W3mInputToken.prototype, "token", void 0);
__decorate$i([
  n2({ type: Number })
], W3mInputToken.prototype, "sendTokenAmount", void 0);
__decorate$i([
  n2({ type: Number })
], W3mInputToken.prototype, "gasPriceInUSD", void 0);
W3mInputToken = __decorate$i([
  customElement("w3m-input-token")
], W3mInputToken);
const styles$6 = i$2`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  .paste {
    display: inline-flex;
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;
var __decorate$h = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mInputAddress = class W3mInputAddress2 extends h {
  constructor() {
    super(...arguments);
    this.inputElementRef = ii();
    this.instructionElementRef = ii();
    this.instructionHidden = Boolean(this.value);
    this.pasting = false;
    this.onDebouncedSearch = CoreHelperUtil.debounce(async (value2) => {
      const address = await ConnectionController.getEnsAddress(value2);
      SendController.setLoading(false);
      if (address) {
        SendController.setReceiverProfileName(value2);
        SendController.setReceiverAddress(address);
        const avatar = await ConnectionController.getEnsAvatar(value2);
        if (avatar) {
          SendController.setReceiverProfileImageUrl(avatar);
        }
      } else {
        SendController.setReceiverAddress(value2);
        SendController.setReceiverProfileName(void 0);
        SendController.setReceiverProfileImageUrl(void 0);
      }
    });
  }
  firstUpdated() {
    if (this.value) {
      this.instructionHidden = true;
    }
    this.checkHidden();
  }
  render() {
    return ke$1` <wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${["2xl", "l", "xl", "l"]}
    >
      <wui-text
        ${Kt$1(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <wui-button
          class="paste"
          size="md"
          variant="neutral"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></wui-icon>
          Paste
        </wui-button>
        address
      </wui-text>
      <textarea
        spellcheck="false"
        ?disabled=${!this.instructionHidden}
        ${Kt$1(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.value ?? ""}
        autocomplete="off"
      >
${this.value ?? ""}</textarea
      >
    </wui-flex>`;
  }
  async focusInput() {
    var _a2;
    if (this.instructionElementRef.value) {
      this.instructionHidden = true;
      await this.toggleInstructionFocus(false);
      this.instructionElementRef.value.style.pointerEvents = "none";
      (_a2 = this.inputElementRef.value) == null ? void 0 : _a2.focus();
      if (this.inputElementRef.value) {
        this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd = this.inputElementRef.value.value.length;
      }
    }
  }
  async focusInstruction() {
    var _a2;
    if (this.instructionElementRef.value) {
      this.instructionHidden = false;
      await this.toggleInstructionFocus(true);
      this.instructionElementRef.value.style.pointerEvents = "auto";
      (_a2 = this.inputElementRef.value) == null ? void 0 : _a2.blur();
    }
  }
  async toggleInstructionFocus(focus2) {
    if (this.instructionElementRef.value) {
      await this.instructionElementRef.value.animate([{ opacity: focus2 ? 0 : 1 }, { opacity: focus2 ? 1 : 0 }], {
        duration: 100,
        easing: "ease",
        fill: "forwards"
      }).finished;
    }
  }
  onBoxClick() {
    if (!this.value && !this.instructionHidden) {
      this.focusInput();
    }
  }
  onBlur() {
    if (!this.value && this.instructionHidden && !this.pasting) {
      this.focusInstruction();
    }
  }
  checkHidden() {
    if (this.instructionHidden) {
      this.focusInput();
    }
  }
  async onPasteClick() {
    this.pasting = true;
    const text = await navigator.clipboard.readText();
    SendController.setReceiverAddress(text);
    this.focusInput();
  }
  onInputChange(e2) {
    this.pasting = false;
    const element = e2.target;
    if (element.value && !this.instructionHidden) {
      this.focusInput();
    }
    SendController.setLoading(true);
    this.onDebouncedSearch(element.value);
  }
};
W3mInputAddress.styles = styles$6;
__decorate$h([
  n2()
], W3mInputAddress.prototype, "value", void 0);
__decorate$h([
  r$1()
], W3mInputAddress.prototype, "instructionHidden", void 0);
__decorate$h([
  r$1()
], W3mInputAddress.prototype, "pasting", void 0);
W3mInputAddress = __decorate$h([
  customElement("w3m-input-address")
], W3mInputAddress);
const styles$5 = i$2`
  :host {
    display: flex;
    width: auto;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .network:active {
    background-color: var(--wui-color-gray-glass-010);
  }
`;
var __decorate$g = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletSendDetails = class W3mWalletSendDetails2 extends h {
  render() {
    return ke$1` <wui-text variant="small-400" color="fg-200">Details</wui-text>
      <wui-flex flexDirection="column" gap="xxs">
        <wui-list-content textTitle="Network cost" textValue="$${to(UiHelperUtil.formatNumberToLocalString(this.networkFee, 2))}"></wui-list-content></wui-list-content>
        <wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
      string: this.receiverAddress ?? "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
        >
        </wui-list-content>
        ${this.networkTemplate()}
      </wui-flex>`;
  }
  networkTemplate() {
    var _a2;
    if ((_a2 = this.caipNetwork) == null ? void 0 : _a2.name) {
      return ke$1` <wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${to(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></wui-list-content>`;
    }
    return null;
  }
  onNetworkClick(network) {
    if (network) {
      RouterController.push("Networks", { network });
    }
  }
};
W3mWalletSendDetails.styles = styles$5;
__decorate$g([
  n2()
], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
__decorate$g([
  n2({ type: Object })
], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
__decorate$g([
  n2({ type: Number })
], W3mWalletSendDetails.prototype, "networkFee", void 0);
W3mWalletSendDetails = __decorate$g([
  customElement("w3m-wallet-send-details")
], W3mWalletSendDetails);
const styles$4 = i$2`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$f = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mTooltip = class W3mTooltip2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = TooltipController.state.open;
    this.message = TooltipController.state.message;
    this.triggerRect = TooltipController.state.triggerRect;
    this.variant = TooltipController.state.variant;
    this.unsubscribe.push(...[
      TooltipController.subscribe((newState) => {
        this.open = newState.open;
        this.message = newState.message;
        this.triggerRect = newState.triggerRect;
        this.variant = newState.variant;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.dataset["variant"] = this.variant;
    const topValue = this.triggerRect.top;
    const leftValue = this.triggerRect.left;
    this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
    return ke$1`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`;
  }
};
W3mTooltip.styles = [styles$4];
__decorate$f([
  r$1()
], W3mTooltip.prototype, "open", void 0);
__decorate$f([
  r$1()
], W3mTooltip.prototype, "message", void 0);
__decorate$f([
  r$1()
], W3mTooltip.prototype, "triggerRect", void 0);
__decorate$f([
  r$1()
], W3mTooltip.prototype, "variant", void 0);
W3mTooltip = __decorate$f([
  customElement("w3m-tooltip")
], W3mTooltip);
const styles$3 = i$2`
  :host {
    width: 100%;
    display: block;
  }
`;
var __decorate$e = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let WuiTooltipTrigger = class WuiTooltipTrigger2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.text = "";
    this.open = TooltipController.state.open;
    this.unsubscribe.push(RouterController.subscribeKey("view", () => {
      TooltipController.hide();
    }), ModalController.subscribeKey("open", (modalOpen) => {
      if (!modalOpen) {
        TooltipController.hide();
      }
    }), TooltipController.subscribeKey("open", (tooltipOpen) => {
      this.open = tooltipOpen;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    TooltipController.hide();
  }
  render() {
    return ke$1`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
  }
  renderChildren() {
    return ke$1`<slot></slot> `;
  }
  onMouseEnter() {
    const rect = this.getBoundingClientRect();
    if (!this.open) {
      TooltipController.showTooltip({
        message: this.text,
        triggerRect: {
          width: rect.width,
          height: rect.height,
          left: rect.left,
          top: rect.top
        },
        variant: "shade"
      });
    }
  }
  onMouseLeave(event) {
    if (!this.contains(event.relatedTarget)) {
      TooltipController.hide();
    }
  }
};
WuiTooltipTrigger.styles = [styles$3];
__decorate$e([
  n2()
], WuiTooltipTrigger.prototype, "text", void 0);
__decorate$e([
  r$1()
], WuiTooltipTrigger.prototype, "open", void 0);
WuiTooltipTrigger = __decorate$e([
  customElement("w3m-tooltip-trigger")
], WuiTooltipTrigger);
const styles$2 = i$2`
  :host > wui-flex:first-child {
    margin-top: var(--wui-spacing-s);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-m)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$d = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const MAX_TOP_VIEW = 2;
const MAXIMUM_LENGTH = 6;
let W3mSocialLoginWidget = class W3mSocialLoginWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    if (!((_a2 = this.connector) == null ? void 0 : _a2.socials)) {
      return null;
    }
    return ke$1`
      <wui-flex
        class="container"
        flexDirection="column"
        gap="xs"
        .padding=${["0", "0", "xs", "0"]}
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  topViewTemplate() {
    var _a2, _b2, _c2;
    if (!((_a2 = this.connector) == null ? void 0 : _a2.socials)) {
      return null;
    }
    if (this.connector.socials.length === 2) {
      return ke$1` <wui-flex gap="xs">
        ${this.connector.socials.slice(0, MAX_TOP_VIEW).map((social) => ke$1`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
      </wui-flex>`;
    }
    return ke$1` <wui-list-social
      data-testid=${`social-selector-${(_c2 = (_b2 = this.connector) == null ? void 0 : _b2.socials) == null ? void 0 : _c2[0]}`}
      @click=${() => {
      var _a3, _b3;
      this.onSocialClick((_b3 = (_a3 = this.connector) == null ? void 0 : _a3.socials) == null ? void 0 : _b3[0]);
    }}
      logo=${to(this.connector.socials[0])}
      align="center"
      name=${`Continue with ${this.connector.socials[0]}`}
    ></wui-list-social>`;
  }
  bottomViewTemplate() {
    var _a2, _b2, _c2;
    if (!((_a2 = this.connector) == null ? void 0 : _a2.socials)) {
      return null;
    }
    if (((_b2 = this.connector) == null ? void 0 : _b2.socials.length) <= MAX_TOP_VIEW) {
      return null;
    }
    if (((_c2 = this.connector) == null ? void 0 : _c2.socials.length) > MAXIMUM_LENGTH) {
      return ke$1`<wui-flex gap="xs">
        ${this.connector.socials.slice(1, MAXIMUM_LENGTH - 1).map((social) => ke$1`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
        <wui-logo-select logo="more" @click=${this.onMoreSocialsClick.bind(this)}></wui-logo-select>
      </wui-flex>`;
    }
    return ke$1`<wui-flex gap="xs">
      ${this.connector.socials.slice(1, this.connector.socials.length).map((social) => ke$1`<wui-logo-select
            data-testid=${`social-selector-${social}`}
            @click=${() => {
      this.onSocialClick(social);
    }}
            logo=${social}
          ></wui-logo-select>`)}
    </wui-flex>`;
  }
  separatorTemplate() {
    const walletConnectConnector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (walletConnectConnector) {
      return ke$1`<wui-separator text="or"></wui-separator>`;
    }
    return null;
  }
  onMoreSocialsClick() {
    RouterController.push("ConnectSocials");
  }
  async onSocialClick(socialProvider) {
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
      RouterController.push("ConnectingSocial");
    }
    const authConnector = ConnectorController.getAuthConnector();
    if (CoreHelperUtil.isMobile()) {
      this.mobileWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
    }
    try {
      if (authConnector && socialProvider) {
        const { uri } = await authConnector.provider.getSocialRedirectUri({
          provider: socialProvider
        });
        if (!CoreHelperUtil.isMobile()) {
          this.desktopWindow = CoreHelperUtil.returnOpenHref(uri, "popupWindow", "width=600,height=800,scrollbars=yes");
        }
        if (this.desktopWindow && uri) {
          AccountController.setSocialWindow(this.desktopWindow);
        } else if (this.mobileWindow && uri) {
          this.mobileWindow.location.href = uri;
          AccountController.setSocialWindow(this.mobileWindow);
        } else {
          throw new Error("Something went wrong");
        }
      }
    } catch (error) {
      SnackController.showError("Something went wrong");
    }
  }
};
W3mSocialLoginWidget.styles = styles$2;
__decorate$d([
  r$1()
], W3mSocialLoginWidget.prototype, "connectors", void 0);
W3mSocialLoginWidget = __decorate$d([
  customElement("w3m-social-login-widget")
], W3mSocialLoginWidget);
const styles$1 = i$2`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$c = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mWalletLoginList = class W3mWalletLoginList2 extends h {
  render() {
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        <w3m-connect-walletconnect-widget></w3m-connect-walletconnect-widget>
        <w3m-connect-recent-widget></w3m-connect-recent-widget>
        <w3m-connect-announced-widget></w3m-connect-announced-widget>
        <w3m-connect-injected-widget></w3m-connect-injected-widget>
        <w3m-connect-featured-widget></w3m-connect-featured-widget>
        <w3m-connect-custom-widget></w3m-connect-custom-widget>
        <w3m-connect-coinbase-widget></w3m-connect-coinbase-widget>
        <w3m-connect-recommended-widget></w3m-connect-recommended-widget>
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>
    `;
  }
};
W3mWalletLoginList.styles = styles$1;
W3mWalletLoginList = __decorate$c([
  customElement("w3m-wallet-login-list")
], W3mWalletLoginList);
const styles = i$2`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$b = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mSocialLoginList = class W3mSocialLoginList2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    if (!((_a2 = this.connector) == null ? void 0 : _a2.socials)) {
      return null;
    }
    return ke$1` <wui-flex flexDirection="column" gap="xs">
      ${this.connector.socials.map((social) => ke$1`<wui-list-social name=${social} logo=${social}></wui-list-social>`)}
    </wui-flex>`;
  }
};
W3mSocialLoginList.styles = styles;
__decorate$b([
  r$1()
], W3mSocialLoginList.prototype, "connectors", void 0);
W3mSocialLoginList = __decorate$b([
  customElement("w3m-social-login-list")
], W3mSocialLoginList);
var __decorate$a = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    if (!(announcedConnectors == null ? void 0 : announcedConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.map((connector) => ke$1`
            <wui-list-wallet
              imageSrc=${to(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate$a([
  r$1()
], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
W3mConnectAnnouncedWidget = __decorate$a([
  customElement("w3m-connect-announced-widget")
], W3mConnectAnnouncedWidget);
var __decorate$9 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { customWallets } = OptionsController.state;
    if (!(customWallets == null ? void 0 : customWallets.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return ke$1`<wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => ke$1`
          <wui-list-wallet
            imageSrc=${to(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
          >
          </wui-list-wallet>
        `)}
    </wui-flex>`;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a2;
      return (_a2 = connector.info) == null ? void 0 : _a2.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate$9([
  r$1()
], W3mConnectCustomWidget.prototype, "connectors", void 0);
W3mConnectCustomWidget = __decorate$9([
  customElement("w3m-connect-custom-widget")
], W3mConnectCustomWidget);
var __decorate$8 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { featured } = ApiController.state;
    if (!featured.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(featured);
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => ke$1`
            <wui-list-wallet
              imageSrc=${to(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a2;
      return (_a2 = connector.info) == null ? void 0 : _a2.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate$8([
  r$1()
], W3mConnectFeaturedWidget.prototype, "connectors", void 0);
W3mConnectFeaturedWidget = __decorate$8([
  customElement("w3m-connect-featured-widget")
], W3mConnectFeaturedWidget);
var __decorate$7 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    const injectedConnectors = this.connectors.filter((connector) => connector.type === "INJECTED");
    if (!(injectedConnectors == null ? void 0 : injectedConnectors.length) || injectedConnectors.length === 1 && ((_a2 = injectedConnectors[0]) == null ? void 0 : _a2.name) === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return null;
      }
      if (!ConnectionController.checkInstalled()) {
        return null;
      }
      return ke$1`
            <wui-list-wallet
              imageSrc=${to(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate$7([
  r$1()
], W3mConnectInjectedWidget.prototype, "connectors", void 0);
W3mConnectInjectedWidget = __decorate$7([
  customElement("w3m-connect-injected-widget")
], W3mConnectInjectedWidget);
var __decorate$6 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectCoinbaseWidget = class W3mConnectCoinbaseWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const coinbaseConnector = this.connectors.find((connector) => connector.id === "coinbaseWalletSDK");
    if (!coinbaseConnector) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        <wui-list-wallet
          imageSrc=${to(AssetUtil.getConnectorImage(coinbaseConnector))}
          .installed=${true}
          name=${to(coinbaseConnector.name)}
          data-testid=${`wallet-selector-${coinbaseConnector.id}`}
          @click=${() => this.onConnector(coinbaseConnector)}
        >
        </wui-list-wallet>
      </wui-flex>
    `;
  }
  async onCoinbaseConnector(connector) {
    try {
      ConnectionController.setWcError(false);
      if (connector.imageUrl) {
        StorageUtil.setConnectedWalletImageUrl(connector.imageUrl);
      }
      await ConnectionController.connectExternal(connector);
      if (OptionsController.state.isSiweEnabled) {
        RouterController.push("ConnectingSiwe");
      } else {
        ModalController.close();
      }
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser", name: connector.name || "Unknown" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
    }
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
    if (connector.id === ConstantsUtil$1.COINBASE_SDK_CONNECTOR_ID) {
      this.onCoinbaseConnector(connector);
    }
  }
};
__decorate$6([
  r$1()
], W3mConnectCoinbaseWidget.prototype, "connectors", void 0);
W3mConnectCoinbaseWidget = __decorate$6([
  customElement("w3m-connect-coinbase-widget")
], W3mConnectCoinbaseWidget);
var __decorate$5 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends h {
  render() {
    const recent = StorageUtil.getRecentWallets();
    if (!(recent == null ? void 0 : recent.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        ${recent.map((wallet) => ke$1`
            <wui-list-wallet
              imageSrc=${to(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectRecentWidget = __decorate$5([
  customElement("w3m-connect-recent-widget")
], W3mConnectRecentWidget);
var __decorate$4 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected = connectors.filter((c2) => c2.type === "INJECTED" || c2.type === "ANNOUNCED");
    const injectedWallets = injected.filter((i2) => i2.name !== "Browser Wallet");
    if (featuredWalletIds || customWallets || !recommended.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const overrideLength = injectedWallets.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = this.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    if (!wallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => ke$1`
            <wui-list-wallet
              imageSrc=${to(AssetUtil.getWalletImage(wallet))}
              name=${(wallet == null ? void 0 : wallet.name) ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a2;
      return (_a2 = connector.info) == null ? void 0 : _a2.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate$4([
  r$1()
], W3mConnectRecommendedWidget.prototype, "connectors", void 0);
W3mConnectRecommendedWidget = __decorate$4([
  customElement("w3m-connect-recommended-widget")
], W3mConnectRecommendedWidget);
var __decorate$3 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      this.style.cssText = `display: none`;
      return null;
    }
    return ke$1`
      <wui-list-wallet
        imageSrc=${to(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate$3([
  r$1()
], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
W3mConnectWalletConnectWidget = __decorate$3([
  customElement("w3m-connect-walletconnect-widget")
], W3mConnectWalletConnectWidget);
var __decorate$2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends h {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.count = ApiController.state.count;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("count", (val) => this.count = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    const { allWallets } = OptionsController.state;
    if (!connector || allWallets === "HIDE") {
      return null;
    }
    if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
      return null;
    }
    const featuredCount = ApiController.state.featured.length;
    const rawCount = this.count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return ke$1`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
};
__decorate$2([
  r$1()
], W3mAllWalletsWidget.prototype, "connectors", void 0);
__decorate$2([
  r$1()
], W3mAllWalletsWidget.prototype, "count", void 0);
W3mAllWalletsWidget = __decorate$2([
  customElement("w3m-all-wallets-widget")
], W3mAllWalletsWidget);
var __decorate$1 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let W3mAccountAuthButton = class W3mAccountAuthButton2 extends h {
  constructor() {
    super(...arguments);
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.socialUsername = StorageUtil.getConnectedSocialUsername();
  }
  render() {
    const type3 = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type3 !== "AUTH") {
      this.style.cssText = `display: none`;
      return null;
    }
    const email = authConnector.provider.getEmail() ?? "";
    return ke$1`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon=${this.socialProvider ?? "mail"}
        iconSize=${this.socialProvider ? "xxl" : "sm"}
        data-testid="w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
      this.onGoToUpdateEmail(email, this.socialProvider);
    }}
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.getAuthName(email)}</wui-text>
      </wui-list-item>
    `;
  }
  onGoToUpdateEmail(email, socialProvider) {
    if (!socialProvider) {
      RouterController.push("UpdateEmailWallet", { email });
    }
  }
  getAuthName(email) {
    if (this.socialUsername) {
      if (this.socialProvider === "discord" && this.socialUsername.endsWith("0")) {
        return this.socialUsername.slice(0, -1);
      }
      return this.socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  }
};
W3mAccountAuthButton = __decorate$1([
  customElement("w3m-account-auth-button")
], W3mAccountAuthButton);
var WalletAdapterNetwork;
(function(WalletAdapterNetwork2) {
  WalletAdapterNetwork2["Mainnet"] = "mainnet-beta";
  WalletAdapterNetwork2["Testnet"] = "testnet";
  WalletAdapterNetwork2["Devnet"] = "devnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));
const SolConstantsUtil = {
  HASH_PREFIX: "SPL Name Service",
  ROOT_DOMAIN_ACCOUNT: new PublicKey2("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx"),
  NAME_PROGRAM_ID: new PublicKey2("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"),
  REVERSE_LOOKUP_CLASS: new PublicKey2("33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z"),
  WALLET_ID: "@w3m/solana_wallet",
  CAIP_CHAIN_ID: "@w3m/solana_caip_chain",
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  DEFAULT_CHAIN: {
    chainId: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    name: "Solana",
    currency: "SOL",
    explorerUrl: "https://solscan.io",
    rpcUrl: `${ConstantsUtil$3.BLOCKCHAIN_API_RPC_URL}/v1`
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (b3.hasOwnProperty(p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2) if (p2 !== "default" && !exports.hasOwnProperty(p2)) exports[p2] = m2[p2];
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n3) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n3) {
    if (g2[n3]) i2[n3] = function(v2) {
      return new Promise(function(a2, b2) {
        q3.push([n3, v2, a2, b2]) > 1 || resume(n3, v2);
      });
    };
  }
  function resume(n3, v2) {
    try {
      step(g2[n3](v2));
    } catch (e2) {
      settle(q3[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q3[0][2], r2);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f2, v2) {
    if (f2(v2), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n3, f2) {
    i2[n3] = o2[n3] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n3](v2)), done: n3 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n3) {
    i2[n3] = o2[n3] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n3](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2) if (Object.hasOwnProperty.call(mod2, k2)) result[k2] = mod2[k2];
  }
  result.default = mod2;
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value2) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value2);
  return value2;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
function tryStringify(o2) {
  try {
    return JSON.stringify(o2);
  } catch (e2) {
    return '"[Circular]"';
  }
}
var quickFormatUnescaped = format$1;
function format$1(f2, args, opts) {
  var ss = opts && opts.stringify || tryStringify;
  var offset2 = 1;
  if (typeof f2 === "object" && f2 !== null) {
    var len = args.length + offset2;
    if (len === 1) return f2;
    var objects = new Array(len);
    objects[0] = ss(f2);
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index]);
    }
    return objects.join(" ");
  }
  if (typeof f2 !== "string") {
    return f2;
  }
  var argLen = args.length;
  if (argLen === 0) return f2;
  var str = "";
  var a2 = 1 - offset2;
  var lastPos = -1;
  var flen = f2 && f2.length || 0;
  for (var i2 = 0; i2 < flen; ) {
    if (f2.charCodeAt(i2) === 37 && i2 + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0;
      switch (f2.charCodeAt(i2 + 1)) {
        case 100:
        case 102:
          if (a2 >= argLen)
            break;
          if (args[a2] == null) break;
          if (lastPos < i2)
            str += f2.slice(lastPos, i2);
          str += Number(args[a2]);
          lastPos = i2 + 2;
          i2++;
          break;
        case 105:
          if (a2 >= argLen)
            break;
          if (args[a2] == null) break;
          if (lastPos < i2)
            str += f2.slice(lastPos, i2);
          str += Math.floor(Number(args[a2]));
          lastPos = i2 + 2;
          i2++;
          break;
        case 79:
        case 111:
        case 106:
          if (a2 >= argLen)
            break;
          if (args[a2] === void 0) break;
          if (lastPos < i2)
            str += f2.slice(lastPos, i2);
          var type3 = typeof args[a2];
          if (type3 === "string") {
            str += "'" + args[a2] + "'";
            lastPos = i2 + 2;
            i2++;
            break;
          }
          if (type3 === "function") {
            str += args[a2].name || "<anonymous>";
            lastPos = i2 + 2;
            i2++;
            break;
          }
          str += ss(args[a2]);
          lastPos = i2 + 2;
          i2++;
          break;
        case 115:
          if (a2 >= argLen)
            break;
          if (lastPos < i2)
            str += f2.slice(lastPos, i2);
          str += String(args[a2]);
          lastPos = i2 + 2;
          i2++;
          break;
        case 37:
          if (lastPos < i2)
            str += f2.slice(lastPos, i2);
          str += "%";
          lastPos = i2 + 2;
          i2++;
          a2--;
          break;
      }
      ++a2;
    }
    ++i2;
  }
  if (lastPos === -1)
    return f2;
  else if (lastPos < flen) {
    str += f2.slice(lastPos);
  }
  return str;
}
const format = quickFormatUnescaped;
const _console = pfGlobalThisOrFallback().console || {};
const stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
};
function shouldSerialize(serialize2, serializers) {
  if (Array.isArray(serialize2)) {
    const hasToFilter = serialize2.filter(function(k2) {
      return k2 !== "!stdSerializers.err";
    });
    return hasToFilter;
  } else if (serialize2 === true) {
    return Object.keys(serializers);
  }
  return false;
}
function pino(opts) {
  opts = opts || {};
  opts.browser = opts.browser || {};
  const transmit2 = opts.browser.transmit;
  if (transmit2 && typeof transmit2.send !== "function") {
    throw Error("pino: transmit option must have a send function");
  }
  const proto = opts.browser.write || _console;
  if (opts.browser.write) opts.browser.asObject = true;
  const serializers = opts.serializers || {};
  const serialize2 = shouldSerialize(opts.browser.serialize, serializers);
  let stdErrSerialize = opts.browser.serialize;
  if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
  const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
  if (typeof proto === "function") {
    proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
  }
  if (opts.enabled === false) opts.level = "silent";
  const level = opts.level || "info";
  const logger2 = Object.create(proto);
  if (!logger2.log) logger2.log = noop;
  Object.defineProperty(logger2, "levelVal", {
    get: getLevelVal
  });
  Object.defineProperty(logger2, "level", {
    get: getLevel,
    set: setLevel
  });
  const setOpts = {
    transmit: transmit2,
    serialize: serialize2,
    asObject: opts.browser.asObject,
    levels,
    timestamp: getTimeFunction(opts)
  };
  logger2.levels = pino.levels;
  logger2.level = level;
  logger2.setMaxListeners = logger2.getMaxListeners = logger2.emit = logger2.addListener = logger2.on = logger2.prependListener = logger2.once = logger2.prependOnceListener = logger2.removeListener = logger2.removeAllListeners = logger2.listeners = logger2.listenerCount = logger2.eventNames = logger2.write = logger2.flush = noop;
  logger2.serializers = serializers;
  logger2._serialize = serialize2;
  logger2._stdErrSerialize = stdErrSerialize;
  logger2.child = child;
  if (transmit2) logger2._logEvent = createLogEventShape();
  function getLevelVal() {
    return this.level === "silent" ? Infinity : this.levels.values[this.level];
  }
  function getLevel() {
    return this._level;
  }
  function setLevel(level2) {
    if (level2 !== "silent" && !this.levels.values[level2]) {
      throw Error("unknown level " + level2);
    }
    this._level = level2;
    set(setOpts, logger2, "error", "log");
    set(setOpts, logger2, "fatal", "error");
    set(setOpts, logger2, "warn", "error");
    set(setOpts, logger2, "info", "log");
    set(setOpts, logger2, "debug", "log");
    set(setOpts, logger2, "trace", "log");
  }
  function child(bindings, childOptions) {
    if (!bindings) {
      throw new Error("missing bindings for child Pino");
    }
    childOptions = childOptions || {};
    if (serialize2 && bindings.serializers) {
      childOptions.serializers = bindings.serializers;
    }
    const childOptionsSerializers = childOptions.serializers;
    if (serialize2 && childOptionsSerializers) {
      var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
      var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize2;
      delete bindings.serializers;
      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
    }
    function Child(parent) {
      this._childLevel = (parent._childLevel | 0) + 1;
      this.error = bind(parent, bindings, "error");
      this.fatal = bind(parent, bindings, "fatal");
      this.warn = bind(parent, bindings, "warn");
      this.info = bind(parent, bindings, "info");
      this.debug = bind(parent, bindings, "debug");
      this.trace = bind(parent, bindings, "trace");
      if (childSerializers) {
        this.serializers = childSerializers;
        this._serialize = childSerialize;
      }
      if (transmit2) {
        this._logEvent = createLogEventShape(
          [].concat(parent._logEvent.bindings, bindings)
        );
      }
    }
    Child.prototype = this;
    return new Child(this);
  }
  return logger2;
}
pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
function set(opts, logger2, level, fallback) {
  const proto = Object.getPrototypeOf(logger2);
  logger2[level] = logger2.levelVal > logger2.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
  wrap(opts, logger2, level);
}
function wrap(opts, logger2, level) {
  if (!opts.transmit && logger2[level] === noop) return;
  logger2[level] = /* @__PURE__ */ function(write3) {
    return function LOG() {
      const ts = opts.timestamp();
      const args = new Array(arguments.length);
      const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
      for (var i2 = 0; i2 < args.length; i2++) args[i2] = arguments[i2];
      if (opts.serialize && !opts.asObject) {
        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
      }
      if (opts.asObject) write3.call(proto, asObject(this, level, args, ts));
      else write3.apply(proto, args);
      if (opts.transmit) {
        const transmitLevel = opts.transmit.level || logger2.level;
        const transmitValue = pino.levels.values[transmitLevel];
        const methodValue = pino.levels.values[level];
        if (methodValue < transmitValue) return;
        transmit(this, {
          ts,
          methodLevel: level,
          methodValue,
          transmitLevel,
          transmitValue: pino.levels.values[opts.transmit.level || logger2.level],
          send: opts.transmit.send,
          val: logger2.levelVal
        }, args);
      }
    };
  }(logger2[level]);
}
function asObject(logger2, level, args, ts) {
  if (logger2._serialize) applySerializers(args, logger2._serialize, logger2.serializers, logger2._stdErrSerialize);
  const argsCloned = args.slice();
  let msg = argsCloned[0];
  const o2 = {};
  if (ts) {
    o2.time = ts;
  }
  o2.level = pino.levels.values[level];
  let lvl = (logger2._childLevel | 0) + 1;
  if (lvl < 1) lvl = 1;
  if (msg !== null && typeof msg === "object") {
    while (lvl-- && typeof argsCloned[0] === "object") {
      Object.assign(o2, argsCloned.shift());
    }
    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
  } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
  if (msg !== void 0) o2.msg = msg;
  return o2;
}
function applySerializers(args, serialize2, serializers, stdErrSerialize) {
  for (const i2 in args) {
    if (stdErrSerialize && args[i2] instanceof Error) {
      args[i2] = pino.stdSerializers.err(args[i2]);
    } else if (typeof args[i2] === "object" && !Array.isArray(args[i2])) {
      for (const k2 in args[i2]) {
        if (serialize2 && serialize2.indexOf(k2) > -1 && k2 in serializers) {
          args[i2][k2] = serializers[k2](args[i2][k2]);
        }
      }
    }
  }
}
function bind(parent, bindings, level) {
  return function() {
    const args = new Array(1 + arguments.length);
    args[0] = bindings;
    for (var i2 = 1; i2 < args.length; i2++) {
      args[i2] = arguments[i2 - 1];
    }
    return parent[level].apply(this, args);
  };
}
function transmit(logger2, opts, args) {
  const send = opts.send;
  const ts = opts.ts;
  const methodLevel = opts.methodLevel;
  const methodValue = opts.methodValue;
  const val = opts.val;
  const bindings = logger2._logEvent.bindings;
  applySerializers(
    args,
    logger2._serialize || Object.keys(logger2.serializers),
    logger2.serializers,
    logger2._stdErrSerialize === void 0 ? true : logger2._stdErrSerialize
  );
  logger2._logEvent.ts = ts;
  logger2._logEvent.messages = args.filter(function(arg) {
    return bindings.indexOf(arg) === -1;
  });
  logger2._logEvent.level.label = methodLevel;
  logger2._logEvent.level.value = methodValue;
  send(methodLevel, logger2._logEvent, val);
  logger2._logEvent = createLogEventShape(bindings);
}
function createLogEventShape(bindings) {
  return {
    ts: 0,
    messages: [],
    bindings: bindings || [],
    level: { label: "", value: 0 }
  };
}
function asErrValue(err) {
  const obj = {
    type: err.constructor.name,
    msg: err.message,
    stack: err.stack
  };
  for (const key in err) {
    if (obj[key] === void 0) {
      obj[key] = err[key];
    }
  }
  return obj;
}
function getTimeFunction(opts) {
  if (typeof opts.timestamp === "function") {
    return opts.timestamp;
  }
  if (opts.timestamp === false) {
    return nullTime;
  }
  return epochTime;
}
function mock() {
  return {};
}
function passthrough(a2) {
  return a2;
}
function noop() {
}
function nullTime() {
  return false;
}
function epochTime() {
  return Date.now();
}
function unixTime() {
  return Math.round(Date.now() / 1e3);
}
function isoTime() {
  return new Date(Date.now()).toISOString();
}
function pfGlobalThisOrFallback() {
  function defd(o2) {
    return typeof o2 !== "undefined" && o2;
  }
  try {
    if (typeof globalThis !== "undefined") return globalThis;
    Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        delete Object.prototype.globalThis;
        return this.globalThis = this;
      },
      configurable: true
    });
    return globalThis;
  } catch (e2) {
    return defd(self) || defd(window) || defd(this) || {};
  }
}
var cjs = {};
var crypto$2 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$2;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$2, "__esModule", { value: true });
  crypto$2.isBrowserCryptoAvailable = crypto$2.getSubtleCrypto = crypto$2.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$2.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$2.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$2;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative2() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative2;
  function isNode2() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }
  env.isNode = isNode2;
  function isBrowser2() {
    return !isReactNative2() && !isNode2();
  }
  env.isBrowser = isBrowser2;
  return env;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_12 = require$$0;
  tslib_12.__exportStar(requireCrypto(), exports);
  tslib_12.__exportStar(requireEnv(), exports);
})(cjs);
var ge$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ui = { exports: {} };
/**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
(function(A2, u2) {
  (function() {
    var i2, d2 = "4.17.21", w2 = 200, L2 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", D2 = "Expected a function", En2 = "Invalid `variable` option passed into `_.template`", zt2 = "__lodash_hash_undefined__", pr2 = 500, It2 = "__lodash_placeholder__", Ln = 1, Fn = 2, xt2 = 4, Et2 = 1, ve2 = 2, vn2 = 1, ct2 = 2, qi2 = 4, Dn = 8, yt2 = 16, Hn2 = 32, St2 = 64, Mn = 128, Kt2 = 256, dr2 = 512, Da2 = 30, Ha2 = "...", Na2 = 800, $a = 16, Bi2 = 1, Ua2 = 2, Wa2 = 3, ht2 = 1 / 0, kn2 = 9007199254740991, Fa2 = 17976931348623157e292, _e3 = 0 / 0, Nn2 = 4294967295, Ma2 = Nn2 - 1, qa2 = Nn2 >>> 1, Ba2 = [["ary", Mn], ["bind", vn2], ["bindKey", ct2], ["curry", Dn], ["curryRight", yt2], ["flip", dr2], ["partial", Hn2], ["partialRight", St2], ["rearg", Kt2]], Ot2 = "[object Arguments]", me2 = "[object Array]", Ga2 = "[object AsyncFunction]", Yt2 = "[object Boolean]", Zt3 = "[object Date]", za2 = "[object DOMException]", we2 = "[object Error]", Pe2 = "[object Function]", Gi2 = "[object GeneratorFunction]", yn = "[object Map]", Jt2 = "[object Number]", Ka2 = "[object Null]", qn = "[object Object]", zi2 = "[object Promise]", Ya2 = "[object Proxy]", Xt2 = "[object RegExp]", Sn2 = "[object Set]", Qt = "[object String]", Ae2 = "[object Symbol]", Za2 = "[object Undefined]", Vt2 = "[object WeakMap]", Ja2 = "[object WeakSet]", kt2 = "[object ArrayBuffer]", Rt2 = "[object DataView]", gr2 = "[object Float32Array]", vr2 = "[object Float64Array]", _r3 = "[object Int8Array]", mr2 = "[object Int16Array]", wr2 = "[object Int32Array]", Pr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Cr2 = "[object Uint16Array]", Ir = "[object Uint32Array]", Xa2 = /\b__p \+= '';/g, Qa2 = /\b(__p \+=) '' \+/g, Va2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ki2 = /&(?:amp|lt|gt|quot|#39);/g, Yi2 = /[&<>"']/g, ka2 = RegExp(Ki2.source), ja2 = RegExp(Yi2.source), no = /<%-([\s\S]+?)%>/g, to2 = /<%([\s\S]+?)%>/g, Zi2 = /<%=([\s\S]+?)%>/g, eo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ro2 = /^\w*$/, io = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xr2 = /[\\^$.*+?()[\]{}|]/g, so = RegExp(xr2.source), Er2 = /^\s+/, uo = /\s/, ao = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, oo = /\{\n\/\* \[wrapped with (.+)\] \*/, fo = /,? & /, co = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, ho = /[()=,{}\[\]\/\s]/, lo = /\\(\\)?/g, po = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ji2 = /\w*$/, go = /^[-+]0x[0-9a-f]+$/i, vo = /^0b[01]+$/i, _o3 = /^\[object .+?Constructor\]$/, mo = /^0o[0-7]+$/i, wo = /^(?:0|[1-9]\d*)$/, Po2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ce2 = /($^)/, Ao = /['\n\r\u2028\u2029\\]/g, Ie2 = "\\ud800-\\udfff", Co = "\\u0300-\\u036f", Io = "\\ufe20-\\ufe2f", xo = "\\u20d0-\\u20ff", Xi2 = Co + Io + xo, Qi2 = "\\u2700-\\u27bf", Vi2 = "a-z\\xdf-\\xf6\\xf8-\\xff", Eo = "\\xac\\xb1\\xd7\\xf7", yo = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", So = "\\u2000-\\u206f", Oo2 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ki2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ji2 = "\\ufe0e\\ufe0f", ns = Eo + yo + So + Oo2, yr2 = "['’]", Ro2 = "[" + Ie2 + "]", ts = "[" + ns + "]", xe2 = "[" + Xi2 + "]", es = "\\d+", bo = "[" + Qi2 + "]", rs = "[" + Vi2 + "]", is2 = "[^" + Ie2 + ns + es + Qi2 + Vi2 + ki2 + "]", Sr2 = "\\ud83c[\\udffb-\\udfff]", To2 = "(?:" + xe2 + "|" + Sr2 + ")", ss = "[^" + Ie2 + "]", Or2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rr2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", bt2 = "[" + ki2 + "]", us = "\\u200d", as = "(?:" + rs + "|" + is2 + ")", Lo2 = "(?:" + bt2 + "|" + is2 + ")", os = "(?:" + yr2 + "(?:d|ll|m|re|s|t|ve))?", fs = "(?:" + yr2 + "(?:D|LL|M|RE|S|T|VE))?", cs = To2 + "?", hs = "[" + ji2 + "]?", Do2 = "(?:" + us + "(?:" + [ss, Or2, Rr2].join("|") + ")" + hs + cs + ")*", Ho2 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", No2 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ls = hs + cs + Do2, $o = "(?:" + [bo, Or2, Rr2].join("|") + ")" + ls, Uo2 = "(?:" + [ss + xe2 + "?", xe2, Or2, Rr2, Ro2].join("|") + ")", Wo2 = RegExp(yr2, "g"), Fo2 = RegExp(xe2, "g"), br2 = RegExp(Sr2 + "(?=" + Sr2 + ")|" + Uo2 + ls, "g"), Mo2 = RegExp([bt2 + "?" + rs + "+" + os + "(?=" + [ts, bt2, "$"].join("|") + ")", Lo2 + "+" + fs + "(?=" + [ts, bt2 + as, "$"].join("|") + ")", bt2 + "?" + as + "+" + os, bt2 + "+" + fs, No2, Ho2, es, $o].join("|"), "g"), qo2 = RegExp("[" + us + Ie2 + Xi2 + ji2 + "]"), Bo2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Go2 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], zo2 = -1, B3 = {};
    B3[gr2] = B3[vr2] = B3[_r3] = B3[mr2] = B3[wr2] = B3[Pr2] = B3[Ar2] = B3[Cr2] = B3[Ir] = true, B3[Ot2] = B3[me2] = B3[kt2] = B3[Yt2] = B3[Rt2] = B3[Zt3] = B3[we2] = B3[Pe2] = B3[yn] = B3[Jt2] = B3[qn] = B3[Xt2] = B3[Sn2] = B3[Qt] = B3[Vt2] = false;
    var q3 = {};
    q3[Ot2] = q3[me2] = q3[kt2] = q3[Rt2] = q3[Yt2] = q3[Zt3] = q3[gr2] = q3[vr2] = q3[_r3] = q3[mr2] = q3[wr2] = q3[yn] = q3[Jt2] = q3[qn] = q3[Xt2] = q3[Sn2] = q3[Qt] = q3[Ae2] = q3[Pr2] = q3[Ar2] = q3[Cr2] = q3[Ir] = true, q3[we2] = q3[Pe2] = q3[Vt2] = false;
    var Ko2 = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, Yo = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Zo2 = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Jo2 = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Xo2 = parseFloat, Qo2 = parseInt, ps = typeof ge$1 == "object" && ge$1 && ge$1.Object === Object && ge$1, Vo2 = typeof self == "object" && self && self.Object === Object && self, k2 = ps || Vo2 || Function("return this")(), Tr2 = u2 && !u2.nodeType && u2, lt2 = Tr2 && true && A2 && !A2.nodeType && A2, ds = lt2 && lt2.exports === Tr2, Lr2 = ds && ps.process, _n3 = function() {
      try {
        var h2 = lt2 && lt2.require && lt2.require("util").types;
        return h2 || Lr2 && Lr2.binding && Lr2.binding("util");
      } catch {
      }
    }(), gs = _n3 && _n3.isArrayBuffer, vs = _n3 && _n3.isDate, _s2 = _n3 && _n3.isMap, ms = _n3 && _n3.isRegExp, ws = _n3 && _n3.isSet, Ps = _n3 && _n3.isTypedArray;
    function cn2(h2, g2, p2) {
      switch (p2.length) {
        case 0:
          return h2.call(g2);
        case 1:
          return h2.call(g2, p2[0]);
        case 2:
          return h2.call(g2, p2[0], p2[1]);
        case 3:
          return h2.call(g2, p2[0], p2[1], p2[2]);
      }
      return h2.apply(g2, p2);
    }
    function ko(h2, g2, p2, C2) {
      for (var S2 = -1, U2 = h2 == null ? 0 : h2.length; ++S2 < U2; ) {
        var X2 = h2[S2];
        g2(C2, X2, p2(X2), h2);
      }
      return C2;
    }
    function mn2(h2, g2) {
      for (var p2 = -1, C2 = h2 == null ? 0 : h2.length; ++p2 < C2 && g2(h2[p2], p2, h2) !== false; ) ;
      return h2;
    }
    function jo(h2, g2) {
      for (var p2 = h2 == null ? 0 : h2.length; p2-- && g2(h2[p2], p2, h2) !== false; ) ;
      return h2;
    }
    function As(h2, g2) {
      for (var p2 = -1, C2 = h2 == null ? 0 : h2.length; ++p2 < C2; ) if (!g2(h2[p2], p2, h2)) return false;
      return true;
    }
    function jn2(h2, g2) {
      for (var p2 = -1, C2 = h2 == null ? 0 : h2.length, S2 = 0, U2 = []; ++p2 < C2; ) {
        var X2 = h2[p2];
        g2(X2, p2, h2) && (U2[S2++] = X2);
      }
      return U2;
    }
    function Ee2(h2, g2) {
      var p2 = h2 == null ? 0 : h2.length;
      return !!p2 && Tt2(h2, g2, 0) > -1;
    }
    function Dr2(h2, g2, p2) {
      for (var C2 = -1, S2 = h2 == null ? 0 : h2.length; ++C2 < S2; ) if (p2(g2, h2[C2])) return true;
      return false;
    }
    function G3(h2, g2) {
      for (var p2 = -1, C2 = h2 == null ? 0 : h2.length, S2 = Array(C2); ++p2 < C2; ) S2[p2] = g2(h2[p2], p2, h2);
      return S2;
    }
    function nt2(h2, g2) {
      for (var p2 = -1, C2 = g2.length, S2 = h2.length; ++p2 < C2; ) h2[S2 + p2] = g2[p2];
      return h2;
    }
    function Hr2(h2, g2, p2, C2) {
      var S2 = -1, U2 = h2 == null ? 0 : h2.length;
      for (C2 && U2 && (p2 = h2[++S2]); ++S2 < U2; ) p2 = g2(p2, h2[S2], S2, h2);
      return p2;
    }
    function nf2(h2, g2, p2, C2) {
      var S2 = h2 == null ? 0 : h2.length;
      for (C2 && S2 && (p2 = h2[--S2]); S2--; ) p2 = g2(p2, h2[S2], S2, h2);
      return p2;
    }
    function Nr(h2, g2) {
      for (var p2 = -1, C2 = h2 == null ? 0 : h2.length; ++p2 < C2; ) if (g2(h2[p2], p2, h2)) return true;
      return false;
    }
    var tf2 = $r("length");
    function ef2(h2) {
      return h2.split("");
    }
    function rf2(h2) {
      return h2.match(co) || [];
    }
    function Cs(h2, g2, p2) {
      var C2;
      return p2(h2, function(S2, U2, X2) {
        if (g2(S2, U2, X2)) return C2 = U2, false;
      }), C2;
    }
    function ye2(h2, g2, p2, C2) {
      for (var S2 = h2.length, U2 = p2 + (C2 ? 1 : -1); C2 ? U2-- : ++U2 < S2; ) if (g2(h2[U2], U2, h2)) return U2;
      return -1;
    }
    function Tt2(h2, g2, p2) {
      return g2 === g2 ? vf2(h2, g2, p2) : ye2(h2, Is, p2);
    }
    function sf2(h2, g2, p2, C2) {
      for (var S2 = p2 - 1, U2 = h2.length; ++S2 < U2; ) if (C2(h2[S2], g2)) return S2;
      return -1;
    }
    function Is(h2) {
      return h2 !== h2;
    }
    function xs(h2, g2) {
      var p2 = h2 == null ? 0 : h2.length;
      return p2 ? Wr2(h2, g2) / p2 : _e3;
    }
    function $r(h2) {
      return function(g2) {
        return g2 == null ? i2 : g2[h2];
      };
    }
    function Ur2(h2) {
      return function(g2) {
        return h2 == null ? i2 : h2[g2];
      };
    }
    function Es(h2, g2, p2, C2, S2) {
      return S2(h2, function(U2, X2, M2) {
        p2 = C2 ? (C2 = false, U2) : g2(p2, U2, X2, M2);
      }), p2;
    }
    function uf2(h2, g2) {
      var p2 = h2.length;
      for (h2.sort(g2); p2--; ) h2[p2] = h2[p2].value;
      return h2;
    }
    function Wr2(h2, g2) {
      for (var p2, C2 = -1, S2 = h2.length; ++C2 < S2; ) {
        var U2 = g2(h2[C2]);
        U2 !== i2 && (p2 = p2 === i2 ? U2 : p2 + U2);
      }
      return p2;
    }
    function Fr2(h2, g2) {
      for (var p2 = -1, C2 = Array(h2); ++p2 < h2; ) C2[p2] = g2(p2);
      return C2;
    }
    function af2(h2, g2) {
      return G3(g2, function(p2) {
        return [p2, h2[p2]];
      });
    }
    function ys(h2) {
      return h2 && h2.slice(0, bs(h2) + 1).replace(Er2, "");
    }
    function hn2(h2) {
      return function(g2) {
        return h2(g2);
      };
    }
    function Mr2(h2, g2) {
      return G3(g2, function(p2) {
        return h2[p2];
      });
    }
    function jt2(h2, g2) {
      return h2.has(g2);
    }
    function Ss(h2, g2) {
      for (var p2 = -1, C2 = h2.length; ++p2 < C2 && Tt2(g2, h2[p2], 0) > -1; ) ;
      return p2;
    }
    function Os(h2, g2) {
      for (var p2 = h2.length; p2-- && Tt2(g2, h2[p2], 0) > -1; ) ;
      return p2;
    }
    function of2(h2, g2) {
      for (var p2 = h2.length, C2 = 0; p2--; ) h2[p2] === g2 && ++C2;
      return C2;
    }
    var ff2 = Ur2(Ko2), cf2 = Ur2(Yo);
    function hf(h2) {
      return "\\" + Jo2[h2];
    }
    function lf2(h2, g2) {
      return h2 == null ? i2 : h2[g2];
    }
    function Lt(h2) {
      return qo2.test(h2);
    }
    function pf2(h2) {
      return Bo2.test(h2);
    }
    function df2(h2) {
      for (var g2, p2 = []; !(g2 = h2.next()).done; ) p2.push(g2.value);
      return p2;
    }
    function qr(h2) {
      var g2 = -1, p2 = Array(h2.size);
      return h2.forEach(function(C2, S2) {
        p2[++g2] = [S2, C2];
      }), p2;
    }
    function Rs(h2, g2) {
      return function(p2) {
        return h2(g2(p2));
      };
    }
    function tt2(h2, g2) {
      for (var p2 = -1, C2 = h2.length, S2 = 0, U2 = []; ++p2 < C2; ) {
        var X2 = h2[p2];
        (X2 === g2 || X2 === It2) && (h2[p2] = It2, U2[S2++] = p2);
      }
      return U2;
    }
    function Se2(h2) {
      var g2 = -1, p2 = Array(h2.size);
      return h2.forEach(function(C2) {
        p2[++g2] = C2;
      }), p2;
    }
    function gf(h2) {
      var g2 = -1, p2 = Array(h2.size);
      return h2.forEach(function(C2) {
        p2[++g2] = [C2, C2];
      }), p2;
    }
    function vf2(h2, g2, p2) {
      for (var C2 = p2 - 1, S2 = h2.length; ++C2 < S2; ) if (h2[C2] === g2) return C2;
      return -1;
    }
    function _f2(h2, g2, p2) {
      for (var C2 = p2 + 1; C2--; ) if (h2[C2] === g2) return C2;
      return C2;
    }
    function Dt2(h2) {
      return Lt(h2) ? wf2(h2) : tf2(h2);
    }
    function On(h2) {
      return Lt(h2) ? Pf2(h2) : ef2(h2);
    }
    function bs(h2) {
      for (var g2 = h2.length; g2-- && uo.test(h2.charAt(g2)); ) ;
      return g2;
    }
    var mf2 = Ur2(Zo2);
    function wf2(h2) {
      for (var g2 = br2.lastIndex = 0; br2.test(h2); ) ++g2;
      return g2;
    }
    function Pf2(h2) {
      return h2.match(br2) || [];
    }
    function Af2(h2) {
      return h2.match(Mo2) || [];
    }
    var Cf2 = function h2(g2) {
      g2 = g2 == null ? k2 : Ht2.defaults(k2.Object(), g2, Ht2.pick(k2, Go2));
      var p2 = g2.Array, C2 = g2.Date, S2 = g2.Error, U2 = g2.Function, X2 = g2.Math, M2 = g2.Object, Br2 = g2.RegExp, If2 = g2.String, wn2 = g2.TypeError, Oe2 = p2.prototype, xf2 = U2.prototype, Nt2 = M2.prototype, Re2 = g2["__core-js_shared__"], be2 = xf2.toString, F3 = Nt2.hasOwnProperty, Ef2 = 0, Ts = function() {
        var n3 = /[^.]+$/.exec(Re2 && Re2.keys && Re2.keys.IE_PROTO || "");
        return n3 ? "Symbol(src)_1." + n3 : "";
      }(), Te2 = Nt2.toString, yf2 = be2.call(M2), Sf2 = k2._, Of2 = Br2("^" + be2.call(F3).replace(xr2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Le2 = ds ? g2.Buffer : i2, et3 = g2.Symbol, De2 = g2.Uint8Array, Ls = Le2 ? Le2.allocUnsafe : i2, He2 = Rs(M2.getPrototypeOf, M2), Ds = M2.create, Hs = Nt2.propertyIsEnumerable, Ne2 = Oe2.splice, Ns = et3 ? et3.isConcatSpreadable : i2, ne2 = et3 ? et3.iterator : i2, pt2 = et3 ? et3.toStringTag : i2, $e2 = function() {
        try {
          var n3 = mt2(M2, "defineProperty");
          return n3({}, "", {}), n3;
        } catch {
        }
      }(), Rf2 = g2.clearTimeout !== k2.clearTimeout && g2.clearTimeout, bf2 = C2 && C2.now !== k2.Date.now && C2.now, Tf2 = g2.setTimeout !== k2.setTimeout && g2.setTimeout, Ue2 = X2.ceil, We2 = X2.floor, Gr2 = M2.getOwnPropertySymbols, Lf2 = Le2 ? Le2.isBuffer : i2, $s = g2.isFinite, Df2 = Oe2.join, Hf2 = Rs(M2.keys, M2), Q2 = X2.max, nn2 = X2.min, Nf2 = C2.now, $f2 = g2.parseInt, Us = X2.random, Uf2 = Oe2.reverse, zr2 = mt2(g2, "DataView"), te2 = mt2(g2, "Map"), Kr2 = mt2(g2, "Promise"), $t3 = mt2(g2, "Set"), ee2 = mt2(g2, "WeakMap"), re2 = mt2(M2, "create"), Fe2 = ee2 && new ee2(), Ut = {}, Wf2 = wt2(zr2), Ff2 = wt2(te2), Mf2 = wt2(Kr2), qf2 = wt2($t3), Bf2 = wt2(ee2), Me2 = et3 ? et3.prototype : i2, ie2 = Me2 ? Me2.valueOf : i2, Ws = Me2 ? Me2.toString : i2;
      function a2(n3) {
        if (Y3(n3) && !O2(n3) && !(n3 instanceof N2)) {
          if (n3 instanceof Pn2) return n3;
          if (F3.call(n3, "__wrapped__")) return Fu(n3);
        }
        return new Pn2(n3);
      }
      var Wt2 = /* @__PURE__ */ function() {
        function n3() {
        }
        return function(t2) {
          if (!K3(t2)) return {};
          if (Ds) return Ds(t2);
          n3.prototype = t2;
          var e2 = new n3();
          return n3.prototype = i2, e2;
        };
      }();
      function qe2() {
      }
      function Pn2(n3, t2) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = i2;
      }
      a2.templateSettings = { escape: no, evaluate: to2, interpolate: Zi2, variable: "", imports: { _: a2 } }, a2.prototype = qe2.prototype, a2.prototype.constructor = a2, Pn2.prototype = Wt2(qe2.prototype), Pn2.prototype.constructor = Pn2;
      function N2(n3) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Nn2, this.__views__ = [];
      }
      function Gf2() {
        var n3 = new N2(this.__wrapped__);
        return n3.__actions__ = un2(this.__actions__), n3.__dir__ = this.__dir__, n3.__filtered__ = this.__filtered__, n3.__iteratees__ = un2(this.__iteratees__), n3.__takeCount__ = this.__takeCount__, n3.__views__ = un2(this.__views__), n3;
      }
      function zf2() {
        if (this.__filtered__) {
          var n3 = new N2(this);
          n3.__dir__ = -1, n3.__filtered__ = true;
        } else n3 = this.clone(), n3.__dir__ *= -1;
        return n3;
      }
      function Kf2() {
        var n3 = this.__wrapped__.value(), t2 = this.__dir__, e2 = O2(n3), r2 = t2 < 0, s2 = e2 ? n3.length : 0, o2 = rh2(0, s2, this.__views__), f2 = o2.start, c2 = o2.end, l2 = c2 - f2, v2 = r2 ? c2 : f2 - 1, _2 = this.__iteratees__, m2 = _2.length, P2 = 0, I2 = nn2(l2, this.__takeCount__);
        if (!e2 || !r2 && s2 == l2 && I2 == l2) return ou(n3, this.__actions__);
        var E2 = [];
        n: for (; l2-- && P2 < I2; ) {
          v2 += t2;
          for (var b2 = -1, y2 = n3[v2]; ++b2 < m2; ) {
            var H2 = _2[b2], $2 = H2.iteratee, dn = H2.type, sn2 = $2(y2);
            if (dn == Ua2) y2 = sn2;
            else if (!sn2) {
              if (dn == Bi2) continue n;
              break n;
            }
          }
          E2[P2++] = y2;
        }
        return E2;
      }
      N2.prototype = Wt2(qe2.prototype), N2.prototype.constructor = N2;
      function dt2(n3) {
        var t2 = -1, e2 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n3[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function Yf2() {
        this.__data__ = re2 ? re2(null) : {}, this.size = 0;
      }
      function Zf2(n3) {
        var t2 = this.has(n3) && delete this.__data__[n3];
        return this.size -= t2 ? 1 : 0, t2;
      }
      function Jf2(n3) {
        var t2 = this.__data__;
        if (re2) {
          var e2 = t2[n3];
          return e2 === zt2 ? i2 : e2;
        }
        return F3.call(t2, n3) ? t2[n3] : i2;
      }
      function Xf2(n3) {
        var t2 = this.__data__;
        return re2 ? t2[n3] !== i2 : F3.call(t2, n3);
      }
      function Qf2(n3, t2) {
        var e2 = this.__data__;
        return this.size += this.has(n3) ? 0 : 1, e2[n3] = re2 && t2 === i2 ? zt2 : t2, this;
      }
      dt2.prototype.clear = Yf2, dt2.prototype.delete = Zf2, dt2.prototype.get = Jf2, dt2.prototype.has = Xf2, dt2.prototype.set = Qf2;
      function Bn2(n3) {
        var t2 = -1, e2 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n3[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function Vf2() {
        this.__data__ = [], this.size = 0;
      }
      function kf(n3) {
        var t2 = this.__data__, e2 = Be2(t2, n3);
        if (e2 < 0) return false;
        var r2 = t2.length - 1;
        return e2 == r2 ? t2.pop() : Ne2.call(t2, e2, 1), --this.size, true;
      }
      function jf(n3) {
        var t2 = this.__data__, e2 = Be2(t2, n3);
        return e2 < 0 ? i2 : t2[e2][1];
      }
      function nc2(n3) {
        return Be2(this.__data__, n3) > -1;
      }
      function tc2(n3, t2) {
        var e2 = this.__data__, r2 = Be2(e2, n3);
        return r2 < 0 ? (++this.size, e2.push([n3, t2])) : e2[r2][1] = t2, this;
      }
      Bn2.prototype.clear = Vf2, Bn2.prototype.delete = kf, Bn2.prototype.get = jf, Bn2.prototype.has = nc2, Bn2.prototype.set = tc2;
      function Gn2(n3) {
        var t2 = -1, e2 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n3[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function ec2() {
        this.size = 0, this.__data__ = { hash: new dt2(), map: new (te2 || Bn2)(), string: new dt2() };
      }
      function rc2(n3) {
        var t2 = nr2(this, n3).delete(n3);
        return this.size -= t2 ? 1 : 0, t2;
      }
      function ic2(n3) {
        return nr2(this, n3).get(n3);
      }
      function sc2(n3) {
        return nr2(this, n3).has(n3);
      }
      function uc2(n3, t2) {
        var e2 = nr2(this, n3), r2 = e2.size;
        return e2.set(n3, t2), this.size += e2.size == r2 ? 0 : 1, this;
      }
      Gn2.prototype.clear = ec2, Gn2.prototype.delete = rc2, Gn2.prototype.get = ic2, Gn2.prototype.has = sc2, Gn2.prototype.set = uc2;
      function gt2(n3) {
        var t2 = -1, e2 = n3 == null ? 0 : n3.length;
        for (this.__data__ = new Gn2(); ++t2 < e2; ) this.add(n3[t2]);
      }
      function ac2(n3) {
        return this.__data__.set(n3, zt2), this;
      }
      function oc2(n3) {
        return this.__data__.has(n3);
      }
      gt2.prototype.add = gt2.prototype.push = ac2, gt2.prototype.has = oc2;
      function Rn2(n3) {
        var t2 = this.__data__ = new Bn2(n3);
        this.size = t2.size;
      }
      function fc2() {
        this.__data__ = new Bn2(), this.size = 0;
      }
      function cc2(n3) {
        var t2 = this.__data__, e2 = t2.delete(n3);
        return this.size = t2.size, e2;
      }
      function hc2(n3) {
        return this.__data__.get(n3);
      }
      function lc2(n3) {
        return this.__data__.has(n3);
      }
      function pc2(n3, t2) {
        var e2 = this.__data__;
        if (e2 instanceof Bn2) {
          var r2 = e2.__data__;
          if (!te2 || r2.length < w2 - 1) return r2.push([n3, t2]), this.size = ++e2.size, this;
          e2 = this.__data__ = new Gn2(r2);
        }
        return e2.set(n3, t2), this.size = e2.size, this;
      }
      Rn2.prototype.clear = fc2, Rn2.prototype.delete = cc2, Rn2.prototype.get = hc2, Rn2.prototype.has = lc2, Rn2.prototype.set = pc2;
      function Fs(n3, t2) {
        var e2 = O2(n3), r2 = !e2 && Pt2(n3), s2 = !e2 && !r2 && at2(n3), o2 = !e2 && !r2 && !s2 && Bt2(n3), f2 = e2 || r2 || s2 || o2, c2 = f2 ? Fr2(n3.length, If2) : [], l2 = c2.length;
        for (var v2 in n3) (t2 || F3.call(n3, v2)) && !(f2 && (v2 == "length" || s2 && (v2 == "offset" || v2 == "parent") || o2 && (v2 == "buffer" || v2 == "byteLength" || v2 == "byteOffset") || Zn2(v2, l2))) && c2.push(v2);
        return c2;
      }
      function Ms(n3) {
        var t2 = n3.length;
        return t2 ? n3[ei2(0, t2 - 1)] : i2;
      }
      function dc2(n3, t2) {
        return tr2(un2(n3), vt2(t2, 0, n3.length));
      }
      function gc2(n3) {
        return tr2(un2(n3));
      }
      function Yr2(n3, t2, e2) {
        (e2 !== i2 && !bn2(n3[t2], e2) || e2 === i2 && !(t2 in n3)) && zn2(n3, t2, e2);
      }
      function se2(n3, t2, e2) {
        var r2 = n3[t2];
        (!(F3.call(n3, t2) && bn2(r2, e2)) || e2 === i2 && !(t2 in n3)) && zn2(n3, t2, e2);
      }
      function Be2(n3, t2) {
        for (var e2 = n3.length; e2--; ) if (bn2(n3[e2][0], t2)) return e2;
        return -1;
      }
      function vc2(n3, t2, e2, r2) {
        return rt2(n3, function(s2, o2, f2) {
          t2(r2, s2, e2(s2), f2);
        }), r2;
      }
      function qs(n3, t2) {
        return n3 && Un(t2, V2(t2), n3);
      }
      function _c2(n3, t2) {
        return n3 && Un(t2, on2(t2), n3);
      }
      function zn2(n3, t2, e2) {
        t2 == "__proto__" && $e2 ? $e2(n3, t2, { configurable: true, enumerable: true, value: e2, writable: true }) : n3[t2] = e2;
      }
      function Zr2(n3, t2) {
        for (var e2 = -1, r2 = t2.length, s2 = p2(r2), o2 = n3 == null; ++e2 < r2; ) s2[e2] = o2 ? i2 : Si2(n3, t2[e2]);
        return s2;
      }
      function vt2(n3, t2, e2) {
        return n3 === n3 && (e2 !== i2 && (n3 = n3 <= e2 ? n3 : e2), t2 !== i2 && (n3 = n3 >= t2 ? n3 : t2)), n3;
      }
      function An2(n3, t2, e2, r2, s2, o2) {
        var f2, c2 = t2 & Ln, l2 = t2 & Fn, v2 = t2 & xt2;
        if (e2 && (f2 = s2 ? e2(n3, r2, s2, o2) : e2(n3)), f2 !== i2) return f2;
        if (!K3(n3)) return n3;
        var _2 = O2(n3);
        if (_2) {
          if (f2 = sh2(n3), !c2) return un2(n3, f2);
        } else {
          var m2 = tn2(n3), P2 = m2 == Pe2 || m2 == Gi2;
          if (at2(n3)) return hu(n3, c2);
          if (m2 == qn || m2 == Ot2 || P2 && !s2) {
            if (f2 = l2 || P2 ? {} : bu(n3), !c2) return l2 ? Jc2(n3, _c2(f2, n3)) : Zc2(n3, qs(f2, n3));
          } else {
            if (!q3[m2]) return s2 ? n3 : {};
            f2 = uh2(n3, m2, c2);
          }
        }
        o2 || (o2 = new Rn2());
        var I2 = o2.get(n3);
        if (I2) return I2;
        o2.set(n3, f2), sa2(n3) ? n3.forEach(function(y2) {
          f2.add(An2(y2, t2, e2, y2, n3, o2));
        }) : ra2(n3) && n3.forEach(function(y2, H2) {
          f2.set(H2, An2(y2, t2, e2, H2, n3, o2));
        });
        var E2 = v2 ? l2 ? pi2 : li2 : l2 ? on2 : V2, b2 = _2 ? i2 : E2(n3);
        return mn2(b2 || n3, function(y2, H2) {
          b2 && (H2 = y2, y2 = n3[H2]), se2(f2, H2, An2(y2, t2, e2, H2, n3, o2));
        }), f2;
      }
      function mc2(n3) {
        var t2 = V2(n3);
        return function(e2) {
          return Bs(e2, n3, t2);
        };
      }
      function Bs(n3, t2, e2) {
        var r2 = e2.length;
        if (n3 == null) return !r2;
        for (n3 = M2(n3); r2--; ) {
          var s2 = e2[r2], o2 = t2[s2], f2 = n3[s2];
          if (f2 === i2 && !(s2 in n3) || !o2(f2)) return false;
        }
        return true;
      }
      function Gs(n3, t2, e2) {
        if (typeof n3 != "function") throw new wn2(D2);
        return le2(function() {
          n3.apply(i2, e2);
        }, t2);
      }
      function ue2(n3, t2, e2, r2) {
        var s2 = -1, o2 = Ee2, f2 = true, c2 = n3.length, l2 = [], v2 = t2.length;
        if (!c2) return l2;
        e2 && (t2 = G3(t2, hn2(e2))), r2 ? (o2 = Dr2, f2 = false) : t2.length >= w2 && (o2 = jt2, f2 = false, t2 = new gt2(t2));
        n: for (; ++s2 < c2; ) {
          var _2 = n3[s2], m2 = e2 == null ? _2 : e2(_2);
          if (_2 = r2 || _2 !== 0 ? _2 : 0, f2 && m2 === m2) {
            for (var P2 = v2; P2--; ) if (t2[P2] === m2) continue n;
            l2.push(_2);
          } else o2(t2, m2, r2) || l2.push(_2);
        }
        return l2;
      }
      var rt2 = vu($n), zs = vu(Xr2, true);
      function wc2(n3, t2) {
        var e2 = true;
        return rt2(n3, function(r2, s2, o2) {
          return e2 = !!t2(r2, s2, o2), e2;
        }), e2;
      }
      function Ge2(n3, t2, e2) {
        for (var r2 = -1, s2 = n3.length; ++r2 < s2; ) {
          var o2 = n3[r2], f2 = t2(o2);
          if (f2 != null && (c2 === i2 ? f2 === f2 && !pn2(f2) : e2(f2, c2))) var c2 = f2, l2 = o2;
        }
        return l2;
      }
      function Pc2(n3, t2, e2, r2) {
        var s2 = n3.length;
        for (e2 = R2(e2), e2 < 0 && (e2 = -e2 > s2 ? 0 : s2 + e2), r2 = r2 === i2 || r2 > s2 ? s2 : R2(r2), r2 < 0 && (r2 += s2), r2 = e2 > r2 ? 0 : aa2(r2); e2 < r2; ) n3[e2++] = t2;
        return n3;
      }
      function Ks(n3, t2) {
        var e2 = [];
        return rt2(n3, function(r2, s2, o2) {
          t2(r2, s2, o2) && e2.push(r2);
        }), e2;
      }
      function j2(n3, t2, e2, r2, s2) {
        var o2 = -1, f2 = n3.length;
        for (e2 || (e2 = oh2), s2 || (s2 = []); ++o2 < f2; ) {
          var c2 = n3[o2];
          t2 > 0 && e2(c2) ? t2 > 1 ? j2(c2, t2 - 1, e2, r2, s2) : nt2(s2, c2) : r2 || (s2[s2.length] = c2);
        }
        return s2;
      }
      var Jr2 = _u(), Ys = _u(true);
      function $n(n3, t2) {
        return n3 && Jr2(n3, t2, V2);
      }
      function Xr2(n3, t2) {
        return n3 && Ys(n3, t2, V2);
      }
      function ze2(n3, t2) {
        return jn2(t2, function(e2) {
          return Jn2(n3[e2]);
        });
      }
      function _t6(n3, t2) {
        t2 = st2(t2, n3);
        for (var e2 = 0, r2 = t2.length; n3 != null && e2 < r2; ) n3 = n3[Wn(t2[e2++])];
        return e2 && e2 == r2 ? n3 : i2;
      }
      function Zs(n3, t2, e2) {
        var r2 = t2(n3);
        return O2(n3) ? r2 : nt2(r2, e2(n3));
      }
      function en2(n3) {
        return n3 == null ? n3 === i2 ? Za2 : Ka2 : pt2 && pt2 in M2(n3) ? eh2(n3) : gh2(n3);
      }
      function Qr2(n3, t2) {
        return n3 > t2;
      }
      function Ac2(n3, t2) {
        return n3 != null && F3.call(n3, t2);
      }
      function Cc2(n3, t2) {
        return n3 != null && t2 in M2(n3);
      }
      function Ic2(n3, t2, e2) {
        return n3 >= nn2(t2, e2) && n3 < Q2(t2, e2);
      }
      function Vr2(n3, t2, e2) {
        for (var r2 = e2 ? Dr2 : Ee2, s2 = n3[0].length, o2 = n3.length, f2 = o2, c2 = p2(o2), l2 = 1 / 0, v2 = []; f2--; ) {
          var _2 = n3[f2];
          f2 && t2 && (_2 = G3(_2, hn2(t2))), l2 = nn2(_2.length, l2), c2[f2] = !e2 && (t2 || s2 >= 120 && _2.length >= 120) ? new gt2(f2 && _2) : i2;
        }
        _2 = n3[0];
        var m2 = -1, P2 = c2[0];
        n: for (; ++m2 < s2 && v2.length < l2; ) {
          var I2 = _2[m2], E2 = t2 ? t2(I2) : I2;
          if (I2 = e2 || I2 !== 0 ? I2 : 0, !(P2 ? jt2(P2, E2) : r2(v2, E2, e2))) {
            for (f2 = o2; --f2; ) {
              var b2 = c2[f2];
              if (!(b2 ? jt2(b2, E2) : r2(n3[f2], E2, e2))) continue n;
            }
            P2 && P2.push(E2), v2.push(I2);
          }
        }
        return v2;
      }
      function xc2(n3, t2, e2, r2) {
        return $n(n3, function(s2, o2, f2) {
          t2(r2, e2(s2), o2, f2);
        }), r2;
      }
      function ae2(n3, t2, e2) {
        t2 = st2(t2, n3), n3 = Hu(n3, t2);
        var r2 = n3 == null ? n3 : n3[Wn(In2(t2))];
        return r2 == null ? i2 : cn2(r2, n3, e2);
      }
      function Js(n3) {
        return Y3(n3) && en2(n3) == Ot2;
      }
      function Ec2(n3) {
        return Y3(n3) && en2(n3) == kt2;
      }
      function yc2(n3) {
        return Y3(n3) && en2(n3) == Zt3;
      }
      function oe2(n3, t2, e2, r2, s2) {
        return n3 === t2 ? true : n3 == null || t2 == null || !Y3(n3) && !Y3(t2) ? n3 !== n3 && t2 !== t2 : Sc2(n3, t2, e2, r2, oe2, s2);
      }
      function Sc2(n3, t2, e2, r2, s2, o2) {
        var f2 = O2(n3), c2 = O2(t2), l2 = f2 ? me2 : tn2(n3), v2 = c2 ? me2 : tn2(t2);
        l2 = l2 == Ot2 ? qn : l2, v2 = v2 == Ot2 ? qn : v2;
        var _2 = l2 == qn, m2 = v2 == qn, P2 = l2 == v2;
        if (P2 && at2(n3)) {
          if (!at2(t2)) return false;
          f2 = true, _2 = false;
        }
        if (P2 && !_2) return o2 || (o2 = new Rn2()), f2 || Bt2(n3) ? Su(n3, t2, e2, r2, s2, o2) : nh2(n3, t2, l2, e2, r2, s2, o2);
        if (!(e2 & Et2)) {
          var I2 = _2 && F3.call(n3, "__wrapped__"), E2 = m2 && F3.call(t2, "__wrapped__");
          if (I2 || E2) {
            var b2 = I2 ? n3.value() : n3, y2 = E2 ? t2.value() : t2;
            return o2 || (o2 = new Rn2()), s2(b2, y2, e2, r2, o2);
          }
        }
        return P2 ? (o2 || (o2 = new Rn2()), th2(n3, t2, e2, r2, s2, o2)) : false;
      }
      function Oc2(n3) {
        return Y3(n3) && tn2(n3) == yn;
      }
      function kr2(n3, t2, e2, r2) {
        var s2 = e2.length, o2 = s2, f2 = !r2;
        if (n3 == null) return !o2;
        for (n3 = M2(n3); s2--; ) {
          var c2 = e2[s2];
          if (f2 && c2[2] ? c2[1] !== n3[c2[0]] : !(c2[0] in n3)) return false;
        }
        for (; ++s2 < o2; ) {
          c2 = e2[s2];
          var l2 = c2[0], v2 = n3[l2], _2 = c2[1];
          if (f2 && c2[2]) {
            if (v2 === i2 && !(l2 in n3)) return false;
          } else {
            var m2 = new Rn2();
            if (r2) var P2 = r2(v2, _2, l2, n3, t2, m2);
            if (!(P2 === i2 ? oe2(_2, v2, Et2 | ve2, r2, m2) : P2)) return false;
          }
        }
        return true;
      }
      function Xs(n3) {
        if (!K3(n3) || ch2(n3)) return false;
        var t2 = Jn2(n3) ? Of2 : _o3;
        return t2.test(wt2(n3));
      }
      function Rc2(n3) {
        return Y3(n3) && en2(n3) == Xt2;
      }
      function bc2(n3) {
        return Y3(n3) && tn2(n3) == Sn2;
      }
      function Tc2(n3) {
        return Y3(n3) && ar(n3.length) && !!B3[en2(n3)];
      }
      function Qs(n3) {
        return typeof n3 == "function" ? n3 : n3 == null ? fn2 : typeof n3 == "object" ? O2(n3) ? js(n3[0], n3[1]) : ks(n3) : ma2(n3);
      }
      function jr2(n3) {
        if (!he2(n3)) return Hf2(n3);
        var t2 = [];
        for (var e2 in M2(n3)) F3.call(n3, e2) && e2 != "constructor" && t2.push(e2);
        return t2;
      }
      function Lc2(n3) {
        if (!K3(n3)) return dh2(n3);
        var t2 = he2(n3), e2 = [];
        for (var r2 in n3) r2 == "constructor" && (t2 || !F3.call(n3, r2)) || e2.push(r2);
        return e2;
      }
      function ni2(n3, t2) {
        return n3 < t2;
      }
      function Vs(n3, t2) {
        var e2 = -1, r2 = an2(n3) ? p2(n3.length) : [];
        return rt2(n3, function(s2, o2, f2) {
          r2[++e2] = t2(s2, o2, f2);
        }), r2;
      }
      function ks(n3) {
        var t2 = gi2(n3);
        return t2.length == 1 && t2[0][2] ? Lu(t2[0][0], t2[0][1]) : function(e2) {
          return e2 === n3 || kr2(e2, n3, t2);
        };
      }
      function js(n3, t2) {
        return _i2(n3) && Tu(t2) ? Lu(Wn(n3), t2) : function(e2) {
          var r2 = Si2(e2, n3);
          return r2 === i2 && r2 === t2 ? Oi2(e2, n3) : oe2(t2, r2, Et2 | ve2);
        };
      }
      function Ke2(n3, t2, e2, r2, s2) {
        n3 !== t2 && Jr2(t2, function(o2, f2) {
          if (s2 || (s2 = new Rn2()), K3(o2)) Dc2(n3, t2, f2, e2, Ke2, r2, s2);
          else {
            var c2 = r2 ? r2(wi2(n3, f2), o2, f2 + "", n3, t2, s2) : i2;
            c2 === i2 && (c2 = o2), Yr2(n3, f2, c2);
          }
        }, on2);
      }
      function Dc2(n3, t2, e2, r2, s2, o2, f2) {
        var c2 = wi2(n3, e2), l2 = wi2(t2, e2), v2 = f2.get(l2);
        if (v2) {
          Yr2(n3, e2, v2);
          return;
        }
        var _2 = o2 ? o2(c2, l2, e2 + "", n3, t2, f2) : i2, m2 = _2 === i2;
        if (m2) {
          var P2 = O2(l2), I2 = !P2 && at2(l2), E2 = !P2 && !I2 && Bt2(l2);
          _2 = l2, P2 || I2 || E2 ? O2(c2) ? _2 = c2 : Z3(c2) ? _2 = un2(c2) : I2 ? (m2 = false, _2 = hu(l2, true)) : E2 ? (m2 = false, _2 = lu(l2, true)) : _2 = [] : pe2(l2) || Pt2(l2) ? (_2 = c2, Pt2(c2) ? _2 = oa2(c2) : (!K3(c2) || Jn2(c2)) && (_2 = bu(l2))) : m2 = false;
        }
        m2 && (f2.set(l2, _2), s2(_2, l2, r2, o2, f2), f2.delete(l2)), Yr2(n3, e2, _2);
      }
      function nu(n3, t2) {
        var e2 = n3.length;
        if (e2) return t2 += t2 < 0 ? e2 : 0, Zn2(t2, e2) ? n3[t2] : i2;
      }
      function tu(n3, t2, e2) {
        t2.length ? t2 = G3(t2, function(o2) {
          return O2(o2) ? function(f2) {
            return _t6(f2, o2.length === 1 ? o2[0] : o2);
          } : o2;
        }) : t2 = [fn2];
        var r2 = -1;
        t2 = G3(t2, hn2(x2()));
        var s2 = Vs(n3, function(o2, f2, c2) {
          var l2 = G3(t2, function(v2) {
            return v2(o2);
          });
          return { criteria: l2, index: ++r2, value: o2 };
        });
        return uf2(s2, function(o2, f2) {
          return Yc2(o2, f2, e2);
        });
      }
      function Hc2(n3, t2) {
        return eu2(n3, t2, function(e2, r2) {
          return Oi2(n3, r2);
        });
      }
      function eu2(n3, t2, e2) {
        for (var r2 = -1, s2 = t2.length, o2 = {}; ++r2 < s2; ) {
          var f2 = t2[r2], c2 = _t6(n3, f2);
          e2(c2, f2) && fe2(o2, st2(f2, n3), c2);
        }
        return o2;
      }
      function Nc2(n3) {
        return function(t2) {
          return _t6(t2, n3);
        };
      }
      function ti2(n3, t2, e2, r2) {
        var s2 = r2 ? sf2 : Tt2, o2 = -1, f2 = t2.length, c2 = n3;
        for (n3 === t2 && (t2 = un2(t2)), e2 && (c2 = G3(n3, hn2(e2))); ++o2 < f2; ) for (var l2 = 0, v2 = t2[o2], _2 = e2 ? e2(v2) : v2; (l2 = s2(c2, _2, l2, r2)) > -1; ) c2 !== n3 && Ne2.call(c2, l2, 1), Ne2.call(n3, l2, 1);
        return n3;
      }
      function ru(n3, t2) {
        for (var e2 = n3 ? t2.length : 0, r2 = e2 - 1; e2--; ) {
          var s2 = t2[e2];
          if (e2 == r2 || s2 !== o2) {
            var o2 = s2;
            Zn2(s2) ? Ne2.call(n3, s2, 1) : si2(n3, s2);
          }
        }
        return n3;
      }
      function ei2(n3, t2) {
        return n3 + We2(Us() * (t2 - n3 + 1));
      }
      function $c2(n3, t2, e2, r2) {
        for (var s2 = -1, o2 = Q2(Ue2((t2 - n3) / (e2 || 1)), 0), f2 = p2(o2); o2--; ) f2[r2 ? o2 : ++s2] = n3, n3 += e2;
        return f2;
      }
      function ri2(n3, t2) {
        var e2 = "";
        if (!n3 || t2 < 1 || t2 > kn2) return e2;
        do
          t2 % 2 && (e2 += n3), t2 = We2(t2 / 2), t2 && (n3 += n3);
        while (t2);
        return e2;
      }
      function T2(n3, t2) {
        return Pi2(Du(n3, t2, fn2), n3 + "");
      }
      function Uc2(n3) {
        return Ms(Gt2(n3));
      }
      function Wc2(n3, t2) {
        var e2 = Gt2(n3);
        return tr2(e2, vt2(t2, 0, e2.length));
      }
      function fe2(n3, t2, e2, r2) {
        if (!K3(n3)) return n3;
        t2 = st2(t2, n3);
        for (var s2 = -1, o2 = t2.length, f2 = o2 - 1, c2 = n3; c2 != null && ++s2 < o2; ) {
          var l2 = Wn(t2[s2]), v2 = e2;
          if (l2 === "__proto__" || l2 === "constructor" || l2 === "prototype") return n3;
          if (s2 != f2) {
            var _2 = c2[l2];
            v2 = r2 ? r2(_2, l2, c2) : i2, v2 === i2 && (v2 = K3(_2) ? _2 : Zn2(t2[s2 + 1]) ? [] : {});
          }
          se2(c2, l2, v2), c2 = c2[l2];
        }
        return n3;
      }
      var iu = Fe2 ? function(n3, t2) {
        return Fe2.set(n3, t2), n3;
      } : fn2, Fc2 = $e2 ? function(n3, t2) {
        return $e2(n3, "toString", { configurable: true, enumerable: false, value: bi2(t2), writable: true });
      } : fn2;
      function Mc2(n3) {
        return tr2(Gt2(n3));
      }
      function Cn2(n3, t2, e2) {
        var r2 = -1, s2 = n3.length;
        t2 < 0 && (t2 = -t2 > s2 ? 0 : s2 + t2), e2 = e2 > s2 ? s2 : e2, e2 < 0 && (e2 += s2), s2 = t2 > e2 ? 0 : e2 - t2 >>> 0, t2 >>>= 0;
        for (var o2 = p2(s2); ++r2 < s2; ) o2[r2] = n3[r2 + t2];
        return o2;
      }
      function qc2(n3, t2) {
        var e2;
        return rt2(n3, function(r2, s2, o2) {
          return e2 = t2(r2, s2, o2), !e2;
        }), !!e2;
      }
      function Ye2(n3, t2, e2) {
        var r2 = 0, s2 = n3 == null ? r2 : n3.length;
        if (typeof t2 == "number" && t2 === t2 && s2 <= qa2) {
          for (; r2 < s2; ) {
            var o2 = r2 + s2 >>> 1, f2 = n3[o2];
            f2 !== null && !pn2(f2) && (e2 ? f2 <= t2 : f2 < t2) ? r2 = o2 + 1 : s2 = o2;
          }
          return s2;
        }
        return ii2(n3, t2, fn2, e2);
      }
      function ii2(n3, t2, e2, r2) {
        var s2 = 0, o2 = n3 == null ? 0 : n3.length;
        if (o2 === 0) return 0;
        t2 = e2(t2);
        for (var f2 = t2 !== t2, c2 = t2 === null, l2 = pn2(t2), v2 = t2 === i2; s2 < o2; ) {
          var _2 = We2((s2 + o2) / 2), m2 = e2(n3[_2]), P2 = m2 !== i2, I2 = m2 === null, E2 = m2 === m2, b2 = pn2(m2);
          if (f2) var y2 = r2 || E2;
          else v2 ? y2 = E2 && (r2 || P2) : c2 ? y2 = E2 && P2 && (r2 || !I2) : l2 ? y2 = E2 && P2 && !I2 && (r2 || !b2) : I2 || b2 ? y2 = false : y2 = r2 ? m2 <= t2 : m2 < t2;
          y2 ? s2 = _2 + 1 : o2 = _2;
        }
        return nn2(o2, Ma2);
      }
      function su(n3, t2) {
        for (var e2 = -1, r2 = n3.length, s2 = 0, o2 = []; ++e2 < r2; ) {
          var f2 = n3[e2], c2 = t2 ? t2(f2) : f2;
          if (!e2 || !bn2(c2, l2)) {
            var l2 = c2;
            o2[s2++] = f2 === 0 ? 0 : f2;
          }
        }
        return o2;
      }
      function uu(n3) {
        return typeof n3 == "number" ? n3 : pn2(n3) ? _e3 : +n3;
      }
      function ln2(n3) {
        if (typeof n3 == "string") return n3;
        if (O2(n3)) return G3(n3, ln2) + "";
        if (pn2(n3)) return Ws ? Ws.call(n3) : "";
        var t2 = n3 + "";
        return t2 == "0" && 1 / n3 == -ht2 ? "-0" : t2;
      }
      function it2(n3, t2, e2) {
        var r2 = -1, s2 = Ee2, o2 = n3.length, f2 = true, c2 = [], l2 = c2;
        if (e2) f2 = false, s2 = Dr2;
        else if (o2 >= w2) {
          var v2 = t2 ? null : kc2(n3);
          if (v2) return Se2(v2);
          f2 = false, s2 = jt2, l2 = new gt2();
        } else l2 = t2 ? [] : c2;
        n: for (; ++r2 < o2; ) {
          var _2 = n3[r2], m2 = t2 ? t2(_2) : _2;
          if (_2 = e2 || _2 !== 0 ? _2 : 0, f2 && m2 === m2) {
            for (var P2 = l2.length; P2--; ) if (l2[P2] === m2) continue n;
            t2 && l2.push(m2), c2.push(_2);
          } else s2(l2, m2, e2) || (l2 !== c2 && l2.push(m2), c2.push(_2));
        }
        return c2;
      }
      function si2(n3, t2) {
        return t2 = st2(t2, n3), n3 = Hu(n3, t2), n3 == null || delete n3[Wn(In2(t2))];
      }
      function au(n3, t2, e2, r2) {
        return fe2(n3, t2, e2(_t6(n3, t2)), r2);
      }
      function Ze2(n3, t2, e2, r2) {
        for (var s2 = n3.length, o2 = r2 ? s2 : -1; (r2 ? o2-- : ++o2 < s2) && t2(n3[o2], o2, n3); ) ;
        return e2 ? Cn2(n3, r2 ? 0 : o2, r2 ? o2 + 1 : s2) : Cn2(n3, r2 ? o2 + 1 : 0, r2 ? s2 : o2);
      }
      function ou(n3, t2) {
        var e2 = n3;
        return e2 instanceof N2 && (e2 = e2.value()), Hr2(t2, function(r2, s2) {
          return s2.func.apply(s2.thisArg, nt2([r2], s2.args));
        }, e2);
      }
      function ui2(n3, t2, e2) {
        var r2 = n3.length;
        if (r2 < 2) return r2 ? it2(n3[0]) : [];
        for (var s2 = -1, o2 = p2(r2); ++s2 < r2; ) for (var f2 = n3[s2], c2 = -1; ++c2 < r2; ) c2 != s2 && (o2[s2] = ue2(o2[s2] || f2, n3[c2], t2, e2));
        return it2(j2(o2, 1), t2, e2);
      }
      function fu(n3, t2, e2) {
        for (var r2 = -1, s2 = n3.length, o2 = t2.length, f2 = {}; ++r2 < s2; ) {
          var c2 = r2 < o2 ? t2[r2] : i2;
          e2(f2, n3[r2], c2);
        }
        return f2;
      }
      function ai2(n3) {
        return Z3(n3) ? n3 : [];
      }
      function oi2(n3) {
        return typeof n3 == "function" ? n3 : fn2;
      }
      function st2(n3, t2) {
        return O2(n3) ? n3 : _i2(n3, t2) ? [n3] : Wu2(W2(n3));
      }
      var Bc2 = T2;
      function ut2(n3, t2, e2) {
        var r2 = n3.length;
        return e2 = e2 === i2 ? r2 : e2, !t2 && e2 >= r2 ? n3 : Cn2(n3, t2, e2);
      }
      var cu = Rf2 || function(n3) {
        return k2.clearTimeout(n3);
      };
      function hu(n3, t2) {
        if (t2) return n3.slice();
        var e2 = n3.length, r2 = Ls ? Ls(e2) : new n3.constructor(e2);
        return n3.copy(r2), r2;
      }
      function fi2(n3) {
        var t2 = new n3.constructor(n3.byteLength);
        return new De2(t2).set(new De2(n3)), t2;
      }
      function Gc2(n3, t2) {
        var e2 = t2 ? fi2(n3.buffer) : n3.buffer;
        return new n3.constructor(e2, n3.byteOffset, n3.byteLength);
      }
      function zc2(n3) {
        var t2 = new n3.constructor(n3.source, Ji2.exec(n3));
        return t2.lastIndex = n3.lastIndex, t2;
      }
      function Kc2(n3) {
        return ie2 ? M2(ie2.call(n3)) : {};
      }
      function lu(n3, t2) {
        var e2 = t2 ? fi2(n3.buffer) : n3.buffer;
        return new n3.constructor(e2, n3.byteOffset, n3.length);
      }
      function pu(n3, t2) {
        if (n3 !== t2) {
          var e2 = n3 !== i2, r2 = n3 === null, s2 = n3 === n3, o2 = pn2(n3), f2 = t2 !== i2, c2 = t2 === null, l2 = t2 === t2, v2 = pn2(t2);
          if (!c2 && !v2 && !o2 && n3 > t2 || o2 && f2 && l2 && !c2 && !v2 || r2 && f2 && l2 || !e2 && l2 || !s2) return 1;
          if (!r2 && !o2 && !v2 && n3 < t2 || v2 && e2 && s2 && !r2 && !o2 || c2 && e2 && s2 || !f2 && s2 || !l2) return -1;
        }
        return 0;
      }
      function Yc2(n3, t2, e2) {
        for (var r2 = -1, s2 = n3.criteria, o2 = t2.criteria, f2 = s2.length, c2 = e2.length; ++r2 < f2; ) {
          var l2 = pu(s2[r2], o2[r2]);
          if (l2) {
            if (r2 >= c2) return l2;
            var v2 = e2[r2];
            return l2 * (v2 == "desc" ? -1 : 1);
          }
        }
        return n3.index - t2.index;
      }
      function du(n3, t2, e2, r2) {
        for (var s2 = -1, o2 = n3.length, f2 = e2.length, c2 = -1, l2 = t2.length, v2 = Q2(o2 - f2, 0), _2 = p2(l2 + v2), m2 = !r2; ++c2 < l2; ) _2[c2] = t2[c2];
        for (; ++s2 < f2; ) (m2 || s2 < o2) && (_2[e2[s2]] = n3[s2]);
        for (; v2--; ) _2[c2++] = n3[s2++];
        return _2;
      }
      function gu(n3, t2, e2, r2) {
        for (var s2 = -1, o2 = n3.length, f2 = -1, c2 = e2.length, l2 = -1, v2 = t2.length, _2 = Q2(o2 - c2, 0), m2 = p2(_2 + v2), P2 = !r2; ++s2 < _2; ) m2[s2] = n3[s2];
        for (var I2 = s2; ++l2 < v2; ) m2[I2 + l2] = t2[l2];
        for (; ++f2 < c2; ) (P2 || s2 < o2) && (m2[I2 + e2[f2]] = n3[s2++]);
        return m2;
      }
      function un2(n3, t2) {
        var e2 = -1, r2 = n3.length;
        for (t2 || (t2 = p2(r2)); ++e2 < r2; ) t2[e2] = n3[e2];
        return t2;
      }
      function Un(n3, t2, e2, r2) {
        var s2 = !e2;
        e2 || (e2 = {});
        for (var o2 = -1, f2 = t2.length; ++o2 < f2; ) {
          var c2 = t2[o2], l2 = r2 ? r2(e2[c2], n3[c2], c2, e2, n3) : i2;
          l2 === i2 && (l2 = n3[c2]), s2 ? zn2(e2, c2, l2) : se2(e2, c2, l2);
        }
        return e2;
      }
      function Zc2(n3, t2) {
        return Un(n3, vi2(n3), t2);
      }
      function Jc2(n3, t2) {
        return Un(n3, Ou(n3), t2);
      }
      function Je2(n3, t2) {
        return function(e2, r2) {
          var s2 = O2(e2) ? ko : vc2, o2 = t2 ? t2() : {};
          return s2(e2, n3, x2(r2, 2), o2);
        };
      }
      function Ft2(n3) {
        return T2(function(t2, e2) {
          var r2 = -1, s2 = e2.length, o2 = s2 > 1 ? e2[s2 - 1] : i2, f2 = s2 > 2 ? e2[2] : i2;
          for (o2 = n3.length > 3 && typeof o2 == "function" ? (s2--, o2) : i2, f2 && rn2(e2[0], e2[1], f2) && (o2 = s2 < 3 ? i2 : o2, s2 = 1), t2 = M2(t2); ++r2 < s2; ) {
            var c2 = e2[r2];
            c2 && n3(t2, c2, r2, o2);
          }
          return t2;
        });
      }
      function vu(n3, t2) {
        return function(e2, r2) {
          if (e2 == null) return e2;
          if (!an2(e2)) return n3(e2, r2);
          for (var s2 = e2.length, o2 = t2 ? s2 : -1, f2 = M2(e2); (t2 ? o2-- : ++o2 < s2) && r2(f2[o2], o2, f2) !== false; ) ;
          return e2;
        };
      }
      function _u(n3) {
        return function(t2, e2, r2) {
          for (var s2 = -1, o2 = M2(t2), f2 = r2(t2), c2 = f2.length; c2--; ) {
            var l2 = f2[n3 ? c2 : ++s2];
            if (e2(o2[l2], l2, o2) === false) break;
          }
          return t2;
        };
      }
      function Xc2(n3, t2, e2) {
        var r2 = t2 & vn2, s2 = ce2(n3);
        function o2() {
          var f2 = this && this !== k2 && this instanceof o2 ? s2 : n3;
          return f2.apply(r2 ? e2 : this, arguments);
        }
        return o2;
      }
      function mu(n3) {
        return function(t2) {
          t2 = W2(t2);
          var e2 = Lt(t2) ? On(t2) : i2, r2 = e2 ? e2[0] : t2.charAt(0), s2 = e2 ? ut2(e2, 1).join("") : t2.slice(1);
          return r2[n3]() + s2;
        };
      }
      function Mt2(n3) {
        return function(t2) {
          return Hr2(va2(ga(t2).replace(Wo2, "")), n3, "");
        };
      }
      function ce2(n3) {
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return new n3();
            case 1:
              return new n3(t2[0]);
            case 2:
              return new n3(t2[0], t2[1]);
            case 3:
              return new n3(t2[0], t2[1], t2[2]);
            case 4:
              return new n3(t2[0], t2[1], t2[2], t2[3]);
            case 5:
              return new n3(t2[0], t2[1], t2[2], t2[3], t2[4]);
            case 6:
              return new n3(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
            case 7:
              return new n3(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
          }
          var e2 = Wt2(n3.prototype), r2 = n3.apply(e2, t2);
          return K3(r2) ? r2 : e2;
        };
      }
      function Qc2(n3, t2, e2) {
        var r2 = ce2(n3);
        function s2() {
          for (var o2 = arguments.length, f2 = p2(o2), c2 = o2, l2 = qt2(s2); c2--; ) f2[c2] = arguments[c2];
          var v2 = o2 < 3 && f2[0] !== l2 && f2[o2 - 1] !== l2 ? [] : tt2(f2, l2);
          if (o2 -= v2.length, o2 < e2) return Iu(n3, t2, Xe2, s2.placeholder, i2, f2, v2, i2, i2, e2 - o2);
          var _2 = this && this !== k2 && this instanceof s2 ? r2 : n3;
          return cn2(_2, this, f2);
        }
        return s2;
      }
      function wu(n3) {
        return function(t2, e2, r2) {
          var s2 = M2(t2);
          if (!an2(t2)) {
            var o2 = x2(e2, 3);
            t2 = V2(t2), e2 = function(c2) {
              return o2(s2[c2], c2, s2);
            };
          }
          var f2 = n3(t2, e2, r2);
          return f2 > -1 ? s2[o2 ? t2[f2] : f2] : i2;
        };
      }
      function Pu(n3) {
        return Yn2(function(t2) {
          var e2 = t2.length, r2 = e2, s2 = Pn2.prototype.thru;
          for (n3 && t2.reverse(); r2--; ) {
            var o2 = t2[r2];
            if (typeof o2 != "function") throw new wn2(D2);
            if (s2 && !f2 && je2(o2) == "wrapper") var f2 = new Pn2([], true);
          }
          for (r2 = f2 ? r2 : e2; ++r2 < e2; ) {
            o2 = t2[r2];
            var c2 = je2(o2), l2 = c2 == "wrapper" ? di2(o2) : i2;
            l2 && mi2(l2[0]) && l2[1] == (Mn | Dn | Hn2 | Kt2) && !l2[4].length && l2[9] == 1 ? f2 = f2[je2(l2[0])].apply(f2, l2[3]) : f2 = o2.length == 1 && mi2(o2) ? f2[c2]() : f2.thru(o2);
          }
          return function() {
            var v2 = arguments, _2 = v2[0];
            if (f2 && v2.length == 1 && O2(_2)) return f2.plant(_2).value();
            for (var m2 = 0, P2 = e2 ? t2[m2].apply(this, v2) : _2; ++m2 < e2; ) P2 = t2[m2].call(this, P2);
            return P2;
          };
        });
      }
      function Xe2(n3, t2, e2, r2, s2, o2, f2, c2, l2, v2) {
        var _2 = t2 & Mn, m2 = t2 & vn2, P2 = t2 & ct2, I2 = t2 & (Dn | yt2), E2 = t2 & dr2, b2 = P2 ? i2 : ce2(n3);
        function y2() {
          for (var H2 = arguments.length, $2 = p2(H2), dn = H2; dn--; ) $2[dn] = arguments[dn];
          if (I2) var sn2 = qt2(y2), gn = of2($2, sn2);
          if (r2 && ($2 = du($2, r2, s2, I2)), o2 && ($2 = gu($2, o2, f2, I2)), H2 -= gn, I2 && H2 < v2) {
            var J2 = tt2($2, sn2);
            return Iu(n3, t2, Xe2, y2.placeholder, e2, $2, J2, c2, l2, v2 - H2);
          }
          var Tn2 = m2 ? e2 : this, Qn = P2 ? Tn2[n3] : n3;
          return H2 = $2.length, c2 ? $2 = vh2($2, c2) : E2 && H2 > 1 && $2.reverse(), _2 && l2 < H2 && ($2.length = l2), this && this !== k2 && this instanceof y2 && (Qn = b2 || ce2(Qn)), Qn.apply(Tn2, $2);
        }
        return y2;
      }
      function Au(n3, t2) {
        return function(e2, r2) {
          return xc2(e2, n3, t2(r2), {});
        };
      }
      function Qe2(n3, t2) {
        return function(e2, r2) {
          var s2;
          if (e2 === i2 && r2 === i2) return t2;
          if (e2 !== i2 && (s2 = e2), r2 !== i2) {
            if (s2 === i2) return r2;
            typeof e2 == "string" || typeof r2 == "string" ? (e2 = ln2(e2), r2 = ln2(r2)) : (e2 = uu(e2), r2 = uu(r2)), s2 = n3(e2, r2);
          }
          return s2;
        };
      }
      function ci2(n3) {
        return Yn2(function(t2) {
          return t2 = G3(t2, hn2(x2())), T2(function(e2) {
            var r2 = this;
            return n3(t2, function(s2) {
              return cn2(s2, r2, e2);
            });
          });
        });
      }
      function Ve2(n3, t2) {
        t2 = t2 === i2 ? " " : ln2(t2);
        var e2 = t2.length;
        if (e2 < 2) return e2 ? ri2(t2, n3) : t2;
        var r2 = ri2(t2, Ue2(n3 / Dt2(t2)));
        return Lt(t2) ? ut2(On(r2), 0, n3).join("") : r2.slice(0, n3);
      }
      function Vc2(n3, t2, e2, r2) {
        var s2 = t2 & vn2, o2 = ce2(n3);
        function f2() {
          for (var c2 = -1, l2 = arguments.length, v2 = -1, _2 = r2.length, m2 = p2(_2 + l2), P2 = this && this !== k2 && this instanceof f2 ? o2 : n3; ++v2 < _2; ) m2[v2] = r2[v2];
          for (; l2--; ) m2[v2++] = arguments[++c2];
          return cn2(P2, s2 ? e2 : this, m2);
        }
        return f2;
      }
      function Cu(n3) {
        return function(t2, e2, r2) {
          return r2 && typeof r2 != "number" && rn2(t2, e2, r2) && (e2 = r2 = i2), t2 = Xn2(t2), e2 === i2 ? (e2 = t2, t2 = 0) : e2 = Xn2(e2), r2 = r2 === i2 ? t2 < e2 ? 1 : -1 : Xn2(r2), $c2(t2, e2, r2, n3);
        };
      }
      function ke2(n3) {
        return function(t2, e2) {
          return typeof t2 == "string" && typeof e2 == "string" || (t2 = xn2(t2), e2 = xn2(e2)), n3(t2, e2);
        };
      }
      function Iu(n3, t2, e2, r2, s2, o2, f2, c2, l2, v2) {
        var _2 = t2 & Dn, m2 = _2 ? f2 : i2, P2 = _2 ? i2 : f2, I2 = _2 ? o2 : i2, E2 = _2 ? i2 : o2;
        t2 |= _2 ? Hn2 : St2, t2 &= ~(_2 ? St2 : Hn2), t2 & qi2 || (t2 &= ~(vn2 | ct2));
        var b2 = [n3, t2, s2, I2, m2, E2, P2, c2, l2, v2], y2 = e2.apply(i2, b2);
        return mi2(n3) && Nu(y2, b2), y2.placeholder = r2, $u(y2, n3, t2);
      }
      function hi2(n3) {
        var t2 = X2[n3];
        return function(e2, r2) {
          if (e2 = xn2(e2), r2 = r2 == null ? 0 : nn2(R2(r2), 292), r2 && $s(e2)) {
            var s2 = (W2(e2) + "e").split("e"), o2 = t2(s2[0] + "e" + (+s2[1] + r2));
            return s2 = (W2(o2) + "e").split("e"), +(s2[0] + "e" + (+s2[1] - r2));
          }
          return t2(e2);
        };
      }
      var kc2 = $t3 && 1 / Se2(new $t3([, -0]))[1] == ht2 ? function(n3) {
        return new $t3(n3);
      } : Di2;
      function xu(n3) {
        return function(t2) {
          var e2 = tn2(t2);
          return e2 == yn ? qr(t2) : e2 == Sn2 ? gf(t2) : af2(t2, n3(t2));
        };
      }
      function Kn(n3, t2, e2, r2, s2, o2, f2, c2) {
        var l2 = t2 & ct2;
        if (!l2 && typeof n3 != "function") throw new wn2(D2);
        var v2 = r2 ? r2.length : 0;
        if (v2 || (t2 &= ~(Hn2 | St2), r2 = s2 = i2), f2 = f2 === i2 ? f2 : Q2(R2(f2), 0), c2 = c2 === i2 ? c2 : R2(c2), v2 -= s2 ? s2.length : 0, t2 & St2) {
          var _2 = r2, m2 = s2;
          r2 = s2 = i2;
        }
        var P2 = l2 ? i2 : di2(n3), I2 = [n3, t2, e2, r2, s2, _2, m2, o2, f2, c2];
        if (P2 && ph2(I2, P2), n3 = I2[0], t2 = I2[1], e2 = I2[2], r2 = I2[3], s2 = I2[4], c2 = I2[9] = I2[9] === i2 ? l2 ? 0 : n3.length : Q2(I2[9] - v2, 0), !c2 && t2 & (Dn | yt2) && (t2 &= ~(Dn | yt2)), !t2 || t2 == vn2) var E2 = Xc2(n3, t2, e2);
        else t2 == Dn || t2 == yt2 ? E2 = Qc2(n3, t2, c2) : (t2 == Hn2 || t2 == (vn2 | Hn2)) && !s2.length ? E2 = Vc2(n3, t2, e2, r2) : E2 = Xe2.apply(i2, I2);
        var b2 = P2 ? iu : Nu;
        return $u(b2(E2, I2), n3, t2);
      }
      function Eu(n3, t2, e2, r2) {
        return n3 === i2 || bn2(n3, Nt2[e2]) && !F3.call(r2, e2) ? t2 : n3;
      }
      function yu(n3, t2, e2, r2, s2, o2) {
        return K3(n3) && K3(t2) && (o2.set(t2, n3), Ke2(n3, t2, i2, yu, o2), o2.delete(t2)), n3;
      }
      function jc2(n3) {
        return pe2(n3) ? i2 : n3;
      }
      function Su(n3, t2, e2, r2, s2, o2) {
        var f2 = e2 & Et2, c2 = n3.length, l2 = t2.length;
        if (c2 != l2 && !(f2 && l2 > c2)) return false;
        var v2 = o2.get(n3), _2 = o2.get(t2);
        if (v2 && _2) return v2 == t2 && _2 == n3;
        var m2 = -1, P2 = true, I2 = e2 & ve2 ? new gt2() : i2;
        for (o2.set(n3, t2), o2.set(t2, n3); ++m2 < c2; ) {
          var E2 = n3[m2], b2 = t2[m2];
          if (r2) var y2 = f2 ? r2(b2, E2, m2, t2, n3, o2) : r2(E2, b2, m2, n3, t2, o2);
          if (y2 !== i2) {
            if (y2) continue;
            P2 = false;
            break;
          }
          if (I2) {
            if (!Nr(t2, function(H2, $2) {
              if (!jt2(I2, $2) && (E2 === H2 || s2(E2, H2, e2, r2, o2))) return I2.push($2);
            })) {
              P2 = false;
              break;
            }
          } else if (!(E2 === b2 || s2(E2, b2, e2, r2, o2))) {
            P2 = false;
            break;
          }
        }
        return o2.delete(n3), o2.delete(t2), P2;
      }
      function nh2(n3, t2, e2, r2, s2, o2, f2) {
        switch (e2) {
          case Rt2:
            if (n3.byteLength != t2.byteLength || n3.byteOffset != t2.byteOffset) return false;
            n3 = n3.buffer, t2 = t2.buffer;
          case kt2:
            return !(n3.byteLength != t2.byteLength || !o2(new De2(n3), new De2(t2)));
          case Yt2:
          case Zt3:
          case Jt2:
            return bn2(+n3, +t2);
          case we2:
            return n3.name == t2.name && n3.message == t2.message;
          case Xt2:
          case Qt:
            return n3 == t2 + "";
          case yn:
            var c2 = qr;
          case Sn2:
            var l2 = r2 & Et2;
            if (c2 || (c2 = Se2), n3.size != t2.size && !l2) return false;
            var v2 = f2.get(n3);
            if (v2) return v2 == t2;
            r2 |= ve2, f2.set(n3, t2);
            var _2 = Su(c2(n3), c2(t2), r2, s2, o2, f2);
            return f2.delete(n3), _2;
          case Ae2:
            if (ie2) return ie2.call(n3) == ie2.call(t2);
        }
        return false;
      }
      function th2(n3, t2, e2, r2, s2, o2) {
        var f2 = e2 & Et2, c2 = li2(n3), l2 = c2.length, v2 = li2(t2), _2 = v2.length;
        if (l2 != _2 && !f2) return false;
        for (var m2 = l2; m2--; ) {
          var P2 = c2[m2];
          if (!(f2 ? P2 in t2 : F3.call(t2, P2))) return false;
        }
        var I2 = o2.get(n3), E2 = o2.get(t2);
        if (I2 && E2) return I2 == t2 && E2 == n3;
        var b2 = true;
        o2.set(n3, t2), o2.set(t2, n3);
        for (var y2 = f2; ++m2 < l2; ) {
          P2 = c2[m2];
          var H2 = n3[P2], $2 = t2[P2];
          if (r2) var dn = f2 ? r2($2, H2, P2, t2, n3, o2) : r2(H2, $2, P2, n3, t2, o2);
          if (!(dn === i2 ? H2 === $2 || s2(H2, $2, e2, r2, o2) : dn)) {
            b2 = false;
            break;
          }
          y2 || (y2 = P2 == "constructor");
        }
        if (b2 && !y2) {
          var sn2 = n3.constructor, gn = t2.constructor;
          sn2 != gn && "constructor" in n3 && "constructor" in t2 && !(typeof sn2 == "function" && sn2 instanceof sn2 && typeof gn == "function" && gn instanceof gn) && (b2 = false);
        }
        return o2.delete(n3), o2.delete(t2), b2;
      }
      function Yn2(n3) {
        return Pi2(Du(n3, i2, Bu), n3 + "");
      }
      function li2(n3) {
        return Zs(n3, V2, vi2);
      }
      function pi2(n3) {
        return Zs(n3, on2, Ou);
      }
      var di2 = Fe2 ? function(n3) {
        return Fe2.get(n3);
      } : Di2;
      function je2(n3) {
        for (var t2 = n3.name + "", e2 = Ut[t2], r2 = F3.call(Ut, t2) ? e2.length : 0; r2--; ) {
          var s2 = e2[r2], o2 = s2.func;
          if (o2 == null || o2 == n3) return s2.name;
        }
        return t2;
      }
      function qt2(n3) {
        var t2 = F3.call(a2, "placeholder") ? a2 : n3;
        return t2.placeholder;
      }
      function x2() {
        var n3 = a2.iteratee || Ti2;
        return n3 = n3 === Ti2 ? Qs : n3, arguments.length ? n3(arguments[0], arguments[1]) : n3;
      }
      function nr2(n3, t2) {
        var e2 = n3.__data__;
        return fh2(t2) ? e2[typeof t2 == "string" ? "string" : "hash"] : e2.map;
      }
      function gi2(n3) {
        for (var t2 = V2(n3), e2 = t2.length; e2--; ) {
          var r2 = t2[e2], s2 = n3[r2];
          t2[e2] = [r2, s2, Tu(s2)];
        }
        return t2;
      }
      function mt2(n3, t2) {
        var e2 = lf2(n3, t2);
        return Xs(e2) ? e2 : i2;
      }
      function eh2(n3) {
        var t2 = F3.call(n3, pt2), e2 = n3[pt2];
        try {
          n3[pt2] = i2;
          var r2 = true;
        } catch {
        }
        var s2 = Te2.call(n3);
        return r2 && (t2 ? n3[pt2] = e2 : delete n3[pt2]), s2;
      }
      var vi2 = Gr2 ? function(n3) {
        return n3 == null ? [] : (n3 = M2(n3), jn2(Gr2(n3), function(t2) {
          return Hs.call(n3, t2);
        }));
      } : Hi2, Ou = Gr2 ? function(n3) {
        for (var t2 = []; n3; ) nt2(t2, vi2(n3)), n3 = He2(n3);
        return t2;
      } : Hi2, tn2 = en2;
      (zr2 && tn2(new zr2(new ArrayBuffer(1))) != Rt2 || te2 && tn2(new te2()) != yn || Kr2 && tn2(Kr2.resolve()) != zi2 || $t3 && tn2(new $t3()) != Sn2 || ee2 && tn2(new ee2()) != Vt2) && (tn2 = function(n3) {
        var t2 = en2(n3), e2 = t2 == qn ? n3.constructor : i2, r2 = e2 ? wt2(e2) : "";
        if (r2) switch (r2) {
          case Wf2:
            return Rt2;
          case Ff2:
            return yn;
          case Mf2:
            return zi2;
          case qf2:
            return Sn2;
          case Bf2:
            return Vt2;
        }
        return t2;
      });
      function rh2(n3, t2, e2) {
        for (var r2 = -1, s2 = e2.length; ++r2 < s2; ) {
          var o2 = e2[r2], f2 = o2.size;
          switch (o2.type) {
            case "drop":
              n3 += f2;
              break;
            case "dropRight":
              t2 -= f2;
              break;
            case "take":
              t2 = nn2(t2, n3 + f2);
              break;
            case "takeRight":
              n3 = Q2(n3, t2 - f2);
              break;
          }
        }
        return { start: n3, end: t2 };
      }
      function ih2(n3) {
        var t2 = n3.match(oo);
        return t2 ? t2[1].split(fo) : [];
      }
      function Ru(n3, t2, e2) {
        t2 = st2(t2, n3);
        for (var r2 = -1, s2 = t2.length, o2 = false; ++r2 < s2; ) {
          var f2 = Wn(t2[r2]);
          if (!(o2 = n3 != null && e2(n3, f2))) break;
          n3 = n3[f2];
        }
        return o2 || ++r2 != s2 ? o2 : (s2 = n3 == null ? 0 : n3.length, !!s2 && ar(s2) && Zn2(f2, s2) && (O2(n3) || Pt2(n3)));
      }
      function sh2(n3) {
        var t2 = n3.length, e2 = new n3.constructor(t2);
        return t2 && typeof n3[0] == "string" && F3.call(n3, "index") && (e2.index = n3.index, e2.input = n3.input), e2;
      }
      function bu(n3) {
        return typeof n3.constructor == "function" && !he2(n3) ? Wt2(He2(n3)) : {};
      }
      function uh2(n3, t2, e2) {
        var r2 = n3.constructor;
        switch (t2) {
          case kt2:
            return fi2(n3);
          case Yt2:
          case Zt3:
            return new r2(+n3);
          case Rt2:
            return Gc2(n3, e2);
          case gr2:
          case vr2:
          case _r3:
          case mr2:
          case wr2:
          case Pr2:
          case Ar2:
          case Cr2:
          case Ir:
            return lu(n3, e2);
          case yn:
            return new r2();
          case Jt2:
          case Qt:
            return new r2(n3);
          case Xt2:
            return zc2(n3);
          case Sn2:
            return new r2();
          case Ae2:
            return Kc2(n3);
        }
      }
      function ah2(n3, t2) {
        var e2 = t2.length;
        if (!e2) return n3;
        var r2 = e2 - 1;
        return t2[r2] = (e2 > 1 ? "& " : "") + t2[r2], t2 = t2.join(e2 > 2 ? ", " : " "), n3.replace(ao, `{
/* [wrapped with ` + t2 + `] */
`);
      }
      function oh2(n3) {
        return O2(n3) || Pt2(n3) || !!(Ns && n3 && n3[Ns]);
      }
      function Zn2(n3, t2) {
        var e2 = typeof n3;
        return t2 = t2 ?? kn2, !!t2 && (e2 == "number" || e2 != "symbol" && wo.test(n3)) && n3 > -1 && n3 % 1 == 0 && n3 < t2;
      }
      function rn2(n3, t2, e2) {
        if (!K3(e2)) return false;
        var r2 = typeof t2;
        return (r2 == "number" ? an2(e2) && Zn2(t2, e2.length) : r2 == "string" && t2 in e2) ? bn2(e2[t2], n3) : false;
      }
      function _i2(n3, t2) {
        if (O2(n3)) return false;
        var e2 = typeof n3;
        return e2 == "number" || e2 == "symbol" || e2 == "boolean" || n3 == null || pn2(n3) ? true : ro2.test(n3) || !eo.test(n3) || t2 != null && n3 in M2(t2);
      }
      function fh2(n3) {
        var t2 = typeof n3;
        return t2 == "string" || t2 == "number" || t2 == "symbol" || t2 == "boolean" ? n3 !== "__proto__" : n3 === null;
      }
      function mi2(n3) {
        var t2 = je2(n3), e2 = a2[t2];
        if (typeof e2 != "function" || !(t2 in N2.prototype)) return false;
        if (n3 === e2) return true;
        var r2 = di2(e2);
        return !!r2 && n3 === r2[0];
      }
      function ch2(n3) {
        return !!Ts && Ts in n3;
      }
      var hh2 = Re2 ? Jn2 : Ni2;
      function he2(n3) {
        var t2 = n3 && n3.constructor, e2 = typeof t2 == "function" && t2.prototype || Nt2;
        return n3 === e2;
      }
      function Tu(n3) {
        return n3 === n3 && !K3(n3);
      }
      function Lu(n3, t2) {
        return function(e2) {
          return e2 == null ? false : e2[n3] === t2 && (t2 !== i2 || n3 in M2(e2));
        };
      }
      function lh2(n3) {
        var t2 = sr2(n3, function(r2) {
          return e2.size === pr2 && e2.clear(), r2;
        }), e2 = t2.cache;
        return t2;
      }
      function ph2(n3, t2) {
        var e2 = n3[1], r2 = t2[1], s2 = e2 | r2, o2 = s2 < (vn2 | ct2 | Mn), f2 = r2 == Mn && e2 == Dn || r2 == Mn && e2 == Kt2 && n3[7].length <= t2[8] || r2 == (Mn | Kt2) && t2[7].length <= t2[8] && e2 == Dn;
        if (!(o2 || f2)) return n3;
        r2 & vn2 && (n3[2] = t2[2], s2 |= e2 & vn2 ? 0 : qi2);
        var c2 = t2[3];
        if (c2) {
          var l2 = n3[3];
          n3[3] = l2 ? du(l2, c2, t2[4]) : c2, n3[4] = l2 ? tt2(n3[3], It2) : t2[4];
        }
        return c2 = t2[5], c2 && (l2 = n3[5], n3[5] = l2 ? gu(l2, c2, t2[6]) : c2, n3[6] = l2 ? tt2(n3[5], It2) : t2[6]), c2 = t2[7], c2 && (n3[7] = c2), r2 & Mn && (n3[8] = n3[8] == null ? t2[8] : nn2(n3[8], t2[8])), n3[9] == null && (n3[9] = t2[9]), n3[0] = t2[0], n3[1] = s2, n3;
      }
      function dh2(n3) {
        var t2 = [];
        if (n3 != null) for (var e2 in M2(n3)) t2.push(e2);
        return t2;
      }
      function gh2(n3) {
        return Te2.call(n3);
      }
      function Du(n3, t2, e2) {
        return t2 = Q2(t2 === i2 ? n3.length - 1 : t2, 0), function() {
          for (var r2 = arguments, s2 = -1, o2 = Q2(r2.length - t2, 0), f2 = p2(o2); ++s2 < o2; ) f2[s2] = r2[t2 + s2];
          s2 = -1;
          for (var c2 = p2(t2 + 1); ++s2 < t2; ) c2[s2] = r2[s2];
          return c2[t2] = e2(f2), cn2(n3, this, c2);
        };
      }
      function Hu(n3, t2) {
        return t2.length < 2 ? n3 : _t6(n3, Cn2(t2, 0, -1));
      }
      function vh2(n3, t2) {
        for (var e2 = n3.length, r2 = nn2(t2.length, e2), s2 = un2(n3); r2--; ) {
          var o2 = t2[r2];
          n3[r2] = Zn2(o2, e2) ? s2[o2] : i2;
        }
        return n3;
      }
      function wi2(n3, t2) {
        if (!(t2 === "constructor" && typeof n3[t2] == "function") && t2 != "__proto__") return n3[t2];
      }
      var Nu = Uu(iu), le2 = Tf2 || function(n3, t2) {
        return k2.setTimeout(n3, t2);
      }, Pi2 = Uu(Fc2);
      function $u(n3, t2, e2) {
        var r2 = t2 + "";
        return Pi2(n3, ah2(r2, _h2(ih2(r2), e2)));
      }
      function Uu(n3) {
        var t2 = 0, e2 = 0;
        return function() {
          var r2 = Nf2(), s2 = $a - (r2 - e2);
          if (e2 = r2, s2 > 0) {
            if (++t2 >= Na2) return arguments[0];
          } else t2 = 0;
          return n3.apply(i2, arguments);
        };
      }
      function tr2(n3, t2) {
        var e2 = -1, r2 = n3.length, s2 = r2 - 1;
        for (t2 = t2 === i2 ? r2 : t2; ++e2 < t2; ) {
          var o2 = ei2(e2, s2), f2 = n3[o2];
          n3[o2] = n3[e2], n3[e2] = f2;
        }
        return n3.length = t2, n3;
      }
      var Wu2 = lh2(function(n3) {
        var t2 = [];
        return n3.charCodeAt(0) === 46 && t2.push(""), n3.replace(io, function(e2, r2, s2, o2) {
          t2.push(s2 ? o2.replace(lo, "$1") : r2 || e2);
        }), t2;
      });
      function Wn(n3) {
        if (typeof n3 == "string" || pn2(n3)) return n3;
        var t2 = n3 + "";
        return t2 == "0" && 1 / n3 == -ht2 ? "-0" : t2;
      }
      function wt2(n3) {
        if (n3 != null) {
          try {
            return be2.call(n3);
          } catch {
          }
          try {
            return n3 + "";
          } catch {
          }
        }
        return "";
      }
      function _h2(n3, t2) {
        return mn2(Ba2, function(e2) {
          var r2 = "_." + e2[0];
          t2 & e2[1] && !Ee2(n3, r2) && n3.push(r2);
        }), n3.sort();
      }
      function Fu(n3) {
        if (n3 instanceof N2) return n3.clone();
        var t2 = new Pn2(n3.__wrapped__, n3.__chain__);
        return t2.__actions__ = un2(n3.__actions__), t2.__index__ = n3.__index__, t2.__values__ = n3.__values__, t2;
      }
      function mh2(n3, t2, e2) {
        (e2 ? rn2(n3, t2, e2) : t2 === i2) ? t2 = 1 : t2 = Q2(R2(t2), 0);
        var r2 = n3 == null ? 0 : n3.length;
        if (!r2 || t2 < 1) return [];
        for (var s2 = 0, o2 = 0, f2 = p2(Ue2(r2 / t2)); s2 < r2; ) f2[o2++] = Cn2(n3, s2, s2 += t2);
        return f2;
      }
      function wh2(n3) {
        for (var t2 = -1, e2 = n3 == null ? 0 : n3.length, r2 = 0, s2 = []; ++t2 < e2; ) {
          var o2 = n3[t2];
          o2 && (s2[r2++] = o2);
        }
        return s2;
      }
      function Ph2() {
        var n3 = arguments.length;
        if (!n3) return [];
        for (var t2 = p2(n3 - 1), e2 = arguments[0], r2 = n3; r2--; ) t2[r2 - 1] = arguments[r2];
        return nt2(O2(e2) ? un2(e2) : [e2], j2(t2, 1));
      }
      var Ah2 = T2(function(n3, t2) {
        return Z3(n3) ? ue2(n3, j2(t2, 1, Z3, true)) : [];
      }), Ch2 = T2(function(n3, t2) {
        var e2 = In2(t2);
        return Z3(e2) && (e2 = i2), Z3(n3) ? ue2(n3, j2(t2, 1, Z3, true), x2(e2, 2)) : [];
      }), Ih2 = T2(function(n3, t2) {
        var e2 = In2(t2);
        return Z3(e2) && (e2 = i2), Z3(n3) ? ue2(n3, j2(t2, 1, Z3, true), i2, e2) : [];
      });
      function xh2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        return r2 ? (t2 = e2 || t2 === i2 ? 1 : R2(t2), Cn2(n3, t2 < 0 ? 0 : t2, r2)) : [];
      }
      function Eh2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        return r2 ? (t2 = e2 || t2 === i2 ? 1 : R2(t2), t2 = r2 - t2, Cn2(n3, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function yh2(n3, t2) {
        return n3 && n3.length ? Ze2(n3, x2(t2, 3), true, true) : [];
      }
      function Sh2(n3, t2) {
        return n3 && n3.length ? Ze2(n3, x2(t2, 3), true) : [];
      }
      function Oh2(n3, t2, e2, r2) {
        var s2 = n3 == null ? 0 : n3.length;
        return s2 ? (e2 && typeof e2 != "number" && rn2(n3, t2, e2) && (e2 = 0, r2 = s2), Pc2(n3, t2, e2, r2)) : [];
      }
      function Mu(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        if (!r2) return -1;
        var s2 = e2 == null ? 0 : R2(e2);
        return s2 < 0 && (s2 = Q2(r2 + s2, 0)), ye2(n3, x2(t2, 3), s2);
      }
      function qu(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        if (!r2) return -1;
        var s2 = r2 - 1;
        return e2 !== i2 && (s2 = R2(e2), s2 = e2 < 0 ? Q2(r2 + s2, 0) : nn2(s2, r2 - 1)), ye2(n3, x2(t2, 3), s2, true);
      }
      function Bu(n3) {
        var t2 = n3 == null ? 0 : n3.length;
        return t2 ? j2(n3, 1) : [];
      }
      function Rh2(n3) {
        var t2 = n3 == null ? 0 : n3.length;
        return t2 ? j2(n3, ht2) : [];
      }
      function bh2(n3, t2) {
        var e2 = n3 == null ? 0 : n3.length;
        return e2 ? (t2 = t2 === i2 ? 1 : R2(t2), j2(n3, t2)) : [];
      }
      function Th2(n3) {
        for (var t2 = -1, e2 = n3 == null ? 0 : n3.length, r2 = {}; ++t2 < e2; ) {
          var s2 = n3[t2];
          r2[s2[0]] = s2[1];
        }
        return r2;
      }
      function Gu(n3) {
        return n3 && n3.length ? n3[0] : i2;
      }
      function Lh2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        if (!r2) return -1;
        var s2 = e2 == null ? 0 : R2(e2);
        return s2 < 0 && (s2 = Q2(r2 + s2, 0)), Tt2(n3, t2, s2);
      }
      function Dh2(n3) {
        var t2 = n3 == null ? 0 : n3.length;
        return t2 ? Cn2(n3, 0, -1) : [];
      }
      var Hh2 = T2(function(n3) {
        var t2 = G3(n3, ai2);
        return t2.length && t2[0] === n3[0] ? Vr2(t2) : [];
      }), Nh2 = T2(function(n3) {
        var t2 = In2(n3), e2 = G3(n3, ai2);
        return t2 === In2(e2) ? t2 = i2 : e2.pop(), e2.length && e2[0] === n3[0] ? Vr2(e2, x2(t2, 2)) : [];
      }), $h2 = T2(function(n3) {
        var t2 = In2(n3), e2 = G3(n3, ai2);
        return t2 = typeof t2 == "function" ? t2 : i2, t2 && e2.pop(), e2.length && e2[0] === n3[0] ? Vr2(e2, i2, t2) : [];
      });
      function Uh2(n3, t2) {
        return n3 == null ? "" : Df2.call(n3, t2);
      }
      function In2(n3) {
        var t2 = n3 == null ? 0 : n3.length;
        return t2 ? n3[t2 - 1] : i2;
      }
      function Wh2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        if (!r2) return -1;
        var s2 = r2;
        return e2 !== i2 && (s2 = R2(e2), s2 = s2 < 0 ? Q2(r2 + s2, 0) : nn2(s2, r2 - 1)), t2 === t2 ? _f2(n3, t2, s2) : ye2(n3, Is, s2, true);
      }
      function Fh2(n3, t2) {
        return n3 && n3.length ? nu(n3, R2(t2)) : i2;
      }
      var Mh2 = T2(zu);
      function zu(n3, t2) {
        return n3 && n3.length && t2 && t2.length ? ti2(n3, t2) : n3;
      }
      function qh2(n3, t2, e2) {
        return n3 && n3.length && t2 && t2.length ? ti2(n3, t2, x2(e2, 2)) : n3;
      }
      function Bh2(n3, t2, e2) {
        return n3 && n3.length && t2 && t2.length ? ti2(n3, t2, i2, e2) : n3;
      }
      var Gh2 = Yn2(function(n3, t2) {
        var e2 = n3 == null ? 0 : n3.length, r2 = Zr2(n3, t2);
        return ru(n3, G3(t2, function(s2) {
          return Zn2(s2, e2) ? +s2 : s2;
        }).sort(pu)), r2;
      });
      function zh2(n3, t2) {
        var e2 = [];
        if (!(n3 && n3.length)) return e2;
        var r2 = -1, s2 = [], o2 = n3.length;
        for (t2 = x2(t2, 3); ++r2 < o2; ) {
          var f2 = n3[r2];
          t2(f2, r2, n3) && (e2.push(f2), s2.push(r2));
        }
        return ru(n3, s2), e2;
      }
      function Ai2(n3) {
        return n3 == null ? n3 : Uf2.call(n3);
      }
      function Kh2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        return r2 ? (e2 && typeof e2 != "number" && rn2(n3, t2, e2) ? (t2 = 0, e2 = r2) : (t2 = t2 == null ? 0 : R2(t2), e2 = e2 === i2 ? r2 : R2(e2)), Cn2(n3, t2, e2)) : [];
      }
      function Yh2(n3, t2) {
        return Ye2(n3, t2);
      }
      function Zh2(n3, t2, e2) {
        return ii2(n3, t2, x2(e2, 2));
      }
      function Jh2(n3, t2) {
        var e2 = n3 == null ? 0 : n3.length;
        if (e2) {
          var r2 = Ye2(n3, t2);
          if (r2 < e2 && bn2(n3[r2], t2)) return r2;
        }
        return -1;
      }
      function Xh2(n3, t2) {
        return Ye2(n3, t2, true);
      }
      function Qh2(n3, t2, e2) {
        return ii2(n3, t2, x2(e2, 2), true);
      }
      function Vh2(n3, t2) {
        var e2 = n3 == null ? 0 : n3.length;
        if (e2) {
          var r2 = Ye2(n3, t2, true) - 1;
          if (bn2(n3[r2], t2)) return r2;
        }
        return -1;
      }
      function kh2(n3) {
        return n3 && n3.length ? su(n3) : [];
      }
      function jh2(n3, t2) {
        return n3 && n3.length ? su(n3, x2(t2, 2)) : [];
      }
      function nl2(n3) {
        var t2 = n3 == null ? 0 : n3.length;
        return t2 ? Cn2(n3, 1, t2) : [];
      }
      function tl2(n3, t2, e2) {
        return n3 && n3.length ? (t2 = e2 || t2 === i2 ? 1 : R2(t2), Cn2(n3, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function el2(n3, t2, e2) {
        var r2 = n3 == null ? 0 : n3.length;
        return r2 ? (t2 = e2 || t2 === i2 ? 1 : R2(t2), t2 = r2 - t2, Cn2(n3, t2 < 0 ? 0 : t2, r2)) : [];
      }
      function rl2(n3, t2) {
        return n3 && n3.length ? Ze2(n3, x2(t2, 3), false, true) : [];
      }
      function il2(n3, t2) {
        return n3 && n3.length ? Ze2(n3, x2(t2, 3)) : [];
      }
      var sl2 = T2(function(n3) {
        return it2(j2(n3, 1, Z3, true));
      }), ul2 = T2(function(n3) {
        var t2 = In2(n3);
        return Z3(t2) && (t2 = i2), it2(j2(n3, 1, Z3, true), x2(t2, 2));
      }), al2 = T2(function(n3) {
        var t2 = In2(n3);
        return t2 = typeof t2 == "function" ? t2 : i2, it2(j2(n3, 1, Z3, true), i2, t2);
      });
      function ol2(n3) {
        return n3 && n3.length ? it2(n3) : [];
      }
      function fl2(n3, t2) {
        return n3 && n3.length ? it2(n3, x2(t2, 2)) : [];
      }
      function cl2(n3, t2) {
        return t2 = typeof t2 == "function" ? t2 : i2, n3 && n3.length ? it2(n3, i2, t2) : [];
      }
      function Ci2(n3) {
        if (!(n3 && n3.length)) return [];
        var t2 = 0;
        return n3 = jn2(n3, function(e2) {
          if (Z3(e2)) return t2 = Q2(e2.length, t2), true;
        }), Fr2(t2, function(e2) {
          return G3(n3, $r(e2));
        });
      }
      function Ku(n3, t2) {
        if (!(n3 && n3.length)) return [];
        var e2 = Ci2(n3);
        return t2 == null ? e2 : G3(e2, function(r2) {
          return cn2(t2, i2, r2);
        });
      }
      var hl2 = T2(function(n3, t2) {
        return Z3(n3) ? ue2(n3, t2) : [];
      }), ll2 = T2(function(n3) {
        return ui2(jn2(n3, Z3));
      }), pl2 = T2(function(n3) {
        var t2 = In2(n3);
        return Z3(t2) && (t2 = i2), ui2(jn2(n3, Z3), x2(t2, 2));
      }), dl2 = T2(function(n3) {
        var t2 = In2(n3);
        return t2 = typeof t2 == "function" ? t2 : i2, ui2(jn2(n3, Z3), i2, t2);
      }), gl2 = T2(Ci2);
      function vl2(n3, t2) {
        return fu(n3 || [], t2 || [], se2);
      }
      function _l2(n3, t2) {
        return fu(n3 || [], t2 || [], fe2);
      }
      var ml2 = T2(function(n3) {
        var t2 = n3.length, e2 = t2 > 1 ? n3[t2 - 1] : i2;
        return e2 = typeof e2 == "function" ? (n3.pop(), e2) : i2, Ku(n3, e2);
      });
      function Yu(n3) {
        var t2 = a2(n3);
        return t2.__chain__ = true, t2;
      }
      function wl(n3, t2) {
        return t2(n3), n3;
      }
      function er2(n3, t2) {
        return t2(n3);
      }
      var Pl = Yn2(function(n3) {
        var t2 = n3.length, e2 = t2 ? n3[0] : 0, r2 = this.__wrapped__, s2 = function(o2) {
          return Zr2(o2, n3);
        };
        return t2 > 1 || this.__actions__.length || !(r2 instanceof N2) || !Zn2(e2) ? this.thru(s2) : (r2 = r2.slice(e2, +e2 + (t2 ? 1 : 0)), r2.__actions__.push({ func: er2, args: [s2], thisArg: i2 }), new Pn2(r2, this.__chain__).thru(function(o2) {
          return t2 && !o2.length && o2.push(i2), o2;
        }));
      });
      function Al() {
        return Yu(this);
      }
      function Cl() {
        return new Pn2(this.value(), this.__chain__);
      }
      function Il() {
        this.__values__ === i2 && (this.__values__ = ua2(this.value()));
        var n3 = this.__index__ >= this.__values__.length, t2 = n3 ? i2 : this.__values__[this.__index__++];
        return { done: n3, value: t2 };
      }
      function xl() {
        return this;
      }
      function El(n3) {
        for (var t2, e2 = this; e2 instanceof qe2; ) {
          var r2 = Fu(e2);
          r2.__index__ = 0, r2.__values__ = i2, t2 ? s2.__wrapped__ = r2 : t2 = r2;
          var s2 = r2;
          e2 = e2.__wrapped__;
        }
        return s2.__wrapped__ = n3, t2;
      }
      function yl() {
        var n3 = this.__wrapped__;
        if (n3 instanceof N2) {
          var t2 = n3;
          return this.__actions__.length && (t2 = new N2(this)), t2 = t2.reverse(), t2.__actions__.push({ func: er2, args: [Ai2], thisArg: i2 }), new Pn2(t2, this.__chain__);
        }
        return this.thru(Ai2);
      }
      function Sl2() {
        return ou(this.__wrapped__, this.__actions__);
      }
      var Ol = Je2(function(n3, t2, e2) {
        F3.call(n3, e2) ? ++n3[e2] : zn2(n3, e2, 1);
      });
      function Rl(n3, t2, e2) {
        var r2 = O2(n3) ? As : wc2;
        return e2 && rn2(n3, t2, e2) && (t2 = i2), r2(n3, x2(t2, 3));
      }
      function bl2(n3, t2) {
        var e2 = O2(n3) ? jn2 : Ks;
        return e2(n3, x2(t2, 3));
      }
      var Tl = wu(Mu), Ll = wu(qu);
      function Dl(n3, t2) {
        return j2(rr2(n3, t2), 1);
      }
      function Hl(n3, t2) {
        return j2(rr2(n3, t2), ht2);
      }
      function Nl(n3, t2, e2) {
        return e2 = e2 === i2 ? 1 : R2(e2), j2(rr2(n3, t2), e2);
      }
      function Zu(n3, t2) {
        var e2 = O2(n3) ? mn2 : rt2;
        return e2(n3, x2(t2, 3));
      }
      function Ju(n3, t2) {
        var e2 = O2(n3) ? jo : zs;
        return e2(n3, x2(t2, 3));
      }
      var $l = Je2(function(n3, t2, e2) {
        F3.call(n3, e2) ? n3[e2].push(t2) : zn2(n3, e2, [t2]);
      });
      function Ul(n3, t2, e2, r2) {
        n3 = an2(n3) ? n3 : Gt2(n3), e2 = e2 && !r2 ? R2(e2) : 0;
        var s2 = n3.length;
        return e2 < 0 && (e2 = Q2(s2 + e2, 0)), or(n3) ? e2 <= s2 && n3.indexOf(t2, e2) > -1 : !!s2 && Tt2(n3, t2, e2) > -1;
      }
      var Wl = T2(function(n3, t2, e2) {
        var r2 = -1, s2 = typeof t2 == "function", o2 = an2(n3) ? p2(n3.length) : [];
        return rt2(n3, function(f2) {
          o2[++r2] = s2 ? cn2(t2, f2, e2) : ae2(f2, t2, e2);
        }), o2;
      }), Fl = Je2(function(n3, t2, e2) {
        zn2(n3, e2, t2);
      });
      function rr2(n3, t2) {
        var e2 = O2(n3) ? G3 : Vs;
        return e2(n3, x2(t2, 3));
      }
      function Ml(n3, t2, e2, r2) {
        return n3 == null ? [] : (O2(t2) || (t2 = t2 == null ? [] : [t2]), e2 = r2 ? i2 : e2, O2(e2) || (e2 = e2 == null ? [] : [e2]), tu(n3, t2, e2));
      }
      var ql2 = Je2(function(n3, t2, e2) {
        n3[e2 ? 0 : 1].push(t2);
      }, function() {
        return [[], []];
      });
      function Bl(n3, t2, e2) {
        var r2 = O2(n3) ? Hr2 : Es, s2 = arguments.length < 3;
        return r2(n3, x2(t2, 4), e2, s2, rt2);
      }
      function Gl(n3, t2, e2) {
        var r2 = O2(n3) ? nf2 : Es, s2 = arguments.length < 3;
        return r2(n3, x2(t2, 4), e2, s2, zs);
      }
      function zl(n3, t2) {
        var e2 = O2(n3) ? jn2 : Ks;
        return e2(n3, ur2(x2(t2, 3)));
      }
      function Kl2(n3) {
        var t2 = O2(n3) ? Ms : Uc2;
        return t2(n3);
      }
      function Yl(n3, t2, e2) {
        (e2 ? rn2(n3, t2, e2) : t2 === i2) ? t2 = 1 : t2 = R2(t2);
        var r2 = O2(n3) ? dc2 : Wc2;
        return r2(n3, t2);
      }
      function Zl(n3) {
        var t2 = O2(n3) ? gc2 : Mc2;
        return t2(n3);
      }
      function Jl(n3) {
        if (n3 == null) return 0;
        if (an2(n3)) return or(n3) ? Dt2(n3) : n3.length;
        var t2 = tn2(n3);
        return t2 == yn || t2 == Sn2 ? n3.size : jr2(n3).length;
      }
      function Xl(n3, t2, e2) {
        var r2 = O2(n3) ? Nr : qc2;
        return e2 && rn2(n3, t2, e2) && (t2 = i2), r2(n3, x2(t2, 3));
      }
      var Ql = T2(function(n3, t2) {
        if (n3 == null) return [];
        var e2 = t2.length;
        return e2 > 1 && rn2(n3, t2[0], t2[1]) ? t2 = [] : e2 > 2 && rn2(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), tu(n3, j2(t2, 1), []);
      }), ir = bf2 || function() {
        return k2.Date.now();
      };
      function Vl(n3, t2) {
        if (typeof t2 != "function") throw new wn2(D2);
        return n3 = R2(n3), function() {
          if (--n3 < 1) return t2.apply(this, arguments);
        };
      }
      function Xu(n3, t2, e2) {
        return t2 = e2 ? i2 : t2, t2 = n3 && t2 == null ? n3.length : t2, Kn(n3, Mn, i2, i2, i2, i2, t2);
      }
      function Qu(n3, t2) {
        var e2;
        if (typeof t2 != "function") throw new wn2(D2);
        return n3 = R2(n3), function() {
          return --n3 > 0 && (e2 = t2.apply(this, arguments)), n3 <= 1 && (t2 = i2), e2;
        };
      }
      var Ii2 = T2(function(n3, t2, e2) {
        var r2 = vn2;
        if (e2.length) {
          var s2 = tt2(e2, qt2(Ii2));
          r2 |= Hn2;
        }
        return Kn(n3, r2, t2, e2, s2);
      }), Vu = T2(function(n3, t2, e2) {
        var r2 = vn2 | ct2;
        if (e2.length) {
          var s2 = tt2(e2, qt2(Vu));
          r2 |= Hn2;
        }
        return Kn(t2, r2, n3, e2, s2);
      });
      function ku(n3, t2, e2) {
        t2 = e2 ? i2 : t2;
        var r2 = Kn(n3, Dn, i2, i2, i2, i2, i2, t2);
        return r2.placeholder = ku.placeholder, r2;
      }
      function ju(n3, t2, e2) {
        t2 = e2 ? i2 : t2;
        var r2 = Kn(n3, yt2, i2, i2, i2, i2, i2, t2);
        return r2.placeholder = ju.placeholder, r2;
      }
      function na(n3, t2, e2) {
        var r2, s2, o2, f2, c2, l2, v2 = 0, _2 = false, m2 = false, P2 = true;
        if (typeof n3 != "function") throw new wn2(D2);
        t2 = xn2(t2) || 0, K3(e2) && (_2 = !!e2.leading, m2 = "maxWait" in e2, o2 = m2 ? Q2(xn2(e2.maxWait) || 0, t2) : o2, P2 = "trailing" in e2 ? !!e2.trailing : P2);
        function I2(J2) {
          var Tn2 = r2, Qn = s2;
          return r2 = s2 = i2, v2 = J2, f2 = n3.apply(Qn, Tn2), f2;
        }
        function E2(J2) {
          return v2 = J2, c2 = le2(H2, t2), _2 ? I2(J2) : f2;
        }
        function b2(J2) {
          var Tn2 = J2 - l2, Qn = J2 - v2, wa2 = t2 - Tn2;
          return m2 ? nn2(wa2, o2 - Qn) : wa2;
        }
        function y2(J2) {
          var Tn2 = J2 - l2, Qn = J2 - v2;
          return l2 === i2 || Tn2 >= t2 || Tn2 < 0 || m2 && Qn >= o2;
        }
        function H2() {
          var J2 = ir();
          if (y2(J2)) return $2(J2);
          c2 = le2(H2, b2(J2));
        }
        function $2(J2) {
          return c2 = i2, P2 && r2 ? I2(J2) : (r2 = s2 = i2, f2);
        }
        function dn() {
          c2 !== i2 && cu(c2), v2 = 0, r2 = l2 = s2 = c2 = i2;
        }
        function sn2() {
          return c2 === i2 ? f2 : $2(ir());
        }
        function gn() {
          var J2 = ir(), Tn2 = y2(J2);
          if (r2 = arguments, s2 = this, l2 = J2, Tn2) {
            if (c2 === i2) return E2(l2);
            if (m2) return cu(c2), c2 = le2(H2, t2), I2(l2);
          }
          return c2 === i2 && (c2 = le2(H2, t2)), f2;
        }
        return gn.cancel = dn, gn.flush = sn2, gn;
      }
      var kl2 = T2(function(n3, t2) {
        return Gs(n3, 1, t2);
      }), jl2 = T2(function(n3, t2, e2) {
        return Gs(n3, xn2(t2) || 0, e2);
      });
      function np(n3) {
        return Kn(n3, dr2);
      }
      function sr2(n3, t2) {
        if (typeof n3 != "function" || t2 != null && typeof t2 != "function") throw new wn2(D2);
        var e2 = function() {
          var r2 = arguments, s2 = t2 ? t2.apply(this, r2) : r2[0], o2 = e2.cache;
          if (o2.has(s2)) return o2.get(s2);
          var f2 = n3.apply(this, r2);
          return e2.cache = o2.set(s2, f2) || o2, f2;
        };
        return e2.cache = new (sr2.Cache || Gn2)(), e2;
      }
      sr2.Cache = Gn2;
      function ur2(n3) {
        if (typeof n3 != "function") throw new wn2(D2);
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return !n3.call(this);
            case 1:
              return !n3.call(this, t2[0]);
            case 2:
              return !n3.call(this, t2[0], t2[1]);
            case 3:
              return !n3.call(this, t2[0], t2[1], t2[2]);
          }
          return !n3.apply(this, t2);
        };
      }
      function tp(n3) {
        return Qu(2, n3);
      }
      var ep = Bc2(function(n3, t2) {
        t2 = t2.length == 1 && O2(t2[0]) ? G3(t2[0], hn2(x2())) : G3(j2(t2, 1), hn2(x2()));
        var e2 = t2.length;
        return T2(function(r2) {
          for (var s2 = -1, o2 = nn2(r2.length, e2); ++s2 < o2; ) r2[s2] = t2[s2].call(this, r2[s2]);
          return cn2(n3, this, r2);
        });
      }), xi2 = T2(function(n3, t2) {
        var e2 = tt2(t2, qt2(xi2));
        return Kn(n3, Hn2, i2, t2, e2);
      }), ta2 = T2(function(n3, t2) {
        var e2 = tt2(t2, qt2(ta2));
        return Kn(n3, St2, i2, t2, e2);
      }), rp = Yn2(function(n3, t2) {
        return Kn(n3, Kt2, i2, i2, i2, t2);
      });
      function ip(n3, t2) {
        if (typeof n3 != "function") throw new wn2(D2);
        return t2 = t2 === i2 ? t2 : R2(t2), T2(n3, t2);
      }
      function sp(n3, t2) {
        if (typeof n3 != "function") throw new wn2(D2);
        return t2 = t2 == null ? 0 : Q2(R2(t2), 0), T2(function(e2) {
          var r2 = e2[t2], s2 = ut2(e2, 0, t2);
          return r2 && nt2(s2, r2), cn2(n3, this, s2);
        });
      }
      function up(n3, t2, e2) {
        var r2 = true, s2 = true;
        if (typeof n3 != "function") throw new wn2(D2);
        return K3(e2) && (r2 = "leading" in e2 ? !!e2.leading : r2, s2 = "trailing" in e2 ? !!e2.trailing : s2), na(n3, t2, { leading: r2, maxWait: t2, trailing: s2 });
      }
      function ap(n3) {
        return Xu(n3, 1);
      }
      function op(n3, t2) {
        return xi2(oi2(t2), n3);
      }
      function fp() {
        if (!arguments.length) return [];
        var n3 = arguments[0];
        return O2(n3) ? n3 : [n3];
      }
      function cp(n3) {
        return An2(n3, xt2);
      }
      function hp(n3, t2) {
        return t2 = typeof t2 == "function" ? t2 : i2, An2(n3, xt2, t2);
      }
      function lp(n3) {
        return An2(n3, Ln | xt2);
      }
      function pp(n3, t2) {
        return t2 = typeof t2 == "function" ? t2 : i2, An2(n3, Ln | xt2, t2);
      }
      function dp(n3, t2) {
        return t2 == null || Bs(n3, t2, V2(t2));
      }
      function bn2(n3, t2) {
        return n3 === t2 || n3 !== n3 && t2 !== t2;
      }
      var gp = ke2(Qr2), vp = ke2(function(n3, t2) {
        return n3 >= t2;
      }), Pt2 = Js(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Js : function(n3) {
        return Y3(n3) && F3.call(n3, "callee") && !Hs.call(n3, "callee");
      }, O2 = p2.isArray, _p2 = gs ? hn2(gs) : Ec2;
      function an2(n3) {
        return n3 != null && ar(n3.length) && !Jn2(n3);
      }
      function Z3(n3) {
        return Y3(n3) && an2(n3);
      }
      function mp(n3) {
        return n3 === true || n3 === false || Y3(n3) && en2(n3) == Yt2;
      }
      var at2 = Lf2 || Ni2, wp2 = vs ? hn2(vs) : yc2;
      function Pp(n3) {
        return Y3(n3) && n3.nodeType === 1 && !pe2(n3);
      }
      function Ap(n3) {
        if (n3 == null) return true;
        if (an2(n3) && (O2(n3) || typeof n3 == "string" || typeof n3.splice == "function" || at2(n3) || Bt2(n3) || Pt2(n3))) return !n3.length;
        var t2 = tn2(n3);
        if (t2 == yn || t2 == Sn2) return !n3.size;
        if (he2(n3)) return !jr2(n3).length;
        for (var e2 in n3) if (F3.call(n3, e2)) return false;
        return true;
      }
      function Cp(n3, t2) {
        return oe2(n3, t2);
      }
      function Ip(n3, t2, e2) {
        e2 = typeof e2 == "function" ? e2 : i2;
        var r2 = e2 ? e2(n3, t2) : i2;
        return r2 === i2 ? oe2(n3, t2, i2, e2) : !!r2;
      }
      function Ei2(n3) {
        if (!Y3(n3)) return false;
        var t2 = en2(n3);
        return t2 == we2 || t2 == za2 || typeof n3.message == "string" && typeof n3.name == "string" && !pe2(n3);
      }
      function xp(n3) {
        return typeof n3 == "number" && $s(n3);
      }
      function Jn2(n3) {
        if (!K3(n3)) return false;
        var t2 = en2(n3);
        return t2 == Pe2 || t2 == Gi2 || t2 == Ga2 || t2 == Ya2;
      }
      function ea2(n3) {
        return typeof n3 == "number" && n3 == R2(n3);
      }
      function ar(n3) {
        return typeof n3 == "number" && n3 > -1 && n3 % 1 == 0 && n3 <= kn2;
      }
      function K3(n3) {
        var t2 = typeof n3;
        return n3 != null && (t2 == "object" || t2 == "function");
      }
      function Y3(n3) {
        return n3 != null && typeof n3 == "object";
      }
      var ra2 = _s2 ? hn2(_s2) : Oc2;
      function Ep(n3, t2) {
        return n3 === t2 || kr2(n3, t2, gi2(t2));
      }
      function yp(n3, t2, e2) {
        return e2 = typeof e2 == "function" ? e2 : i2, kr2(n3, t2, gi2(t2), e2);
      }
      function Sp(n3) {
        return ia2(n3) && n3 != +n3;
      }
      function Op(n3) {
        if (hh2(n3)) throw new S2(L2);
        return Xs(n3);
      }
      function Rp(n3) {
        return n3 === null;
      }
      function bp(n3) {
        return n3 == null;
      }
      function ia2(n3) {
        return typeof n3 == "number" || Y3(n3) && en2(n3) == Jt2;
      }
      function pe2(n3) {
        if (!Y3(n3) || en2(n3) != qn) return false;
        var t2 = He2(n3);
        if (t2 === null) return true;
        var e2 = F3.call(t2, "constructor") && t2.constructor;
        return typeof e2 == "function" && e2 instanceof e2 && be2.call(e2) == yf2;
      }
      var yi2 = ms ? hn2(ms) : Rc2;
      function Tp(n3) {
        return ea2(n3) && n3 >= -kn2 && n3 <= kn2;
      }
      var sa2 = ws ? hn2(ws) : bc2;
      function or(n3) {
        return typeof n3 == "string" || !O2(n3) && Y3(n3) && en2(n3) == Qt;
      }
      function pn2(n3) {
        return typeof n3 == "symbol" || Y3(n3) && en2(n3) == Ae2;
      }
      var Bt2 = Ps ? hn2(Ps) : Tc2;
      function Lp(n3) {
        return n3 === i2;
      }
      function Dp(n3) {
        return Y3(n3) && tn2(n3) == Vt2;
      }
      function Hp(n3) {
        return Y3(n3) && en2(n3) == Ja2;
      }
      var Np = ke2(ni2), $p = ke2(function(n3, t2) {
        return n3 <= t2;
      });
      function ua2(n3) {
        if (!n3) return [];
        if (an2(n3)) return or(n3) ? On(n3) : un2(n3);
        if (ne2 && n3[ne2]) return df2(n3[ne2]());
        var t2 = tn2(n3), e2 = t2 == yn ? qr : t2 == Sn2 ? Se2 : Gt2;
        return e2(n3);
      }
      function Xn2(n3) {
        if (!n3) return n3 === 0 ? n3 : 0;
        if (n3 = xn2(n3), n3 === ht2 || n3 === -ht2) {
          var t2 = n3 < 0 ? -1 : 1;
          return t2 * Fa2;
        }
        return n3 === n3 ? n3 : 0;
      }
      function R2(n3) {
        var t2 = Xn2(n3), e2 = t2 % 1;
        return t2 === t2 ? e2 ? t2 - e2 : t2 : 0;
      }
      function aa2(n3) {
        return n3 ? vt2(R2(n3), 0, Nn2) : 0;
      }
      function xn2(n3) {
        if (typeof n3 == "number") return n3;
        if (pn2(n3)) return _e3;
        if (K3(n3)) {
          var t2 = typeof n3.valueOf == "function" ? n3.valueOf() : n3;
          n3 = K3(t2) ? t2 + "" : t2;
        }
        if (typeof n3 != "string") return n3 === 0 ? n3 : +n3;
        n3 = ys(n3);
        var e2 = vo.test(n3);
        return e2 || mo.test(n3) ? Qo2(n3.slice(2), e2 ? 2 : 8) : go.test(n3) ? _e3 : +n3;
      }
      function oa2(n3) {
        return Un(n3, on2(n3));
      }
      function Up(n3) {
        return n3 ? vt2(R2(n3), -kn2, kn2) : n3 === 0 ? n3 : 0;
      }
      function W2(n3) {
        return n3 == null ? "" : ln2(n3);
      }
      var Wp = Ft2(function(n3, t2) {
        if (he2(t2) || an2(t2)) {
          Un(t2, V2(t2), n3);
          return;
        }
        for (var e2 in t2) F3.call(t2, e2) && se2(n3, e2, t2[e2]);
      }), fa2 = Ft2(function(n3, t2) {
        Un(t2, on2(t2), n3);
      }), fr2 = Ft2(function(n3, t2, e2, r2) {
        Un(t2, on2(t2), n3, r2);
      }), Fp2 = Ft2(function(n3, t2, e2, r2) {
        Un(t2, V2(t2), n3, r2);
      }), Mp = Yn2(Zr2);
      function qp(n3, t2) {
        var e2 = Wt2(n3);
        return t2 == null ? e2 : qs(e2, t2);
      }
      var Bp = T2(function(n3, t2) {
        n3 = M2(n3);
        var e2 = -1, r2 = t2.length, s2 = r2 > 2 ? t2[2] : i2;
        for (s2 && rn2(t2[0], t2[1], s2) && (r2 = 1); ++e2 < r2; ) for (var o2 = t2[e2], f2 = on2(o2), c2 = -1, l2 = f2.length; ++c2 < l2; ) {
          var v2 = f2[c2], _2 = n3[v2];
          (_2 === i2 || bn2(_2, Nt2[v2]) && !F3.call(n3, v2)) && (n3[v2] = o2[v2]);
        }
        return n3;
      }), Gp = T2(function(n3) {
        return n3.push(i2, yu), cn2(ca2, i2, n3);
      });
      function zp(n3, t2) {
        return Cs(n3, x2(t2, 3), $n);
      }
      function Kp(n3, t2) {
        return Cs(n3, x2(t2, 3), Xr2);
      }
      function Yp(n3, t2) {
        return n3 == null ? n3 : Jr2(n3, x2(t2, 3), on2);
      }
      function Zp(n3, t2) {
        return n3 == null ? n3 : Ys(n3, x2(t2, 3), on2);
      }
      function Jp(n3, t2) {
        return n3 && $n(n3, x2(t2, 3));
      }
      function Xp(n3, t2) {
        return n3 && Xr2(n3, x2(t2, 3));
      }
      function Qp(n3) {
        return n3 == null ? [] : ze2(n3, V2(n3));
      }
      function Vp(n3) {
        return n3 == null ? [] : ze2(n3, on2(n3));
      }
      function Si2(n3, t2, e2) {
        var r2 = n3 == null ? i2 : _t6(n3, t2);
        return r2 === i2 ? e2 : r2;
      }
      function kp(n3, t2) {
        return n3 != null && Ru(n3, t2, Ac2);
      }
      function Oi2(n3, t2) {
        return n3 != null && Ru(n3, t2, Cc2);
      }
      var jp = Au(function(n3, t2, e2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Te2.call(t2)), n3[t2] = e2;
      }, bi2(fn2)), nd2 = Au(function(n3, t2, e2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Te2.call(t2)), F3.call(n3, t2) ? n3[t2].push(e2) : n3[t2] = [e2];
      }, x2), td2 = T2(ae2);
      function V2(n3) {
        return an2(n3) ? Fs(n3) : jr2(n3);
      }
      function on2(n3) {
        return an2(n3) ? Fs(n3, true) : Lc2(n3);
      }
      function ed2(n3, t2) {
        var e2 = {};
        return t2 = x2(t2, 3), $n(n3, function(r2, s2, o2) {
          zn2(e2, t2(r2, s2, o2), r2);
        }), e2;
      }
      function rd2(n3, t2) {
        var e2 = {};
        return t2 = x2(t2, 3), $n(n3, function(r2, s2, o2) {
          zn2(e2, s2, t2(r2, s2, o2));
        }), e2;
      }
      var id2 = Ft2(function(n3, t2, e2) {
        Ke2(n3, t2, e2);
      }), ca2 = Ft2(function(n3, t2, e2, r2) {
        Ke2(n3, t2, e2, r2);
      }), sd2 = Yn2(function(n3, t2) {
        var e2 = {};
        if (n3 == null) return e2;
        var r2 = false;
        t2 = G3(t2, function(o2) {
          return o2 = st2(o2, n3), r2 || (r2 = o2.length > 1), o2;
        }), Un(n3, pi2(n3), e2), r2 && (e2 = An2(e2, Ln | Fn | xt2, jc2));
        for (var s2 = t2.length; s2--; ) si2(e2, t2[s2]);
        return e2;
      });
      function ud2(n3, t2) {
        return ha2(n3, ur2(x2(t2)));
      }
      var ad2 = Yn2(function(n3, t2) {
        return n3 == null ? {} : Hc2(n3, t2);
      });
      function ha2(n3, t2) {
        if (n3 == null) return {};
        var e2 = G3(pi2(n3), function(r2) {
          return [r2];
        });
        return t2 = x2(t2), eu2(n3, e2, function(r2, s2) {
          return t2(r2, s2[0]);
        });
      }
      function od2(n3, t2, e2) {
        t2 = st2(t2, n3);
        var r2 = -1, s2 = t2.length;
        for (s2 || (s2 = 1, n3 = i2); ++r2 < s2; ) {
          var o2 = n3 == null ? i2 : n3[Wn(t2[r2])];
          o2 === i2 && (r2 = s2, o2 = e2), n3 = Jn2(o2) ? o2.call(n3) : o2;
        }
        return n3;
      }
      function fd2(n3, t2, e2) {
        return n3 == null ? n3 : fe2(n3, t2, e2);
      }
      function cd2(n3, t2, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i2, n3 == null ? n3 : fe2(n3, t2, e2, r2);
      }
      var la2 = xu(V2), pa2 = xu(on2);
      function hd2(n3, t2, e2) {
        var r2 = O2(n3), s2 = r2 || at2(n3) || Bt2(n3);
        if (t2 = x2(t2, 4), e2 == null) {
          var o2 = n3 && n3.constructor;
          s2 ? e2 = r2 ? new o2() : [] : K3(n3) ? e2 = Jn2(o2) ? Wt2(He2(n3)) : {} : e2 = {};
        }
        return (s2 ? mn2 : $n)(n3, function(f2, c2, l2) {
          return t2(e2, f2, c2, l2);
        }), e2;
      }
      function ld2(n3, t2) {
        return n3 == null ? true : si2(n3, t2);
      }
      function pd2(n3, t2, e2) {
        return n3 == null ? n3 : au(n3, t2, oi2(e2));
      }
      function dd2(n3, t2, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i2, n3 == null ? n3 : au(n3, t2, oi2(e2), r2);
      }
      function Gt2(n3) {
        return n3 == null ? [] : Mr2(n3, V2(n3));
      }
      function gd2(n3) {
        return n3 == null ? [] : Mr2(n3, on2(n3));
      }
      function vd2(n3, t2, e2) {
        return e2 === i2 && (e2 = t2, t2 = i2), e2 !== i2 && (e2 = xn2(e2), e2 = e2 === e2 ? e2 : 0), t2 !== i2 && (t2 = xn2(t2), t2 = t2 === t2 ? t2 : 0), vt2(xn2(n3), t2, e2);
      }
      function _d2(n3, t2, e2) {
        return t2 = Xn2(t2), e2 === i2 ? (e2 = t2, t2 = 0) : e2 = Xn2(e2), n3 = xn2(n3), Ic2(n3, t2, e2);
      }
      function md2(n3, t2, e2) {
        if (e2 && typeof e2 != "boolean" && rn2(n3, t2, e2) && (t2 = e2 = i2), e2 === i2 && (typeof t2 == "boolean" ? (e2 = t2, t2 = i2) : typeof n3 == "boolean" && (e2 = n3, n3 = i2)), n3 === i2 && t2 === i2 ? (n3 = 0, t2 = 1) : (n3 = Xn2(n3), t2 === i2 ? (t2 = n3, n3 = 0) : t2 = Xn2(t2)), n3 > t2) {
          var r2 = n3;
          n3 = t2, t2 = r2;
        }
        if (e2 || n3 % 1 || t2 % 1) {
          var s2 = Us();
          return nn2(n3 + s2 * (t2 - n3 + Xo2("1e-" + ((s2 + "").length - 1))), t2);
        }
        return ei2(n3, t2);
      }
      var wd2 = Mt2(function(n3, t2, e2) {
        return t2 = t2.toLowerCase(), n3 + (e2 ? da2(t2) : t2);
      });
      function da2(n3) {
        return Ri2(W2(n3).toLowerCase());
      }
      function ga(n3) {
        return n3 = W2(n3), n3 && n3.replace(Po2, ff2).replace(Fo2, "");
      }
      function Pd2(n3, t2, e2) {
        n3 = W2(n3), t2 = ln2(t2);
        var r2 = n3.length;
        e2 = e2 === i2 ? r2 : vt2(R2(e2), 0, r2);
        var s2 = e2;
        return e2 -= t2.length, e2 >= 0 && n3.slice(e2, s2) == t2;
      }
      function Ad2(n3) {
        return n3 = W2(n3), n3 && ja2.test(n3) ? n3.replace(Yi2, cf2) : n3;
      }
      function Cd2(n3) {
        return n3 = W2(n3), n3 && so.test(n3) ? n3.replace(xr2, "\\$&") : n3;
      }
      var Id2 = Mt2(function(n3, t2, e2) {
        return n3 + (e2 ? "-" : "") + t2.toLowerCase();
      }), xd2 = Mt2(function(n3, t2, e2) {
        return n3 + (e2 ? " " : "") + t2.toLowerCase();
      }), Ed2 = mu("toLowerCase");
      function yd2(n3, t2, e2) {
        n3 = W2(n3), t2 = R2(t2);
        var r2 = t2 ? Dt2(n3) : 0;
        if (!t2 || r2 >= t2) return n3;
        var s2 = (t2 - r2) / 2;
        return Ve2(We2(s2), e2) + n3 + Ve2(Ue2(s2), e2);
      }
      function Sd2(n3, t2, e2) {
        n3 = W2(n3), t2 = R2(t2);
        var r2 = t2 ? Dt2(n3) : 0;
        return t2 && r2 < t2 ? n3 + Ve2(t2 - r2, e2) : n3;
      }
      function Od2(n3, t2, e2) {
        n3 = W2(n3), t2 = R2(t2);
        var r2 = t2 ? Dt2(n3) : 0;
        return t2 && r2 < t2 ? Ve2(t2 - r2, e2) + n3 : n3;
      }
      function Rd2(n3, t2, e2) {
        return e2 || t2 == null ? t2 = 0 : t2 && (t2 = +t2), $f2(W2(n3).replace(Er2, ""), t2 || 0);
      }
      function bd2(n3, t2, e2) {
        return (e2 ? rn2(n3, t2, e2) : t2 === i2) ? t2 = 1 : t2 = R2(t2), ri2(W2(n3), t2);
      }
      function Td2() {
        var n3 = arguments, t2 = W2(n3[0]);
        return n3.length < 3 ? t2 : t2.replace(n3[1], n3[2]);
      }
      var Ld2 = Mt2(function(n3, t2, e2) {
        return n3 + (e2 ? "_" : "") + t2.toLowerCase();
      });
      function Dd2(n3, t2, e2) {
        return e2 && typeof e2 != "number" && rn2(n3, t2, e2) && (t2 = e2 = i2), e2 = e2 === i2 ? Nn2 : e2 >>> 0, e2 ? (n3 = W2(n3), n3 && (typeof t2 == "string" || t2 != null && !yi2(t2)) && (t2 = ln2(t2), !t2 && Lt(n3)) ? ut2(On(n3), 0, e2) : n3.split(t2, e2)) : [];
      }
      var Hd2 = Mt2(function(n3, t2, e2) {
        return n3 + (e2 ? " " : "") + Ri2(t2);
      });
      function Nd2(n3, t2, e2) {
        return n3 = W2(n3), e2 = e2 == null ? 0 : vt2(R2(e2), 0, n3.length), t2 = ln2(t2), n3.slice(e2, e2 + t2.length) == t2;
      }
      function $d2(n3, t2, e2) {
        var r2 = a2.templateSettings;
        e2 && rn2(n3, t2, e2) && (t2 = i2), n3 = W2(n3), t2 = fr2({}, t2, r2, Eu);
        var s2 = fr2({}, t2.imports, r2.imports, Eu), o2 = V2(s2), f2 = Mr2(s2, o2), c2, l2, v2 = 0, _2 = t2.interpolate || Ce2, m2 = "__p += '", P2 = Br2((t2.escape || Ce2).source + "|" + _2.source + "|" + (_2 === Zi2 ? po : Ce2).source + "|" + (t2.evaluate || Ce2).source + "|$", "g"), I2 = "//# sourceURL=" + (F3.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++zo2 + "]") + `
`;
        n3.replace(P2, function(y2, H2, $2, dn, sn2, gn) {
          return $2 || ($2 = dn), m2 += n3.slice(v2, gn).replace(Ao, hf), H2 && (c2 = true, m2 += `' +
__e(` + H2 + `) +
'`), sn2 && (l2 = true, m2 += `';
` + sn2 + `;
__p += '`), $2 && (m2 += `' +
((__t = (` + $2 + `)) == null ? '' : __t) +
'`), v2 = gn + y2.length, y2;
        }), m2 += `';
`;
        var E2 = F3.call(t2, "variable") && t2.variable;
        if (!E2) m2 = `with (obj) {
` + m2 + `
}
`;
        else if (ho.test(E2)) throw new S2(En2);
        m2 = (l2 ? m2.replace(Xa2, "") : m2).replace(Qa2, "$1").replace(Va2, "$1;"), m2 = "function(" + (E2 || "obj") + `) {
` + (E2 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c2 ? ", __e = _.escape" : "") + (l2 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var b2 = _a2(function() {
          return U2(o2, I2 + "return " + m2).apply(i2, f2);
        });
        if (b2.source = m2, Ei2(b2)) throw b2;
        return b2;
      }
      function Ud2(n3) {
        return W2(n3).toLowerCase();
      }
      function Wd2(n3) {
        return W2(n3).toUpperCase();
      }
      function Fd2(n3, t2, e2) {
        if (n3 = W2(n3), n3 && (e2 || t2 === i2)) return ys(n3);
        if (!n3 || !(t2 = ln2(t2))) return n3;
        var r2 = On(n3), s2 = On(t2), o2 = Ss(r2, s2), f2 = Os(r2, s2) + 1;
        return ut2(r2, o2, f2).join("");
      }
      function Md2(n3, t2, e2) {
        if (n3 = W2(n3), n3 && (e2 || t2 === i2)) return n3.slice(0, bs(n3) + 1);
        if (!n3 || !(t2 = ln2(t2))) return n3;
        var r2 = On(n3), s2 = Os(r2, On(t2)) + 1;
        return ut2(r2, 0, s2).join("");
      }
      function qd2(n3, t2, e2) {
        if (n3 = W2(n3), n3 && (e2 || t2 === i2)) return n3.replace(Er2, "");
        if (!n3 || !(t2 = ln2(t2))) return n3;
        var r2 = On(n3), s2 = Ss(r2, On(t2));
        return ut2(r2, s2).join("");
      }
      function Bd2(n3, t2) {
        var e2 = Da2, r2 = Ha2;
        if (K3(t2)) {
          var s2 = "separator" in t2 ? t2.separator : s2;
          e2 = "length" in t2 ? R2(t2.length) : e2, r2 = "omission" in t2 ? ln2(t2.omission) : r2;
        }
        n3 = W2(n3);
        var o2 = n3.length;
        if (Lt(n3)) {
          var f2 = On(n3);
          o2 = f2.length;
        }
        if (e2 >= o2) return n3;
        var c2 = e2 - Dt2(r2);
        if (c2 < 1) return r2;
        var l2 = f2 ? ut2(f2, 0, c2).join("") : n3.slice(0, c2);
        if (s2 === i2) return l2 + r2;
        if (f2 && (c2 += l2.length - c2), yi2(s2)) {
          if (n3.slice(c2).search(s2)) {
            var v2, _2 = l2;
            for (s2.global || (s2 = Br2(s2.source, W2(Ji2.exec(s2)) + "g")), s2.lastIndex = 0; v2 = s2.exec(_2); ) var m2 = v2.index;
            l2 = l2.slice(0, m2 === i2 ? c2 : m2);
          }
        } else if (n3.indexOf(ln2(s2), c2) != c2) {
          var P2 = l2.lastIndexOf(s2);
          P2 > -1 && (l2 = l2.slice(0, P2));
        }
        return l2 + r2;
      }
      function Gd2(n3) {
        return n3 = W2(n3), n3 && ka2.test(n3) ? n3.replace(Ki2, mf2) : n3;
      }
      var zd2 = Mt2(function(n3, t2, e2) {
        return n3 + (e2 ? " " : "") + t2.toUpperCase();
      }), Ri2 = mu("toUpperCase");
      function va2(n3, t2, e2) {
        return n3 = W2(n3), t2 = e2 ? i2 : t2, t2 === i2 ? pf2(n3) ? Af2(n3) : rf2(n3) : n3.match(t2) || [];
      }
      var _a2 = T2(function(n3, t2) {
        try {
          return cn2(n3, i2, t2);
        } catch (e2) {
          return Ei2(e2) ? e2 : new S2(e2);
        }
      }), Kd2 = Yn2(function(n3, t2) {
        return mn2(t2, function(e2) {
          e2 = Wn(e2), zn2(n3, e2, Ii2(n3[e2], n3));
        }), n3;
      });
      function Yd2(n3) {
        var t2 = n3 == null ? 0 : n3.length, e2 = x2();
        return n3 = t2 ? G3(n3, function(r2) {
          if (typeof r2[1] != "function") throw new wn2(D2);
          return [e2(r2[0]), r2[1]];
        }) : [], T2(function(r2) {
          for (var s2 = -1; ++s2 < t2; ) {
            var o2 = n3[s2];
            if (cn2(o2[0], this, r2)) return cn2(o2[1], this, r2);
          }
        });
      }
      function Zd2(n3) {
        return mc2(An2(n3, Ln));
      }
      function bi2(n3) {
        return function() {
          return n3;
        };
      }
      function Jd2(n3, t2) {
        return n3 == null || n3 !== n3 ? t2 : n3;
      }
      var Xd2 = Pu(), Qd2 = Pu(true);
      function fn2(n3) {
        return n3;
      }
      function Ti2(n3) {
        return Qs(typeof n3 == "function" ? n3 : An2(n3, Ln));
      }
      function Vd2(n3) {
        return ks(An2(n3, Ln));
      }
      function kd2(n3, t2) {
        return js(n3, An2(t2, Ln));
      }
      var jd2 = T2(function(n3, t2) {
        return function(e2) {
          return ae2(e2, n3, t2);
        };
      }), ng2 = T2(function(n3, t2) {
        return function(e2) {
          return ae2(n3, e2, t2);
        };
      });
      function Li2(n3, t2, e2) {
        var r2 = V2(t2), s2 = ze2(t2, r2);
        e2 == null && !(K3(t2) && (s2.length || !r2.length)) && (e2 = t2, t2 = n3, n3 = this, s2 = ze2(t2, V2(t2)));
        var o2 = !(K3(e2) && "chain" in e2) || !!e2.chain, f2 = Jn2(n3);
        return mn2(s2, function(c2) {
          var l2 = t2[c2];
          n3[c2] = l2, f2 && (n3.prototype[c2] = function() {
            var v2 = this.__chain__;
            if (o2 || v2) {
              var _2 = n3(this.__wrapped__), m2 = _2.__actions__ = un2(this.__actions__);
              return m2.push({ func: l2, args: arguments, thisArg: n3 }), _2.__chain__ = v2, _2;
            }
            return l2.apply(n3, nt2([this.value()], arguments));
          });
        }), n3;
      }
      function tg2() {
        return k2._ === this && (k2._ = Sf2), this;
      }
      function Di2() {
      }
      function eg2(n3) {
        return n3 = R2(n3), T2(function(t2) {
          return nu(t2, n3);
        });
      }
      var rg2 = ci2(G3), ig2 = ci2(As), sg2 = ci2(Nr);
      function ma2(n3) {
        return _i2(n3) ? $r(Wn(n3)) : Nc2(n3);
      }
      function ug2(n3) {
        return function(t2) {
          return n3 == null ? i2 : _t6(n3, t2);
        };
      }
      var ag2 = Cu(), og2 = Cu(true);
      function Hi2() {
        return [];
      }
      function Ni2() {
        return false;
      }
      function fg2() {
        return {};
      }
      function cg2() {
        return "";
      }
      function hg2() {
        return true;
      }
      function lg2(n3, t2) {
        if (n3 = R2(n3), n3 < 1 || n3 > kn2) return [];
        var e2 = Nn2, r2 = nn2(n3, Nn2);
        t2 = x2(t2), n3 -= Nn2;
        for (var s2 = Fr2(r2, t2); ++e2 < n3; ) t2(e2);
        return s2;
      }
      function pg2(n3) {
        return O2(n3) ? G3(n3, Wn) : pn2(n3) ? [n3] : un2(Wu2(W2(n3)));
      }
      function dg2(n3) {
        var t2 = ++Ef2;
        return W2(n3) + t2;
      }
      var gg2 = Qe2(function(n3, t2) {
        return n3 + t2;
      }, 0), vg2 = hi2("ceil"), _g2 = Qe2(function(n3, t2) {
        return n3 / t2;
      }, 1), mg2 = hi2("floor");
      function wg2(n3) {
        return n3 && n3.length ? Ge2(n3, fn2, Qr2) : i2;
      }
      function Pg2(n3, t2) {
        return n3 && n3.length ? Ge2(n3, x2(t2, 2), Qr2) : i2;
      }
      function Ag2(n3) {
        return xs(n3, fn2);
      }
      function Cg2(n3, t2) {
        return xs(n3, x2(t2, 2));
      }
      function Ig2(n3) {
        return n3 && n3.length ? Ge2(n3, fn2, ni2) : i2;
      }
      function xg2(n3, t2) {
        return n3 && n3.length ? Ge2(n3, x2(t2, 2), ni2) : i2;
      }
      var Eg2 = Qe2(function(n3, t2) {
        return n3 * t2;
      }, 1), yg2 = hi2("round"), Sg2 = Qe2(function(n3, t2) {
        return n3 - t2;
      }, 0);
      function Og2(n3) {
        return n3 && n3.length ? Wr2(n3, fn2) : 0;
      }
      function Rg2(n3, t2) {
        return n3 && n3.length ? Wr2(n3, x2(t2, 2)) : 0;
      }
      return a2.after = Vl, a2.ary = Xu, a2.assign = Wp, a2.assignIn = fa2, a2.assignInWith = fr2, a2.assignWith = Fp2, a2.at = Mp, a2.before = Qu, a2.bind = Ii2, a2.bindAll = Kd2, a2.bindKey = Vu, a2.castArray = fp, a2.chain = Yu, a2.chunk = mh2, a2.compact = wh2, a2.concat = Ph2, a2.cond = Yd2, a2.conforms = Zd2, a2.constant = bi2, a2.countBy = Ol, a2.create = qp, a2.curry = ku, a2.curryRight = ju, a2.debounce = na, a2.defaults = Bp, a2.defaultsDeep = Gp, a2.defer = kl2, a2.delay = jl2, a2.difference = Ah2, a2.differenceBy = Ch2, a2.differenceWith = Ih2, a2.drop = xh2, a2.dropRight = Eh2, a2.dropRightWhile = yh2, a2.dropWhile = Sh2, a2.fill = Oh2, a2.filter = bl2, a2.flatMap = Dl, a2.flatMapDeep = Hl, a2.flatMapDepth = Nl, a2.flatten = Bu, a2.flattenDeep = Rh2, a2.flattenDepth = bh2, a2.flip = np, a2.flow = Xd2, a2.flowRight = Qd2, a2.fromPairs = Th2, a2.functions = Qp, a2.functionsIn = Vp, a2.groupBy = $l, a2.initial = Dh2, a2.intersection = Hh2, a2.intersectionBy = Nh2, a2.intersectionWith = $h2, a2.invert = jp, a2.invertBy = nd2, a2.invokeMap = Wl, a2.iteratee = Ti2, a2.keyBy = Fl, a2.keys = V2, a2.keysIn = on2, a2.map = rr2, a2.mapKeys = ed2, a2.mapValues = rd2, a2.matches = Vd2, a2.matchesProperty = kd2, a2.memoize = sr2, a2.merge = id2, a2.mergeWith = ca2, a2.method = jd2, a2.methodOf = ng2, a2.mixin = Li2, a2.negate = ur2, a2.nthArg = eg2, a2.omit = sd2, a2.omitBy = ud2, a2.once = tp, a2.orderBy = Ml, a2.over = rg2, a2.overArgs = ep, a2.overEvery = ig2, a2.overSome = sg2, a2.partial = xi2, a2.partialRight = ta2, a2.partition = ql2, a2.pick = ad2, a2.pickBy = ha2, a2.property = ma2, a2.propertyOf = ug2, a2.pull = Mh2, a2.pullAll = zu, a2.pullAllBy = qh2, a2.pullAllWith = Bh2, a2.pullAt = Gh2, a2.range = ag2, a2.rangeRight = og2, a2.rearg = rp, a2.reject = zl, a2.remove = zh2, a2.rest = ip, a2.reverse = Ai2, a2.sampleSize = Yl, a2.set = fd2, a2.setWith = cd2, a2.shuffle = Zl, a2.slice = Kh2, a2.sortBy = Ql, a2.sortedUniq = kh2, a2.sortedUniqBy = jh2, a2.split = Dd2, a2.spread = sp, a2.tail = nl2, a2.take = tl2, a2.takeRight = el2, a2.takeRightWhile = rl2, a2.takeWhile = il2, a2.tap = wl, a2.throttle = up, a2.thru = er2, a2.toArray = ua2, a2.toPairs = la2, a2.toPairsIn = pa2, a2.toPath = pg2, a2.toPlainObject = oa2, a2.transform = hd2, a2.unary = ap, a2.union = sl2, a2.unionBy = ul2, a2.unionWith = al2, a2.uniq = ol2, a2.uniqBy = fl2, a2.uniqWith = cl2, a2.unset = ld2, a2.unzip = Ci2, a2.unzipWith = Ku, a2.update = pd2, a2.updateWith = dd2, a2.values = Gt2, a2.valuesIn = gd2, a2.without = hl2, a2.words = va2, a2.wrap = op, a2.xor = ll2, a2.xorBy = pl2, a2.xorWith = dl2, a2.zip = gl2, a2.zipObject = vl2, a2.zipObjectDeep = _l2, a2.zipWith = ml2, a2.entries = la2, a2.entriesIn = pa2, a2.extend = fa2, a2.extendWith = fr2, Li2(a2, a2), a2.add = gg2, a2.attempt = _a2, a2.camelCase = wd2, a2.capitalize = da2, a2.ceil = vg2, a2.clamp = vd2, a2.clone = cp, a2.cloneDeep = lp, a2.cloneDeepWith = pp, a2.cloneWith = hp, a2.conformsTo = dp, a2.deburr = ga, a2.defaultTo = Jd2, a2.divide = _g2, a2.endsWith = Pd2, a2.eq = bn2, a2.escape = Ad2, a2.escapeRegExp = Cd2, a2.every = Rl, a2.find = Tl, a2.findIndex = Mu, a2.findKey = zp, a2.findLast = Ll, a2.findLastIndex = qu, a2.findLastKey = Kp, a2.floor = mg2, a2.forEach = Zu, a2.forEachRight = Ju, a2.forIn = Yp, a2.forInRight = Zp, a2.forOwn = Jp, a2.forOwnRight = Xp, a2.get = Si2, a2.gt = gp, a2.gte = vp, a2.has = kp, a2.hasIn = Oi2, a2.head = Gu, a2.identity = fn2, a2.includes = Ul, a2.indexOf = Lh2, a2.inRange = _d2, a2.invoke = td2, a2.isArguments = Pt2, a2.isArray = O2, a2.isArrayBuffer = _p2, a2.isArrayLike = an2, a2.isArrayLikeObject = Z3, a2.isBoolean = mp, a2.isBuffer = at2, a2.isDate = wp2, a2.isElement = Pp, a2.isEmpty = Ap, a2.isEqual = Cp, a2.isEqualWith = Ip, a2.isError = Ei2, a2.isFinite = xp, a2.isFunction = Jn2, a2.isInteger = ea2, a2.isLength = ar, a2.isMap = ra2, a2.isMatch = Ep, a2.isMatchWith = yp, a2.isNaN = Sp, a2.isNative = Op, a2.isNil = bp, a2.isNull = Rp, a2.isNumber = ia2, a2.isObject = K3, a2.isObjectLike = Y3, a2.isPlainObject = pe2, a2.isRegExp = yi2, a2.isSafeInteger = Tp, a2.isSet = sa2, a2.isString = or, a2.isSymbol = pn2, a2.isTypedArray = Bt2, a2.isUndefined = Lp, a2.isWeakMap = Dp, a2.isWeakSet = Hp, a2.join = Uh2, a2.kebabCase = Id2, a2.last = In2, a2.lastIndexOf = Wh2, a2.lowerCase = xd2, a2.lowerFirst = Ed2, a2.lt = Np, a2.lte = $p, a2.max = wg2, a2.maxBy = Pg2, a2.mean = Ag2, a2.meanBy = Cg2, a2.min = Ig2, a2.minBy = xg2, a2.stubArray = Hi2, a2.stubFalse = Ni2, a2.stubObject = fg2, a2.stubString = cg2, a2.stubTrue = hg2, a2.multiply = Eg2, a2.nth = Fh2, a2.noConflict = tg2, a2.noop = Di2, a2.now = ir, a2.pad = yd2, a2.padEnd = Sd2, a2.padStart = Od2, a2.parseInt = Rd2, a2.random = md2, a2.reduce = Bl, a2.reduceRight = Gl, a2.repeat = bd2, a2.replace = Td2, a2.result = od2, a2.round = yg2, a2.runInContext = h2, a2.sample = Kl2, a2.size = Jl, a2.snakeCase = Ld2, a2.some = Xl, a2.sortedIndex = Yh2, a2.sortedIndexBy = Zh2, a2.sortedIndexOf = Jh2, a2.sortedLastIndex = Xh2, a2.sortedLastIndexBy = Qh2, a2.sortedLastIndexOf = Vh2, a2.startCase = Hd2, a2.startsWith = Nd2, a2.subtract = Sg2, a2.sum = Og2, a2.sumBy = Rg2, a2.template = $d2, a2.times = lg2, a2.toFinite = Xn2, a2.toInteger = R2, a2.toLength = aa2, a2.toLower = Ud2, a2.toNumber = xn2, a2.toSafeInteger = Up, a2.toString = W2, a2.toUpper = Wd2, a2.trim = Fd2, a2.trimEnd = Md2, a2.trimStart = qd2, a2.truncate = Bd2, a2.unescape = Gd2, a2.uniqueId = dg2, a2.upperCase = zd2, a2.upperFirst = Ri2, a2.each = Zu, a2.eachRight = Ju, a2.first = Gu, Li2(a2, function() {
        var n3 = {};
        return $n(a2, function(t2, e2) {
          F3.call(a2.prototype, e2) || (n3[e2] = t2);
        }), n3;
      }(), { chain: false }), a2.VERSION = d2, mn2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n3) {
        a2[n3].placeholder = a2;
      }), mn2(["drop", "take"], function(n3, t2) {
        N2.prototype[n3] = function(e2) {
          e2 = e2 === i2 ? 1 : Q2(R2(e2), 0);
          var r2 = this.__filtered__ && !t2 ? new N2(this) : this.clone();
          return r2.__filtered__ ? r2.__takeCount__ = nn2(e2, r2.__takeCount__) : r2.__views__.push({ size: nn2(e2, Nn2), type: n3 + (r2.__dir__ < 0 ? "Right" : "") }), r2;
        }, N2.prototype[n3 + "Right"] = function(e2) {
          return this.reverse()[n3](e2).reverse();
        };
      }), mn2(["filter", "map", "takeWhile"], function(n3, t2) {
        var e2 = t2 + 1, r2 = e2 == Bi2 || e2 == Wa2;
        N2.prototype[n3] = function(s2) {
          var o2 = this.clone();
          return o2.__iteratees__.push({ iteratee: x2(s2, 3), type: e2 }), o2.__filtered__ = o2.__filtered__ || r2, o2;
        };
      }), mn2(["head", "last"], function(n3, t2) {
        var e2 = "take" + (t2 ? "Right" : "");
        N2.prototype[n3] = function() {
          return this[e2](1).value()[0];
        };
      }), mn2(["initial", "tail"], function(n3, t2) {
        var e2 = "drop" + (t2 ? "" : "Right");
        N2.prototype[n3] = function() {
          return this.__filtered__ ? new N2(this) : this[e2](1);
        };
      }), N2.prototype.compact = function() {
        return this.filter(fn2);
      }, N2.prototype.find = function(n3) {
        return this.filter(n3).head();
      }, N2.prototype.findLast = function(n3) {
        return this.reverse().find(n3);
      }, N2.prototype.invokeMap = T2(function(n3, t2) {
        return typeof n3 == "function" ? new N2(this) : this.map(function(e2) {
          return ae2(e2, n3, t2);
        });
      }), N2.prototype.reject = function(n3) {
        return this.filter(ur2(x2(n3)));
      }, N2.prototype.slice = function(n3, t2) {
        n3 = R2(n3);
        var e2 = this;
        return e2.__filtered__ && (n3 > 0 || t2 < 0) ? new N2(e2) : (n3 < 0 ? e2 = e2.takeRight(-n3) : n3 && (e2 = e2.drop(n3)), t2 !== i2 && (t2 = R2(t2), e2 = t2 < 0 ? e2.dropRight(-t2) : e2.take(t2 - n3)), e2);
      }, N2.prototype.takeRightWhile = function(n3) {
        return this.reverse().takeWhile(n3).reverse();
      }, N2.prototype.toArray = function() {
        return this.take(Nn2);
      }, $n(N2.prototype, function(n3, t2) {
        var e2 = /^(?:filter|find|map|reject)|While$/.test(t2), r2 = /^(?:head|last)$/.test(t2), s2 = a2[r2 ? "take" + (t2 == "last" ? "Right" : "") : t2], o2 = r2 || /^find/.test(t2);
        s2 && (a2.prototype[t2] = function() {
          var f2 = this.__wrapped__, c2 = r2 ? [1] : arguments, l2 = f2 instanceof N2, v2 = c2[0], _2 = l2 || O2(f2), m2 = function(H2) {
            var $2 = s2.apply(a2, nt2([H2], c2));
            return r2 && P2 ? $2[0] : $2;
          };
          _2 && e2 && typeof v2 == "function" && v2.length != 1 && (l2 = _2 = false);
          var P2 = this.__chain__, I2 = !!this.__actions__.length, E2 = o2 && !P2, b2 = l2 && !I2;
          if (!o2 && _2) {
            f2 = b2 ? f2 : new N2(this);
            var y2 = n3.apply(f2, c2);
            return y2.__actions__.push({ func: er2, args: [m2], thisArg: i2 }), new Pn2(y2, P2);
          }
          return E2 && b2 ? n3.apply(this, c2) : (y2 = this.thru(m2), E2 ? r2 ? y2.value()[0] : y2.value() : y2);
        });
      }), mn2(["pop", "push", "shift", "sort", "splice", "unshift"], function(n3) {
        var t2 = Oe2[n3], e2 = /^(?:push|sort|unshift)$/.test(n3) ? "tap" : "thru", r2 = /^(?:pop|shift)$/.test(n3);
        a2.prototype[n3] = function() {
          var s2 = arguments;
          if (r2 && !this.__chain__) {
            var o2 = this.value();
            return t2.apply(O2(o2) ? o2 : [], s2);
          }
          return this[e2](function(f2) {
            return t2.apply(O2(f2) ? f2 : [], s2);
          });
        };
      }), $n(N2.prototype, function(n3, t2) {
        var e2 = a2[t2];
        if (e2) {
          var r2 = e2.name + "";
          F3.call(Ut, r2) || (Ut[r2] = []), Ut[r2].push({ name: t2, func: e2 });
        }
      }), Ut[Xe2(i2, ct2).name] = [{ name: "wrapper", func: i2 }], N2.prototype.clone = Gf2, N2.prototype.reverse = zf2, N2.prototype.value = Kf2, a2.prototype.at = Pl, a2.prototype.chain = Al, a2.prototype.commit = Cl, a2.prototype.next = Il, a2.prototype.plant = El, a2.prototype.reverse = yl, a2.prototype.toJSON = a2.prototype.valueOf = a2.prototype.value = Sl2, a2.prototype.first = a2.prototype.head, ne2 && (a2.prototype[ne2] = xl), a2;
    }, Ht2 = Cf2();
    lt2 ? ((lt2.exports = Ht2)._ = Ht2, Tr2._ = Ht2) : k2._ = Ht2;
  }).call(ge$1);
})(Ui, Ui.exports);
proxy({
  provider: void 0,
  providerType: void 0,
  address: void 0,
  currentChain: void 0,
  chainId: void 0,
  caipChainId: void 0,
  connection: null,
  isConnected: false
});
const solana = {
  chainId: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  currency: "SOL",
  explorerUrl: "https://solscan.io",
  rpcUrl: `${ConstantsUtil$3.BLOCKCHAIN_API_RPC_URL}/v1`
};
const solanaTestnet = {
  chainId: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  currency: "SOL",
  explorerUrl: "https://explorer.solana.com/?cluster=testnet",
  rpcUrl: "https://api.testnet.solana.com"
};
const solanaDevnet = {
  chainId: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  currency: "SOL",
  explorerUrl: "https://explorer.solana.com/?cluster=devnet",
  rpcUrl: "https://api.devnet.solana.com"
};
({
  [solana.chainId]: WalletAdapterNetwork.Mainnet,
  [solanaDevnet.chainId]: WalletAdapterNetwork.Devnet,
  [solanaTestnet.chainId]: WalletAdapterNetwork.Testnet
});
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode3
  };
}
var src = base;
const basex = src;
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
basex(ALPHABET);
proxy({});
proxy({});
var hash$2 = {};
var utils$9 = {};
var minimalisticAssert = assert$5;
function assert$5(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$5.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
var assert$4 = minimalisticAssert;
var inherits = inherits_browserExports;
utils$9.inherits = inherits;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$9.toArray = toArray;
function toHex(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$9.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$9.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$9.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$9.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$9.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$4(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$9.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$9.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$9.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$9.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$9.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$9.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$9.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$9.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo;
}
utils$9.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$9.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
utils$9.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$9.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
utils$9.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$9.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
utils$9.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$9.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$9.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$9.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$9.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$8 = utils$9;
var assert$3 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$8.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$8.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$3(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes2 = this._delta8;
  var k2 = bytes2 - (len + this.padLength) % bytes2;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k2; i2++)
    res[i2] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len & 255;
  } else {
    res[i2++] = len & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$7 = utils$9;
var rotr32 = utils$7.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$6 = utils$9;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$6.rotl32;
var sum32$2 = utils$6.sum32;
var sum32_5$1 = utils$6.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$6.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h, "big");
  else
    return utils$6.split32(this.h, "big");
};
var utils$5 = utils$9;
var common$2 = common$5;
var shaCommon = common$4;
var assert$2 = minimalisticAssert;
var sum32$1 = utils$5.sum32;
var sum32_4$1 = utils$5.sum32_4;
var sum32_5 = utils$5.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$5.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$2(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$2.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "big");
  else
    return utils$5.split32(this.h, "big");
};
var utils$4 = utils$9;
var SHA256$1 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$1.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$4.inherits(SHA224, SHA256$1);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$4.split32(this.h.slice(0, 7), "big");
};
var utils$3 = utils$9;
var common$1 = common$5;
var assert$1 = minimalisticAssert;
var rotr64_hi = utils$3.rotr64_hi;
var rotr64_lo = utils$3.rotr64_lo;
var shr64_hi = utils$3.shr64_hi;
var shr64_lo = utils$3.shr64_lo;
var sum64 = utils$3.sum64;
var sum64_hi = utils$3.sum64_hi;
var sum64_lo = utils$3.sum64_lo;
var sum64_4_hi = utils$3.sum64_4_hi;
var sum64_4_lo = utils$3.sum64_4_lo;
var sum64_5_hi = utils$3.sum64_5_hi;
var sum64_5_lo = utils$3.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$3.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i2 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$1(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$3.toHex32(this.h, "big");
  else
    return utils$3.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$2 = utils$9;
var SHA5122 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA5122.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$2.inherits(SHA384, SHA5122);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$2.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$2.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$1 = utils$9;
var common = common$5;
var rotl32 = utils$1.rotl32;
var sum32 = utils$1.sum32;
var sum32_3 = utils$1.sum32_3;
var sum32_4 = utils$1.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD1602() {
  if (!(this instanceof RIPEMD1602))
    return new RIPEMD1602();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$1.inherits(RIPEMD1602, BlockHash);
ripemd.ripemd160 = RIPEMD1602;
RIPEMD1602.blockSize = 512;
RIPEMD1602.outSize = 160;
RIPEMD1602.hmacStrength = 192;
RIPEMD1602.padLength = 64;
RIPEMD1602.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B3 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B3;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f(j2, B3, C2, D2), msg[r[j2] + start], K$1(j2)),
        s[j2]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B3;
    B3 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f(79 - j2, Bh2, Ch2, Dh2), msg[rh[j2] + start], Kh(j2)),
        sh[j2]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B3, Ch2);
  this.h[0] = T2;
};
RIPEMD1602.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$1.toHex32(this.h, "little");
  else
    return utils$1.split32(this.h, "little");
};
function f(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$1(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils = utils$9;
var assert = minimalisticAssert;
function Hmac(hash2, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils.toArray(key, enc));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function init(key) {
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);
  for (var i2 = key.length; i2 < this.blockSize; i2++)
    key.push(0);
  for (i2 = 0; i2 < key.length; i2++)
    key[i2] ^= 54;
  this.inner = new this.Hash().update(key);
  for (i2 = 0; i2 < key.length; i2++)
    key[i2] ^= 106;
  this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$9;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$1;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$2);
const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash$2);
function sha256$1(data2) {
  return "0x" + hash$1.sha256().update(arrayify(data2)).digest("hex");
}
function getHashedName(name) {
  const input = SolConstantsUtil.HASH_PREFIX + name;
  const str = sha256$1(buffer.Buffer.from(input, "utf8")).slice(2);
  return buffer.Buffer.from(str, "hex");
}
if (typeof window !== "undefined") {
  window.getHashedName = getHashedName;
}
function number(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error(`positive integer expected, not ${n3}`);
}
function isBytes$1(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes$1(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h2.outputLen);
  number(h2.blockLen);
}
function exists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance2) {
  bytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$1(data2);
  bytes(data2);
  return data2;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    bytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(view, byteOffset, value2, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value2 >> _32n2 & _u32_max);
  const wl = Number(value2 & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
class HashMD2 extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data2) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = toBytes(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data2);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state2 = this.get();
    if (outLen > state2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state2[i2], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished: finished2, destroyed, pos } = this;
    to2.length = length2;
    to2.pos = pos;
    to2.finished = finished2;
    to2.destroyed = destroyed;
    if (length2 % blockLen)
      to2.buffer.set(buffer2);
    return to2;
  }
}
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2562 extends HashMD2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B3, C: C2, D: D2, E: E2, F: F3, G: G3, H: H2 } = this;
    return [A2, B3, C2, D2, E2, F3, G3, H2];
  }
  // prettier-ignore
  set(A2, B3, C2, D2, E2, F3, G3, H2) {
    this.A = A2 | 0;
    this.B = B3 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F3 | 0;
    this.G = G3 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4)
      SHA256_W[i2] = view.getUint32(offset2, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A: A2, B: B3, C: C2, D: D2, E: E2, F: F3, G: G3, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F3, G3) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B3, C2) | 0;
      H2 = G3;
      G3 = F3;
      F3 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B3;
      B3 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B3 = B3 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F3 = F3 + this.F | 0;
    G3 = G3 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B3, C2, D2, E2, F3, G3, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA2562());
class HMAC2 extends Hash2 {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key = toBytes(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash$12.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished2;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC2(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0);
const _1n$4 = /* @__PURE__ */ BigInt(1);
const _2n$2 = /* @__PURE__ */ BigInt(2);
function isBytes(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex += hexes[bytes2[i2]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char2) {
  if (char2 >= asciis._0 && char2 <= asciis._9)
    return char2 - asciis._0;
  if (char2 >= asciis._A && char2 <= asciis._F)
    return char2 - (asciis._A - 10);
  if (char2 >= asciis._a && char2 <= asciis._f)
    return char2 - (asciis._a - 10);
  return;
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl2 = hex.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi2));
    const n22 = asciiToBase16(hex.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char2 = hex[hi2] + hex[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n22;
  }
  return array2;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n3, len) {
  return hexToBytes$1(n3.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n3, len) {
  return numberToBytesBE(n3, len).reverse();
}
function numberToVarBytesBE(n3) {
  return hexToBytes$1(numberToHexUnpadded(n3));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$1(hex);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
function equalBytes(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b2[i2];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n3) {
  let len;
  for (len = 0; n3 > _0n$3; n3 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n3, pos) {
  return n3 >> BigInt(pos) & _1n$4;
}
function bitSet(n3, pos, value2) {
  return n3 | (value2 ? _1n$4 : _0n$3) << BigInt(pos);
}
const bitMask = (n3) => (_2n$2 << BigInt(n3 - 1)) - _1n$4;
const u8n = (data2) => new Uint8Array(data2);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i2 = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed2 = u8n()) => {
    k2 = h2(u8fr([0]), seed2);
    v2 = h2();
    if (seed2.length === 0)
      return;
    k2 = h2(u8fr([1]), seed2);
    v2 = h2();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len += v2.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed2, pred) => {
    reset();
    reseed(seed2);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type3, isOptional) => {
    const checkVal = validatorFns[type3];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type3}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type3}`);
    }
  };
  for (const [fieldName, type3] of Object.entries(validators))
    checkField(fieldName, type3, false);
  for (const [fieldName, type3] of Object.entries(optValidators))
    checkField(fieldName, type3, true);
  return object;
}
const ut$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes: hexToBytes$1,
  hexToNumber,
  isBytes,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$2, u2 = _1n$3;
  while (a2 !== _0n$2) {
    const q3 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q3;
    b2 = a2, a2 = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$3) / _2n$1;
  let Q2, S2, Z3;
  for (Q2 = P2 - _1n$3, S2 = 0; Q2 % _2n$1 === _0n$2; Q2 /= _2n$1, S2++)
    ;
  for (Z3 = _2n$1; Z3 < P2 && pow(Z3, legendreC, P2) !== P2 - _1n$3; Z3++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n3) {
    if (Fp2.pow(n3, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z3), Q2);
    let x2 = Fp2.pow(n3, Q1div2);
    let b2 = Fp2.pow(n3, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$3 << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n$1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n3) {
      const n22 = Fp2.mul(n3, _2n$1);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n3, v2);
      const i2 = Fp2.mul(Fp2.mul(nv, _2n$1), v2);
      const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$3;
  }
  return p2;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = f2.mul(acc, tmp[i2]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n3, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n3.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n3) => sqrtP(f2, n3)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n3) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n3 > _0n$1) {
        if (n3 & _1n$2)
          p2 = p2.add(d2);
        d2 = d2.double();
        n3 >>= _1n$2;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n3) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n3 & mask2);
        n3 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n3 += _1n$2;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n3, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n3);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut$1;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data2) {
    const { Err: E2 } = DER;
    if (data2.length < 2 || data2[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data2[1];
    const res = data2.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data2.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER;
    const data2 = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data2);
    let l2 = data2.length;
    if (l2 < 2 || data2[0] != 48)
      throw new E2("Invalid signature tag");
    if (data2[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data2.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s2 = slice2(h2(sig.s));
    const r2 = slice2(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s2}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n3 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n3);
    assertGE(num);
    return num;
  }
  const pointPrecomputes2 = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z22 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z22 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y22);
      let t2 = Fp2.mul(Z1, Z22);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y22);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z22);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y22, Z22);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, pointPrecomputes2, n3, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n3) {
      const I2 = Point.ZERO;
      if (n3 === _0n)
        return I2;
      assertGE(n3);
      if (n3 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n3);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d2);
        if (k2 & _1n$1)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n3 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n3);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G3 = Point.BASE;
      const mul2 = (P2, a3) => a3 === _0n || a3 === _1n$1 || !P2.equals(G3) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul2(this, a2).add(mul2(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from2, to2) => bytesToNumberBE(b2.slice(from2, to2));
  class Signature {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l2 * 2);
      return new Signature(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix2 = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix2 + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length2), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes3(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed2 = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q3 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q3.x);
      if (r2 === _0n)
        return;
      const s2 = modN(ik2 * modN(m2 + r2 * d2));
      if (s2 === _0n)
        return;
      let recovery = (q3.x === r2 ? 0 : 2) | Number(q3.y & _1n$1);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r2, normS, recovery);
    }
    return { seed: seed2, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed: seed2, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed2, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey2, opts = defaultVerOpts) {
    var _a2;
    const sg2 = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey2 = ensureBytes("publicKey", publicKey2);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || isBytes(sg2)) {
        try {
          _sig = Signature.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s3 } = sg2;
        _sig = new Signature(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s2);
    const u1 = modN(h2 * is2);
    const u2 = modN(r2 * is2);
    const R2 = (_a2 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a2, b2) => (a2 + b2 / _2n) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n, P2);
  if (!Fp.eql(Fp.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n3 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n3);
      const c2 = divNearest(-b1 * k2, n3);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n3);
      let k22 = mod(-c1 * b1 - c2 * b2, n3);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n3 - k1;
      if (k2neg)
        k22 = n3 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
function padToEven(value2) {
  let a2 = value2;
  if (typeof a2 !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a2}`);
  }
  if (a2.length % 2)
    a2 = `0${a2}`;
  return a2;
}
BigInt(0);
const hexToBytesMapFirstKey = {};
const hexToBytesMapSecondKey = {};
for (let i2 = 0; i2 < 16; i2++) {
  const vSecondKey = i2;
  const vFirstKey = i2 * 16;
  const key = i2.toString(16).toLowerCase();
  hexToBytesMapSecondKey[key] = vSecondKey;
  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;
  hexToBytesMapFirstKey[key] = vFirstKey;
  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;
}
function _unprefixedHexToBytes(hex) {
  const byteLen = hex.length;
  const bytes2 = new Uint8Array(byteLen / 2);
  for (let i2 = 0; i2 < byteLen; i2 += 2) {
    bytes2[i2 / 2] = hexToBytesMapFirstKey[hex[i2]] + hexToBytesMapSecondKey[hex[i2 + 1]];
  }
  return bytes2;
}
Array.from({ length: 256 }, (v2, i2) => i2.toString(16).padStart(2, "0"));
for (let i2 = 0; i2 <= 256 * 256 - 1; i2++) {
  BigInt(i2);
}
const hexToBytes = (hex) => {
  if (typeof hex !== "string") {
    throw new Error(`hex argument type ${typeof hex} must be of type string`);
  }
  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {
    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
  }
  hex = hex.slice(2);
  if (hex.length % 2 !== 0) {
    hex = padToEven(hex);
  }
  return _unprefixedHexToBytes(hex);
};
BigInt("0xffffffffffffffff");
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
secp256k1.CURVE.n;
secp256k1.CURVE.n / BigInt(2);
BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
const KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
hexToBytes(KECCAK256_NULL_S);
const KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
hexToBytes(KECCAK256_RLP_ARRAY_S);
const KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
hexToBytes(KECCAK256_RLP_S);
Uint8Array.from([128]);
BigInt(-1);
BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(7);
BigInt(8);
BigInt(27);
BigInt(28);
BigInt(31);
BigInt(32);
BigInt(64);
BigInt(128);
BigInt(255);
BigInt(256);
BigInt(96);
BigInt(100);
BigInt(160);
BigInt(224);
BigInt(7922816251426434e13);
BigInt(1461501637330903e33);
BigInt(2695994666715064e52);
BigInt(1e9);
Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
var KeyEncoding;
(function(KeyEncoding2) {
  KeyEncoding2["String"] = "string";
  KeyEncoding2["Bytes"] = "view";
  KeyEncoding2["Number"] = "number";
})(KeyEncoding || (KeyEncoding = {}));
var ValueEncoding;
(function(ValueEncoding2) {
  ValueEncoding2["String"] = "string";
  ValueEncoding2["Bytes"] = "view";
  ValueEncoding2["JSON"] = "json";
})(ValueEncoding || (ValueEncoding = {}));
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));
var U, W, Y2 = Object.create, Q = Object.defineProperty, B2 = Object.getOwnPropertyDescriptor, J = Object.getOwnPropertyNames, F2 = Object.getPrototypeOf, G2 = Object.prototype.hasOwnProperty, q2 = ((e2) => "undefined" != typeof require ? require : "undefined" != typeof Proxy ? new Proxy(e2, { get: (e3, t2) => ("undefined" != typeof require ? require : e3)[t2] }) : e2)(function(e2) {
  if ("undefined" != typeof require) return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e2 + '" is not supported');
}), Z2 = (e2, t2) => function() {
  return t2 || (0, e2[J(e2)[0]])((t2 = { exports: {} }).exports, t2), t2.exports;
}, V = (e2, t2, n3) => (n3 = null != e2 ? Y2(F2(e2)) : {}, ((e3, t3, n4, r2) => {
  if (t3 && "object" == typeof t3 || "function" == typeof t3) for (let o2 of J(t3)) G2.call(e3, o2) || o2 === n4 || Q(e3, o2, { get: () => t3[o2], enumerable: !(r2 = B2(t3, o2)) || r2.enumerable });
  return e3;
})(e2 && e2.__esModule ? n3 : Q(n3, "default", { value: e2, enumerable: true }), e2)), X = (U = { "../../node_modules/.pnpm/tsup@8.0.2_ts-node@10.9.2_typescript@5.4.5/node_modules/tsup/assets/esm_shims.js"() {
} }, function() {
  return U && (W = (0, U[J(U)[0]])(U = 0)), W;
}), K2 = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/models.js"(e2) {
  X();
  var t2 = e2 && e2.__extends || /* @__PURE__ */ function() {
    var e3 = function(t3, n4) {
      return (e3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
        e4.__proto__ = t4;
      } || function(e4, t4) {
        for (var n5 in t4) Object.prototype.hasOwnProperty.call(t4, n5) && (e4[n5] = t4[n5]);
      })(t3, n4);
    };
    return function(t3, n4) {
      if ("function" != typeof n4 && null !== n4) throw new TypeError("Class extends value " + String(n4) + " is not a constructor or null");
      function r3() {
        this.constructor = t3;
      }
      e3(t3, n4), t3.prototype = null === n4 ? Object.create(n4) : (r3.prototype = n4.prototype, new r3());
    };
  }();
  Object.defineProperty(e2, "__esModule", { value: true }), e2.createJSONRPCNotification = e2.createJSONRPCRequest = e2.createJSONRPCSuccessResponse = e2.createJSONRPCErrorResponse = e2.JSONRPCErrorCode = e2.JSONRPCErrorException = e2.isJSONRPCResponses = e2.isJSONRPCResponse = e2.isJSONRPCRequests = e2.isJSONRPCRequest = e2.isJSONRPCID = e2.JSONRPC = void 0, e2.JSONRPC = "2.0";
  e2.isJSONRPCID = function(e3) {
    return "string" == typeof e3 || "number" == typeof e3 || null === e3;
  };
  e2.isJSONRPCRequest = function(t3) {
    return t3.jsonrpc === e2.JSONRPC && void 0 !== t3.method && void 0 === t3.result && void 0 === t3.error;
  };
  e2.isJSONRPCRequests = function(t3) {
    return Array.isArray(t3) && t3.every(e2.isJSONRPCRequest);
  };
  e2.isJSONRPCResponse = function(t3) {
    return t3.jsonrpc === e2.JSONRPC && void 0 !== t3.id && (void 0 !== t3.result || void 0 !== t3.error);
  };
  e2.isJSONRPCResponses = function(t3) {
    return Array.isArray(t3) && t3.every(e2.isJSONRPCResponse);
  };
  var n3, r2 = function(e3, t3, n4) {
    var r3 = { code: e3, message: t3 };
    return null != n4 && (r3.data = n4), r3;
  }, o2 = function(e3) {
    function n4(t3, r3, o3) {
      var i2 = e3.call(this, t3) || this;
      return Object.setPrototypeOf(i2, n4.prototype), i2.code = r3, i2.data = o3, i2;
    }
    return t2(n4, e3), n4.prototype.toObject = function() {
      return r2(this.code, this.message, this.data);
    }, n4;
  }(Error);
  e2.JSONRPCErrorException = o2, (n3 = e2.JSONRPCErrorCode || (e2.JSONRPCErrorCode = {}))[n3.ParseError = -32700] = "ParseError", n3[n3.InvalidRequest = -32600] = "InvalidRequest", n3[n3.MethodNotFound = -32601] = "MethodNotFound", n3[n3.InvalidParams = -32602] = "InvalidParams", n3[n3.InternalError = -32603] = "InternalError";
  e2.createJSONRPCErrorResponse = function(t3, n4, o3, i2) {
    return { jsonrpc: e2.JSONRPC, id: t3, error: r2(n4, o3, i2) };
  };
  e2.createJSONRPCSuccessResponse = function(t3, n4) {
    return { jsonrpc: e2.JSONRPC, id: t3, result: null != n4 ? n4 : null };
  };
  e2.createJSONRPCRequest = function(t3, n4, r3) {
    return { jsonrpc: e2.JSONRPC, id: t3, method: n4, params: r3 };
  };
  e2.createJSONRPCNotification = function(t3, n4) {
    return { jsonrpc: e2.JSONRPC, method: t3, params: n4 };
  };
} }), H = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/internal.js"(e2) {
  X(), Object.defineProperty(e2, "__esModule", { value: true }), e2.DefaultErrorCode = void 0, e2.DefaultErrorCode = 0;
} }), $ = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/client.js"(e2) {
  X();
  var t2 = e2 && e2.__awaiter || function(e3, t3, n4, r3) {
    return new (n4 || (n4 = Promise))(function(o3, i3) {
      function a3(e4) {
        try {
          c2(r3.next(e4));
        } catch (e5) {
          i3(e5);
        }
      }
      function s2(e4) {
        try {
          c2(r3.throw(e4));
        } catch (e5) {
          i3(e5);
        }
      }
      function c2(e4) {
        var t4;
        e4.done ? o3(e4.value) : (t4 = e4.value, t4 instanceof n4 ? t4 : new n4(function(e5) {
          e5(t4);
        })).then(a3, s2);
      }
      c2((r3 = r3.apply(e3, t3 || [])).next());
    });
  }, n3 = e2 && e2.__generator || function(e3, t3) {
    var n4, r3, o3, i3, a3 = { label: 0, sent: function() {
      if (1 & o3[0]) throw o3[1];
      return o3[1];
    }, trys: [], ops: [] };
    return i3 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i3[Symbol.iterator] = function() {
      return this;
    }), i3;
    function s2(s3) {
      return function(c2) {
        return function(s4) {
          if (n4) throw new TypeError("Generator is already executing.");
          for (; i3 && (i3 = 0, s4[0] && (a3 = 0)), a3; ) try {
            if (n4 = 1, r3 && (o3 = 2 & s4[0] ? r3.return : s4[0] ? r3.throw || ((o3 = r3.return) && o3.call(r3), 0) : r3.next) && !(o3 = o3.call(r3, s4[1])).done) return o3;
            switch (r3 = 0, o3 && (s4 = [2 & s4[0], o3.value]), s4[0]) {
              case 0:
              case 1:
                o3 = s4;
                break;
              case 4:
                return a3.label++, { value: s4[1], done: false };
              case 5:
                a3.label++, r3 = s4[1], s4 = [0];
                continue;
              case 7:
                s4 = a3.ops.pop(), a3.trys.pop();
                continue;
              default:
                if (!(o3 = a3.trys, (o3 = o3.length > 0 && o3[o3.length - 1]) || 6 !== s4[0] && 2 !== s4[0])) {
                  a3 = 0;
                  continue;
                }
                if (3 === s4[0] && (!o3 || s4[1] > o3[0] && s4[1] < o3[3])) {
                  a3.label = s4[1];
                  break;
                }
                if (6 === s4[0] && a3.label < o3[1]) {
                  a3.label = o3[1], o3 = s4;
                  break;
                }
                if (o3 && a3.label < o3[2]) {
                  a3.label = o3[2], a3.ops.push(s4);
                  break;
                }
                o3[2] && a3.ops.pop(), a3.trys.pop();
                continue;
            }
            s4 = t3.call(e3, a3);
          } catch (e4) {
            s4 = [6, e4], r3 = 0;
          } finally {
            n4 = o3 = 0;
          }
          if (5 & s4[0]) throw s4[1];
          return { value: s4[0] ? s4[1] : void 0, done: true };
        }([s3, c2]);
      };
    }
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.JSONRPCClient = void 0;
  var r2 = K2(), o2 = H(), i2 = function() {
    function e3(e4, t3) {
      this._send = e4, this.createID = t3, this.idToResolveMap = /* @__PURE__ */ new Map(), this.id = 0;
    }
    return e3.prototype._createID = function() {
      return this.createID ? this.createID() : ++this.id;
    }, e3.prototype.timeout = function(e4, t3) {
      var n4 = this;
      void 0 === t3 && (t3 = function(e5) {
        return (0, r2.createJSONRPCErrorResponse)(e5, o2.DefaultErrorCode, "Request timeout");
      });
      var i3 = function(r3, o3) {
        var i4 = setTimeout(function() {
          r3.forEach(function(e5) {
            var r4 = n4.idToResolveMap.get(e5);
            r4 && (n4.idToResolveMap.delete(e5), r4(t3(e5)));
          });
        }, e4);
        return o3().then(function(e5) {
          return clearTimeout(i4), e5;
        }, function(e5) {
          return clearTimeout(i4), Promise.reject(e5);
        });
      };
      return { request: function(e5, t4, r3) {
        var o3 = n4._createID();
        return i3([o3], function() {
          return n4.requestWithID(e5, t4, r3, o3);
        });
      }, requestAdvanced: function(e5, t4) {
        return function(e6, t5) {
          var r3 = (Array.isArray(e6) ? e6 : [e6]).map(function(e7) {
            return e7.id;
          }).filter(a2);
          return i3(r3, function() {
            return n4.requestAdvanced(e6, t5);
          });
        }(e5, t4);
      } };
    }, e3.prototype.request = function(e4, t3, n4) {
      return this.requestWithID(e4, t3, n4, this._createID());
    }, e3.prototype.requestWithID = function(e4, o3, i3, a3) {
      return t2(this, void 0, void 0, function() {
        var t3, s2;
        return n3(this, function(n4) {
          switch (n4.label) {
            case 0:
              return t3 = (0, r2.createJSONRPCRequest)(a3, e4, o3), [4, this.requestAdvanced(t3, i3)];
            case 1:
              return void 0 === (s2 = n4.sent()).result || s2.error ? void 0 === s2.result && s2.error ? [2, Promise.reject(new r2.JSONRPCErrorException(s2.error.message, s2.error.code, s2.error.data))] : [2, Promise.reject(new Error("An unexpected error occurred"))] : [2, s2.result];
          }
        });
      });
    }, e3.prototype.requestAdvanced = function(e4, t3) {
      var n4 = this, i3 = Array.isArray(e4);
      Array.isArray(e4) || (e4 = [e4]);
      var s2 = e4.filter(function(e5) {
        return a2(e5.id);
      }), c2 = s2.map(function(e5) {
        return new Promise(function(t4) {
          return n4.idToResolveMap.set(e5.id, t4);
        });
      }), u2 = Promise.all(c2).then(function(e5) {
        return i3 || !e5.length ? e5 : e5[0];
      });
      return this.send(i3 ? e4 : e4[0], t3).then(function() {
        return u2;
      }, function(e5) {
        return s2.forEach(function(t4) {
          n4.receive((0, r2.createJSONRPCErrorResponse)(t4.id, o2.DefaultErrorCode, e5 && e5.message || "Failed to send a request"));
        }), u2;
      });
    }, e3.prototype.notify = function(e4, t3, n4) {
      var o3 = (0, r2.createJSONRPCNotification)(e4, t3);
      this.send(o3, n4).then(void 0, function() {
      });
    }, e3.prototype.send = function(e4, r3) {
      return t2(this, void 0, void 0, function() {
        return n3(this, function(t3) {
          return [2, this._send(e4, r3)];
        });
      });
    }, e3.prototype.rejectAllPendingRequests = function(e4) {
      this.idToResolveMap.forEach(function(t3, n4) {
        return t3((0, r2.createJSONRPCErrorResponse)(n4, o2.DefaultErrorCode, e4));
      }), this.idToResolveMap.clear();
    }, e3.prototype.receive = function(e4) {
      var t3 = this;
      Array.isArray(e4) || (e4 = [e4]), e4.forEach(function(e5) {
        var n4 = t3.idToResolveMap.get(e5.id);
        n4 && (t3.idToResolveMap.delete(e5.id), n4(e5));
      });
    }, e3;
  }();
  e2.JSONRPCClient = i2;
  var a2 = function(e3) {
    return null != e3;
  };
} }), ee = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/interfaces.js"(e2) {
  X(), Object.defineProperty(e2, "__esModule", { value: true });
} }), te = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/server.js"(e2) {
  X();
  var t2 = e2 && e2.__assign || function() {
    return t2 = Object.assign || function(e3) {
      for (var t3, n4 = 1, r3 = arguments.length; n4 < r3; n4++) for (var o3 in t3 = arguments[n4]) Object.prototype.hasOwnProperty.call(t3, o3) && (e3[o3] = t3[o3]);
      return e3;
    }, t2.apply(this, arguments);
  }, n3 = e2 && e2.__awaiter || function(e3, t3, n4, r3) {
    return new (n4 || (n4 = Promise))(function(o3, i3) {
      function a3(e4) {
        try {
          c3(r3.next(e4));
        } catch (e5) {
          i3(e5);
        }
      }
      function s3(e4) {
        try {
          c3(r3.throw(e4));
        } catch (e5) {
          i3(e5);
        }
      }
      function c3(e4) {
        var t4;
        e4.done ? o3(e4.value) : (t4 = e4.value, t4 instanceof n4 ? t4 : new n4(function(e5) {
          e5(t4);
        })).then(a3, s3);
      }
      c3((r3 = r3.apply(e3, t3 || [])).next());
    });
  }, r2 = e2 && e2.__generator || function(e3, t3) {
    var n4, r3, o3, i3, a3 = { label: 0, sent: function() {
      if (1 & o3[0]) throw o3[1];
      return o3[1];
    }, trys: [], ops: [] };
    return i3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (i3[Symbol.iterator] = function() {
      return this;
    }), i3;
    function s3(s4) {
      return function(c3) {
        return function(s5) {
          if (n4) throw new TypeError("Generator is already executing.");
          for (; i3 && (i3 = 0, s5[0] && (a3 = 0)), a3; ) try {
            if (n4 = 1, r3 && (o3 = 2 & s5[0] ? r3.return : s5[0] ? r3.throw || ((o3 = r3.return) && o3.call(r3), 0) : r3.next) && !(o3 = o3.call(r3, s5[1])).done) return o3;
            switch (r3 = 0, o3 && (s5 = [2 & s5[0], o3.value]), s5[0]) {
              case 0:
              case 1:
                o3 = s5;
                break;
              case 4:
                return a3.label++, { value: s5[1], done: false };
              case 5:
                a3.label++, r3 = s5[1], s5 = [0];
                continue;
              case 7:
                s5 = a3.ops.pop(), a3.trys.pop();
                continue;
              default:
                if (!(o3 = a3.trys, (o3 = o3.length > 0 && o3[o3.length - 1]) || 6 !== s5[0] && 2 !== s5[0])) {
                  a3 = 0;
                  continue;
                }
                if (3 === s5[0] && (!o3 || s5[1] > o3[0] && s5[1] < o3[3])) {
                  a3.label = s5[1];
                  break;
                }
                if (6 === s5[0] && a3.label < o3[1]) {
                  a3.label = o3[1], o3 = s5;
                  break;
                }
                if (o3 && a3.label < o3[2]) {
                  a3.label = o3[2], a3.ops.push(s5);
                  break;
                }
                o3[2] && a3.ops.pop(), a3.trys.pop();
                continue;
            }
            s5 = t3.call(e3, a3);
          } catch (e4) {
            s5 = [6, e4], r3 = 0;
          } finally {
            n4 = o3 = 0;
          }
          if (5 & s5[0]) throw s5[1];
          return { value: s5[0] ? s5[1] : void 0, done: true };
        }([s4, c3]);
      };
    }
  }, o2 = e2 && e2.__spreadArray || function(e3, t3, n4) {
    if (n4 || 2 === arguments.length) for (var r3, o3 = 0, i3 = t3.length; o3 < i3; o3++) !r3 && o3 in t3 || (r3 || (r3 = Array.prototype.slice.call(t3, 0, o3)), r3[o3] = t3[o3]);
    return e3.concat(r3 || Array.prototype.slice.call(t3));
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.JSONRPCServer = void 0;
  var i2 = K2(), a2 = H(), s2 = function(e3) {
    return (0, i2.createJSONRPCErrorResponse)((0, i2.isJSONRPCID)(e3.id) ? e3.id : null, i2.JSONRPCErrorCode.InvalidRequest, "Invalid Request");
  }, c2 = function() {
    function e3(e4) {
      var t3;
      void 0 === e4 && (e4 = {}), this.mapErrorToJSONRPCErrorResponse = l2, this.nameToMethodDictionary = {}, this.middleware = null, this.errorListener = null !== (t3 = e4.errorListener) && void 0 !== t3 ? t3 : console.warn;
    }
    return e3.prototype.hasMethod = function(e4) {
      return !!this.nameToMethodDictionary[e4];
    }, e3.prototype.addMethod = function(e4, t3) {
      this.addMethodAdvanced(e4, this.toJSONRPCMethod(t3));
    }, e3.prototype.removeMethod = function(e4) {
      delete this.nameToMethodDictionary[e4];
    }, e3.prototype.toJSONRPCMethod = function(e4) {
      return function(t3, n4) {
        var r3 = e4(t3.params, n4);
        return Promise.resolve(r3).then(function(e5) {
          return f2(t3.id, e5);
        });
      };
    }, e3.prototype.addMethodAdvanced = function(e4, n4) {
      var r3;
      this.nameToMethodDictionary = t2(t2({}, this.nameToMethodDictionary), ((r3 = {})[e4] = n4, r3));
    }, e3.prototype.receiveJSON = function(e4, t3) {
      var n4 = this.tryParseRequestJSON(e4);
      return n4 ? this.receive(n4, t3) : Promise.resolve((0, i2.createJSONRPCErrorResponse)(null, i2.JSONRPCErrorCode.ParseError, "Parse error"));
    }, e3.prototype.tryParseRequestJSON = function(e4) {
      try {
        return JSON.parse(e4);
      } catch (e5) {
        return null;
      }
    }, e3.prototype.receive = function(e4, t3) {
      return Array.isArray(e4) ? this.receiveMultiple(e4, t3) : this.receiveSingle(e4, t3);
    }, e3.prototype.receiveMultiple = function(e4, t3) {
      return n3(this, void 0, void 0, function() {
        var n4, o3 = this;
        return r2(this, function(r3) {
          switch (r3.label) {
            case 0:
              return [4, Promise.all(e4.map(function(e5) {
                return o3.receiveSingle(e5, t3);
              }))];
            case 1:
              return 1 === (n4 = r3.sent().filter(u2)).length ? [2, n4[0]] : n4.length ? [2, n4] : [2, null];
          }
        });
      });
    }, e3.prototype.receiveSingle = function(e4, t3) {
      return n3(this, void 0, void 0, function() {
        var n4, o3;
        return r2(this, function(r3) {
          switch (r3.label) {
            case 0:
              return n4 = this.nameToMethodDictionary[e4.method], (0, i2.isJSONRPCRequest)(e4) ? [3, 1] : [2, s2(e4)];
            case 1:
              return [4, this.callMethod(n4, e4, t3)];
            case 2:
              return o3 = r3.sent(), [2, h2(e4, o3)];
          }
        });
      });
    }, e3.prototype.applyMiddleware = function() {
      for (var e4 = [], t3 = 0; t3 < arguments.length; t3++) e4[t3] = arguments[t3];
      this.middleware ? this.middleware = this.combineMiddlewares(o2([this.middleware], e4, true)) : this.middleware = this.combineMiddlewares(e4);
    }, e3.prototype.combineMiddlewares = function(e4) {
      return e4.length ? e4.reduce(this.middlewareReducer) : null;
    }, e3.prototype.middlewareReducer = function(e4, t3) {
      return function(n4, r3, o3) {
        return e4(function(e5, r4) {
          return t3(n4, e5, r4);
        }, r3, o3);
      };
    }, e3.prototype.callMethod = function(e4, t3, n4) {
      var r3 = this, o3 = function(e5) {
        return r3.errorListener('An unexpected error occurred while executing "'.concat(t3.method, '" JSON-RPC method:'), e5), Promise.resolve(r3.mapErrorToJSONRPCErrorResponseIfNecessary(t3.id, e5));
      };
      try {
        return (this.middleware || d2)(function(t4, n5) {
          return e4 ? e4(t4, n5) : void 0 !== t4.id ? Promise.resolve((r4 = t4.id, (0, i2.createJSONRPCErrorResponse)(r4, i2.JSONRPCErrorCode.MethodNotFound, "Method not found"))) : Promise.resolve(null);
          var r4;
        }, t3, n4).then(void 0, o3);
      } catch (e5) {
        return o3(e5);
      }
    }, e3.prototype.mapErrorToJSONRPCErrorResponseIfNecessary = function(e4, t3) {
      return void 0 !== e4 ? this.mapErrorToJSONRPCErrorResponse(e4, t3) : null;
    }, e3;
  }();
  e2.JSONRPCServer = c2;
  var u2 = function(e3) {
    return null !== e3;
  }, d2 = function(e3, t3, n4) {
    return e3(t3, n4);
  }, f2 = function(e3, t3) {
    return void 0 !== e3 ? (0, i2.createJSONRPCSuccessResponse)(e3, t3) : null;
  }, l2 = function(e3, t3) {
    var n4, r3, o3 = null !== (n4 = null == t3 ? void 0 : t3.message) && void 0 !== n4 ? n4 : "An unexpected error occurred", s3 = a2.DefaultErrorCode;
    return t3 instanceof i2.JSONRPCErrorException && (s3 = t3.code, r3 = t3.data), (0, i2.createJSONRPCErrorResponse)(e3, s3, o3, r3);
  }, h2 = function(e3, t3) {
    return t3 || (void 0 !== e3.id ? (0, i2.createJSONRPCErrorResponse)(e3.id, i2.JSONRPCErrorCode.InternalError, "Internal error") : null);
  };
} }), ne = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/server-and-client.js"(e2) {
  X();
  var t2 = e2 && e2.__awaiter || function(e3, t3, n4, r3) {
    return new (n4 || (n4 = Promise))(function(o3, i2) {
      function a2(e4) {
        try {
          c2(r3.next(e4));
        } catch (e5) {
          i2(e5);
        }
      }
      function s2(e4) {
        try {
          c2(r3.throw(e4));
        } catch (e5) {
          i2(e5);
        }
      }
      function c2(e4) {
        var t4;
        e4.done ? o3(e4.value) : (t4 = e4.value, t4 instanceof n4 ? t4 : new n4(function(e5) {
          e5(t4);
        })).then(a2, s2);
      }
      c2((r3 = r3.apply(e3, t3 || [])).next());
    });
  }, n3 = e2 && e2.__generator || function(e3, t3) {
    var n4, r3, o3, i2, a2 = { label: 0, sent: function() {
      if (1 & o3[0]) throw o3[1];
      return o3[1];
    }, trys: [], ops: [] };
    return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
      return this;
    }), i2;
    function s2(s3) {
      return function(c2) {
        return function(s4) {
          if (n4) throw new TypeError("Generator is already executing.");
          for (; i2 && (i2 = 0, s4[0] && (a2 = 0)), a2; ) try {
            if (n4 = 1, r3 && (o3 = 2 & s4[0] ? r3.return : s4[0] ? r3.throw || ((o3 = r3.return) && o3.call(r3), 0) : r3.next) && !(o3 = o3.call(r3, s4[1])).done) return o3;
            switch (r3 = 0, o3 && (s4 = [2 & s4[0], o3.value]), s4[0]) {
              case 0:
              case 1:
                o3 = s4;
                break;
              case 4:
                return a2.label++, { value: s4[1], done: false };
              case 5:
                a2.label++, r3 = s4[1], s4 = [0];
                continue;
              case 7:
                s4 = a2.ops.pop(), a2.trys.pop();
                continue;
              default:
                if (!(o3 = a2.trys, (o3 = o3.length > 0 && o3[o3.length - 1]) || 6 !== s4[0] && 2 !== s4[0])) {
                  a2 = 0;
                  continue;
                }
                if (3 === s4[0] && (!o3 || s4[1] > o3[0] && s4[1] < o3[3])) {
                  a2.label = s4[1];
                  break;
                }
                if (6 === s4[0] && a2.label < o3[1]) {
                  a2.label = o3[1], o3 = s4;
                  break;
                }
                if (o3 && a2.label < o3[2]) {
                  a2.label = o3[2], a2.ops.push(s4);
                  break;
                }
                o3[2] && a2.ops.pop(), a2.trys.pop();
                continue;
            }
            s4 = t3.call(e3, a2);
          } catch (e4) {
            s4 = [6, e4], r3 = 0;
          } finally {
            n4 = o3 = 0;
          }
          if (5 & s4[0]) throw s4[1];
          return { value: s4[0] ? s4[1] : void 0, done: true };
        }([s3, c2]);
      };
    }
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.JSONRPCServerAndClient = void 0;
  var r2 = K2(), o2 = function() {
    function e3(e4, t3, n4) {
      var r3;
      void 0 === n4 && (n4 = {}), this.server = e4, this.client = t3, this.errorListener = null !== (r3 = n4.errorListener) && void 0 !== r3 ? r3 : console.warn;
    }
    return e3.prototype.applyServerMiddleware = function() {
      for (var e4, t3 = [], n4 = 0; n4 < arguments.length; n4++) t3[n4] = arguments[n4];
      (e4 = this.server).applyMiddleware.apply(e4, t3);
    }, e3.prototype.hasMethod = function(e4) {
      return this.server.hasMethod(e4);
    }, e3.prototype.addMethod = function(e4, t3) {
      this.server.addMethod(e4, t3);
    }, e3.prototype.addMethodAdvanced = function(e4, t3) {
      this.server.addMethodAdvanced(e4, t3);
    }, e3.prototype.removeMethod = function(e4) {
      this.server.removeMethod(e4);
    }, e3.prototype.timeout = function(e4) {
      return this.client.timeout(e4);
    }, e3.prototype.request = function(e4, t3, n4) {
      return this.client.request(e4, t3, n4);
    }, e3.prototype.requestAdvanced = function(e4, t3) {
      return this.client.requestAdvanced(e4, t3);
    }, e3.prototype.notify = function(e4, t3, n4) {
      this.client.notify(e4, t3, n4);
    }, e3.prototype.rejectAllPendingRequests = function(e4) {
      this.client.rejectAllPendingRequests(e4);
    }, e3.prototype.receiveAndSend = function(e4, o3, i2) {
      return t2(this, void 0, void 0, function() {
        var t3, a2;
        return n3(this, function(n4) {
          switch (n4.label) {
            case 0:
              return (0, r2.isJSONRPCResponse)(e4) || (0, r2.isJSONRPCResponses)(e4) ? (this.client.receive(e4), [3, 4]) : [3, 1];
            case 1:
              return (0, r2.isJSONRPCRequest)(e4) || (0, r2.isJSONRPCRequests)(e4) ? [4, this.server.receive(e4, o3)] : [3, 3];
            case 2:
              return (t3 = n4.sent()) ? [2, this.client.send(t3, i2)] : [3, 4];
            case 3:
              return a2 = "Received an invalid JSON-RPC message", this.errorListener(a2, e4), [2, Promise.reject(new Error(a2))];
            case 4:
              return [2];
          }
        });
      });
    }, e3;
  }();
  e2.JSONRPCServerAndClient = o2;
} }), re = Z2({ "../../node_modules/.pnpm/json-rpc-2.0@1.7.0/node_modules/json-rpc-2.0/dist/index.js"(e2) {
  X();
  var t2 = e2 && e2.__createBinding || (Object.create ? function(e3, t3, n4, r2) {
    void 0 === r2 && (r2 = n4);
    var o2 = Object.getOwnPropertyDescriptor(t3, n4);
    o2 && !("get" in o2 ? !t3.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
      return t3[n4];
    } }), Object.defineProperty(e3, r2, o2);
  } : function(e3, t3, n4, r2) {
    void 0 === r2 && (r2 = n4), e3[r2] = t3[n4];
  }), n3 = e2 && e2.__exportStar || function(e3, n4) {
    for (var r2 in e3) "default" === r2 || Object.prototype.hasOwnProperty.call(n4, r2) || t2(n4, e3, r2);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), n3($(), e2), n3(ee(), e2), n3(K2(), e2), n3(te(), e2), n3(ne(), e2);
} }), oe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/function/noop.js"(e2, t2) {
  X(), t2.exports = function() {
  };
} }), ie = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/is-value.js"(e2, t2) {
  X();
  var n3 = oe()();
  t2.exports = function(e3) {
    return e3 !== n3 && null !== e3;
  };
} }), ae = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/normalize-options.js"(e2, t2) {
  X();
  var n3 = ie(), r2 = Array.prototype.forEach, o2 = Object.create;
  t2.exports = function(e3) {
    var t3 = o2(null);
    return r2.call(arguments, function(e4) {
      n3(e4) && function(e5, t4) {
        var n4;
        for (n4 in e5) t4[n4] = e5[n4];
      }(Object(e4), t3);
    }), t3;
  };
} }), se = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/math/sign/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    var e3 = Math.sign;
    return "function" == typeof e3 && (1 === e3(10) && -1 === e3(-20));
  };
} }), ce = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/math/sign/shim.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    return e3 = Number(e3), isNaN(e3) || 0 === e3 ? e3 : e3 > 0 ? 1 : -1;
  };
} }), ue = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/math/sign/index.js"(e2, t2) {
  X(), t2.exports = se()() ? Math.sign : ce();
} }), de = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/number/to-integer.js"(e2, t2) {
  X();
  var n3 = ue(), r2 = Math.abs, o2 = Math.floor;
  t2.exports = function(e3) {
    return isNaN(e3) ? 0 : 0 !== (e3 = Number(e3)) && isFinite(e3) ? n3(e3) * o2(r2(e3)) : e3;
  };
} }), fe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/number/to-pos-integer.js"(e2, t2) {
  X();
  var n3 = de(), r2 = Math.max;
  t2.exports = function(e3) {
    return r2(0, n3(e3));
  };
} }), le = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-length.js"(e2, t2) {
  X();
  var n3 = fe();
  t2.exports = function(e3, t3, r2) {
    var o2;
    return isNaN(e3) ? (o2 = t3) >= 0 ? r2 && o2 ? o2 - 1 : o2 : 1 : false !== e3 && n3(e3);
  };
} }), he = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/valid-callable.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    if ("function" != typeof e3) throw new TypeError(e3 + " is not a function");
    return e3;
  };
} }), pe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/valid-value.js"(e2, t2) {
  X();
  var n3 = ie();
  t2.exports = function(e3) {
    if (!n3(e3)) throw new TypeError("Cannot use null or undefined");
    return e3;
  };
} }), be = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/_iterate.js"(e2, t2) {
  X();
  var n3 = he(), r2 = pe(), o2 = Function.prototype.bind, i2 = Function.prototype.call, a2 = Object.keys, s2 = Object.prototype.propertyIsEnumerable;
  t2.exports = function(e3, t3) {
    return function(c2, u2) {
      var d2, f2 = arguments[2], l2 = arguments[3];
      return c2 = Object(r2(c2)), n3(u2), d2 = a2(c2), l2 && d2.sort("function" == typeof l2 ? o2.call(l2, c2) : void 0), "function" != typeof e3 && (e3 = d2[e3]), i2.call(e3, d2, function(e4, n4) {
        return s2.call(c2, e4) ? i2.call(u2, f2, c2[e4], e4, c2, n4) : t3;
      });
    };
  };
} }), ye = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/for-each.js"(e2, t2) {
  X(), t2.exports = be()("forEach");
} }), me = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/registered-extensions.js"() {
  X();
} }), ge = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/assign/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    var e3, t3 = Object.assign;
    return "function" == typeof t3 && (t3(e3 = { foo: "raz" }, { bar: "dwa" }, { trzy: "trzy" }), e3.foo + e3.bar + e3.trzy === "razdwatrzy");
  };
} }), Me = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/keys/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    try {
      return Object.keys("primitive"), true;
    } catch (e3) {
      return false;
    }
  };
} }), we = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/keys/shim.js"(e2, t2) {
  X();
  var n3 = ie(), r2 = Object.keys;
  t2.exports = function(e3) {
    return r2(n3(e3) ? Object(e3) : e3);
  };
} }), ve = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/keys/index.js"(e2, t2) {
  X(), t2.exports = Me()() ? Object.keys : we();
} }), Ne = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/assign/shim.js"(e2, t2) {
  X();
  var n3 = ve(), r2 = pe(), o2 = Math.max;
  t2.exports = function(e3, t3) {
    var i2, a2, s2, c2 = o2(arguments.length, 2);
    for (e3 = Object(r2(e3)), s2 = function(n4) {
      try {
        e3[n4] = t3[n4];
      } catch (e4) {
        i2 || (i2 = e4);
      }
    }, a2 = 1; a2 < c2; ++a2) n3(t3 = arguments[a2]).forEach(s2);
    if (void 0 !== i2) throw i2;
    return e3;
  };
} }), Ae = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/assign/index.js"(e2, t2) {
  X(), t2.exports = ge()() ? Object.assign : Ne();
} }), Ie = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/is-object.js"(e2, t2) {
  X();
  var n3 = ie(), r2 = { function: true, object: true };
  t2.exports = function(e3) {
    return n3(e3) && r2[typeof e3] || false;
  };
} }), je = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/error/custom.js"(e2, t2) {
  X();
  var n3 = Ae(), r2 = Ie(), o2 = ie(), i2 = Error.captureStackTrace;
  t2.exports = function(e3) {
    var a2 = new Error(e3), s2 = arguments[1], c2 = arguments[2];
    return o2(c2) || r2(s2) && (c2 = s2, s2 = null), o2(c2) && n3(a2, c2), o2(s2) && (a2.code = s2), i2 && i2(a2, t2.exports), a2;
  };
} }), xe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/mixin.js"(e2, t2) {
  X();
  var n3 = pe(), r2 = Object.defineProperty, o2 = Object.getOwnPropertyDescriptor, i2 = Object.getOwnPropertyNames, a2 = Object.getOwnPropertySymbols;
  t2.exports = function(e3, t3) {
    var s2, c2 = Object(n3(t3));
    if (e3 = Object(n3(e3)), i2(c2).forEach(function(n4) {
      try {
        r2(e3, n4, o2(t3, n4));
      } catch (e4) {
        s2 = e4;
      }
    }), "function" == typeof a2 && a2(c2).forEach(function(n4) {
      try {
        r2(e3, n4, o2(t3, n4));
      } catch (e4) {
        s2 = e4;
      }
    }), void 0 !== s2) throw s2;
    return e3;
  };
} }), _e = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/function/_define-length.js"(e2, t2) {
  X();
  var n3, r2, o2, i2, a2 = fe(), s2 = function(e3, t3) {
    return t3;
  };
  try {
    Object.defineProperty(s2, "length", { configurable: true, writable: false, enumerable: false, value: 1 });
  } catch (e3) {
  }
  1 === s2.length ? (n3 = { configurable: true, writable: false, enumerable: false }, r2 = Object.defineProperty, t2.exports = function(e3, t3) {
    return t3 = a2(t3), e3.length === t3 ? e3 : (n3.value = t3, r2(e3, "length", n3));
  }) : (i2 = xe(), o2 = /* @__PURE__ */ function() {
    var e3 = [];
    return function(t3) {
      var n4, r3 = 0;
      if (e3[t3]) return e3[t3];
      for (n4 = []; t3--; ) n4.push("a" + (++r3).toString(36));
      return new Function("fn", "return function (" + n4.join(", ") + ") { return fn.apply(this, arguments); };");
    };
  }(), t2.exports = function(e3, t3) {
    var n4;
    if (t3 = a2(t3), e3.length === t3) return e3;
    n4 = o2(t3)(e3);
    try {
      i2(n4, e3);
    } catch (e4) {
    }
    return n4;
  });
} }), Ee = Z2({ "../../node_modules/.pnpm/type@2.7.2/node_modules/type/value/is.js"(e2, t2) {
  X();
  t2.exports = function(e3) {
    return null != e3;
  };
} }), Te = Z2({ "../../node_modules/.pnpm/type@2.7.2/node_modules/type/object/is.js"(e2, t2) {
  X();
  var n3 = Ee(), r2 = { object: true, function: true, undefined: true };
  t2.exports = function(e3) {
    return !!n3(e3) && hasOwnProperty.call(r2, typeof e3);
  };
} }), Oe = Z2({ "../../node_modules/.pnpm/type@2.7.2/node_modules/type/prototype/is.js"(e2, t2) {
  X();
  var n3 = Te();
  t2.exports = function(e3) {
    if (!n3(e3)) return false;
    try {
      return !!e3.constructor && e3.constructor.prototype === e3;
    } catch (e4) {
      return false;
    }
  };
} }), De = Z2({ "../../node_modules/.pnpm/type@2.7.2/node_modules/type/function/is.js"(e2, t2) {
  X();
  var n3 = Oe();
  t2.exports = function(e3) {
    if ("function" != typeof e3) return false;
    if (!hasOwnProperty.call(e3, "length")) return false;
    try {
      if ("number" != typeof e3.length) return false;
      if ("function" != typeof e3.call) return false;
      if ("function" != typeof e3.apply) return false;
    } catch (e4) {
      return false;
    }
    return !n3(e3);
  };
} }), Ce = Z2({ "../../node_modules/.pnpm/type@2.7.2/node_modules/type/plain-function/is.js"(e2, t2) {
  X();
  var n3 = De(), r2 = /^\s*class[\s{/}]/, o2 = Function.prototype.toString;
  t2.exports = function(e3) {
    return !!n3(e3) && !r2.test(o2.call(e3));
  };
} }), ze = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/string/#/contains/is-implemented.js"(e2, t2) {
  X();
  var n3 = "razdwatrzy";
  t2.exports = function() {
    return "function" == typeof n3.contains && (true === n3.contains("dwa") && false === n3.contains("foo"));
  };
} }), Se = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/string/#/contains/shim.js"(e2, t2) {
  X();
  var n3 = String.prototype.indexOf;
  t2.exports = function(e3) {
    return n3.call(this, e3, arguments[1]) > -1;
  };
} }), Pe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/string/#/contains/index.js"(e2, t2) {
  X(), t2.exports = ze()() ? String.prototype.contains : Se();
} }), Le = Z2({ "../../node_modules/.pnpm/d@1.0.2/node_modules/d/index.js"(e2, t2) {
  X();
  var n3 = Ee(), r2 = Ce(), o2 = Ae(), i2 = ae(), a2 = Pe(), s2 = t2.exports = function(e3, t3) {
    var r3, s3, c2, u2, d2;
    return arguments.length < 2 || "string" != typeof e3 ? (u2 = t3, t3 = e3, e3 = null) : u2 = arguments[2], n3(e3) ? (r3 = a2.call(e3, "c"), s3 = a2.call(e3, "e"), c2 = a2.call(e3, "w")) : (r3 = c2 = true, s3 = false), d2 = { value: t3, configurable: r3, enumerable: s3, writable: c2 }, u2 ? o2(i2(u2), d2) : d2;
  };
  s2.gs = function(e3, t3, s3) {
    var c2, u2, d2, f2;
    return "string" != typeof e3 ? (d2 = s3, s3 = t3, t3 = e3, e3 = null) : d2 = arguments[3], n3(t3) ? r2(t3) ? n3(s3) ? r2(s3) || (d2 = s3, s3 = void 0) : s3 = void 0 : (d2 = t3, t3 = s3 = void 0) : t3 = void 0, n3(e3) ? (c2 = a2.call(e3, "c"), u2 = a2.call(e3, "e")) : (c2 = true, u2 = false), f2 = { get: t3, set: s3, configurable: c2, enumerable: u2 }, d2 ? o2(i2(d2), f2) : f2;
  };
} }), ke = Z2({ "../../node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/index.js"(e2, t2) {
  X();
  var n3, r2, o2, i2, a2, s2, c2, u2 = Le(), d2 = he(), f2 = Function.prototype.apply, l2 = Function.prototype.call, h2 = Object.create, p2 = Object.defineProperty, b2 = Object.defineProperties, y2 = Object.prototype.hasOwnProperty, m2 = { configurable: true, enumerable: false, writable: true };
  r2 = function(e3, t3) {
    var r3, i3;
    return d2(t3), i3 = this, n3.call(this, e3, r3 = function() {
      o2.call(i3, e3, r3), f2.call(t3, this, arguments);
    }), r3.__eeOnceListener__ = t3, this;
  }, i2 = function(e3) {
    var t3, n4, r3, o3, i3;
    if (y2.call(this, "__ee__") && (o3 = this.__ee__[e3])) if ("object" == typeof o3) {
      for (n4 = arguments.length, i3 = new Array(n4 - 1), t3 = 1; t3 < n4; ++t3) i3[t3 - 1] = arguments[t3];
      for (o3 = o3.slice(), t3 = 0; r3 = o3[t3]; ++t3) f2.call(r3, this, i3);
    } else switch (arguments.length) {
      case 1:
        l2.call(o3, this);
        break;
      case 2:
        l2.call(o3, this, arguments[1]);
        break;
      case 3:
        l2.call(o3, this, arguments[1], arguments[2]);
        break;
      default:
        for (n4 = arguments.length, i3 = new Array(n4 - 1), t3 = 1; t3 < n4; ++t3) i3[t3 - 1] = arguments[t3];
        f2.call(o3, this, i3);
    }
  }, a2 = { on: n3 = function(e3, t3) {
    var n4;
    return d2(t3), y2.call(this, "__ee__") ? n4 = this.__ee__ : (n4 = m2.value = h2(null), p2(this, "__ee__", m2), m2.value = null), n4[e3] ? "object" == typeof n4[e3] ? n4[e3].push(t3) : n4[e3] = [n4[e3], t3] : n4[e3] = t3, this;
  }, once: r2, off: o2 = function(e3, t3) {
    var n4, r3, o3, i3;
    if (d2(t3), !y2.call(this, "__ee__")) return this;
    if (!(n4 = this.__ee__)[e3]) return this;
    if ("object" == typeof (r3 = n4[e3])) for (i3 = 0; o3 = r3[i3]; ++i3) o3 !== t3 && o3.__eeOnceListener__ !== t3 || (2 === r3.length ? n4[e3] = r3[i3 ? 0 : 1] : r3.splice(i3, 1));
    else r3 !== t3 && r3.__eeOnceListener__ !== t3 || delete n4[e3];
    return this;
  }, emit: i2 }, s2 = { on: u2(n3), once: u2(r2), off: u2(o2), emit: u2(i2) }, c2 = b2({}, s2), t2.exports = e2 = function(e3) {
    return null == e3 ? h2(c2) : b2(Object(e3), s2);
  }, e2.methods = a2;
} }), Re = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/array/from/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    var e3, t3, n3 = Array.from;
    return "function" == typeof n3 && (t3 = n3(e3 = ["raz", "dwa"]), Boolean(t3 && t3 !== e3 && "dwa" === t3[1]));
  };
} }), Ue = Z2({ "../../node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    return "object" == typeof globalThis && (!!globalThis && globalThis.Array === Array);
  };
} }), We = Z2({ "../../node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/implementation.js"(e2, t2) {
  X();
  var n3 = function() {
    if ("object" == typeof self && self) return self;
    if ("object" == typeof window && window) return window;
    throw new Error("Unable to resolve global `this`");
  };
  t2.exports = function() {
    if (this) return this;
    try {
      Object.defineProperty(Object.prototype, "__global__", { get: function() {
        return this;
      }, configurable: true });
    } catch (e3) {
      return n3();
    }
    try {
      return __global__ || n3();
    } finally {
      delete Object.prototype.__global__;
    }
  }();
} }), Ye = Z2({ "../../node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/index.js"(e2, t2) {
  X(), t2.exports = Ue()() ? globalThis : We();
} }), Qe = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/is-implemented.js"(e2, t2) {
  X();
  var n3 = Ye(), r2 = { object: true, symbol: true };
  t2.exports = function() {
    var e3, t3 = n3.Symbol;
    if ("function" != typeof t3) return false;
    e3 = t3("test symbol");
    try {
      String(e3);
    } catch (e4) {
      return false;
    }
    return !!r2[typeof t3.iterator] && (!!r2[typeof t3.toPrimitive] && !!r2[typeof t3.toStringTag]);
  };
} }), Be = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/is-symbol.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    return !!e3 && ("symbol" == typeof e3 || !!e3.constructor && ("Symbol" === e3.constructor.name && "Symbol" === e3[e3.constructor.toStringTag]));
  };
} }), Je = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/validate-symbol.js"(e2, t2) {
  X();
  var n3 = Be();
  t2.exports = function(e3) {
    if (!n3(e3)) throw new TypeError(e3 + " is not a symbol");
    return e3;
  };
} }), Fe = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/lib/private/generate-name.js"(e2, t2) {
  X();
  var n3 = Le(), r2 = Object.create, o2 = Object.defineProperty, i2 = Object.prototype, a2 = r2(null);
  t2.exports = function(e3) {
    for (var t3, r3, s2 = 0; a2[e3 + (s2 || "")]; ) ++s2;
    return a2[e3 += s2 || ""] = true, o2(i2, t3 = "@@" + e3, n3.gs(null, function(e4) {
      r3 || (r3 = true, o2(this, t3, n3(e4)), r3 = false);
    })), t3;
  };
} }), Ge = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(e2, t2) {
  X();
  var n3 = Le(), r2 = Ye().Symbol;
  t2.exports = function(e3) {
    return Object.defineProperties(e3, { hasInstance: n3("", r2 && r2.hasInstance || e3("hasInstance")), isConcatSpreadable: n3("", r2 && r2.isConcatSpreadable || e3("isConcatSpreadable")), iterator: n3("", r2 && r2.iterator || e3("iterator")), match: n3("", r2 && r2.match || e3("match")), replace: n3("", r2 && r2.replace || e3("replace")), search: n3("", r2 && r2.search || e3("search")), species: n3("", r2 && r2.species || e3("species")), split: n3("", r2 && r2.split || e3("split")), toPrimitive: n3("", r2 && r2.toPrimitive || e3("toPrimitive")), toStringTag: n3("", r2 && r2.toStringTag || e3("toStringTag")), unscopables: n3("", r2 && r2.unscopables || e3("unscopables")) });
  };
} }), qe = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(e2, t2) {
  X();
  var n3 = Le(), r2 = Je(), o2 = /* @__PURE__ */ Object.create(null);
  t2.exports = function(e3) {
    return Object.defineProperties(e3, { for: n3(function(t3) {
      return o2[t3] ? o2[t3] : o2[t3] = e3(String(t3));
    }), keyFor: n3(function(e4) {
      var t3;
      for (t3 in r2(e4), o2) if (o2[t3] === e4) return t3;
    }) });
  };
} }), Ze = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/polyfill.js"(e2, t2) {
  X();
  var n3, r2, o2, i2 = Le(), a2 = Je(), s2 = Ye().Symbol, c2 = Fe(), u2 = Ge(), d2 = qe(), f2 = Object.create, l2 = Object.defineProperties, h2 = Object.defineProperty;
  if ("function" == typeof s2) try {
    String(s2()), o2 = true;
  } catch (e3) {
  }
  else s2 = null;
  r2 = function(e3) {
    if (this instanceof r2) throw new TypeError("Symbol is not a constructor");
    return n3(e3);
  }, t2.exports = n3 = function e3(t3) {
    var n4;
    if (this instanceof e3) throw new TypeError("Symbol is not a constructor");
    return o2 ? s2(t3) : (n4 = f2(r2.prototype), t3 = void 0 === t3 ? "" : String(t3), l2(n4, { __description__: i2("", t3), __name__: i2("", c2(t3)) }));
  }, u2(n3), d2(n3), l2(r2.prototype, { constructor: i2(n3), toString: i2("", function() {
    return this.__name__;
  }) }), l2(n3.prototype, { toString: i2(function() {
    return "Symbol (" + a2(this).__description__ + ")";
  }), valueOf: i2(function() {
    return a2(this);
  }) }), h2(n3.prototype, n3.toPrimitive, i2("", function() {
    var e3 = a2(this);
    return "symbol" == typeof e3 ? e3 : e3.toString();
  })), h2(n3.prototype, n3.toStringTag, i2("c", "Symbol")), h2(r2.prototype, n3.toStringTag, i2("c", n3.prototype[n3.toStringTag])), h2(r2.prototype, n3.toPrimitive, i2("c", n3.prototype[n3.toPrimitive]));
} }), Ve = Z2({ "../../node_modules/.pnpm/es6-symbol@3.1.4/node_modules/es6-symbol/index.js"(e2, t2) {
  X(), t2.exports = Qe()() ? Ye().Symbol : Ze();
} }), Xe = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/function/is-arguments.js"(e2, t2) {
  X();
  var n3 = Object.prototype.toString, r2 = n3.call(/* @__PURE__ */ function() {
    return arguments;
  }());
  t2.exports = function(e3) {
    return n3.call(e3) === r2;
  };
} }), Ke = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/function/is-function.js"(e2, t2) {
  X();
  var n3 = Object.prototype.toString, r2 = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  t2.exports = function(e3) {
    return "function" == typeof e3 && r2(n3.call(e3));
  };
} }), He = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/string/is-string.js"(e2, t2) {
  X();
  var n3 = Object.prototype.toString, r2 = n3.call("");
  t2.exports = function(e3) {
    return "string" == typeof e3 || e3 && "object" == typeof e3 && (e3 instanceof String || n3.call(e3) === r2) || false;
  };
} }), $e = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/array/from/shim.js"(e2, t2) {
  X();
  var n3 = Ve().iterator, r2 = Xe(), o2 = Ke(), i2 = fe(), a2 = he(), s2 = pe(), c2 = ie(), u2 = He(), d2 = Array.isArray, f2 = Function.prototype.call, l2 = { configurable: true, enumerable: true, writable: true, value: null }, h2 = Object.defineProperty;
  t2.exports = function(e3) {
    var t3, p2, b2, y2, m2, g2, M2, w2, v2, N2, A2 = arguments[1], I2 = arguments[2];
    if (e3 = Object(s2(e3)), c2(A2) && a2(A2), this && this !== Array && o2(this)) t3 = this;
    else {
      if (!A2) {
        if (r2(e3)) return 1 !== (m2 = e3.length) ? Array.apply(null, e3) : ((y2 = new Array(1))[0] = e3[0], y2);
        if (d2(e3)) {
          for (y2 = new Array(m2 = e3.length), p2 = 0; p2 < m2; ++p2) y2[p2] = e3[p2];
          return y2;
        }
      }
      y2 = [];
    }
    if (!d2(e3)) {
      if (void 0 !== (v2 = e3[n3])) {
        for (M2 = a2(v2).call(e3), t3 && (y2 = new t3()), w2 = M2.next(), p2 = 0; !w2.done; ) N2 = A2 ? f2.call(A2, I2, w2.value, p2) : w2.value, t3 ? (l2.value = N2, h2(y2, p2, l2)) : y2[p2] = N2, w2 = M2.next(), ++p2;
        m2 = p2;
      } else if (u2(e3)) {
        for (m2 = e3.length, t3 && (y2 = new t3()), p2 = 0, b2 = 0; p2 < m2; ++p2) N2 = e3[p2], p2 + 1 < m2 && (g2 = N2.charCodeAt(0)) >= 55296 && g2 <= 56319 && (N2 += e3[++p2]), N2 = A2 ? f2.call(A2, I2, N2, b2) : N2, t3 ? (l2.value = N2, h2(y2, b2, l2)) : y2[b2] = N2, ++b2;
        m2 = b2;
      }
    }
    if (void 0 === m2) for (m2 = i2(e3.length), t3 && (y2 = new t3(m2)), p2 = 0; p2 < m2; ++p2) N2 = A2 ? f2.call(A2, I2, e3[p2], p2) : e3[p2], t3 ? (l2.value = N2, h2(y2, p2, l2)) : y2[p2] = N2;
    return t3 && (l2.value = null, y2.length = m2), y2;
  };
} }), et2 = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/array/from/index.js"(e2, t2) {
  X(), t2.exports = Re()() ? Array.from : $e();
} }), tt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/array/to-array.js"(e2, t2) {
  X();
  var n3 = et2(), r2 = Array.isArray;
  t2.exports = function(e3) {
    return r2(e3) ? e3 : n3(e3);
  };
} }), nt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-resolve.js"(e2, t2) {
  X();
  var n3, r2 = tt(), o2 = ie(), i2 = he(), a2 = Array.prototype.slice;
  n3 = function(e3) {
    return this.map(function(t3, n4) {
      return t3 ? t3(e3[n4]) : e3[n4];
    }).concat(a2.call(e3, this.length));
  }, t2.exports = function(e3) {
    return (e3 = r2(e3)).forEach(function(e4) {
      o2(e4) && i2(e4);
    }), n3.bind(e3);
  };
} }), rt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-normalize.js"(e2, t2) {
  X();
  var n3 = he();
  t2.exports = function(e3) {
    var t3;
    return "function" == typeof e3 ? { set: e3, get: e3 } : (t3 = { get: n3(e3.get) }, void 0 !== e3.set ? (t3.set = n3(e3.set), e3.delete && (t3.delete = n3(e3.delete)), e3.clear && (t3.clear = n3(e3.clear)), t3) : (t3.set = t3.get, t3));
  };
} }), ot = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/configure-map.js"(e2, t2) {
  X();
  var n3 = je(), r2 = _e(), o2 = Le(), i2 = ke().methods, a2 = nt(), s2 = rt(), c2 = Function.prototype.apply, u2 = Function.prototype.call, d2 = Object.create, f2 = Object.defineProperties, l2 = i2.on, h2 = i2.emit;
  t2.exports = function(e3, t3, i3) {
    var p2, b2, y2, m2, g2, M2, w2, v2, N2, A2, I2, j2, x2, _2, E2, T2 = d2(null);
    return b2 = false !== t3 ? t3 : isNaN(e3.length) ? 1 : e3.length, i3.normalizer && (A2 = s2(i3.normalizer), y2 = A2.get, m2 = A2.set, g2 = A2.delete, M2 = A2.clear), null != i3.resolvers && (E2 = a2(i3.resolvers)), _2 = y2 ? r2(function(t4) {
      var r3, o3, i4 = arguments;
      if (E2 && (i4 = E2(i4)), null !== (r3 = y2(i4)) && hasOwnProperty.call(T2, r3)) return I2 && p2.emit("get", r3, i4, this), T2[r3];
      if (o3 = 1 === i4.length ? u2.call(e3, this, i4[0]) : c2.call(e3, this, i4), null === r3) {
        if (null !== (r3 = y2(i4))) throw n3("Circular invocation", "CIRCULAR_INVOCATION");
        r3 = m2(i4);
      } else if (hasOwnProperty.call(T2, r3)) throw n3("Circular invocation", "CIRCULAR_INVOCATION");
      return T2[r3] = o3, j2 && p2.emit("set", r3, null, o3), o3;
    }, b2) : 0 === t3 ? function() {
      var t4;
      if (hasOwnProperty.call(T2, "data")) return I2 && p2.emit("get", "data", arguments, this), T2.data;
      if (t4 = arguments.length ? c2.call(e3, this, arguments) : u2.call(e3, this), hasOwnProperty.call(T2, "data")) throw n3("Circular invocation", "CIRCULAR_INVOCATION");
      return T2.data = t4, j2 && p2.emit("set", "data", null, t4), t4;
    } : function(t4) {
      var r3, o3, i4 = arguments;
      if (E2 && (i4 = E2(arguments)), o3 = String(i4[0]), hasOwnProperty.call(T2, o3)) return I2 && p2.emit("get", o3, i4, this), T2[o3];
      if (r3 = 1 === i4.length ? u2.call(e3, this, i4[0]) : c2.call(e3, this, i4), hasOwnProperty.call(T2, o3)) throw n3("Circular invocation", "CIRCULAR_INVOCATION");
      return T2[o3] = r3, j2 && p2.emit("set", o3, null, r3), r3;
    }, p2 = { original: e3, memoized: _2, profileName: i3.profileName, get: function(e4) {
      return E2 && (e4 = E2(e4)), y2 ? y2(e4) : String(e4[0]);
    }, has: function(e4) {
      return hasOwnProperty.call(T2, e4);
    }, delete: function(e4) {
      var t4;
      hasOwnProperty.call(T2, e4) && (g2 && g2(e4), t4 = T2[e4], delete T2[e4], x2 && p2.emit("delete", e4, t4));
    }, clear: function() {
      var e4 = T2;
      M2 && M2(), T2 = d2(null), p2.emit("clear", e4);
    }, on: function(e4, t4) {
      return "get" === e4 ? I2 = true : "set" === e4 ? j2 = true : "delete" === e4 && (x2 = true), l2.call(this, e4, t4);
    }, emit: h2, updateEnv: function() {
      e3 = p2.original;
    } }, w2 = y2 ? r2(function(e4) {
      var t4, n4 = arguments;
      E2 && (n4 = E2(n4)), null !== (t4 = y2(n4)) && p2.delete(t4);
    }, b2) : 0 === t3 ? function() {
      return p2.delete("data");
    } : function(e4) {
      return E2 && (e4 = E2(arguments)[0]), p2.delete(e4);
    }, v2 = r2(function() {
      var e4, n4 = arguments;
      return 0 === t3 ? T2.data : (E2 && (n4 = E2(n4)), e4 = y2 ? y2(n4) : String(n4[0]), T2[e4]);
    }), N2 = r2(function() {
      var e4, n4 = arguments;
      return 0 === t3 ? p2.has("data") : (E2 && (n4 = E2(n4)), null !== (e4 = y2 ? y2(n4) : String(n4[0])) && p2.has(e4));
    }), f2(_2, { __memoized__: o2(true), delete: o2(w2), clear: o2(p2.clear), _get: o2(v2), _has: o2(N2) }), p2;
  };
} }), it = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/plain.js"(e2, t2) {
  X();
  var n3 = he(), r2 = ye(), o2 = me(), i2 = ot(), a2 = le();
  t2.exports = function e3(t3) {
    var s2, c2, u2;
    if (n3(t3), (s2 = Object(arguments[1])).async && s2.promise) throw new Error("Options 'async' and 'promise' cannot be used together");
    return hasOwnProperty.call(t3, "__memoized__") && !s2.force ? t3 : (c2 = a2(s2.length, t3.length, s2.async && o2.async), u2 = i2(t3, c2, s2), r2(o2, function(e4, t4) {
      s2[t4] && e4(s2[t4], u2, s2);
    }), e3.__profiler__ && e3.__profiler__(u2), u2.updateEnv(), u2.memoized);
  };
} }), at = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/primitive.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    var t3, n3, r2 = e3.length;
    if (!r2) return "";
    for (t3 = String(e3[n3 = 0]); --r2; ) t3 += "" + e3[++n3];
    return t3;
  };
} }), st = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-primitive-fixed.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    return e3 ? function(t3) {
      for (var n3 = String(t3[0]), r2 = 0, o2 = e3; --o2; ) n3 += "" + t3[++r2];
      return n3;
    } : function() {
      return "";
    };
  };
} }), ct = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/number/is-nan/is-implemented.js"(e2, t2) {
  X(), t2.exports = function() {
    var e3 = Number.isNaN;
    return "function" == typeof e3 && (!e3({}) && e3(NaN) && !e3(34));
  };
} }), ut = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/number/is-nan/shim.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    return e3 != e3;
  };
} }), dt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/number/is-nan/index.js"(e2, t2) {
  X(), t2.exports = ct()() ? Number.isNaN : ut();
} }), ft = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/array/#/e-index-of.js"(e2, t2) {
  X();
  var n3 = dt(), r2 = fe(), o2 = pe(), i2 = Array.prototype.indexOf, a2 = Object.prototype.hasOwnProperty, s2 = Math.abs, c2 = Math.floor;
  t2.exports = function(e3) {
    var t3, u2, d2, f2;
    if (!n3(e3)) return i2.apply(this, arguments);
    for (u2 = r2(o2(this).length), d2 = arguments[1], t3 = d2 = isNaN(d2) ? 0 : d2 >= 0 ? c2(d2) : r2(this.length) - c2(s2(d2)); t3 < u2; ++t3) if (a2.call(this, t3) && (f2 = this[t3], n3(f2))) return t3;
    return -1;
  };
} }), lt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get.js"(e2, t2) {
  X();
  var n3 = ft(), r2 = Object.create;
  t2.exports = function() {
    var e3 = 0, t3 = [], o2 = r2(null);
    return { get: function(e4) {
      var r3, o3 = 0, i2 = t3, a2 = e4.length;
      if (0 === a2) return i2[a2] || null;
      if (i2 = i2[a2]) {
        for (; o3 < a2 - 1; ) {
          if (-1 === (r3 = n3.call(i2[0], e4[o3]))) return null;
          i2 = i2[1][r3], ++o3;
        }
        return -1 === (r3 = n3.call(i2[0], e4[o3])) ? null : i2[1][r3] || null;
      }
      return null;
    }, set: function(r3) {
      var i2, a2 = 0, s2 = t3, c2 = r3.length;
      if (0 === c2) s2[c2] = ++e3;
      else {
        for (s2[c2] || (s2[c2] = [[], []]), s2 = s2[c2]; a2 < c2 - 1; ) -1 === (i2 = n3.call(s2[0], r3[a2])) && (i2 = s2[0].push(r3[a2]) - 1, s2[1].push([[], []])), s2 = s2[1][i2], ++a2;
        -1 === (i2 = n3.call(s2[0], r3[a2])) && (i2 = s2[0].push(r3[a2]) - 1), s2[1][i2] = ++e3;
      }
      return o2[e3] = r3, e3;
    }, delete: function(e4) {
      var r3, i2 = 0, a2 = t3, s2 = o2[e4], c2 = s2.length, u2 = [];
      if (0 === c2) delete a2[c2];
      else if (a2 = a2[c2]) {
        for (; i2 < c2 - 1; ) {
          if (-1 === (r3 = n3.call(a2[0], s2[i2]))) return;
          u2.push(a2, r3), a2 = a2[1][r3], ++i2;
        }
        if (-1 === (r3 = n3.call(a2[0], s2[i2]))) return;
        for (e4 = a2[1][r3], a2[0].splice(r3, 1), a2[1].splice(r3, 1); !a2[0].length && u2.length; ) r3 = u2.pop(), (a2 = u2.pop())[0].splice(r3, 1), a2[1].splice(r3, 1);
      }
      delete o2[e4];
    }, clear: function() {
      t3 = [], o2 = r2(null);
    } };
  };
} }), ht = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-1.js"(e2, t2) {
  X();
  var n3 = ft();
  t2.exports = function() {
    var e3 = 0, t3 = [], r2 = [];
    return { get: function(e4) {
      var o2 = n3.call(t3, e4[0]);
      return -1 === o2 ? null : r2[o2];
    }, set: function(n4) {
      return t3.push(n4[0]), r2.push(++e3), e3;
    }, delete: function(e4) {
      var o2 = n3.call(r2, e4);
      -1 !== o2 && (t3.splice(o2, 1), r2.splice(o2, 1));
    }, clear: function() {
      t3 = [], r2 = [];
    } };
  };
} }), pt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-fixed.js"(e2, t2) {
  X();
  var n3 = ft(), r2 = Object.create;
  t2.exports = function(e3) {
    var t3 = 0, o2 = [[], []], i2 = r2(null);
    return { get: function(t4) {
      for (var r3, i3 = 0, a2 = o2; i3 < e3 - 1; ) {
        if (-1 === (r3 = n3.call(a2[0], t4[i3]))) return null;
        a2 = a2[1][r3], ++i3;
      }
      return -1 === (r3 = n3.call(a2[0], t4[i3])) ? null : a2[1][r3] || null;
    }, set: function(r3) {
      for (var a2, s2 = 0, c2 = o2; s2 < e3 - 1; ) -1 === (a2 = n3.call(c2[0], r3[s2])) && (a2 = c2[0].push(r3[s2]) - 1, c2[1].push([[], []])), c2 = c2[1][a2], ++s2;
      return -1 === (a2 = n3.call(c2[0], r3[s2])) && (a2 = c2[0].push(r3[s2]) - 1), c2[1][a2] = ++t3, i2[t3] = r3, t3;
    }, delete: function(t4) {
      for (var r3, a2 = 0, s2 = o2, c2 = [], u2 = i2[t4]; a2 < e3 - 1; ) {
        if (-1 === (r3 = n3.call(s2[0], u2[a2]))) return;
        c2.push(s2, r3), s2 = s2[1][r3], ++a2;
      }
      if (-1 !== (r3 = n3.call(s2[0], u2[a2]))) {
        for (t4 = s2[1][r3], s2[0].splice(r3, 1), s2[1].splice(r3, 1); !s2[0].length && c2.length; ) r3 = c2.pop(), (s2 = c2.pop())[0].splice(r3, 1), s2[1].splice(r3, 1);
        delete i2[t4];
      }
    }, clear: function() {
      o2 = [[], []], i2 = r2(null);
    } };
  };
} }), bt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/map.js"(e2, t2) {
  X();
  var n3 = he(), r2 = ye(), o2 = Function.prototype.call;
  t2.exports = function(e3, t3) {
    var i2 = {}, a2 = arguments[2];
    return n3(t3), r2(e3, function(e4, n4, r3, s2) {
      i2[n4] = o2.call(t3, a2, e4, n4, r3, s2);
    }), i2;
  };
} }), yt = Z2({ "../../node_modules/.pnpm/next-tick@1.1.0/node_modules/next-tick/index.js"(e2, t2) {
  X();
  var n3 = function(e3) {
    if ("function" != typeof e3) throw new TypeError(e3 + " is not a function");
    return e3;
  }, r2 = function(e3) {
    var t3, r3, o2 = document.createTextNode(""), i2 = 0;
    return new e3(function() {
      var e4;
      if (t3) r3 && (t3 = r3.concat(t3));
      else {
        if (!r3) return;
        t3 = r3;
      }
      if (r3 = t3, t3 = null, "function" == typeof r3) return e4 = r3, r3 = null, void e4();
      for (o2.data = i2 = ++i2 % 2; r3; ) e4 = r3.shift(), r3.length || (r3 = null), e4();
    }).observe(o2, { characterData: true }), function(e4) {
      n3(e4), t3 ? "function" == typeof t3 ? t3 = [t3, e4] : t3.push(e4) : (t3 = e4, o2.data = i2 = ++i2 % 2);
    };
  };
  t2.exports = function() {
    if ("object" == typeof process && process && "function" == typeof process.nextTick) return process.nextTick;
    if ("function" == typeof queueMicrotask) return function(e3) {
      queueMicrotask(n3(e3));
    };
    if ("object" == typeof document && document) {
      if ("function" == typeof MutationObserver) return r2(MutationObserver);
      if ("function" == typeof WebKitMutationObserver) return r2(WebKitMutationObserver);
    }
    return "function" == typeof setImmediate ? function(e3) {
      setImmediate(n3(e3));
    } : "function" == typeof setTimeout || "object" == typeof setTimeout ? function(e3) {
      setTimeout(n3(e3), 0);
    } : null;
  }();
} }), mt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/async.js"() {
  X();
  var e2 = et2(), t2 = bt(), n3 = xe(), r2 = _e(), o2 = yt(), i2 = Array.prototype.slice, a2 = Function.prototype.apply, s2 = Object.create;
  me().async = function(c2, u2) {
    var d2, f2, l2, h2 = s2(null), p2 = s2(null), b2 = u2.memoized, y2 = u2.original;
    u2.memoized = r2(function(e3) {
      var t3 = arguments, n4 = t3[t3.length - 1];
      return "function" == typeof n4 && (d2 = n4, t3 = i2.call(t3, 0, -1)), b2.apply(f2 = this, l2 = t3);
    }, b2);
    try {
      n3(u2.memoized, b2);
    } catch (e3) {
    }
    u2.on("get", function(e3) {
      var t3, n4, r3;
      if (d2) {
        if (h2[e3]) return "function" == typeof h2[e3] ? h2[e3] = [h2[e3], d2] : h2[e3].push(d2), void (d2 = null);
        t3 = d2, n4 = f2, r3 = l2, d2 = f2 = l2 = null, o2(function() {
          var o3;
          hasOwnProperty.call(p2, e3) ? (o3 = p2[e3], u2.emit("getasync", e3, r3, n4), a2.call(t3, o3.context, o3.args)) : (d2 = t3, f2 = n4, l2 = r3, b2.apply(n4, r3));
        });
      }
    }), u2.original = function() {
      var t3, n4, r3, i3;
      return d2 ? (t3 = e2(arguments), n4 = function t4(n5) {
        var r4, s3, c3 = t4.id;
        if (null != c3) {
          if (delete t4.id, r4 = h2[c3], delete h2[c3], r4) return s3 = e2(arguments), u2.has(c3) && (n5 ? u2.delete(c3) : (p2[c3] = { context: this, args: s3 }, u2.emit("setasync", c3, "function" == typeof r4 ? 1 : r4.length))), "function" == typeof r4 ? i3 = a2.call(r4, this, s3) : r4.forEach(function(e3) {
            i3 = a2.call(e3, this, s3);
          }, this), i3;
        } else o2(a2.bind(t4, this, arguments));
      }, r3 = d2, d2 = f2 = l2 = null, t3.push(n4), i3 = a2.call(y2, this, t3), n4.cb = r3, d2 = n4, i3) : a2.call(y2, this, arguments);
    }, u2.on("set", function(e3) {
      d2 ? (h2[e3] ? "function" == typeof h2[e3] ? h2[e3] = [h2[e3], d2.cb] : h2[e3].push(d2.cb) : h2[e3] = d2.cb, delete d2.cb, d2.id = e3, d2 = null) : u2.delete(e3);
    }), u2.on("delete", function(e3) {
      var t3;
      hasOwnProperty.call(h2, e3) || p2[e3] && (t3 = p2[e3], delete p2[e3], u2.emit("deleteasync", e3, i2.call(t3.args, 1)));
    }), u2.on("clear", function() {
      var e3 = p2;
      p2 = s2(null), u2.emit("clearasync", t2(e3, function(e4) {
        return i2.call(e4.args, 1);
      }));
    });
  };
} }), gt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/primitive-set.js"(e2, t2) {
  X();
  var n3 = Array.prototype.forEach, r2 = Object.create;
  t2.exports = function(e3) {
    var t3 = r2(null);
    return n3.call(arguments, function(e4) {
      t3[e4] = true;
    }), t3;
  };
} }), Mt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/is-callable.js"(e2, t2) {
  X(), t2.exports = function(e3) {
    return "function" == typeof e3;
  };
} }), wt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/validate-stringifiable.js"(e2, t2) {
  X();
  var n3 = Mt();
  t2.exports = function(e3) {
    try {
      return e3 && n3(e3.toString) ? e3.toString() : String(e3);
    } catch (e4) {
      throw new TypeError("Passed argument cannot be stringifed");
    }
  };
} }), vt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/object/validate-stringifiable-value.js"(e2, t2) {
  X();
  var n3 = pe(), r2 = wt();
  t2.exports = function(e3) {
    return r2(n3(e3));
  };
} }), Nt = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/safe-to-string.js"(e2, t2) {
  X();
  var n3 = Mt();
  t2.exports = function(e3) {
    try {
      return e3 && n3(e3.toString) ? e3.toString() : String(e3);
    } catch (e4) {
      return "<Non-coercible to string value>";
    }
  };
} }), At = Z2({ "../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/to-short-string-representation.js"(e2, t2) {
  X();
  var n3 = Nt(), r2 = /[\n\r\u2028\u2029]/g;
  t2.exports = function(e3) {
    var t3 = n3(e3);
    return t3.length > 100 && (t3 = t3.slice(0, 99) + "…"), t3 = t3.replace(r2, function(e4) {
      return JSON.stringify(e4).slice(1, -1);
    });
  };
} }), It = Z2({ "../../node_modules/.pnpm/is-promise@2.2.2/node_modules/is-promise/index.js"(e2, t2) {
  function n3(e3) {
    return !!e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof e3.then;
  }
  X(), t2.exports = n3, t2.exports.default = n3;
} }), jt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/promise.js"() {
  X();
  var e2 = bt(), t2 = gt(), n3 = vt(), r2 = At(), o2 = It(), i2 = yt(), a2 = Object.create, s2 = t2("then", "then:finally", "done", "done:finally");
  me().promise = function(t3, c2) {
    var u2 = a2(null), d2 = a2(null), f2 = a2(null);
    if (true === t3) t3 = null;
    else if (t3 = n3(t3), !s2[t3]) throw new TypeError("'" + r2(t3) + "' is not valid promise mode");
    c2.on("set", function(e3, n4, r3) {
      var a3 = false;
      if (!o2(r3)) return d2[e3] = r3, void c2.emit("setasync", e3, 1);
      u2[e3] = 1, f2[e3] = r3;
      var s3 = function(t4) {
        var n5 = u2[e3];
        if (a3) throw new Error("Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead.");
        n5 && (delete u2[e3], d2[e3] = t4, c2.emit("setasync", e3, n5));
      }, l2 = function() {
        a3 = true, u2[e3] && (delete u2[e3], delete f2[e3], c2.delete(e3));
      }, h2 = t3;
      if (h2 || (h2 = "then"), "then" === h2) {
        var p2 = function() {
          i2(l2);
        };
        "function" == typeof (r3 = r3.then(function(e4) {
          i2(s3.bind(this, e4));
        }, p2)).finally && r3.finally(p2);
      } else if ("done" === h2) {
        if ("function" != typeof r3.done) throw new Error("Memoizee error: Retrieved promise does not implement 'done' in 'done' mode");
        r3.done(s3, l2);
      } else if ("done:finally" === h2) {
        if ("function" != typeof r3.done) throw new Error("Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode");
        if ("function" != typeof r3.finally) throw new Error("Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode");
        r3.done(s3), r3.finally(l2);
      }
    }), c2.on("get", function(e3, t4, n4) {
      var r3;
      if (u2[e3]) ++u2[e3];
      else {
        r3 = f2[e3];
        var a3 = function() {
          c2.emit("getasync", e3, t4, n4);
        };
        o2(r3) ? "function" == typeof r3.done ? r3.done(a3) : r3.then(function() {
          i2(a3);
        }) : a3();
      }
    }), c2.on("delete", function(e3) {
      if (delete f2[e3], u2[e3]) delete u2[e3];
      else if (hasOwnProperty.call(d2, e3)) {
        var t4 = d2[e3];
        delete d2[e3], c2.emit("deleteasync", e3, [t4]);
      }
    }), c2.on("clear", function() {
      var t4 = d2;
      d2 = a2(null), u2 = a2(null), f2 = a2(null), c2.emit("clearasync", e2(t4, function(e3) {
        return [e3];
      }));
    });
  };
} }), xt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/dispose.js"() {
  X();
  var e2 = he(), t2 = ye(), n3 = me(), r2 = Function.prototype.apply;
  n3.dispose = function(o2, i2, a2) {
    var s2;
    if (e2(o2), a2.async && n3.async || a2.promise && n3.promise) return i2.on("deleteasync", s2 = function(e3, t3) {
      r2.call(o2, null, t3);
    }), void i2.on("clearasync", function(e3) {
      t2(e3, function(e4, t3) {
        s2(t3, e4);
      });
    });
    i2.on("delete", s2 = function(e3, t3) {
      o2(t3);
    }), i2.on("clear", function(e3) {
      t2(e3, function(e4, t3) {
        s2(t3, e4);
      });
    });
  };
} }), _t = Z2({ "../../node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/max-timeout.js"(e2, t2) {
  X(), t2.exports = 2147483647;
} }), Et = Z2({ "../../node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/valid-timeout.js"(e2, t2) {
  X();
  var n3 = fe(), r2 = _t();
  t2.exports = function(e3) {
    if ((e3 = n3(e3)) > r2) throw new TypeError(e3 + " exceeds maximum possible timeout");
    return e3;
  };
} }), Tt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max-age.js"() {
  X();
  var e2 = et2(), t2 = ye(), n3 = yt(), r2 = It(), o2 = Et(), i2 = me(), a2 = Function.prototype, s2 = Math.max, c2 = Math.min, u2 = Object.create;
  i2.maxAge = function(d2, f2, l2) {
    var h2, p2, b2, y2;
    (d2 = o2(d2)) && (h2 = u2(null), p2 = l2.async && i2.async || l2.promise && i2.promise ? "async" : "", f2.on("set" + p2, function(e3) {
      h2[e3] = setTimeout(function() {
        f2.delete(e3);
      }, d2), "function" == typeof h2[e3].unref && h2[e3].unref(), y2 && (y2[e3] && "nextTick" !== y2[e3] && clearTimeout(y2[e3]), y2[e3] = setTimeout(function() {
        delete y2[e3];
      }, b2), "function" == typeof y2[e3].unref && y2[e3].unref());
    }), f2.on("delete" + p2, function(e3) {
      clearTimeout(h2[e3]), delete h2[e3], y2 && ("nextTick" !== y2[e3] && clearTimeout(y2[e3]), delete y2[e3]);
    }), l2.preFetch && (b2 = true === l2.preFetch || isNaN(l2.preFetch) ? 0.333 : s2(c2(Number(l2.preFetch), 1), 0)) && (y2 = {}, b2 = (1 - b2) * d2, f2.on("get" + p2, function(t3, o3, i3) {
      y2[t3] || (y2[t3] = "nextTick", n3(function() {
        var n4;
        "nextTick" === y2[t3] && (delete y2[t3], f2.delete(t3), l2.async && (o3 = e2(o3)).push(a2), n4 = f2.memoized.apply(i3, o3), l2.promise && r2(n4) && ("function" == typeof n4.done ? n4.done(a2, a2) : n4.then(a2, a2)));
      }));
    })), f2.on("clear" + p2, function() {
      t2(h2, function(e3) {
        clearTimeout(e3);
      }), h2 = {}, y2 && (t2(y2, function(e3) {
        "nextTick" !== e3 && clearTimeout(e3);
      }), y2 = {});
    }));
  };
} }), Ot = Z2({ "../../node_modules/.pnpm/lru-queue@0.1.0/node_modules/lru-queue/index.js"(e2, t2) {
  X();
  var n3 = fe(), r2 = Object.create, o2 = Object.prototype.hasOwnProperty;
  t2.exports = function(e3) {
    var t3, i2 = 0, a2 = 1, s2 = r2(null), c2 = r2(null), u2 = 0;
    return e3 = n3(e3), { hit: function(n4) {
      var r3 = c2[n4], d2 = ++u2;
      if (s2[d2] = n4, c2[n4] = d2, !r3) {
        if (++i2 <= e3) return;
        return n4 = s2[a2], t3(n4), n4;
      }
      if (delete s2[r3], a2 === r3) for (; !o2.call(s2, ++a2); ) continue;
    }, delete: t3 = function(e4) {
      var t4 = c2[e4];
      if (t4 && (delete s2[t4], delete c2[e4], --i2, a2 === t4)) {
        if (!i2) return u2 = 0, void (a2 = 1);
        for (; !o2.call(s2, ++a2); ) continue;
      }
    }, clear: function() {
      i2 = 0, a2 = 1, s2 = r2(null), c2 = r2(null), u2 = 0;
    } };
  };
} }), Dt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max.js"() {
  X();
  var e2 = fe(), t2 = Ot(), n3 = me();
  n3.max = function(r2, o2, i2) {
    var a2, s2, c2;
    (r2 = e2(r2)) && (s2 = t2(r2), a2 = i2.async && n3.async || i2.promise && n3.promise ? "async" : "", o2.on("set" + a2, c2 = function(e3) {
      void 0 !== (e3 = s2.hit(e3)) && o2.delete(e3);
    }), o2.on("get" + a2, c2), o2.on("delete" + a2, s2.delete), o2.on("clear" + a2, s2.clear));
  };
} }), Ct = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/ref-counter.js"() {
  X();
  var e2 = Le(), t2 = me(), n3 = Object.create, r2 = Object.defineProperties;
  t2.refCounter = function(o2, i2, a2) {
    var s2, c2;
    s2 = n3(null), c2 = a2.async && t2.async || a2.promise && t2.promise ? "async" : "", i2.on("set" + c2, function(e3, t3) {
      s2[e3] = t3 || 1;
    }), i2.on("get" + c2, function(e3) {
      ++s2[e3];
    }), i2.on("delete" + c2, function(e3) {
      delete s2[e3];
    }), i2.on("clear" + c2, function() {
      s2 = {};
    }), r2(i2.memoized, { deleteRef: e2(function() {
      var e3 = i2.get(arguments);
      return null === e3 ? null : s2[e3] ? !--s2[e3] && (i2.delete(e3), true) : null;
    }), getRefCount: e2(function() {
      var e3 = i2.get(arguments);
      return null === e3 ? 0 : s2[e3] ? s2[e3] : 0;
    }) });
  };
} }), zt = Z2({ "../../node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/index.js"(e2, t2) {
  X();
  var n3 = ae(), r2 = le(), o2 = it();
  t2.exports = function(e3) {
    var t3, i2 = n3(arguments[1]);
    return i2.normalizer || 0 !== (t3 = i2.length = r2(i2.length, e3.length, i2.async)) && (i2.primitive ? false === t3 ? i2.normalizer = at() : t3 > 1 && (i2.normalizer = st()(t3)) : i2.normalizer = false === t3 ? lt()() : 1 === t3 ? ht()() : pt()(t3)), i2.async && mt(), i2.promise && jt(), i2.dispose && xt(), i2.maxAge && Tt(), i2.max && Dt(), i2.refCounter && Ct(), o2(e3, i2);
  };
} }), St = Z2({ "../../node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(e2, t2) {
  X(), function(e3) {
    var t3 = function(e4) {
      var t4, n4 = new Float64Array(16);
      if (e4) for (t4 = 0; t4 < e4.length; t4++) n4[t4] = e4[t4];
      return n4;
    }, n3 = function() {
      throw new Error("no PRNG");
    }, r2 = new Uint8Array(16), o2 = new Uint8Array(32);
    o2[0] = 9;
    var i2 = t3(), a2 = t3([1]), s2 = t3([56129, 1]), c2 = t3([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), u2 = t3([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), d2 = t3([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), f2 = t3([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), l2 = t3([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function h2(e4, t4, n4, r3) {
      e4[t4] = n4 >> 24 & 255, e4[t4 + 1] = n4 >> 16 & 255, e4[t4 + 2] = n4 >> 8 & 255, e4[t4 + 3] = 255 & n4, e4[t4 + 4] = r3 >> 24 & 255, e4[t4 + 5] = r3 >> 16 & 255, e4[t4 + 6] = r3 >> 8 & 255, e4[t4 + 7] = 255 & r3;
    }
    function p2(e4, t4, n4, r3, o3) {
      var i3, a3 = 0;
      for (i3 = 0; i3 < o3; i3++) a3 |= e4[t4 + i3] ^ n4[r3 + i3];
      return (1 & a3 - 1 >>> 8) - 1;
    }
    function b2(e4, t4, n4, r3) {
      return p2(e4, t4, n4, r3, 16);
    }
    function y2(e4, t4, n4, r3) {
      return p2(e4, t4, n4, r3, 32);
    }
    function m2(e4, t4, n4, r3) {
      !function(e5, t5, n5, r4) {
        for (var o3, i3 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, a3 = 255 & n5[0] | (255 & n5[1]) << 8 | (255 & n5[2]) << 16 | (255 & n5[3]) << 24, s3 = 255 & n5[4] | (255 & n5[5]) << 8 | (255 & n5[6]) << 16 | (255 & n5[7]) << 24, c3 = 255 & n5[8] | (255 & n5[9]) << 8 | (255 & n5[10]) << 16 | (255 & n5[11]) << 24, u3 = 255 & n5[12] | (255 & n5[13]) << 8 | (255 & n5[14]) << 16 | (255 & n5[15]) << 24, d3 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, f3 = 255 & t5[0] | (255 & t5[1]) << 8 | (255 & t5[2]) << 16 | (255 & t5[3]) << 24, l3 = 255 & t5[4] | (255 & t5[5]) << 8 | (255 & t5[6]) << 16 | (255 & t5[7]) << 24, h3 = 255 & t5[8] | (255 & t5[9]) << 8 | (255 & t5[10]) << 16 | (255 & t5[11]) << 24, p3 = 255 & t5[12] | (255 & t5[13]) << 8 | (255 & t5[14]) << 16 | (255 & t5[15]) << 24, b3 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, y3 = 255 & n5[16] | (255 & n5[17]) << 8 | (255 & n5[18]) << 16 | (255 & n5[19]) << 24, m3 = 255 & n5[20] | (255 & n5[21]) << 8 | (255 & n5[22]) << 16 | (255 & n5[23]) << 24, g3 = 255 & n5[24] | (255 & n5[25]) << 8 | (255 & n5[26]) << 16 | (255 & n5[27]) << 24, M3 = 255 & n5[28] | (255 & n5[29]) << 8 | (255 & n5[30]) << 16 | (255 & n5[31]) << 24, w3 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, v6 = i3, N3 = a3, A3 = s3, I3 = c3, j3 = u3, x3 = d3, _3 = f3, E3 = l3, T3 = h3, O3 = p3, D3 = b3, C3 = y3, z3 = m3, S3 = g3, P3 = M3, L3 = w3, k3 = 0; k3 < 20; k3 += 2) v6 ^= (o3 = (z3 ^= (o3 = (T3 ^= (o3 = (j3 ^= (o3 = v6 + z3 | 0) << 7 | o3 >>> 25) + v6 | 0) << 9 | o3 >>> 23) + j3 | 0) << 13 | o3 >>> 19) + T3 | 0) << 18 | o3 >>> 14, x3 ^= (o3 = (N3 ^= (o3 = (S3 ^= (o3 = (O3 ^= (o3 = x3 + N3 | 0) << 7 | o3 >>> 25) + x3 | 0) << 9 | o3 >>> 23) + O3 | 0) << 13 | o3 >>> 19) + S3 | 0) << 18 | o3 >>> 14, D3 ^= (o3 = (_3 ^= (o3 = (A3 ^= (o3 = (P3 ^= (o3 = D3 + _3 | 0) << 7 | o3 >>> 25) + D3 | 0) << 9 | o3 >>> 23) + P3 | 0) << 13 | o3 >>> 19) + A3 | 0) << 18 | o3 >>> 14, L3 ^= (o3 = (C3 ^= (o3 = (E3 ^= (o3 = (I3 ^= (o3 = L3 + C3 | 0) << 7 | o3 >>> 25) + L3 | 0) << 9 | o3 >>> 23) + I3 | 0) << 13 | o3 >>> 19) + E3 | 0) << 18 | o3 >>> 14, v6 ^= (o3 = (I3 ^= (o3 = (A3 ^= (o3 = (N3 ^= (o3 = v6 + I3 | 0) << 7 | o3 >>> 25) + v6 | 0) << 9 | o3 >>> 23) + N3 | 0) << 13 | o3 >>> 19) + A3 | 0) << 18 | o3 >>> 14, x3 ^= (o3 = (j3 ^= (o3 = (E3 ^= (o3 = (_3 ^= (o3 = x3 + j3 | 0) << 7 | o3 >>> 25) + x3 | 0) << 9 | o3 >>> 23) + _3 | 0) << 13 | o3 >>> 19) + E3 | 0) << 18 | o3 >>> 14, D3 ^= (o3 = (O3 ^= (o3 = (T3 ^= (o3 = (C3 ^= (o3 = D3 + O3 | 0) << 7 | o3 >>> 25) + D3 | 0) << 9 | o3 >>> 23) + C3 | 0) << 13 | o3 >>> 19) + T3 | 0) << 18 | o3 >>> 14, L3 ^= (o3 = (P3 ^= (o3 = (S3 ^= (o3 = (z3 ^= (o3 = L3 + P3 | 0) << 7 | o3 >>> 25) + L3 | 0) << 9 | o3 >>> 23) + z3 | 0) << 13 | o3 >>> 19) + S3 | 0) << 18 | o3 >>> 14;
        v6 = v6 + i3 | 0, N3 = N3 + a3 | 0, A3 = A3 + s3 | 0, I3 = I3 + c3 | 0, j3 = j3 + u3 | 0, x3 = x3 + d3 | 0, _3 = _3 + f3 | 0, E3 = E3 + l3 | 0, T3 = T3 + h3 | 0, O3 = O3 + p3 | 0, D3 = D3 + b3 | 0, C3 = C3 + y3 | 0, z3 = z3 + m3 | 0, S3 = S3 + g3 | 0, P3 = P3 + M3 | 0, L3 = L3 + w3 | 0, e5[0] = v6 >>> 0 & 255, e5[1] = v6 >>> 8 & 255, e5[2] = v6 >>> 16 & 255, e5[3] = v6 >>> 24 & 255, e5[4] = N3 >>> 0 & 255, e5[5] = N3 >>> 8 & 255, e5[6] = N3 >>> 16 & 255, e5[7] = N3 >>> 24 & 255, e5[8] = A3 >>> 0 & 255, e5[9] = A3 >>> 8 & 255, e5[10] = A3 >>> 16 & 255, e5[11] = A3 >>> 24 & 255, e5[12] = I3 >>> 0 & 255, e5[13] = I3 >>> 8 & 255, e5[14] = I3 >>> 16 & 255, e5[15] = I3 >>> 24 & 255, e5[16] = j3 >>> 0 & 255, e5[17] = j3 >>> 8 & 255, e5[18] = j3 >>> 16 & 255, e5[19] = j3 >>> 24 & 255, e5[20] = x3 >>> 0 & 255, e5[21] = x3 >>> 8 & 255, e5[22] = x3 >>> 16 & 255, e5[23] = x3 >>> 24 & 255, e5[24] = _3 >>> 0 & 255, e5[25] = _3 >>> 8 & 255, e5[26] = _3 >>> 16 & 255, e5[27] = _3 >>> 24 & 255, e5[28] = E3 >>> 0 & 255, e5[29] = E3 >>> 8 & 255, e5[30] = E3 >>> 16 & 255, e5[31] = E3 >>> 24 & 255, e5[32] = T3 >>> 0 & 255, e5[33] = T3 >>> 8 & 255, e5[34] = T3 >>> 16 & 255, e5[35] = T3 >>> 24 & 255, e5[36] = O3 >>> 0 & 255, e5[37] = O3 >>> 8 & 255, e5[38] = O3 >>> 16 & 255, e5[39] = O3 >>> 24 & 255, e5[40] = D3 >>> 0 & 255, e5[41] = D3 >>> 8 & 255, e5[42] = D3 >>> 16 & 255, e5[43] = D3 >>> 24 & 255, e5[44] = C3 >>> 0 & 255, e5[45] = C3 >>> 8 & 255, e5[46] = C3 >>> 16 & 255, e5[47] = C3 >>> 24 & 255, e5[48] = z3 >>> 0 & 255, e5[49] = z3 >>> 8 & 255, e5[50] = z3 >>> 16 & 255, e5[51] = z3 >>> 24 & 255, e5[52] = S3 >>> 0 & 255, e5[53] = S3 >>> 8 & 255, e5[54] = S3 >>> 16 & 255, e5[55] = S3 >>> 24 & 255, e5[56] = P3 >>> 0 & 255, e5[57] = P3 >>> 8 & 255, e5[58] = P3 >>> 16 & 255, e5[59] = P3 >>> 24 & 255, e5[60] = L3 >>> 0 & 255, e5[61] = L3 >>> 8 & 255, e5[62] = L3 >>> 16 & 255, e5[63] = L3 >>> 24 & 255;
      }(e4, t4, n4, r3);
    }
    function g2(e4, t4, n4, r3) {
      !function(e5, t5, n5, r4) {
        for (var o3, i3 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, a3 = 255 & n5[0] | (255 & n5[1]) << 8 | (255 & n5[2]) << 16 | (255 & n5[3]) << 24, s3 = 255 & n5[4] | (255 & n5[5]) << 8 | (255 & n5[6]) << 16 | (255 & n5[7]) << 24, c3 = 255 & n5[8] | (255 & n5[9]) << 8 | (255 & n5[10]) << 16 | (255 & n5[11]) << 24, u3 = 255 & n5[12] | (255 & n5[13]) << 8 | (255 & n5[14]) << 16 | (255 & n5[15]) << 24, d3 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, f3 = 255 & t5[0] | (255 & t5[1]) << 8 | (255 & t5[2]) << 16 | (255 & t5[3]) << 24, l3 = 255 & t5[4] | (255 & t5[5]) << 8 | (255 & t5[6]) << 16 | (255 & t5[7]) << 24, h3 = 255 & t5[8] | (255 & t5[9]) << 8 | (255 & t5[10]) << 16 | (255 & t5[11]) << 24, p3 = 255 & t5[12] | (255 & t5[13]) << 8 | (255 & t5[14]) << 16 | (255 & t5[15]) << 24, b3 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, y3 = 255 & n5[16] | (255 & n5[17]) << 8 | (255 & n5[18]) << 16 | (255 & n5[19]) << 24, m3 = 255 & n5[20] | (255 & n5[21]) << 8 | (255 & n5[22]) << 16 | (255 & n5[23]) << 24, g3 = 255 & n5[24] | (255 & n5[25]) << 8 | (255 & n5[26]) << 16 | (255 & n5[27]) << 24, M3 = 255 & n5[28] | (255 & n5[29]) << 8 | (255 & n5[30]) << 16 | (255 & n5[31]) << 24, w3 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, v6 = 0; v6 < 20; v6 += 2) i3 ^= (o3 = (m3 ^= (o3 = (h3 ^= (o3 = (u3 ^= (o3 = i3 + m3 | 0) << 7 | o3 >>> 25) + i3 | 0) << 9 | o3 >>> 23) + u3 | 0) << 13 | o3 >>> 19) + h3 | 0) << 18 | o3 >>> 14, d3 ^= (o3 = (a3 ^= (o3 = (g3 ^= (o3 = (p3 ^= (o3 = d3 + a3 | 0) << 7 | o3 >>> 25) + d3 | 0) << 9 | o3 >>> 23) + p3 | 0) << 13 | o3 >>> 19) + g3 | 0) << 18 | o3 >>> 14, b3 ^= (o3 = (f3 ^= (o3 = (s3 ^= (o3 = (M3 ^= (o3 = b3 + f3 | 0) << 7 | o3 >>> 25) + b3 | 0) << 9 | o3 >>> 23) + M3 | 0) << 13 | o3 >>> 19) + s3 | 0) << 18 | o3 >>> 14, w3 ^= (o3 = (y3 ^= (o3 = (l3 ^= (o3 = (c3 ^= (o3 = w3 + y3 | 0) << 7 | o3 >>> 25) + w3 | 0) << 9 | o3 >>> 23) + c3 | 0) << 13 | o3 >>> 19) + l3 | 0) << 18 | o3 >>> 14, i3 ^= (o3 = (c3 ^= (o3 = (s3 ^= (o3 = (a3 ^= (o3 = i3 + c3 | 0) << 7 | o3 >>> 25) + i3 | 0) << 9 | o3 >>> 23) + a3 | 0) << 13 | o3 >>> 19) + s3 | 0) << 18 | o3 >>> 14, d3 ^= (o3 = (u3 ^= (o3 = (l3 ^= (o3 = (f3 ^= (o3 = d3 + u3 | 0) << 7 | o3 >>> 25) + d3 | 0) << 9 | o3 >>> 23) + f3 | 0) << 13 | o3 >>> 19) + l3 | 0) << 18 | o3 >>> 14, b3 ^= (o3 = (p3 ^= (o3 = (h3 ^= (o3 = (y3 ^= (o3 = b3 + p3 | 0) << 7 | o3 >>> 25) + b3 | 0) << 9 | o3 >>> 23) + y3 | 0) << 13 | o3 >>> 19) + h3 | 0) << 18 | o3 >>> 14, w3 ^= (o3 = (M3 ^= (o3 = (g3 ^= (o3 = (m3 ^= (o3 = w3 + M3 | 0) << 7 | o3 >>> 25) + w3 | 0) << 9 | o3 >>> 23) + m3 | 0) << 13 | o3 >>> 19) + g3 | 0) << 18 | o3 >>> 14;
        e5[0] = i3 >>> 0 & 255, e5[1] = i3 >>> 8 & 255, e5[2] = i3 >>> 16 & 255, e5[3] = i3 >>> 24 & 255, e5[4] = d3 >>> 0 & 255, e5[5] = d3 >>> 8 & 255, e5[6] = d3 >>> 16 & 255, e5[7] = d3 >>> 24 & 255, e5[8] = b3 >>> 0 & 255, e5[9] = b3 >>> 8 & 255, e5[10] = b3 >>> 16 & 255, e5[11] = b3 >>> 24 & 255, e5[12] = w3 >>> 0 & 255, e5[13] = w3 >>> 8 & 255, e5[14] = w3 >>> 16 & 255, e5[15] = w3 >>> 24 & 255, e5[16] = f3 >>> 0 & 255, e5[17] = f3 >>> 8 & 255, e5[18] = f3 >>> 16 & 255, e5[19] = f3 >>> 24 & 255, e5[20] = l3 >>> 0 & 255, e5[21] = l3 >>> 8 & 255, e5[22] = l3 >>> 16 & 255, e5[23] = l3 >>> 24 & 255, e5[24] = h3 >>> 0 & 255, e5[25] = h3 >>> 8 & 255, e5[26] = h3 >>> 16 & 255, e5[27] = h3 >>> 24 & 255, e5[28] = p3 >>> 0 & 255, e5[29] = p3 >>> 8 & 255, e5[30] = p3 >>> 16 & 255, e5[31] = p3 >>> 24 & 255;
      }(e4, t4, n4, r3);
    }
    var M2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function w2(e4, t4, n4, r3, o3, i3, a3) {
      var s3, c3, u3 = new Uint8Array(16), d3 = new Uint8Array(64);
      for (c3 = 0; c3 < 16; c3++) u3[c3] = 0;
      for (c3 = 0; c3 < 8; c3++) u3[c3] = i3[c3];
      for (; o3 >= 64; ) {
        for (m2(d3, u3, a3, M2), c3 = 0; c3 < 64; c3++) e4[t4 + c3] = n4[r3 + c3] ^ d3[c3];
        for (s3 = 1, c3 = 8; c3 < 16; c3++) s3 = s3 + (255 & u3[c3]) | 0, u3[c3] = 255 & s3, s3 >>>= 8;
        o3 -= 64, t4 += 64, r3 += 64;
      }
      if (o3 > 0) for (m2(d3, u3, a3, M2), c3 = 0; c3 < o3; c3++) e4[t4 + c3] = n4[r3 + c3] ^ d3[c3];
      return 0;
    }
    function v2(e4, t4, n4, r3, o3) {
      var i3, a3, s3 = new Uint8Array(16), c3 = new Uint8Array(64);
      for (a3 = 0; a3 < 16; a3++) s3[a3] = 0;
      for (a3 = 0; a3 < 8; a3++) s3[a3] = r3[a3];
      for (; n4 >= 64; ) {
        for (m2(c3, s3, o3, M2), a3 = 0; a3 < 64; a3++) e4[t4 + a3] = c3[a3];
        for (i3 = 1, a3 = 8; a3 < 16; a3++) i3 = i3 + (255 & s3[a3]) | 0, s3[a3] = 255 & i3, i3 >>>= 8;
        n4 -= 64, t4 += 64;
      }
      if (n4 > 0) for (m2(c3, s3, o3, M2), a3 = 0; a3 < n4; a3++) e4[t4 + a3] = c3[a3];
      return 0;
    }
    function N2(e4, t4, n4, r3, o3) {
      var i3 = new Uint8Array(32);
      g2(i3, r3, o3, M2);
      for (var a3 = new Uint8Array(8), s3 = 0; s3 < 8; s3++) a3[s3] = r3[s3 + 16];
      return v2(e4, t4, n4, a3, i3);
    }
    function A2(e4, t4, n4, r3, o3, i3, a3) {
      var s3 = new Uint8Array(32);
      g2(s3, i3, a3, M2);
      for (var c3 = new Uint8Array(8), u3 = 0; u3 < 8; u3++) c3[u3] = i3[u3 + 16];
      return w2(e4, t4, n4, r3, o3, c3, s3);
    }
    var I2 = function(e4) {
      var t4, n4, r3, o3, i3, a3, s3, c3;
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, t4 = 255 & e4[0] | (255 & e4[1]) << 8, this.r[0] = 8191 & t4, n4 = 255 & e4[2] | (255 & e4[3]) << 8, this.r[1] = 8191 & (t4 >>> 13 | n4 << 3), r3 = 255 & e4[4] | (255 & e4[5]) << 8, this.r[2] = 7939 & (n4 >>> 10 | r3 << 6), o3 = 255 & e4[6] | (255 & e4[7]) << 8, this.r[3] = 8191 & (r3 >>> 7 | o3 << 9), i3 = 255 & e4[8] | (255 & e4[9]) << 8, this.r[4] = 255 & (o3 >>> 4 | i3 << 12), this.r[5] = i3 >>> 1 & 8190, a3 = 255 & e4[10] | (255 & e4[11]) << 8, this.r[6] = 8191 & (i3 >>> 14 | a3 << 2), s3 = 255 & e4[12] | (255 & e4[13]) << 8, this.r[7] = 8065 & (a3 >>> 11 | s3 << 5), c3 = 255 & e4[14] | (255 & e4[15]) << 8, this.r[8] = 8191 & (s3 >>> 8 | c3 << 8), this.r[9] = c3 >>> 5 & 127, this.pad[0] = 255 & e4[16] | (255 & e4[17]) << 8, this.pad[1] = 255 & e4[18] | (255 & e4[19]) << 8, this.pad[2] = 255 & e4[20] | (255 & e4[21]) << 8, this.pad[3] = 255 & e4[22] | (255 & e4[23]) << 8, this.pad[4] = 255 & e4[24] | (255 & e4[25]) << 8, this.pad[5] = 255 & e4[26] | (255 & e4[27]) << 8, this.pad[6] = 255 & e4[28] | (255 & e4[29]) << 8, this.pad[7] = 255 & e4[30] | (255 & e4[31]) << 8;
    };
    function j2(e4, t4, n4, r3, o3, i3) {
      var a3 = new I2(i3);
      return a3.update(n4, r3, o3), a3.finish(e4, t4), 0;
    }
    function x2(e4, t4, n4, r3, o3, i3) {
      var a3 = new Uint8Array(16);
      return j2(a3, 0, n4, r3, o3, i3), b2(e4, t4, a3, 0);
    }
    function _2(e4, t4, n4, r3, o3) {
      var i3;
      if (n4 < 32) return -1;
      for (A2(e4, 0, t4, 0, n4, r3, o3), j2(e4, 16, e4, 32, n4 - 32, e4), i3 = 0; i3 < 16; i3++) e4[i3] = 0;
      return 0;
    }
    function E2(e4, t4, n4, r3, o3) {
      var i3, a3 = new Uint8Array(32);
      if (n4 < 32) return -1;
      if (N2(a3, 0, 32, r3, o3), 0 !== x2(t4, 16, t4, 32, n4 - 32, a3)) return -1;
      for (A2(e4, 0, t4, 0, n4, r3, o3), i3 = 0; i3 < 32; i3++) e4[i3] = 0;
      return 0;
    }
    function T2(e4, t4) {
      var n4;
      for (n4 = 0; n4 < 16; n4++) e4[n4] = 0 | t4[n4];
    }
    function O2(e4) {
      var t4, n4, r3 = 1;
      for (t4 = 0; t4 < 16; t4++) n4 = e4[t4] + r3 + 65535, r3 = Math.floor(n4 / 65536), e4[t4] = n4 - 65536 * r3;
      e4[0] += r3 - 1 + 37 * (r3 - 1);
    }
    function D2(e4, t4, n4) {
      for (var r3, o3 = ~(n4 - 1), i3 = 0; i3 < 16; i3++) r3 = o3 & (e4[i3] ^ t4[i3]), e4[i3] ^= r3, t4[i3] ^= r3;
    }
    function C2(e4, n4) {
      var r3, o3, i3, a3 = t3(), s3 = t3();
      for (r3 = 0; r3 < 16; r3++) s3[r3] = n4[r3];
      for (O2(s3), O2(s3), O2(s3), o3 = 0; o3 < 2; o3++) {
        for (a3[0] = s3[0] - 65517, r3 = 1; r3 < 15; r3++) a3[r3] = s3[r3] - 65535 - (a3[r3 - 1] >> 16 & 1), a3[r3 - 1] &= 65535;
        a3[15] = s3[15] - 32767 - (a3[14] >> 16 & 1), i3 = a3[15] >> 16 & 1, a3[14] &= 65535, D2(s3, a3, 1 - i3);
      }
      for (r3 = 0; r3 < 16; r3++) e4[2 * r3] = 255 & s3[r3], e4[2 * r3 + 1] = s3[r3] >> 8;
    }
    function z2(e4, t4) {
      var n4 = new Uint8Array(32), r3 = new Uint8Array(32);
      return C2(n4, e4), C2(r3, t4), y2(n4, 0, r3, 0);
    }
    function S2(e4) {
      var t4 = new Uint8Array(32);
      return C2(t4, e4), 1 & t4[0];
    }
    function P2(e4, t4) {
      var n4;
      for (n4 = 0; n4 < 16; n4++) e4[n4] = t4[2 * n4] + (t4[2 * n4 + 1] << 8);
      e4[15] &= 32767;
    }
    function L2(e4, t4, n4) {
      for (var r3 = 0; r3 < 16; r3++) e4[r3] = t4[r3] + n4[r3];
    }
    function k2(e4, t4, n4) {
      for (var r3 = 0; r3 < 16; r3++) e4[r3] = t4[r3] - n4[r3];
    }
    function R2(e4, t4, n4) {
      var r3, o3, i3 = 0, a3 = 0, s3 = 0, c3 = 0, u3 = 0, d3 = 0, f3 = 0, l3 = 0, h3 = 0, p3 = 0, b3 = 0, y3 = 0, m3 = 0, g3 = 0, M3 = 0, w3 = 0, v6 = 0, N3 = 0, A3 = 0, I3 = 0, j3 = 0, x3 = 0, _3 = 0, E3 = 0, T3 = 0, O3 = 0, D3 = 0, C3 = 0, z3 = 0, S3 = 0, P3 = 0, L3 = n4[0], k3 = n4[1], R3 = n4[2], U3 = n4[3], W3 = n4[4], Y4 = n4[5], Q3 = n4[6], B4 = n4[7], J3 = n4[8], F4 = n4[9], G4 = n4[10], q3 = n4[11], Z4 = n4[12], V3 = n4[13], X3 = n4[14], K4 = n4[15];
      i3 += (r3 = t4[0]) * L3, a3 += r3 * k3, s3 += r3 * R3, c3 += r3 * U3, u3 += r3 * W3, d3 += r3 * Y4, f3 += r3 * Q3, l3 += r3 * B4, h3 += r3 * J3, p3 += r3 * F4, b3 += r3 * G4, y3 += r3 * q3, m3 += r3 * Z4, g3 += r3 * V3, M3 += r3 * X3, w3 += r3 * K4, a3 += (r3 = t4[1]) * L3, s3 += r3 * k3, c3 += r3 * R3, u3 += r3 * U3, d3 += r3 * W3, f3 += r3 * Y4, l3 += r3 * Q3, h3 += r3 * B4, p3 += r3 * J3, b3 += r3 * F4, y3 += r3 * G4, m3 += r3 * q3, g3 += r3 * Z4, M3 += r3 * V3, w3 += r3 * X3, v6 += r3 * K4, s3 += (r3 = t4[2]) * L3, c3 += r3 * k3, u3 += r3 * R3, d3 += r3 * U3, f3 += r3 * W3, l3 += r3 * Y4, h3 += r3 * Q3, p3 += r3 * B4, b3 += r3 * J3, y3 += r3 * F4, m3 += r3 * G4, g3 += r3 * q3, M3 += r3 * Z4, w3 += r3 * V3, v6 += r3 * X3, N3 += r3 * K4, c3 += (r3 = t4[3]) * L3, u3 += r3 * k3, d3 += r3 * R3, f3 += r3 * U3, l3 += r3 * W3, h3 += r3 * Y4, p3 += r3 * Q3, b3 += r3 * B4, y3 += r3 * J3, m3 += r3 * F4, g3 += r3 * G4, M3 += r3 * q3, w3 += r3 * Z4, v6 += r3 * V3, N3 += r3 * X3, A3 += r3 * K4, u3 += (r3 = t4[4]) * L3, d3 += r3 * k3, f3 += r3 * R3, l3 += r3 * U3, h3 += r3 * W3, p3 += r3 * Y4, b3 += r3 * Q3, y3 += r3 * B4, m3 += r3 * J3, g3 += r3 * F4, M3 += r3 * G4, w3 += r3 * q3, v6 += r3 * Z4, N3 += r3 * V3, A3 += r3 * X3, I3 += r3 * K4, d3 += (r3 = t4[5]) * L3, f3 += r3 * k3, l3 += r3 * R3, h3 += r3 * U3, p3 += r3 * W3, b3 += r3 * Y4, y3 += r3 * Q3, m3 += r3 * B4, g3 += r3 * J3, M3 += r3 * F4, w3 += r3 * G4, v6 += r3 * q3, N3 += r3 * Z4, A3 += r3 * V3, I3 += r3 * X3, j3 += r3 * K4, f3 += (r3 = t4[6]) * L3, l3 += r3 * k3, h3 += r3 * R3, p3 += r3 * U3, b3 += r3 * W3, y3 += r3 * Y4, m3 += r3 * Q3, g3 += r3 * B4, M3 += r3 * J3, w3 += r3 * F4, v6 += r3 * G4, N3 += r3 * q3, A3 += r3 * Z4, I3 += r3 * V3, j3 += r3 * X3, x3 += r3 * K4, l3 += (r3 = t4[7]) * L3, h3 += r3 * k3, p3 += r3 * R3, b3 += r3 * U3, y3 += r3 * W3, m3 += r3 * Y4, g3 += r3 * Q3, M3 += r3 * B4, w3 += r3 * J3, v6 += r3 * F4, N3 += r3 * G4, A3 += r3 * q3, I3 += r3 * Z4, j3 += r3 * V3, x3 += r3 * X3, _3 += r3 * K4, h3 += (r3 = t4[8]) * L3, p3 += r3 * k3, b3 += r3 * R3, y3 += r3 * U3, m3 += r3 * W3, g3 += r3 * Y4, M3 += r3 * Q3, w3 += r3 * B4, v6 += r3 * J3, N3 += r3 * F4, A3 += r3 * G4, I3 += r3 * q3, j3 += r3 * Z4, x3 += r3 * V3, _3 += r3 * X3, E3 += r3 * K4, p3 += (r3 = t4[9]) * L3, b3 += r3 * k3, y3 += r3 * R3, m3 += r3 * U3, g3 += r3 * W3, M3 += r3 * Y4, w3 += r3 * Q3, v6 += r3 * B4, N3 += r3 * J3, A3 += r3 * F4, I3 += r3 * G4, j3 += r3 * q3, x3 += r3 * Z4, _3 += r3 * V3, E3 += r3 * X3, T3 += r3 * K4, b3 += (r3 = t4[10]) * L3, y3 += r3 * k3, m3 += r3 * R3, g3 += r3 * U3, M3 += r3 * W3, w3 += r3 * Y4, v6 += r3 * Q3, N3 += r3 * B4, A3 += r3 * J3, I3 += r3 * F4, j3 += r3 * G4, x3 += r3 * q3, _3 += r3 * Z4, E3 += r3 * V3, T3 += r3 * X3, O3 += r3 * K4, y3 += (r3 = t4[11]) * L3, m3 += r3 * k3, g3 += r3 * R3, M3 += r3 * U3, w3 += r3 * W3, v6 += r3 * Y4, N3 += r3 * Q3, A3 += r3 * B4, I3 += r3 * J3, j3 += r3 * F4, x3 += r3 * G4, _3 += r3 * q3, E3 += r3 * Z4, T3 += r3 * V3, O3 += r3 * X3, D3 += r3 * K4, m3 += (r3 = t4[12]) * L3, g3 += r3 * k3, M3 += r3 * R3, w3 += r3 * U3, v6 += r3 * W3, N3 += r3 * Y4, A3 += r3 * Q3, I3 += r3 * B4, j3 += r3 * J3, x3 += r3 * F4, _3 += r3 * G4, E3 += r3 * q3, T3 += r3 * Z4, O3 += r3 * V3, D3 += r3 * X3, C3 += r3 * K4, g3 += (r3 = t4[13]) * L3, M3 += r3 * k3, w3 += r3 * R3, v6 += r3 * U3, N3 += r3 * W3, A3 += r3 * Y4, I3 += r3 * Q3, j3 += r3 * B4, x3 += r3 * J3, _3 += r3 * F4, E3 += r3 * G4, T3 += r3 * q3, O3 += r3 * Z4, D3 += r3 * V3, C3 += r3 * X3, z3 += r3 * K4, M3 += (r3 = t4[14]) * L3, w3 += r3 * k3, v6 += r3 * R3, N3 += r3 * U3, A3 += r3 * W3, I3 += r3 * Y4, j3 += r3 * Q3, x3 += r3 * B4, _3 += r3 * J3, E3 += r3 * F4, T3 += r3 * G4, O3 += r3 * q3, D3 += r3 * Z4, C3 += r3 * V3, z3 += r3 * X3, S3 += r3 * K4, w3 += (r3 = t4[15]) * L3, a3 += 38 * (N3 += r3 * R3), s3 += 38 * (A3 += r3 * U3), c3 += 38 * (I3 += r3 * W3), u3 += 38 * (j3 += r3 * Y4), d3 += 38 * (x3 += r3 * Q3), f3 += 38 * (_3 += r3 * B4), l3 += 38 * (E3 += r3 * J3), h3 += 38 * (T3 += r3 * F4), p3 += 38 * (O3 += r3 * G4), b3 += 38 * (D3 += r3 * q3), y3 += 38 * (C3 += r3 * Z4), m3 += 38 * (z3 += r3 * V3), g3 += 38 * (S3 += r3 * X3), M3 += 38 * (P3 += r3 * K4), i3 = (r3 = (i3 += 38 * (v6 += r3 * k3)) + (o3 = 1) + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), a3 = (r3 = a3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), s3 = (r3 = s3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), c3 = (r3 = c3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), u3 = (r3 = u3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), d3 = (r3 = d3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), f3 = (r3 = f3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), l3 = (r3 = l3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), h3 = (r3 = h3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), p3 = (r3 = p3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), b3 = (r3 = b3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), y3 = (r3 = y3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), m3 = (r3 = m3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), g3 = (r3 = g3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), M3 = (r3 = M3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), w3 = (r3 = w3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), i3 = (r3 = (i3 += o3 - 1 + 37 * (o3 - 1)) + (o3 = 1) + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), a3 = (r3 = a3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), s3 = (r3 = s3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), c3 = (r3 = c3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), u3 = (r3 = u3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), d3 = (r3 = d3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), f3 = (r3 = f3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), l3 = (r3 = l3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), h3 = (r3 = h3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), p3 = (r3 = p3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), b3 = (r3 = b3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), y3 = (r3 = y3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), m3 = (r3 = m3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), g3 = (r3 = g3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), M3 = (r3 = M3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), w3 = (r3 = w3 + o3 + 65535) - 65536 * (o3 = Math.floor(r3 / 65536)), i3 += o3 - 1 + 37 * (o3 - 1), e4[0] = i3, e4[1] = a3, e4[2] = s3, e4[3] = c3, e4[4] = u3, e4[5] = d3, e4[6] = f3, e4[7] = l3, e4[8] = h3, e4[9] = p3, e4[10] = b3, e4[11] = y3, e4[12] = m3, e4[13] = g3, e4[14] = M3, e4[15] = w3;
    }
    function U2(e4, t4) {
      R2(e4, t4, t4);
    }
    function W2(e4, n4) {
      var r3, o3 = t3();
      for (r3 = 0; r3 < 16; r3++) o3[r3] = n4[r3];
      for (r3 = 253; r3 >= 0; r3--) U2(o3, o3), 2 !== r3 && 4 !== r3 && R2(o3, o3, n4);
      for (r3 = 0; r3 < 16; r3++) e4[r3] = o3[r3];
    }
    function Y3(e4, n4) {
      var r3, o3 = t3();
      for (r3 = 0; r3 < 16; r3++) o3[r3] = n4[r3];
      for (r3 = 250; r3 >= 0; r3--) U2(o3, o3), 1 !== r3 && R2(o3, o3, n4);
      for (r3 = 0; r3 < 16; r3++) e4[r3] = o3[r3];
    }
    function Q2(e4, n4, r3) {
      var o3, i3, a3 = new Uint8Array(32), c3 = new Float64Array(80), u3 = t3(), d3 = t3(), f3 = t3(), l3 = t3(), h3 = t3(), p3 = t3();
      for (i3 = 0; i3 < 31; i3++) a3[i3] = n4[i3];
      for (a3[31] = 127 & n4[31] | 64, a3[0] &= 248, P2(c3, r3), i3 = 0; i3 < 16; i3++) d3[i3] = c3[i3], l3[i3] = u3[i3] = f3[i3] = 0;
      for (u3[0] = l3[0] = 1, i3 = 254; i3 >= 0; --i3) D2(u3, d3, o3 = a3[i3 >>> 3] >>> (7 & i3) & 1), D2(f3, l3, o3), L2(h3, u3, f3), k2(u3, u3, f3), L2(f3, d3, l3), k2(d3, d3, l3), U2(l3, h3), U2(p3, u3), R2(u3, f3, u3), R2(f3, d3, h3), L2(h3, u3, f3), k2(u3, u3, f3), U2(d3, u3), k2(f3, l3, p3), R2(u3, f3, s2), L2(u3, u3, l3), R2(f3, f3, u3), R2(u3, l3, p3), R2(l3, d3, c3), U2(d3, h3), D2(u3, d3, o3), D2(f3, l3, o3);
      for (i3 = 0; i3 < 16; i3++) c3[i3 + 16] = u3[i3], c3[i3 + 32] = f3[i3], c3[i3 + 48] = d3[i3], c3[i3 + 64] = l3[i3];
      var b3 = c3.subarray(32), y3 = c3.subarray(16);
      return W2(b3, b3), R2(y3, y3, b3), C2(e4, y3), 0;
    }
    function B3(e4, t4) {
      return Q2(e4, t4, o2);
    }
    function J2(e4, t4) {
      return n3(t4, 32), B3(e4, t4);
    }
    function F3(e4, t4, n4) {
      var o3 = new Uint8Array(32);
      return Q2(o3, n4, t4), g2(e4, r2, o3, M2);
    }
    I2.prototype.blocks = function(e4, t4, n4) {
      for (var r3, o3, i3, a3, s3, c3, u3, d3, f3, l3, h3, p3, b3, y3, m3, g3, M3, w3, v6, N3 = this.fin ? 0 : 2048, A3 = this.h[0], I3 = this.h[1], j3 = this.h[2], x3 = this.h[3], _3 = this.h[4], E3 = this.h[5], T3 = this.h[6], O3 = this.h[7], D3 = this.h[8], C3 = this.h[9], z3 = this.r[0], S3 = this.r[1], P3 = this.r[2], L3 = this.r[3], k3 = this.r[4], R3 = this.r[5], U3 = this.r[6], W3 = this.r[7], Y4 = this.r[8], Q3 = this.r[9]; n4 >= 16; ) l3 = f3 = 0, l3 += (A3 += 8191 & (r3 = 255 & e4[t4 + 0] | (255 & e4[t4 + 1]) << 8)) * z3, l3 += (I3 += 8191 & (r3 >>> 13 | (o3 = 255 & e4[t4 + 2] | (255 & e4[t4 + 3]) << 8) << 3)) * (5 * Q3), l3 += (j3 += 8191 & (o3 >>> 10 | (i3 = 255 & e4[t4 + 4] | (255 & e4[t4 + 5]) << 8) << 6)) * (5 * Y4), l3 += (x3 += 8191 & (i3 >>> 7 | (a3 = 255 & e4[t4 + 6] | (255 & e4[t4 + 7]) << 8) << 9)) * (5 * W3), f3 = (l3 += (_3 += 8191 & (a3 >>> 4 | (s3 = 255 & e4[t4 + 8] | (255 & e4[t4 + 9]) << 8) << 12)) * (5 * U3)) >>> 13, l3 &= 8191, l3 += (E3 += s3 >>> 1 & 8191) * (5 * R3), l3 += (T3 += 8191 & (s3 >>> 14 | (c3 = 255 & e4[t4 + 10] | (255 & e4[t4 + 11]) << 8) << 2)) * (5 * k3), l3 += (O3 += 8191 & (c3 >>> 11 | (u3 = 255 & e4[t4 + 12] | (255 & e4[t4 + 13]) << 8) << 5)) * (5 * L3), l3 += (D3 += 8191 & (u3 >>> 8 | (d3 = 255 & e4[t4 + 14] | (255 & e4[t4 + 15]) << 8) << 8)) * (5 * P3), h3 = f3 += (l3 += (C3 += d3 >>> 5 | N3) * (5 * S3)) >>> 13, h3 += A3 * S3, h3 += I3 * z3, h3 += j3 * (5 * Q3), h3 += x3 * (5 * Y4), f3 = (h3 += _3 * (5 * W3)) >>> 13, h3 &= 8191, h3 += E3 * (5 * U3), h3 += T3 * (5 * R3), h3 += O3 * (5 * k3), h3 += D3 * (5 * L3), f3 += (h3 += C3 * (5 * P3)) >>> 13, h3 &= 8191, p3 = f3, p3 += A3 * P3, p3 += I3 * S3, p3 += j3 * z3, p3 += x3 * (5 * Q3), f3 = (p3 += _3 * (5 * Y4)) >>> 13, p3 &= 8191, p3 += E3 * (5 * W3), p3 += T3 * (5 * U3), p3 += O3 * (5 * R3), p3 += D3 * (5 * k3), b3 = f3 += (p3 += C3 * (5 * L3)) >>> 13, b3 += A3 * L3, b3 += I3 * P3, b3 += j3 * S3, b3 += x3 * z3, f3 = (b3 += _3 * (5 * Q3)) >>> 13, b3 &= 8191, b3 += E3 * (5 * Y4), b3 += T3 * (5 * W3), b3 += O3 * (5 * U3), b3 += D3 * (5 * R3), y3 = f3 += (b3 += C3 * (5 * k3)) >>> 13, y3 += A3 * k3, y3 += I3 * L3, y3 += j3 * P3, y3 += x3 * S3, f3 = (y3 += _3 * z3) >>> 13, y3 &= 8191, y3 += E3 * (5 * Q3), y3 += T3 * (5 * Y4), y3 += O3 * (5 * W3), y3 += D3 * (5 * U3), m3 = f3 += (y3 += C3 * (5 * R3)) >>> 13, m3 += A3 * R3, m3 += I3 * k3, m3 += j3 * L3, m3 += x3 * P3, f3 = (m3 += _3 * S3) >>> 13, m3 &= 8191, m3 += E3 * z3, m3 += T3 * (5 * Q3), m3 += O3 * (5 * Y4), m3 += D3 * (5 * W3), g3 = f3 += (m3 += C3 * (5 * U3)) >>> 13, g3 += A3 * U3, g3 += I3 * R3, g3 += j3 * k3, g3 += x3 * L3, f3 = (g3 += _3 * P3) >>> 13, g3 &= 8191, g3 += E3 * S3, g3 += T3 * z3, g3 += O3 * (5 * Q3), g3 += D3 * (5 * Y4), M3 = f3 += (g3 += C3 * (5 * W3)) >>> 13, M3 += A3 * W3, M3 += I3 * U3, M3 += j3 * R3, M3 += x3 * k3, f3 = (M3 += _3 * L3) >>> 13, M3 &= 8191, M3 += E3 * P3, M3 += T3 * S3, M3 += O3 * z3, M3 += D3 * (5 * Q3), w3 = f3 += (M3 += C3 * (5 * Y4)) >>> 13, w3 += A3 * Y4, w3 += I3 * W3, w3 += j3 * U3, w3 += x3 * R3, f3 = (w3 += _3 * k3) >>> 13, w3 &= 8191, w3 += E3 * L3, w3 += T3 * P3, w3 += O3 * S3, w3 += D3 * z3, v6 = f3 += (w3 += C3 * (5 * Q3)) >>> 13, v6 += A3 * Q3, v6 += I3 * Y4, v6 += j3 * W3, v6 += x3 * U3, f3 = (v6 += _3 * R3) >>> 13, v6 &= 8191, v6 += E3 * k3, v6 += T3 * L3, v6 += O3 * P3, v6 += D3 * S3, A3 = l3 = 8191 & (f3 = (f3 = ((f3 += (v6 += C3 * z3) >>> 13) << 2) + f3 | 0) + (l3 &= 8191) | 0), I3 = h3 += f3 >>>= 13, j3 = p3 &= 8191, x3 = b3 &= 8191, _3 = y3 &= 8191, E3 = m3 &= 8191, T3 = g3 &= 8191, O3 = M3 &= 8191, D3 = w3 &= 8191, C3 = v6 &= 8191, t4 += 16, n4 -= 16;
      this.h[0] = A3, this.h[1] = I3, this.h[2] = j3, this.h[3] = x3, this.h[4] = _3, this.h[5] = E3, this.h[6] = T3, this.h[7] = O3, this.h[8] = D3, this.h[9] = C3;
    }, I2.prototype.finish = function(e4, t4) {
      var n4, r3, o3, i3, a3 = new Uint16Array(10);
      if (this.leftover) {
        for (i3 = this.leftover, this.buffer[i3++] = 1; i3 < 16; i3++) this.buffer[i3] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (n4 = this.h[1] >>> 13, this.h[1] &= 8191, i3 = 2; i3 < 10; i3++) this.h[i3] += n4, n4 = this.h[i3] >>> 13, this.h[i3] &= 8191;
      for (this.h[0] += 5 * n4, n4 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += n4, n4 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += n4, a3[0] = this.h[0] + 5, n4 = a3[0] >>> 13, a3[0] &= 8191, i3 = 1; i3 < 10; i3++) a3[i3] = this.h[i3] + n4, n4 = a3[i3] >>> 13, a3[i3] &= 8191;
      for (a3[9] -= 8192, r3 = (1 ^ n4) - 1, i3 = 0; i3 < 10; i3++) a3[i3] &= r3;
      for (r3 = ~r3, i3 = 0; i3 < 10; i3++) this.h[i3] = this.h[i3] & r3 | a3[i3];
      for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), o3 = this.h[0] + this.pad[0], this.h[0] = 65535 & o3, i3 = 1; i3 < 8; i3++) o3 = (this.h[i3] + this.pad[i3] | 0) + (o3 >>> 16) | 0, this.h[i3] = 65535 & o3;
      e4[t4 + 0] = this.h[0] >>> 0 & 255, e4[t4 + 1] = this.h[0] >>> 8 & 255, e4[t4 + 2] = this.h[1] >>> 0 & 255, e4[t4 + 3] = this.h[1] >>> 8 & 255, e4[t4 + 4] = this.h[2] >>> 0 & 255, e4[t4 + 5] = this.h[2] >>> 8 & 255, e4[t4 + 6] = this.h[3] >>> 0 & 255, e4[t4 + 7] = this.h[3] >>> 8 & 255, e4[t4 + 8] = this.h[4] >>> 0 & 255, e4[t4 + 9] = this.h[4] >>> 8 & 255, e4[t4 + 10] = this.h[5] >>> 0 & 255, e4[t4 + 11] = this.h[5] >>> 8 & 255, e4[t4 + 12] = this.h[6] >>> 0 & 255, e4[t4 + 13] = this.h[6] >>> 8 & 255, e4[t4 + 14] = this.h[7] >>> 0 & 255, e4[t4 + 15] = this.h[7] >>> 8 & 255;
    }, I2.prototype.update = function(e4, t4, n4) {
      var r3, o3;
      if (this.leftover) {
        for ((o3 = 16 - this.leftover) > n4 && (o3 = n4), r3 = 0; r3 < o3; r3++) this.buffer[this.leftover + r3] = e4[t4 + r3];
        if (n4 -= o3, t4 += o3, this.leftover += o3, this.leftover < 16) return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (n4 >= 16 && (o3 = n4 - n4 % 16, this.blocks(e4, t4, o3), t4 += o3, n4 -= o3), n4) {
        for (r3 = 0; r3 < n4; r3++) this.buffer[this.leftover + r3] = e4[t4 + r3];
        this.leftover += n4;
      }
    };
    var G3 = _2, Z3 = E2;
    var V2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function X2(e4, t4, n4, r3) {
      for (var o3, i3, a3, s3, c3, u3, d3, f3, l3, h3, p3, b3, y3, m3, g3, M3, w3, v6, N3, A3, I3, j3, x3, _3, E3, T3, O3 = new Int32Array(16), D3 = new Int32Array(16), C3 = e4[0], z3 = e4[1], S3 = e4[2], P3 = e4[3], L3 = e4[4], k3 = e4[5], R3 = e4[6], U3 = e4[7], W3 = t4[0], Y4 = t4[1], Q3 = t4[2], B4 = t4[3], J3 = t4[4], F4 = t4[5], G4 = t4[6], q3 = t4[7], Z4 = 0; r3 >= 128; ) {
        for (N3 = 0; N3 < 16; N3++) A3 = 8 * N3 + Z4, O3[N3] = n4[A3 + 0] << 24 | n4[A3 + 1] << 16 | n4[A3 + 2] << 8 | n4[A3 + 3], D3[N3] = n4[A3 + 4] << 24 | n4[A3 + 5] << 16 | n4[A3 + 6] << 8 | n4[A3 + 7];
        for (N3 = 0; N3 < 80; N3++) if (o3 = C3, i3 = z3, a3 = S3, s3 = P3, c3 = L3, u3 = k3, d3 = R3, l3 = W3, h3 = Y4, p3 = Q3, b3 = B4, y3 = J3, m3 = F4, g3 = G4, x3 = 65535 & (j3 = q3), _3 = j3 >>> 16, E3 = 65535 & (I3 = U3), T3 = I3 >>> 16, x3 += 65535 & (j3 = (J3 >>> 14 | L3 << 18) ^ (J3 >>> 18 | L3 << 14) ^ (L3 >>> 9 | J3 << 23)), _3 += j3 >>> 16, E3 += 65535 & (I3 = (L3 >>> 14 | J3 << 18) ^ (L3 >>> 18 | J3 << 14) ^ (J3 >>> 9 | L3 << 23)), T3 += I3 >>> 16, x3 += 65535 & (j3 = J3 & F4 ^ ~J3 & G4), _3 += j3 >>> 16, E3 += 65535 & (I3 = L3 & k3 ^ ~L3 & R3), T3 += I3 >>> 16, I3 = V2[2 * N3], x3 += 65535 & (j3 = V2[2 * N3 + 1]), _3 += j3 >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, I3 = O3[N3 % 16], _3 += (j3 = D3[N3 % 16]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16, x3 = 65535 & (j3 = v6 = 65535 & x3 | _3 << 16), _3 = j3 >>> 16, E3 = 65535 & (I3 = w3 = 65535 & E3 | (T3 += E3 >>> 16) << 16), T3 = I3 >>> 16, x3 += 65535 & (j3 = (W3 >>> 28 | C3 << 4) ^ (C3 >>> 2 | W3 << 30) ^ (C3 >>> 7 | W3 << 25)), _3 += j3 >>> 16, E3 += 65535 & (I3 = (C3 >>> 28 | W3 << 4) ^ (W3 >>> 2 | C3 << 30) ^ (W3 >>> 7 | C3 << 25)), T3 += I3 >>> 16, _3 += (j3 = W3 & Y4 ^ W3 & Q3 ^ Y4 & Q3) >>> 16, E3 += 65535 & (I3 = C3 & z3 ^ C3 & S3 ^ z3 & S3), T3 += I3 >>> 16, f3 = 65535 & (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) | (T3 += E3 >>> 16) << 16, M3 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = b3), _3 = j3 >>> 16, E3 = 65535 & (I3 = s3), T3 = I3 >>> 16, _3 += (j3 = v6) >>> 16, E3 += 65535 & (I3 = w3), T3 += I3 >>> 16, z3 = o3, S3 = i3, P3 = a3, L3 = s3 = 65535 & (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) | (T3 += E3 >>> 16) << 16, k3 = c3, R3 = u3, U3 = d3, C3 = f3, Y4 = l3, Q3 = h3, B4 = p3, J3 = b3 = 65535 & x3 | _3 << 16, F4 = y3, G4 = m3, q3 = g3, W3 = M3, N3 % 16 == 15) for (A3 = 0; A3 < 16; A3++) I3 = O3[A3], x3 = 65535 & (j3 = D3[A3]), _3 = j3 >>> 16, E3 = 65535 & I3, T3 = I3 >>> 16, I3 = O3[(A3 + 9) % 16], x3 += 65535 & (j3 = D3[(A3 + 9) % 16]), _3 += j3 >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, w3 = O3[(A3 + 1) % 16], x3 += 65535 & (j3 = ((v6 = D3[(A3 + 1) % 16]) >>> 1 | w3 << 31) ^ (v6 >>> 8 | w3 << 24) ^ (v6 >>> 7 | w3 << 25)), _3 += j3 >>> 16, E3 += 65535 & (I3 = (w3 >>> 1 | v6 << 31) ^ (w3 >>> 8 | v6 << 24) ^ w3 >>> 7), T3 += I3 >>> 16, w3 = O3[(A3 + 14) % 16], _3 += (j3 = ((v6 = D3[(A3 + 14) % 16]) >>> 19 | w3 << 13) ^ (w3 >>> 29 | v6 << 3) ^ (v6 >>> 6 | w3 << 26)) >>> 16, E3 += 65535 & (I3 = (w3 >>> 19 | v6 << 13) ^ (v6 >>> 29 | w3 << 3) ^ w3 >>> 6), T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, O3[A3] = 65535 & E3 | T3 << 16, D3[A3] = 65535 & x3 | _3 << 16;
        x3 = 65535 & (j3 = W3), _3 = j3 >>> 16, E3 = 65535 & (I3 = C3), T3 = I3 >>> 16, I3 = e4[0], _3 += (j3 = t4[0]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[0] = C3 = 65535 & E3 | T3 << 16, t4[0] = W3 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = Y4), _3 = j3 >>> 16, E3 = 65535 & (I3 = z3), T3 = I3 >>> 16, I3 = e4[1], _3 += (j3 = t4[1]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[1] = z3 = 65535 & E3 | T3 << 16, t4[1] = Y4 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = Q3), _3 = j3 >>> 16, E3 = 65535 & (I3 = S3), T3 = I3 >>> 16, I3 = e4[2], _3 += (j3 = t4[2]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[2] = S3 = 65535 & E3 | T3 << 16, t4[2] = Q3 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = B4), _3 = j3 >>> 16, E3 = 65535 & (I3 = P3), T3 = I3 >>> 16, I3 = e4[3], _3 += (j3 = t4[3]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[3] = P3 = 65535 & E3 | T3 << 16, t4[3] = B4 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = J3), _3 = j3 >>> 16, E3 = 65535 & (I3 = L3), T3 = I3 >>> 16, I3 = e4[4], _3 += (j3 = t4[4]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[4] = L3 = 65535 & E3 | T3 << 16, t4[4] = J3 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = F4), _3 = j3 >>> 16, E3 = 65535 & (I3 = k3), T3 = I3 >>> 16, I3 = e4[5], _3 += (j3 = t4[5]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[5] = k3 = 65535 & E3 | T3 << 16, t4[5] = F4 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = G4), _3 = j3 >>> 16, E3 = 65535 & (I3 = R3), T3 = I3 >>> 16, I3 = e4[6], _3 += (j3 = t4[6]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[6] = R3 = 65535 & E3 | T3 << 16, t4[6] = G4 = 65535 & x3 | _3 << 16, x3 = 65535 & (j3 = q3), _3 = j3 >>> 16, E3 = 65535 & (I3 = U3), T3 = I3 >>> 16, I3 = e4[7], _3 += (j3 = t4[7]) >>> 16, E3 += 65535 & I3, T3 += I3 >>> 16, T3 += (E3 += (_3 += (x3 += 65535 & j3) >>> 16) >>> 16) >>> 16, e4[7] = U3 = 65535 & E3 | T3 << 16, t4[7] = q3 = 65535 & x3 | _3 << 16, Z4 += 128, r3 -= 128;
      }
      return r3;
    }
    function K3(e4, t4, n4) {
      var r3, o3 = new Int32Array(8), i3 = new Int32Array(8), a3 = new Uint8Array(256), s3 = n4;
      for (o3[0] = 1779033703, o3[1] = 3144134277, o3[2] = 1013904242, o3[3] = 2773480762, o3[4] = 1359893119, o3[5] = 2600822924, o3[6] = 528734635, o3[7] = 1541459225, i3[0] = 4089235720, i3[1] = 2227873595, i3[2] = 4271175723, i3[3] = 1595750129, i3[4] = 2917565137, i3[5] = 725511199, i3[6] = 4215389547, i3[7] = 327033209, X2(o3, i3, t4, n4), n4 %= 128, r3 = 0; r3 < n4; r3++) a3[r3] = t4[s3 - n4 + r3];
      for (a3[n4] = 128, a3[(n4 = 256 - 128 * (n4 < 112 ? 1 : 0)) - 9] = 0, h2(a3, n4 - 8, s3 / 536870912 | 0, s3 << 3), X2(o3, i3, a3, n4), r3 = 0; r3 < 8; r3++) h2(e4, 8 * r3, o3[r3], i3[r3]);
      return 0;
    }
    function H2(e4, n4) {
      var r3 = t3(), o3 = t3(), i3 = t3(), a3 = t3(), s3 = t3(), c3 = t3(), d3 = t3(), f3 = t3(), l3 = t3();
      k2(r3, e4[1], e4[0]), k2(l3, n4[1], n4[0]), R2(r3, r3, l3), L2(o3, e4[0], e4[1]), L2(l3, n4[0], n4[1]), R2(o3, o3, l3), R2(i3, e4[3], n4[3]), R2(i3, i3, u2), R2(a3, e4[2], n4[2]), L2(a3, a3, a3), k2(s3, o3, r3), k2(c3, a3, i3), L2(d3, a3, i3), L2(f3, o3, r3), R2(e4[0], s3, c3), R2(e4[1], f3, d3), R2(e4[2], d3, c3), R2(e4[3], s3, f3);
    }
    function $2(e4, t4, n4) {
      var r3;
      for (r3 = 0; r3 < 4; r3++) D2(e4[r3], t4[r3], n4);
    }
    function ee2(e4, n4) {
      var r3 = t3(), o3 = t3(), i3 = t3();
      W2(i3, n4[2]), R2(r3, n4[0], i3), R2(o3, n4[1], i3), C2(e4, o3), e4[31] ^= S2(r3) << 7;
    }
    function te2(e4, t4, n4) {
      var r3, o3;
      for (T2(e4[0], i2), T2(e4[1], a2), T2(e4[2], a2), T2(e4[3], i2), o3 = 255; o3 >= 0; --o3) $2(e4, t4, r3 = n4[o3 / 8 | 0] >> (7 & o3) & 1), H2(t4, e4), H2(e4, e4), $2(e4, t4, r3);
    }
    function ne2(e4, n4) {
      var r3 = [t3(), t3(), t3(), t3()];
      T2(r3[0], d2), T2(r3[1], f2), T2(r3[2], a2), R2(r3[3], d2, f2), te2(e4, r3, n4);
    }
    function re2(e4, r3, o3) {
      var i3, a3 = new Uint8Array(64), s3 = [t3(), t3(), t3(), t3()];
      for (o3 || n3(r3, 32), K3(a3, r3, 32), a3[0] &= 248, a3[31] &= 127, a3[31] |= 64, ne2(s3, a3), ee2(e4, s3), i3 = 0; i3 < 32; i3++) r3[i3 + 32] = e4[i3];
      return 0;
    }
    var oe2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function ie2(e4, t4) {
      var n4, r3, o3, i3;
      for (r3 = 63; r3 >= 32; --r3) {
        for (n4 = 0, o3 = r3 - 32, i3 = r3 - 12; o3 < i3; ++o3) t4[o3] += n4 - 16 * t4[r3] * oe2[o3 - (r3 - 32)], n4 = Math.floor((t4[o3] + 128) / 256), t4[o3] -= 256 * n4;
        t4[o3] += n4, t4[r3] = 0;
      }
      for (n4 = 0, o3 = 0; o3 < 32; o3++) t4[o3] += n4 - (t4[31] >> 4) * oe2[o3], n4 = t4[o3] >> 8, t4[o3] &= 255;
      for (o3 = 0; o3 < 32; o3++) t4[o3] -= n4 * oe2[o3];
      for (r3 = 0; r3 < 32; r3++) t4[r3 + 1] += t4[r3] >> 8, e4[r3] = 255 & t4[r3];
    }
    function ae2(e4) {
      var t4, n4 = new Float64Array(64);
      for (t4 = 0; t4 < 64; t4++) n4[t4] = e4[t4];
      for (t4 = 0; t4 < 64; t4++) e4[t4] = 0;
      ie2(e4, n4);
    }
    function se2(e4, n4, r3, o3) {
      var i3, a3, s3 = new Uint8Array(64), c3 = new Uint8Array(64), u3 = new Uint8Array(64), d3 = new Float64Array(64), f3 = [t3(), t3(), t3(), t3()];
      K3(s3, o3, 32), s3[0] &= 248, s3[31] &= 127, s3[31] |= 64;
      var l3 = r3 + 64;
      for (i3 = 0; i3 < r3; i3++) e4[64 + i3] = n4[i3];
      for (i3 = 0; i3 < 32; i3++) e4[32 + i3] = s3[32 + i3];
      for (K3(u3, e4.subarray(32), r3 + 32), ae2(u3), ne2(f3, u3), ee2(e4, f3), i3 = 32; i3 < 64; i3++) e4[i3] = o3[i3];
      for (K3(c3, e4, r3 + 64), ae2(c3), i3 = 0; i3 < 64; i3++) d3[i3] = 0;
      for (i3 = 0; i3 < 32; i3++) d3[i3] = u3[i3];
      for (i3 = 0; i3 < 32; i3++) for (a3 = 0; a3 < 32; a3++) d3[i3 + a3] += c3[i3] * s3[a3];
      return ie2(e4.subarray(32), d3), l3;
    }
    function ce2(e4, n4, r3, o3) {
      var s3, u3 = new Uint8Array(32), d3 = new Uint8Array(64), f3 = [t3(), t3(), t3(), t3()], h3 = [t3(), t3(), t3(), t3()];
      if (r3 < 64) return -1;
      if (function(e5, n5) {
        var r4 = t3(), o4 = t3(), s4 = t3(), u4 = t3(), d4 = t3(), f4 = t3(), h4 = t3();
        return T2(e5[2], a2), P2(e5[1], n5), U2(s4, e5[1]), R2(u4, s4, c2), k2(s4, s4, e5[2]), L2(u4, e5[2], u4), U2(d4, u4), U2(f4, d4), R2(h4, f4, d4), R2(r4, h4, s4), R2(r4, r4, u4), Y3(r4, r4), R2(r4, r4, s4), R2(r4, r4, u4), R2(r4, r4, u4), R2(e5[0], r4, u4), U2(o4, e5[0]), R2(o4, o4, u4), z2(o4, s4) && R2(e5[0], e5[0], l2), U2(o4, e5[0]), R2(o4, o4, u4), z2(o4, s4) ? -1 : (S2(e5[0]) === n5[31] >> 7 && k2(e5[0], i2, e5[0]), R2(e5[3], e5[0], e5[1]), 0);
      }(h3, o3)) return -1;
      for (s3 = 0; s3 < r3; s3++) e4[s3] = n4[s3];
      for (s3 = 0; s3 < 32; s3++) e4[s3 + 32] = o3[s3];
      if (K3(d3, e4, r3), ae2(d3), te2(f3, h3, d3), ne2(h3, n4.subarray(32)), H2(f3, h3), ee2(u3, f3), r3 -= 64, y2(n4, 0, u3, 0)) {
        for (s3 = 0; s3 < r3; s3++) e4[s3] = 0;
        return -1;
      }
      for (s3 = 0; s3 < r3; s3++) e4[s3] = n4[s3 + 64];
      return r3;
    }
    var ue2 = 16, de2 = 64, fe2 = 32, le2 = 64;
    function he2(e4, t4) {
      if (32 !== e4.length) throw new Error("bad key size");
      if (24 !== t4.length) throw new Error("bad nonce size");
    }
    function pe2() {
      for (var e4 = 0; e4 < arguments.length; e4++) if (!(arguments[e4] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
    }
    function be2(e4) {
      for (var t4 = 0; t4 < e4.length; t4++) e4[t4] = 0;
    }
    e3.lowlevel = { crypto_core_hsalsa20: g2, crypto_stream_xor: A2, crypto_stream: N2, crypto_stream_salsa20_xor: w2, crypto_stream_salsa20: v2, crypto_onetimeauth: j2, crypto_onetimeauth_verify: x2, crypto_verify_16: b2, crypto_verify_32: y2, crypto_secretbox: _2, crypto_secretbox_open: E2, crypto_scalarmult: Q2, crypto_scalarmult_base: B3, crypto_box_beforenm: F3, crypto_box_afternm: G3, crypto_box: function(e4, t4, n4, r3, o3, i3) {
      var a3 = new Uint8Array(32);
      return F3(a3, o3, i3), G3(e4, t4, n4, r3, a3);
    }, crypto_box_open: function(e4, t4, n4, r3, o3, i3) {
      var a3 = new Uint8Array(32);
      return F3(a3, o3, i3), Z3(e4, t4, n4, r3, a3);
    }, crypto_box_keypair: J2, crypto_hash: K3, crypto_sign: se2, crypto_sign_keypair: re2, crypto_sign_open: ce2, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: ue2, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: de2, crypto_sign_PUBLICKEYBYTES: fe2, crypto_sign_SECRETKEYBYTES: le2, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: t3, D: c2, L: oe2, pack25519: C2, unpack25519: P2, M: R2, A: L2, S: U2, Z: k2, pow2523: Y3, add: H2, set25519: T2, modL: ie2, scalarmult: te2, scalarbase: ne2 }, e3.randomBytes = function(e4) {
      var t4 = new Uint8Array(e4);
      return n3(t4, e4), t4;
    }, e3.secretbox = function(e4, t4, n4) {
      pe2(e4, t4, n4), he2(n4, t4);
      for (var r3 = new Uint8Array(32 + e4.length), o3 = new Uint8Array(r3.length), i3 = 0; i3 < e4.length; i3++) r3[i3 + 32] = e4[i3];
      return _2(o3, r3, r3.length, t4, n4), o3.subarray(ue2);
    }, e3.secretbox.open = function(e4, t4, n4) {
      pe2(e4, t4, n4), he2(n4, t4);
      for (var r3 = new Uint8Array(ue2 + e4.length), o3 = new Uint8Array(r3.length), i3 = 0; i3 < e4.length; i3++) r3[i3 + ue2] = e4[i3];
      return r3.length < 32 || 0 !== E2(o3, r3, r3.length, t4, n4) ? null : o3.subarray(32);
    }, e3.secretbox.keyLength = 32, e3.secretbox.nonceLength = 24, e3.secretbox.overheadLength = ue2, e3.scalarMult = function(e4, t4) {
      if (pe2(e4, t4), 32 !== e4.length) throw new Error("bad n size");
      if (32 !== t4.length) throw new Error("bad p size");
      var n4 = new Uint8Array(32);
      return Q2(n4, e4, t4), n4;
    }, e3.scalarMult.base = function(e4) {
      if (pe2(e4), 32 !== e4.length) throw new Error("bad n size");
      var t4 = new Uint8Array(32);
      return B3(t4, e4), t4;
    }, e3.scalarMult.scalarLength = 32, e3.scalarMult.groupElementLength = 32, e3.box = function(t4, n4, r3, o3) {
      var i3 = e3.box.before(r3, o3);
      return e3.secretbox(t4, n4, i3);
    }, e3.box.before = function(e4, t4) {
      pe2(e4, t4), function(e5, t5) {
        if (32 !== e5.length) throw new Error("bad public key size");
        if (32 !== t5.length) throw new Error("bad secret key size");
      }(e4, t4);
      var n4 = new Uint8Array(32);
      return F3(n4, e4, t4), n4;
    }, e3.box.after = e3.secretbox, e3.box.open = function(t4, n4, r3, o3) {
      var i3 = e3.box.before(r3, o3);
      return e3.secretbox.open(t4, n4, i3);
    }, e3.box.open.after = e3.secretbox.open, e3.box.keyPair = function() {
      var e4 = new Uint8Array(32), t4 = new Uint8Array(32);
      return J2(e4, t4), { publicKey: e4, secretKey: t4 };
    }, e3.box.keyPair.fromSecretKey = function(e4) {
      if (pe2(e4), 32 !== e4.length) throw new Error("bad secret key size");
      var t4 = new Uint8Array(32);
      return B3(t4, e4), { publicKey: t4, secretKey: new Uint8Array(e4) };
    }, e3.box.publicKeyLength = 32, e3.box.secretKeyLength = 32, e3.box.sharedKeyLength = 32, e3.box.nonceLength = 24, e3.box.overheadLength = e3.secretbox.overheadLength, e3.sign = function(e4, t4) {
      if (pe2(e4, t4), t4.length !== le2) throw new Error("bad secret key size");
      var n4 = new Uint8Array(de2 + e4.length);
      return se2(n4, e4, e4.length, t4), n4;
    }, e3.sign.open = function(e4, t4) {
      if (pe2(e4, t4), t4.length !== fe2) throw new Error("bad public key size");
      var n4 = new Uint8Array(e4.length), r3 = ce2(n4, e4, e4.length, t4);
      if (r3 < 0) return null;
      for (var o3 = new Uint8Array(r3), i3 = 0; i3 < o3.length; i3++) o3[i3] = n4[i3];
      return o3;
    }, e3.sign.detached = function(t4, n4) {
      for (var r3 = e3.sign(t4, n4), o3 = new Uint8Array(de2), i3 = 0; i3 < o3.length; i3++) o3[i3] = r3[i3];
      return o3;
    }, e3.sign.detached.verify = function(e4, t4, n4) {
      if (pe2(e4, t4, n4), t4.length !== de2) throw new Error("bad signature size");
      if (n4.length !== fe2) throw new Error("bad public key size");
      var r3, o3 = new Uint8Array(de2 + e4.length), i3 = new Uint8Array(de2 + e4.length);
      for (r3 = 0; r3 < de2; r3++) o3[r3] = t4[r3];
      for (r3 = 0; r3 < e4.length; r3++) o3[r3 + de2] = e4[r3];
      return ce2(i3, o3, o3.length, n4) >= 0;
    }, e3.sign.keyPair = function() {
      var e4 = new Uint8Array(fe2), t4 = new Uint8Array(le2);
      return re2(e4, t4), { publicKey: e4, secretKey: t4 };
    }, e3.sign.keyPair.fromSecretKey = function(e4) {
      if (pe2(e4), e4.length !== le2) throw new Error("bad secret key size");
      for (var t4 = new Uint8Array(fe2), n4 = 0; n4 < t4.length; n4++) t4[n4] = e4[32 + n4];
      return { publicKey: t4, secretKey: new Uint8Array(e4) };
    }, e3.sign.keyPair.fromSeed = function(e4) {
      if (pe2(e4), 32 !== e4.length) throw new Error("bad seed size");
      for (var t4 = new Uint8Array(fe2), n4 = new Uint8Array(le2), r3 = 0; r3 < 32; r3++) n4[r3] = e4[r3];
      return re2(t4, n4, true), { publicKey: t4, secretKey: n4 };
    }, e3.sign.publicKeyLength = fe2, e3.sign.secretKeyLength = le2, e3.sign.seedLength = 32, e3.sign.signatureLength = de2, e3.hash = function(e4) {
      pe2(e4);
      var t4 = new Uint8Array(64);
      return K3(t4, e4, e4.length), t4;
    }, e3.hash.hashLength = 64, e3.verify = function(e4, t4) {
      return pe2(e4, t4), 0 !== e4.length && 0 !== t4.length && (e4.length === t4.length && 0 === p2(e4, 0, t4, 0, e4.length));
    }, e3.setPRNG = function(e4) {
      n3 = e4;
    }, function() {
      var t4 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
      if (t4 && t4.getRandomValues) {
        e3.setPRNG(function(e4, n4) {
          var r3, o3 = new Uint8Array(n4);
          for (r3 = 0; r3 < n4; r3 += 65536) t4.getRandomValues(o3.subarray(r3, r3 + Math.min(n4 - r3, 65536)));
          for (r3 = 0; r3 < n4; r3++) e4[r3] = o3[r3];
          be2(o3);
        });
      } else void 0 !== q2 && (t4 = q2("crypto")) && t4.randomBytes && e3.setPRNG(function(e4, n4) {
        var r3, o3 = t4.randomBytes(n4);
        for (r3 = 0; r3 < n4; r3++) e4[r3] = o3[r3];
        be2(o3);
      });
    }();
  }(void 0 !== t2 && t2.exports ? t2.exports : self.nacl = self.nacl || {});
} });
X(), X(), X(), X(), X();
X(), X();
X(), X();
var Yt = ((e2) => (e2.DEFAULT = "message", e2.CLIENT_DISCONNECTED = "[CLIENT_DISCONNECTED]", e2.CLIENT_CONNECTED = "[CONNECTED]", e2.TX_PENDING = "[TX_EVENT_REQUESTED]", e2.TX_CONFIRMED = "[TX_EVENT_CONFIRMED]", e2.TX_TIMEOUT = "[TX_EVENT_TIMEOUT]", e2.AUTH_CONFIRMED = "[AUTH_CONFIRMED]", e2))(Yt || {});
X();
X(), X(), X();
var Gt = class {
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  async setItem(e2, t2) {
    this.storage.set(e2, t2);
  }
  async getItem(e2) {
    const t2 = this.storage.get(e2);
    return void 0 !== t2 ? t2 : null;
  }
  async removeItem(e2) {
    this.storage.delete(e2);
  }
  async clear() {
    this.storage.clear();
  }
};
X();
var qt = "burner-wallet-private-key", Zt2 = "burner-wallet-status", Vt = class extends FuelConnector {
  constructor(e2 = {}) {
    super(), this.name = "Burner Wallet", this.connected = false, this.installed = true, this.events = FuelConnectorEventTypes, this.metadata = { image: "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0Ny41IDQ3LjUiPjxkZWZzPjxjbGlwUGF0aCBpZD0iYSI+PHBhdGggZD0iTTAgMzhoMzhWMEgwdjM4WiIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSJiIj48cGF0aCBkPSJNMTguNTgzIDI3LjgzM2MtMi45NTctLjIzMS01LjY2NiAyLjU0Mi00LjY2NiA3LjA0Mi0zLjIzOS0yLjM4Ni0zLjMzMi02LjQwMy0yLjMzMy05IDEuMDQxLTIuNzA4LS4wNDItNC45NTgtMi41ODQtNS4yMDgtMi44MzktLjI4LTQuNDE2IDMuMDQyLTIuOTYyIDguMzMzQTE2LjkzNiAxNi45MzYgMCAwIDEgMiAxOEMyIDguNjExIDkuNjExIDEgMTkgMXMxNyA3LjYxMSAxNyAxN2MwIDIuMDYzLS4zNjcgNC4wMzktMS4wNCA1Ljg2OC0uNDYtNS4zODgtMy4zMzMtOC4xNTctNi4zMzUtNi44NjgtMi44MTIgMS4yMDgtLjkxNyA1LjkxNy0uNzc3IDguMTY0LjIzNiAzLjgwOS0uMDEyIDguMTY5LTYuOTMxIDExLjc5NCAyLjg3NS01LjQ5OS4zMzMtOC45MTctMi4zMzQtOS4xMjUiLz48L2NsaXBQYXRoPjwvZGVmcz48ZyBjbGlwLXBhdGg9InVybCgjYSkiIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUgMCAwIC0xLjI1IDAgNDcuNSkiPjxwYXRoIGZpbGw9IiNmNDkwMGMiIGQ9Ik0zNiAxOGMwIDIuMDYzLS4zNjcgNC4wMzktMS4wNCA1Ljg2OC0uNDYtNS4zODktMy4zMzMtOC4xNTctNi4zMzUtNi44NjgtMi44MTMgMS4yMDgtLjkxNyA1LjkxNy0uNzc3IDguMTY0LjIzNiAzLjgwOS0uMDEyIDguMTY5LTYuOTMxIDExLjc5NCAyLjg3NS01LjUuMzMzLTguOTE2LTIuMzM0LTkuMTI1LTIuOTU4LS4yMy01LjY2NiAyLjU0Mi00LjY2NiA3LjA0Mi0zLjIzOC0yLjM4Ni0zLjMzMy02LjQwMi0yLjMzNC05IDEuMDQyLTIuNzA4LS4wNDEtNC45NTgtMi41ODMtNS4yMDgtMi44MzktLjI4LTQuNDE3IDMuMDQxLTIuOTYyIDguMzMzQTE2LjkzNiAxNi45MzYgMCAwIDEgMiAxOEMyIDguNjExIDkuNjExIDEgMTkgMXMxNyA3LjYxMSAxNyAxNyIvPjwvZz48ZyBjbGlwLXBhdGg9InVybCgjYikiIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUgMCAwIC0xLjI1IDAgNDcuNSkiPjxwYXRoIGZpbGw9IiNmZmNjNGQiIGQ9Ik0zMSA3YzAgMi4xODctLjU4NCA0LjIzNi0xLjYwNSA2LjAwMS4xNDctMy4wODQtMi41NjItNC4yOTMtNC4wMi0zLjcwOS0yLjEwNS44NDMtMS41NDEgMi4yOTEtMi4wODMgNS4yOTEtLjU0MiAzLTIuNjI1IDUuMDg0LTUuNzA5IDYgMi4yNS02LjMzMy0xLjI0Ny04LjY2Ny0zLjA4LTkuMDg0LTEuODcyLS40MjYtMy43NTMuMDAxLTMuOTY4IDQuMDA3QTExLjk2NyAxMS45NjcgMCAwIDEgNyA3QzcgLjM3MyAxMi4zNzMtNSAxOS01UzMxIC4zNzMgMzEgNyIvPjwvZz48L3N2Zz4=", install: { action: "", description: "Burner Wallet to connect to Fuel", link: "" } }, this.burnerWallet = null, this.fuelProvider = null, this.config = {}, this.storage = this.getStorage(e2.storage), this.configProvider(e2);
  }
  configProvider(e2 = {}) {
    this.config = Object.assign(e2, { fuelProvider: e2.fuelProvider || Provider.create("https://testnet.fuel.network/v1/graphql") });
  }
  async getProvider() {
    if (!this.config.fuelProvider) throw new Error("Fuel provider not found");
    return this.fuelProvider || (this.fuelProvider = await this.config.fuelProvider), { fuelProvider: this.fuelProvider };
  }
  async generatePrivateKey() {
    const { privateKey: e2 } = Wallet.generate();
    return await this.storage.setItem(qt, e2), e2;
  }
  async getPrivateKey() {
    return await this.storage.getItem(qt) || null;
  }
  async getStatus() {
    return await this.storage.getItem(Zt2) || null;
  }
  async setupBurnerWallet(e2 = false) {
    if (this.burnerWallet) return;
    let t2 = await this.getPrivateKey();
    if (!e2 || t2 && window.confirm("We detected a previous Burner Wallet session. Do you want to continue using the same wallet?") || (t2 = await this.generatePrivateKey()), !t2) return;
    const { fuelProvider: n3 } = await this.getProvider();
    return this.burnerWallet = Wallet.fromPrivateKey(t2, n3), this.burnerWallet;
  }
  getStorage(e2) {
    return e2 || ("undefined" == typeof window ? new Gt() : window.localStorage);
  }
  async ping() {
    return true;
  }
  async version() {
    return { app: "0.0.0", network: "0.0.0" };
  }
  async isConnected() {
    try {
      return "connected" === await this.getStatus() && (await this.setupBurnerWallet(), !!this.burnerWallet);
    } catch {
      return false;
    }
  }
  async connect() {
    var _a2;
    try {
      await Promise.all([this.setupBurnerWallet(true), this.storage.setItem(Zt2, "connected")]);
      const e2 = (_a2 = this.burnerWallet) == null ? void 0 : _a2.address.toAddress();
      return this.emit(this.events.connection, true), this.emit(this.events.currentAccount, e2), this.emit(this.events.accounts, [e2]), true;
    } catch {
      return false;
    }
  }
  async accounts() {
    if (!this.burnerWallet) throw Error("Wallet not connected");
    const e2 = this.burnerWallet.address.toAddress();
    return e2 ? [e2] : [];
  }
  async disconnect() {
    return await this.storage.setItem(Zt2, "disconnected"), this.burnerWallet = null, this.emit(this.events.connection, false), this.emit(this.events.currentAccount, null), this.emit(this.events.accounts, []), false;
  }
  async signMessage(e2, t2) {
    if (!this.burnerWallet) throw Error("Wallet not connected");
    if (e2 !== this.burnerWallet.address.toString()) throw Error("Address not found for the connector");
    return await this.burnerWallet.signMessage(t2);
  }
  async sendTransaction(e2, t2) {
    if (!this.burnerWallet) throw Error("Wallet not connected");
    if (e2 !== this.burnerWallet.address.toString()) throw Error("Address not found for the connector");
    return (await this.burnerWallet.sendTransaction(t2)).id;
  }
  async currentAccount() {
    if (!this.burnerWallet) throw Error("Wallet not connected");
    return this.burnerWallet.address.toB256() || null;
  }
  async addAssets(e2) {
    throw new Error("Method not implemented.");
  }
  async addAsset(e2) {
    throw new Error("Method not implemented.");
  }
  async assets() {
    return [];
  }
  async addNetwork(e2) {
    throw new Error("Method not implemented.");
  }
  async selectNetwork(e2) {
    throw new Error("Method not implemented.");
  }
  async networks() {
    return [await this.currentNetwork()];
  }
  async currentNetwork() {
    const { fuelProvider: e2 } = await this.getProvider();
    return { chainId: e2.getChainId(), url: e2.url ?? "" };
  }
  async addAbi(e2) {
    throw new Error("Method not implemented.");
  }
  async getAbi(e2) {
    throw Error("Method not implemented.");
  }
  async hasAbi(e2) {
    throw Error("Method not implemented.");
  }
};
X(), X(), X(), X(), X();
var Xt = "FuelConnectorScript", Kt = "FuelContentScript", Ht = "message";
X();
var $t2 = V(re());
X();
var en = ((e2) => (e2.ping = "ping", e2.uiEvent = "uiEvent", e2.event = "event", e2.request = "request", e2.response = "response", e2.removeConnection = "removeConnection", e2))(en || {}), tn = class extends FuelConnector {
  constructor(e2 = "Fuel Wallet") {
    super(), this.name = "", this.connected = false, this.installed = false, this.events = FuelConnectorEventTypes, this.metadata = { image: "/connectors/fuel-wallet.svg", install: { action: "Install", description: "To connect your Fuel Wallet, install the browser extension.", link: "https://chrome.google.com/webstore/detail/fuel-wallet/dldjpboieedgcmpkchcjcbijingjcgok" } }, this.onMessage = (e3) => {
      const t2 = Object.freeze(e3);
      if (!this.acceptMessage(t2)) return;
      const { data: n3 } = t2;
      this.onCommunicationMessage(n3);
    }, this.onCommunicationMessage = (e3) => {
      switch (e3.type) {
        case "response":
          this.onResponse(e3);
          break;
        case "event":
          this.onEvent(e3);
      }
    }, this.name = e2, this.setMaxListeners(100), this.client = new $t2.JSONRPCClient(this.sendRequest.bind(this), this.createRequestId), this.setupListener(), this.setupConnector();
  }
  async setupConnector() {
    "undefined" != typeof window && this.ping().then(() => {
      window.dispatchEvent(new CustomEvent(FuelConnectorEventType, { detail: this }));
    }).catch(() => {
    });
  }
  acceptMessage(e2) {
    const { data: t2 } = e2;
    return e2.origin === window.origin && "request" !== t2.type && t2.connectorName === this.name && t2.target === Xt;
  }
  setupListener() {
    "undefined" != typeof window && window.addEventListener(Ht, this.onMessage.bind(this));
  }
  createRequestId() {
    return crypto.randomUUID();
  }
  postMessage(e2, t2) {
    window.postMessage(e2, t2 || window.origin);
  }
  async sendRequest(e2) {
    e2 && this.postMessage({ type: "request", target: Kt, connectorName: this.name, request: e2 });
  }
  onResponse(e2) {
    this.client.receive(e2.response);
  }
  onEvent(e2) {
    e2.events.forEach((e3) => {
      "start" === e3.event ? this.setupConnector() : this.emit(e3.event, ...e3.params);
    });
  }
  async ping() {
    return this.client.timeout(800).request("ping", {});
  }
  async isConnected() {
    try {
      return await this.client.request("isConnected", {});
    } catch {
      return false;
    }
  }
  async connect() {
    return this.client.request("connect", {});
  }
  async disconnect() {
    return this.client.request("disconnect", {});
  }
  async accounts() {
    return await this.client.request("accounts", {});
  }
  async currentAccount() {
    const e2 = await this.client.request("currentAccount", {});
    return e2 ? Address.fromDynamicInput(e2).toB256() : null;
  }
  async signMessage(e2, t2) {
    if (!t2.trim()) throw new Error("Message is required");
    return this.client.request("signMessage", { address: e2, message: t2 });
  }
  async sendTransaction(e2, t2) {
    if (!t2) throw new Error("Transaction is required");
    const n3 = transactionRequestify(t2), r2 = { url: (await this.currentNetwork()).url };
    return this.client.request("sendTransaction", { address: e2, transaction: JSON.stringify(n3), provider: r2 });
  }
  async assets() {
    return this.client.request("assets", {});
  }
  async addAsset(e2) {
    return this.addAssets([e2]);
  }
  async addAssets(e2) {
    const t2 = e2.map((e3) => {
      const t3 = e3.networks.find((e4) => "fuel" === e4.type);
      if (!t3) throw new Error("Asset for Fuel Network not found!");
      return { ...e3, imageUrl: e3.icon, decimals: t3.decimals, assetId: t3.assetId };
    });
    return this.client.request("addAssets", { assets: t2 });
  }
  async addABI(e2, t2) {
    return this.client.request("addAbi", { abiMap: { [e2]: t2 } });
  }
  async getABI(e2) {
    return this.client.request("getAbi", { contractId: e2 });
  }
  async hasABI(e2) {
    return !!await this.getABI(e2);
  }
  async currentNetwork() {
    return this.client.request("network", {});
  }
  async selectNetwork(e2) {
    throw new Error("Method not implemented.");
  }
  async networks() {
    return this.client.request("networks", {});
  }
  async addNetwork(e2) {
    const t2 = await Provider.create(e2);
    return this.client.request("addNetwork", { network: { url: t2.url, name: t2.getChain().name } });
  }
  async version() {
    return this.client.request("version", { app: "0.0.0", network: "0.0.0" });
  }
}, nn = class extends tn {
  constructor() {
    super("Fuel Wallet Development"), this.metadata = { image: "/connectors/fuel-wallet-dev.svg", install: { action: "Install", description: "To connect your Fuel Wallet, you need to install the browser extension first.", link: "https://chrome.google.com/webstore/detail/fuel-wallet-development/hcgmehahnlbhpilepakbdinkhhaackmc" } };
  }
};
X(), X();
var rn = class extends tn {
  constructor() {
    super("Fuelet Wallet"), this.name = "Fuelet Wallet", this.metadata = { image: { light: "/connectors/fuelet-light.svg", dark: "/connectors/fuelet-dark.svg" }, install: { action: "Install", description: "Install Fuelet Wallet in order to connect it.", link: "https://fuelet.app/download/" } };
  }
};
X(), X(), X(), X();
V(zt());
X(), X(), X();
(function(e2) {
  if (e2.length >= 255) throw new TypeError("Alphabet too long");
  const t2 = new Uint8Array(256);
  for (let e3 = 0; e3 < t2.length; e3++) t2[e3] = 255;
  for (let n4 = 0; n4 < e2.length; n4++) {
    const r3 = e2.charAt(n4), o3 = r3.charCodeAt(0);
    if (255 !== t2[o3]) throw new TypeError(r3 + " is ambiguous");
    t2[o3] = n4;
  }
  const n3 = e2.length, r2 = e2.charAt(0), o2 = Math.log(n3) / Math.log(256), i2 = Math.log(256) / Math.log(n3);
  function a2(e3) {
    if ("string" != typeof e3) throw new TypeError("Expected String");
    if (0 === e3.length) return new Uint8Array();
    let i3 = 0, a3 = 0, s2 = 0;
    for (; e3[i3] === r2; ) a3++, i3++;
    const c2 = (e3.length - i3) * o2 + 1 >>> 0, u2 = new Uint8Array(c2);
    for (; e3[i3]; ) {
      let r3 = t2[e3.charCodeAt(i3)];
      if (255 === r3) return;
      let o3 = 0;
      for (let e4 = c2 - 1; (0 !== r3 || o3 < s2) && -1 !== e4; e4--, o3++) r3 += n3 * u2[e4] >>> 0, u2[e4] = r3 % 256 >>> 0, r3 = r3 / 256 >>> 0;
      if (0 !== r3) throw new Error("Non-zero carry");
      s2 = o3, i3++;
    }
    let d2 = c2 - s2;
    for (; d2 !== c2 && 0 === u2[d2]; ) d2++;
    const f2 = new Uint8Array(a3 + (c2 - d2));
    let l2 = a3;
    for (; d2 !== c2; ) f2[l2++] = u2[d2++];
    return f2;
  }
  return { encode: function(t3) {
    if (t3 instanceof Uint8Array || (ArrayBuffer.isView(t3) ? t3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength) : Array.isArray(t3) && (t3 = Uint8Array.from(t3))), !(t3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (0 === t3.length) return "";
    let o3 = 0, a3 = 0, s2 = 0;
    const c2 = t3.length;
    for (; s2 !== c2 && 0 === t3[s2]; ) s2++, o3++;
    const u2 = (c2 - s2) * i2 + 1 >>> 0, d2 = new Uint8Array(u2);
    for (; s2 !== c2; ) {
      let e3 = t3[s2], r3 = 0;
      for (let t4 = u2 - 1; (0 !== e3 || r3 < a3) && -1 !== t4; t4--, r3++) e3 += 256 * d2[t4] >>> 0, d2[t4] = e3 % n3 >>> 0, e3 = e3 / n3 >>> 0;
      if (0 !== e3) throw new Error("Non-zero carry");
      a3 = r3, s2++;
    }
    let f2 = u2 - a3;
    for (; f2 !== u2 && 0 === d2[f2]; ) f2++;
    let l2 = r2.repeat(o3);
    for (; f2 < u2; ++f2) l2 += e2.charAt(d2[f2]);
    return l2;
  }, decodeUnsafe: a2, decode: function(e3) {
    const t3 = a2(e3);
    if (t3) return t3;
    throw new Error("Non-base" + n3 + " character");
  } };
})("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
X();
V(St());
X(), X();
X();
X();
X(), X();
X();
X();
X();
var An = ((e2) => (e2.MAINNET = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", e2.DEVNET = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1", e2.TESTNET = "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z", e2))(An || {}), In = ((e2) => (e2.GET_ACCOUNTS = "solana_getAccounts", e2.SIGN_TRANSACTION = "solana_signTransaction", e2.SIGN_MESSAGE = "solana_signMessage", e2.REQUEST_ACCOUNTS = "solana_requestAccounts", e2))(In || {}), jn = ((e2) => (e2.DISPLAY_URI = "display_uri", e2.SESSION_PING = "session_ping", e2.SESSION_EVENT = "session_event", e2.SESSION_UPDATE = "session_update", e2.SESSION_DELETE = "session_delete", e2))(jn || {});
X(), X(), X();
X(), X();
X();
X();
X();
var Text = ({ children, className, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ...props, className: `text-white font-sans ${className}`, children });
};
var OnboardingTopBar = ({ currentStep }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "flex w-full items-center justify-around", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        className: currentStep === 0 ? "" : "!text-slate-600",
        children: "1. Welcome"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        className: currentStep === 1 ? "" : "!text-slate-600",
        children: "2. Faucet"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        className: currentStep === 2 ? "" : "!text-slate-600",
        children: "3. Success"
      }
    )
  ] });
};
var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var WelcomePage = ({
  message,
  messageProps,
  setCurrentStep
}) => {
  const { connect: connectUI } = re$3();
  const { connect: connectBurner } = Yt$1();
  const {
    wallet,
    isLoading: isLoadingWallet,
    isPending: isPendingWallet,
    isFetching: isFetchingWallet
  } = wp();
  const {
    balance,
    isFetching: isFetchingBalance,
    isPending: isPendingBalance,
    isLoading: isLoadingBalance
  } = Wu({
    address: wallet == null ? void 0 : wallet.address.toString()
  });
  const { isConnected } = vl();
  const isBalanceLoading = isFetchingBalance || isPendingBalance || isLoadingBalance;
  const isWalletLoading = isLoadingWallet || isPendingWallet || isFetchingWallet;
  reactExports.useEffect(() => {
    if (isConnected && wallet) {
      if (balance && balance.gt(0)) {
        setCurrentStep(
          2
          /* Success */
        );
      } else if (!isBalanceLoading) {
        if (isSafari) {
          const redirectUrl = new URL("https://faucet-testnet.fuel.network/");
          redirectUrl.searchParams.append("address", wallet.address.toString());
          redirectUrl.searchParams.append("redirectUrl", window.location.href);
          window.location.href = redirectUrl.href;
        } else {
          setCurrentStep(
            1
            /* Faucet */
          );
        }
      }
    }
  }, [isConnected, wallet, balance, isBalanceLoading]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, className: "w-5/6 items-center", children: [
    message && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...messageProps, children: message }),
    isWalletLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "Loading..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          className: "btn-primary h-12 w-full",
          onClick: () => {
            connectBurner("Burner Wallet");
          },
          children: "Temporary Wallet"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: "border-b-2 border-slate-600 w-full" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          className: "text-white h-12 w-full border-slate-600",
          onClick: () => {
            connectUI();
          },
          children: "Connect"
        }
      )
    ] })
  ] });
};
var TESTNET_FAUCET_LINK = "https://faucet-testnet.fuel.network/";
var useBreakpoints = () => {
  const isMobile = useMedia("(max-width: 640px)", false);
  const isTablet = useMedia("(max-width: 768px)", true);
  return { isMobile, isTablet };
};
var useFaucet = (fuelNodePort = 4e3, privateKey = "0x01") => {
  const [faucetWallet, setFaucetWallet] = reactExports.useState();
  _default$1(async () => {
    if (!faucetWallet) {
      const provider = await Provider.create(
        `http://127.0.0.1:${fuelNodePort}/v1/graphql`
      );
      const wallet = Wallet.fromPrivateKey(privateKey, provider);
      setFaucetWallet(wallet);
    }
  }, [faucetWallet]);
  return {
    faucetWallet
  };
};
var FaucetPage = ({ setCurrentStep }) => {
  const {
    wallet,
    isLoading: isLoadingWallet,
    isPending: isPendingWallet,
    isFetching: isFetchingWallet
  } = wp();
  const {
    isPending: isPendingBalance,
    isLoading: isLoadingBalance,
    isFetching: isFetchingBalance
  } = Wu({ address: wallet == null ? void 0 : wallet.address.toString() });
  useFaucet();
  const [className, setClassName] = reactExports.useState("");
  const isLoading = isLoadingWallet || isPendingWallet || isFetchingWallet || !wallet && (isPendingBalance || isLoadingBalance || isFetchingBalance);
  reactExports.useEffect(() => {
    const logo = document.getElementsByClassName("fuel-logo");
    if (logo) {
      setClassName("overflow-hidden h-[800px]");
    }
  }, []);
  if (isLoading) return /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "Loading..." });
  if (!wallet) return /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "Wallet not found" });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "iframe",
    {
      src: `${TESTNET_FAUCET_LINK}?address=${wallet.address.toAddress()}`,
      id: "test",
      width: "100%",
      height: "800px",
      className,
      children: "hello"
    }
  );
};
var OnboardingFlowContext = reactExports.createContext(null);
var useOnboardingFlowContext = () => {
  const context = reactExports.useContext(
    OnboardingFlowContext
  );
  if (!context) {
    throw new Error(
      "useOnboardingFlowContext must be used within OnboardingFlowProvider"
    );
  }
  return context;
};
var OnboardingFlowProvider = ({
  children
}) => {
  const { isConnected } = vl();
  const [openDialog, setOpenDialog] = reactExports.useState(!isConnected);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(OnboardingFlowContext.Provider, { value: { openDialog, setOpenDialog }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie$1, {}),
    children
  ] });
};
var SuccessPage = ({ message }) => {
  const { setOpenDialog } = useOnboardingFlowContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, className: "items-center w-full", children: [
    message && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        className: "btn-primary h-12 w-3/4",
        onClick: () => setOpenDialog(false),
        children: "Continue to App"
      }
    )
  ] });
};
var OnboardingFlow = ({ container }) => {
  const { openDialog } = useOnboardingFlowContext();
  const [currentStep, setCurrentStep] = reactExports.useState(
    0
    /* Welcome */
  );
  const { isMobile } = useBreakpoints();
  const { wallet } = wp();
  const { balance, refetch: refetchBalance } = Wu({
    address: wallet == null ? void 0 : wallet.address.toString()
  });
  reactExports.useEffect(() => {
    const interval = setInterval(refetchBalance, 500);
    if (balance && balance.gt(0)) {
      setCurrentStep(
        2
        /* Success */
      );
    }
    return () => clearInterval(interval);
  }, [balance]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      fullScreen: isMobile,
      container,
      open: openDialog,
      id: "onboarding",
      PaperProps: { className: "p-8 w-full bg-black border-slate-600 border" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 4, className: "items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingTopBar, { currentStep }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: "flex w-full justify-center items-center", children: currentStep === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          WelcomePage,
          {
            message: "Welcome to Sway NFT!",
            messageProps: { className: "text-xl" },
            setCurrentStep
          }
        ) : currentStep === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(FaucetPage, { setCurrentStep }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessPage, { message: "Success!" }) })
      ] }) })
    }
  );
};
const AppProvider = ({ children }) => {
  const [queryClient] = reactExports.useState(() => {
    return new QueryClient({});
  });
  const [currentProvider] = reactExports.useState(Provider.create(NODE_URL));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledEngineProvider, { injectFirst: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    eu,
    {
      fuelConfig: {
        connectors: [
          new tn(),
          new rn(),
          new nn(),
          new Vt({ fuelProvider: currentProvider })
        ]
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingFlowProvider, { children })
    }
  ) }) }) });
};
client$1.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AppProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie$1, { position: "bottom-center" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingFlow, { container: () => document.getElementById("root") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
  ] }) })
);
export {
  AccountController as A,
  ConnectionController as C,
  EventsController as E,
  ModalController as M,
  NetworkController as N,
  OptionsController as O,
  RouterController as R,
  StorageUtil as S,
  W3mFrameRpcConstants as W,
  subscribe as a,
  r$1 as b,
  customElement as c,
  SnackController as d,
  h,
  i$2 as i,
  ke$1 as k,
  proxy as p,
  ref as r,
  subscribeKey as s
};
